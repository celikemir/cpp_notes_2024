WEBVTT

00:00.000 --> 00:12.040
İyi akşamlar arkadaşlar. 28 Şubat 2025 Cuma günü saat 19.30. 67. ders günümüz.

00:12.360 --> 00:18.800
Dersimize başlıyoruz. Bu arada herkesin ne dilerim Ramazan ayı hayırlı olsun.

00:19.440 --> 00:20.760
Oruç döneminde başlıyor.

00:21.880 --> 00:24.020
Nerede kaldığımızı şöyle bir hatırlayalım.

00:24.020 --> 00:26.020
Atomik işlemlerdeydik.

00:26.300 --> 00:27.460
Atomic operations.

00:27.460 --> 00:36.780
Konkurrensi başlığı altında belki de en önemli konulardan biri atomik operations, atomik işlemler.

00:37.840 --> 00:40.420
Bir işlemin atomik olması ne demek?

00:40.840 --> 00:43.200
Önce bundan bahsettik. Şöyle biraz toparlayalım.

00:44.540 --> 00:49.580
Bir işlemin arkadaşlar atomik olması bölünemez olması demek.

00:49.720 --> 00:52.020
Yani araya bir işlem girmeyecek.

00:52.020 --> 00:58.100
Mesela normalde bir değişkeni atomik olmayan bir değişkeni değerini değiştirmek.

00:58.760 --> 01:02.860
Bir İngilizce'de read, modify, write işlemi.

01:03.400 --> 01:10.960
Burada read ile modify, modify ile write arasına başka bir trade'in bir işlemi girebilir.

01:10.960 --> 01:19.000
Ama eğer arkadaşlar işlem atomik ise bu zaten garanti altına alınıyor.

01:20.180 --> 01:25.360
Dolayısıyla atomik işlemler, atomik değişkenler üstünde yapılıyor.

01:25.360 --> 01:45.240
İşte programlama dillerinin, farklı farklı programlama dillerinin standart kütüphanelerinin bu atomik işlemlerle ya da atomik işlemlerin üstünde yapıldığı atomik değişkenlerle ilgili standart kütüphanelerin verdiği destek ya da destekler var.

01:45.240 --> 01:54.520
Bizim standart kütüphanemizde de bu destek atomik header'ı içindeki sınıflar ve fonksiyonlar idi.

01:56.120 --> 01:58.440
Arkadaşlar sonra neyi gördük?

01:58.740 --> 02:01.600
Şöyle bir akışı hatırlayalım.

02:02.040 --> 02:02.220
Evet.

02:03.300 --> 02:04.480
Biraz bekleteceğim.

02:05.800 --> 02:06.000
Evet.

02:06.460 --> 02:09.180
Arkadaşlar aslında atomik bir template.

02:09.980 --> 02:12.120
Fakat bu template'in neleri var?

02:12.460 --> 02:13.920
Specialization'ları var.

02:13.920 --> 02:16.220
Şöyle biz kendimiz yazalım en iyisi.

02:17.100 --> 02:25.100
Yani atomik sınıf şablonunun, atomik sınıf şablonunun örneğin int açılımı.

02:25.500 --> 02:31.260
Atomik sınıf şablonunun örneğin arkadaşlar int yıldız açılımı.

02:31.340 --> 02:32.640
Bir pointer türü olabilir.

02:33.760 --> 02:36.020
Efendim bir primitive türü olabilir.

02:36.160 --> 02:38.440
Bir tam sayı türü, bir gerçek sayı türü olabilir.

02:38.440 --> 02:45.860
Standart kütüphane bunlar için ya explicit ya da partial specialization'lar veriyor.

02:46.560 --> 02:47.440
Bu da ne demek?

02:48.160 --> 02:49.440
Şimdi template olması yanıltmasın.

02:50.860 --> 02:54.420
Aslında bir master template var.

02:54.420 --> 03:00.800
Ama bir de özelleştirilmiş full specialization ya da partial specialization'lar var.

03:00.900 --> 03:04.040
Bu da şu demek, interfeyslere aynı olmak zorunda değil.

03:05.240 --> 03:05.700
Öyle değil mi?

03:05.800 --> 03:13.280
Ortada tek bir template olsaydı, bir explicit specialization ya da partial specialization olsaydı,

03:13.280 --> 03:18.200
bütün specialization'ların interfeysi aynı olacaktı.

03:18.300 --> 03:21.980
Fakat burada interfeys aynı olmak zorunda değil.

03:22.520 --> 03:25.820
Zaten ilerleyen dakikalarda da tekrar ona bakacağız.

03:26.840 --> 03:34.280
Arkadaşlar şimdi atomik işlemlerin bizi ilgilendiren birden fazla ne diyelim özelliği var.

03:34.280 --> 03:38.200
Birincisi o açık, bölünemez.

03:38.320 --> 03:44.980
Yani atomik işlem hangi atomik değişken üstünde yapılırsa yapılsın bölünemez.

03:45.760 --> 03:52.160
Arkadaşlar ama işlemin bölünemezliğiyle işlemlerin sıralanması,

03:52.340 --> 03:55.360
İngilizcesiyle ordering farklı şeyler.

03:55.360 --> 04:02.840
İşte atomik değişkenlerin kullanımı aynı zamanda işlemlerin sıralanmasıyla ilgili

04:02.840 --> 04:08.720
ve dolayısıyla senkronize edilmesiyle ilgili de bir takım garantiler veriyor.

04:08.920 --> 04:13.660
Biz geçen dersimizde bir giriş yaptık ama o garantilerden bahsetmedik.

04:13.660 --> 04:23.880
Yani bir atomik değişkeni örneğin sadece onun üstünde yapılan işlemler bölünemez olduğu için

04:23.880 --> 04:27.880
veri yarışı, data race'i engellemek için kullanabiliriz.

04:28.020 --> 04:35.060
Fakat bunun yanında aynı zamanda bir senkronizasyon mekanizması olarak da kullanabiliriz.

04:36.140 --> 04:40.120
Geçen dersimizde bu senkronizasyonla ilgisini göstermedik.

04:40.120 --> 04:41.900
Ama bu derste göreceğiz.

04:42.160 --> 04:46.060
İşte burada önemli, biraz da zor bir kavram karşımıza çıkacak.

04:46.380 --> 04:48.020
Memory oradır.

04:48.240 --> 04:51.420
Birazdan bundan bahsetmeye başlayacağız.

04:52.780 --> 04:58.240
Şimdi atomik türlerden arkadaşlar bir ayrı bir tür vardı.

04:58.420 --> 04:59.160
Onu gördük.

04:59.360 --> 05:00.500
Atomic flag.

05:01.260 --> 05:08.240
Onunla dedik atomik sınıf şablonunun buğul açılımını birbiriyle karıştırmayalım.

05:08.240 --> 05:20.380
Arkadaşlar şimdi atomik specialization'ın hangi açılımları için hangi işlemler var onları bir göstermek istiyorum.

05:20.600 --> 05:26.060
Ama madem karşıma hazırladığım bu sayfa çıktığı Yostis'in kitabından hemen buna da değineyim.

05:26.060 --> 05:40.060
Belirli specialization'lar için bu template notasyonunu kullanmak yerine bunlara verilen type areas, türeş isimleri de var.

05:40.060 --> 05:52.060
Örneğin atomik template'inin buğul açılımı demek yerine atomik underscore buğul type def ismini, türeş ismini kullanabilirsiniz.

05:52.060 --> 06:01.620
Örneğin atomik unsigned int açılımı yerine atomik uint type def ismini kullanabilirsiniz.

06:03.060 --> 06:16.400
Ya da işte görüyorsunuz arkadaşlar atomik long long yerine atomik l-l long type def ismini kullanabilirsiniz.

06:16.400 --> 06:23.400
Burada şunu karıştırmayalım, atomik buğul başka, atomik flag başka, atomik flag'i görmüştük.

06:25.560 --> 06:28.440
Arkadaşlar şimdi önce şu sayfaya bakalım.

06:29.420 --> 06:34.020
Şimdi burası önemli, zaten üstünden de geçeceğiz.

06:34.860 --> 06:37.320
Hocam sitattan önce olduğu için mi?

06:38.460 --> 06:40.280
Tam anlayamadım Resul soruyu.

06:40.700 --> 06:43.460
Şimdi sitat başka, türeş ismi başka.

06:43.460 --> 06:50.680
Sitat hemen eğer soruyu yanlış anlamışsam lütfen tekrar düzeltmemi sağlayın.

06:51.380 --> 06:54.400
Şimdi ikisi arasındaki fark çok önemli.

06:55.360 --> 07:08.260
Sitat, konstruktora gönderilen argümanlardan template parametresine karşılık gelen template argümanının anlaşılması sentaks özelliği.

07:08.260 --> 07:14.120
Yani örneğin template, sadece standart kütüphane için geçer değil.

07:14.680 --> 07:16.460
Student class, my class.

07:17.220 --> 07:18.380
Efendim public.

07:19.620 --> 07:21.820
Arkadaşlar, my class.

07:23.320 --> 07:24.280
İzleyin.

07:24.740 --> 07:25.960
P, P.

07:26.960 --> 07:28.360
My class.

07:29.040 --> 07:29.760
P.

07:30.280 --> 07:31.380
Takip edebiliyor muyuz?

07:31.380 --> 07:31.880
Evet.

07:32.880 --> 07:39.500
E şimdi ben yukarıdaki sınıf şalmonunda normalde şöyle yazmalıyım değil mi?

07:39.560 --> 07:41.560
My class'ın int açılımı.

07:42.260 --> 07:43.180
Örneğin x.

07:44.000 --> 07:44.800
Ama şimdi,

07:46.440 --> 07:47.700
geleceğim oraya Resul.

07:48.400 --> 07:49.460
Ben bir bitireyim.

07:49.940 --> 07:52.480
Evet, örneğin ben şöyle yazarsam.

07:52.480 --> 08:11.700
Derleyici 9. satırda bildirilen konstruktör nedeniyle konstruktör'a gönderilen argüman int türden olduğu için template parametresi t'ye karşılık gelen template argümanını int olarak alıyor bu sitat.

08:11.700 --> 08:19.520
Ve sitat, sürekli tekrar ettik, c++ 17 standartıyla direklendi.

08:19.520 --> 08:24.700
Yalnız arkadaşlar, bu konuyla ilgili önemli bir konu daha var.

08:25.520 --> 08:36.600
Ama biraz ileri bir konu olduğu için, biraz da detay bir konu olduğu için, biraz da bizim zamanımızın kısıtlı olduğu için bu kursta anlatmadım.

08:36.600 --> 08:41.980
Bir de Didaction Guide denilen yine bir bildirim var.

08:42.240 --> 08:44.880
Jenerik kodlara ilişkin, sınıflara ilişkin.

08:44.880 --> 08:56.720
Yani, birebir Türkçe'ye çevirirsek, Didaction'ın nasıl yapılması gerektiğini anlatan bir kılavuz gibi bu kursta hiç bahsetmedik.

08:57.560 --> 09:04.640
Evet, şimdi atomik konusuna gelirsek, şimdi şöyle bir bakalım, bir tekneğimde tekrar etmiş oluruz.

09:04.640 --> 09:10.280
Arkadaşlar, bu template işte atomik int açılımı görüyorsunuz değil mi?

09:11.140 --> 09:15.820
Ama, az önceki resme geri dönelim.

09:16.820 --> 09:17.420
Şuradaydı.

09:17.980 --> 09:23.700
Evet, bakın, atomik int, atomik int açılımının türeş ismi.

09:23.700 --> 09:32.840
Yani, böyle yazmakla, arkadaşlar, böyle yazmak arasında fark yok.

09:33.980 --> 09:35.960
Bunun sitatla alakası yok.

09:36.080 --> 09:41.700
Çünkü artık zaten böyle yazarak, template argümanının int olduğunu söylemiştik.

09:43.060 --> 09:43.260
Evet.

09:44.680 --> 09:45.800
Anlaşıldı mı?

09:46.560 --> 09:46.800
Evet.

09:46.800 --> 09:54.280
Yani, Constructor'a gönderdiğiniz argümandan, template argümanının anlaşılmasını istiyorsanız,

09:55.720 --> 09:58.100
sitattan faydalanmış oluyorsunuz.

09:58.100 --> 10:09.300
Ama, ben şöyle yazmak yerine, bu specialization'a karşılık gelen türeş ismini kullanayım diyorsanız,

10:10.000 --> 10:14.700
o zaman da, bu type alias'ı kullanıyorsunuz.

10:14.700 --> 10:17.980
Şimdi, devam edelim.

10:18.340 --> 10:21.420
Arkadaşlar, şimdi, bu resim bence önemli.

10:23.080 --> 10:24.360
Burada neyi görüyoruz?

10:24.760 --> 10:27.600
Burada, atomik operasyonların,

10:28.600 --> 10:30.680
yok, burası değil, özür dilerim.

10:31.320 --> 10:32.020
Biraz karıştı.

10:32.700 --> 10:35.680
Evet, arkadaşlar, şu düzgün bir şey bulamadım.

10:36.620 --> 10:38.100
Evet, tamam, buydu, aradım.

10:38.100 --> 10:48.400
Arkadaşlar, şimdi, burada atomik operasyonların hangi türler için interfezde yer aldığı tablosu.

10:48.960 --> 10:52.280
Mesela, test and set ve clear, bunları görmüştük.

10:52.380 --> 10:53.960
Atomic flag türünde var.

10:54.960 --> 10:56.640
Diğer atomik türlerde yok.

10:56.640 --> 11:03.020
Mesela, is lock free, bütün atomik açılımlarında var.

11:03.280 --> 11:04.520
Tabloyu görüyoruz, değil mi?

11:04.800 --> 11:05.040
Evet.

11:05.560 --> 11:07.300
Arkadaşlar, yani burada ne demek istiyor?

11:07.920 --> 11:09.400
Atomi'in boğul açılımı,

11:09.940 --> 11:11.500
use of define tür açılımı,

11:12.340 --> 11:14.540
atomik pointer açılımı,

11:15.220 --> 11:18.380
atomik herhangi bir tam sayı türü açılımı.

11:19.220 --> 11:20.420
Takip edebiliyor muyuz?

11:20.560 --> 11:20.720
Evet.

11:20.720 --> 11:23.520
Arkadaşlar, is lock free,

11:23.840 --> 11:25.180
görüyorsunuz hepsinde var.

11:25.940 --> 11:27.800
Load, hepsinde var.

11:28.340 --> 11:30.200
Store, hepsinde var.

11:30.880 --> 11:32.580
Exchange, hepsinde var.

11:33.260 --> 11:35.780
Compare Exchange Strong, arkadaşlar,

11:36.780 --> 11:37.500
gördüğünüz gibi,

11:37.640 --> 11:39.600
atomic pool, atomic user type,

11:39.720 --> 11:42.020
atomic pointer, atomic integral'de var.

11:42.880 --> 11:44.620
Aynı şekilde compare exchange with.

11:44.620 --> 11:46.400
Ama fetch at,

11:47.040 --> 11:48.600
atomic pointer'da ve

11:48.600 --> 11:50.900
atomik tam sayı türlerinde var.

11:51.560 --> 11:53.060
Fetch, subtract,

11:53.400 --> 11:54.420
yani bu sub,

11:55.060 --> 11:55.860
arkadaşlar,

11:56.200 --> 11:57.060
görüyorsunuz,

11:57.240 --> 11:57.720
sadece,

11:58.460 --> 11:59.340
yine özür dileyen,

11:59.400 --> 12:01.140
fetch sub da pointer aritmetine

12:01.140 --> 12:02.560
uygun olduğu için,

12:02.720 --> 12:05.020
o da hem pointer açılımlarında,

12:05.120 --> 12:07.320
hem de tam sayı açılımlarında var.

12:08.360 --> 12:08.680
Ama,

12:09.220 --> 12:09.740
arkadaşlar,

12:09.920 --> 12:11.120
bitsel veya,

12:11.520 --> 12:13.020
bitsel özel veya,

12:13.780 --> 12:16.740
bitsel ve eşit işlemleri,

12:16.740 --> 12:19.880
sadece atomik'in int,

12:20.420 --> 12:21.200
integral,

12:21.440 --> 12:24.260
yani int türlerinden açılımları için var.

12:24.980 --> 12:26.440
Art, artı ve eksi eksi,

12:26.860 --> 12:28.760
yine hem pointer açılımları,

12:29.380 --> 12:30.000
hem de,

12:30.300 --> 12:30.800
arkadaşlar,

12:31.640 --> 12:32.040
efendim,

12:32.320 --> 12:34.000
tam sayı açılımları için var.

12:34.160 --> 12:34.600
Arkadaşlar,

12:34.660 --> 12:35.080
bu ne demek?

12:35.200 --> 12:35.500
Bakın,

12:35.620 --> 12:36.740
bunu fiilen bir görelim.

12:36.740 --> 12:37.720
mesela,

12:38.440 --> 12:39.200
atomik,

12:41.860 --> 12:43.420
boğul açılımı türünden,

12:44.220 --> 12:44.560
x.

12:45.340 --> 12:45.680
Şimdi,

12:46.380 --> 12:48.360
zaten yardımcı araç gösteriyor.

12:49.040 --> 12:49.420
Bakın,

12:49.940 --> 12:50.640
store'u var,

12:50.900 --> 12:51.580
load'u var,

12:51.800 --> 12:52.920
is lock price'i var,

12:53.160 --> 12:54.040
exchange'i var,

12:54.680 --> 12:55.480
compare exchange,

12:55.620 --> 12:56.120
tronk'u,

12:56.240 --> 12:57.100
compare exchange,

12:57.200 --> 12:58.900
v2 ve exchange'i var.

12:59.120 --> 12:59.380
Ama,

13:00.260 --> 13:01.740
atomik örneğin,

13:02.020 --> 13:02.520
arkadaşlar,

13:02.520 --> 13:03.980
int yıldız.

13:03.980 --> 13:05.700
şimdi,

13:06.200 --> 13:07.780
arkadaşlar,

13:08.540 --> 13:09.420
görüyorsunuz,

13:09.860 --> 13:10.500
store, load,

13:10.600 --> 13:11.480
is lock free exchange,

13:11.580 --> 13:13.480
patch add de var burada.

13:14.440 --> 13:15.420
Görüyorsunuz değil mi?

13:15.620 --> 13:15.860
Ve,

13:16.320 --> 13:17.620
patch sub da var.

13:18.800 --> 13:19.220
Bunlar,

13:19.460 --> 13:20.120
artı eşit,

13:20.240 --> 13:21.080
eksi eşit,

13:21.280 --> 13:22.240
işlemlerinin,

13:22.440 --> 13:22.880
adeta,

13:23.100 --> 13:24.300
isimlendirilmiş hali.

13:24.940 --> 13:25.600
Bunların hepsini,

13:25.660 --> 13:26.500
bugün göstereceğim.

13:26.680 --> 13:26.860
Fakat,

13:27.000 --> 13:28.180
tabii en karmaşık olan,

13:28.880 --> 13:31.000
geçen dersimizde de orada kalmıştık,

13:31.720 --> 13:33.320
compare exchange,

13:33.320 --> 13:34.680
strong işlemi,

13:34.780 --> 13:35.040
yani,

13:35.240 --> 13:36.200
TAS işlemi.

13:36.980 --> 13:37.700
Arkadaşlar,

13:38.240 --> 13:38.440
evet,

13:38.500 --> 13:40.160
compare and swap deniyordu.

13:40.640 --> 13:40.960
Buradaki,

13:41.140 --> 13:42.520
is always lock free,

13:43.160 --> 13:43.340
bu,

13:43.560 --> 13:44.720
statik veri elemanı,

13:44.780 --> 13:46.080
bu üye fonksiyon değil.

13:46.780 --> 13:47.020
Evet.

13:47.720 --> 13:48.300
Ama bakın,

13:48.900 --> 13:51.540
en geniş interfeiste sahip olan,

13:52.360 --> 13:52.920
atomik,

13:53.480 --> 13:55.060
tam sayı türü açılımları.

13:55.580 --> 13:56.360
Şimdi bakalım,

13:56.600 --> 13:57.040
arkadaşlar,

13:57.040 --> 13:58.100
compare exchange,

13:58.220 --> 13:58.540
strong,

13:58.800 --> 13:59.180
weak,

13:59.680 --> 14:00.300
exchange,

14:00.940 --> 14:01.580
patch add,

14:02.240 --> 14:03.080
patch end,

14:03.320 --> 14:04.500
patch or,

14:05.140 --> 14:05.840
patch sub,

14:06.500 --> 14:07.300
patch exor,

14:07.840 --> 14:09.020
is always lock free,

14:09.460 --> 14:10.280
is lock free,

14:10.980 --> 14:11.400
load,

14:12.080 --> 14:12.780
notify all,

14:12.860 --> 14:13.560
buna değinmeyeceğim,

14:13.640 --> 14:15.560
bunlar C++ 20 ile geldi.

14:16.200 --> 14:17.060
Notify one,

14:17.380 --> 14:18.380
operator int,

14:18.540 --> 14:20.540
operator bitsel ve eşit,

14:21.240 --> 14:22.420
operator artı artı,

14:22.480 --> 14:23.640
hem önek hem son ek,

14:24.680 --> 14:26.040
operator artı eşit,

14:26.160 --> 14:27.380
operator eksi eşit,

14:28.380 --> 14:29.360
operator eşit,

14:29.360 --> 14:31.060
operatör,

14:31.280 --> 14:32.720
bitsel özel ve ya eşit,

14:32.780 --> 14:33.540
ve ya eşit,

14:33.740 --> 14:34.160
store,

14:34.760 --> 14:35.260
weight,

14:35.520 --> 14:37.660
yine C++ 20 ile geldi,

14:37.760 --> 14:39.060
onu anlatmayacağım demiştim.

14:40.580 --> 14:41.620
Şimdi burada,

14:42.280 --> 14:44.960
kritik noktalara yavaş yavaş gelelim.

14:46.080 --> 14:46.700
Arkadaşlar,

14:46.700 --> 14:51.920
bu operasyonların aslında her biri için,

14:52.060 --> 14:54.080
mesela herhangi bir fonksiyonu çağıralım,

14:54.280 --> 14:54.720
store,

14:56.220 --> 14:57.420
dikkat ederseniz,

14:57.660 --> 14:59.720
şöyle bir gösterelim arkadaşlar,

15:00.900 --> 15:01.320
bunun,

15:01.880 --> 15:02.980
bir overloadu,

15:03.220 --> 15:04.760
bizden aslında,

15:05.840 --> 15:07.800
memory order dediğimiz,

15:08.800 --> 15:09.580
değeri istiyor.

15:10.000 --> 15:10.460
İşte biz,

15:10.700 --> 15:13.140
geçen dersimizde memory order'a hiç değinmedik,

15:13.260 --> 15:14.540
bugünkü dersimizin konusu.

15:14.540 --> 15:16.920
Aslında,

15:17.540 --> 15:18.660
ben örneğin,

15:18.860 --> 15:21.280
store fonksiyonunu bu şekilde çağırırsam,

15:22.560 --> 15:26.480
yine o memory order denilen değeri belirlemiş oluyorum,

15:27.260 --> 15:29.880
ama bu durumda o memory order değeri,

15:30.960 --> 15:33.260
ilerleyen dakikalarda göreceğimiz,

15:33.340 --> 15:34.280
memory order,

15:35.000 --> 15:38.120
sequential consistency dediğimiz değer bulacak.

15:38.120 --> 15:40.000
Yani aslında,

15:40.900 --> 15:44.240
bu atomik işlemlerin hepsi için,

15:44.460 --> 15:47.940
bir memory order parametresi var aslında.

15:49.300 --> 15:54.120
Bu parametreye karşılık gelen bir argüman sunmazsanız,

15:54.800 --> 15:55.820
aslında orada,

15:56.580 --> 16:02.120
o farklı memory order kategorilerini ifade eden değerlerden,

16:02.120 --> 16:08.980
memory order sequential consistency değerini seçmiş oluyoruz.

16:10.500 --> 16:12.680
Ama biz oraya daha gelmedik.

16:12.760 --> 16:14.900
Memory order'ın ne olduğunu henüz konuşmadık,

16:14.980 --> 16:16.140
biraz daha konuşmayacağız.

16:17.220 --> 16:17.980
Arkadaşlar,

16:18.060 --> 16:20.100
şimdi en basit işlemlerden başlayalım.

16:21.680 --> 16:22.520
Store demek,

16:23.340 --> 16:24.900
değişkene değer atamak demek.

16:24.900 --> 16:30.040
Yani atomik değişkenin değerini değiştirmek için,

16:30.760 --> 16:32.940
store fonksiyonunu çağırabilirsiniz.

16:33.520 --> 16:34.860
Yalnız bir şeye dikkat edin,

16:35.360 --> 16:36.640
store fonksiyonu,

16:36.860 --> 16:39.000
geri dönüş değerini göstermek istiyorum.

16:39.700 --> 16:40.220
Arkadaşlar,

16:40.280 --> 16:41.320
bu void fonksiyon.

16:42.400 --> 16:44.300
Bu işlem atomik olarak yapılıyor.

16:44.400 --> 16:46.260
Yani bölünemez bir şekilde yapılıyor.

16:47.420 --> 16:48.100
Arkadaşlar,

16:48.780 --> 16:49.780
diyeceksiniz ki,

16:50.020 --> 16:52.920
Necat şöyle bir atomo operatör fonksiyonu da var.

16:52.920 --> 16:53.320
Evet,

16:54.060 --> 16:56.100
böyle bir atomo operatör fonksiyonu da var.

16:56.320 --> 16:56.900
Aslında,

16:57.820 --> 16:58.460
x'in,

16:58.700 --> 17:01.020
geçen dersimizde işte buralarda kalmıştık.

17:01.800 --> 17:04.060
Atomo operatör fonksiyonuna,

17:04.480 --> 17:06.400
argüman olarak 5 geçmekle,

17:06.700 --> 17:07.660
aslında bu fonksiyonu,

17:07.680 --> 17:08.000
şu bakın,

17:08.160 --> 17:08.460
x,

17:08.780 --> 17:09.620
operatör,

17:11.280 --> 17:11.800
atama,

17:12.820 --> 17:13.060
ve,

17:13.940 --> 17:15.080
operatör,

17:15.220 --> 17:15.700
atama,

17:16.020 --> 17:17.020
ve bu fonksiyona,

17:17.680 --> 17:18.060
işte,

17:18.380 --> 17:18.920
diyelim ki,

17:19.200 --> 17:20.200
5 değerini geçiyorum.

17:20.640 --> 17:21.440
Arada,

17:21.440 --> 17:23.460
bir tane önemli fark var.

17:24.120 --> 17:24.540
Biri,

17:24.800 --> 17:26.920
store'un void fonksiyonu olması,

17:27.820 --> 17:30.300
ama atomo operatör fonksiyonunun,

17:30.860 --> 17:31.180
bize,

17:31.720 --> 17:33.020
atanan değeri,

17:33.300 --> 17:35.240
ama referans olarak değil.

17:35.840 --> 17:36.640
Kopyalama olarak,

17:36.780 --> 17:37.840
yani geri dönüş değeri,

17:38.040 --> 17:38.420
aslında,

17:39.200 --> 17:40.280
normal konvensyon,

17:40.420 --> 17:41.340
atomik dışında,

17:41.560 --> 17:42.820
referans döndürmesidir.

17:43.460 --> 17:44.020
Arkadaşlar,

17:44.080 --> 17:44.820
yıldız dizi,

17:45.080 --> 17:46.100
ama burada öyle değil.

17:46.100 --> 17:47.060
Fakat,

17:47.060 --> 17:50.120
ikinci bir özellik daha var.

17:51.120 --> 17:51.700
Eğer bu,

17:51.820 --> 17:52.480
aslında sadece,

17:52.540 --> 17:54.460
atama operatörüyle ilgili değil,

17:55.160 --> 17:57.360
bütün iş atama operatörleri için,

17:57.460 --> 17:58.000
yani ben,

17:58.200 --> 17:59.100
x eşit,

17:59.460 --> 18:00.280
de deseydim,

18:01.280 --> 18:03.160
x artı eşit,

18:03.240 --> 18:04.060
de deseydim,

18:04.400 --> 18:04.840
arkadaşlar,

18:05.840 --> 18:07.180
x eksi eşit,

18:07.260 --> 18:08.060
de deseydim,

18:08.780 --> 18:09.740
takip etmeniz lütfen,

18:09.740 --> 18:11.700
x efendim,

18:11.840 --> 18:14.120
bitsel ve eşit de deseydim,

18:15.260 --> 18:15.540
tamam,

18:15.700 --> 18:17.600
bu işlemlerin hepsi atomik,

18:17.860 --> 18:19.340
hepsinin geri dönüş değeri,

18:20.040 --> 18:21.260
atamadan sonraki,

18:21.460 --> 18:22.600
yıldız dizinin değeri,

18:23.760 --> 18:24.080
ama,

18:24.420 --> 18:25.240
bunların,

18:26.100 --> 18:27.020
memory order,

18:27.600 --> 18:28.660
parametresi yok,

18:29.320 --> 18:29.840
dolayısıyla,

18:30.160 --> 18:31.080
ama bu işlemlerin,

18:31.280 --> 18:33.140
hepsi için bir memory order,

18:34.060 --> 18:34.840
ne diyelim,

18:34.980 --> 18:36.020
seçimi gerekiyor,

18:36.640 --> 18:37.260
işte burada,

18:37.840 --> 18:38.640
memory order,

18:38.640 --> 18:39.180
yine,

18:39.480 --> 18:41.580
sequential consistency,

18:42.300 --> 18:43.340
ilerleyen dakikalarda,

18:43.420 --> 18:44.720
o sequential consistency,

18:44.900 --> 18:45.280
ne demek,

18:45.900 --> 18:46.360
genel olarak,

18:46.460 --> 18:47.400
memory orderları,

18:47.860 --> 18:48.560
inceleyeceğiz,

18:49.260 --> 18:50.100
anlaşıldı değil mi,

18:50.540 --> 18:50.800
yani,

18:50.960 --> 18:52.020
atomik değişkenin,

18:52.080 --> 18:52.680
değerini,

18:53.000 --> 18:54.020
şu biçimlerden,

18:54.080 --> 18:54.980
herhangi bir şekilde,

18:55.780 --> 18:56.820
değiştirebilirsiniz,

18:57.400 --> 18:58.580
atama yapabilirsiniz,

18:59.620 --> 19:01.260
işlemli atama operatörünü,

19:01.560 --> 19:02.360
kullanabilirsiniz,

19:02.360 --> 19:02.760
mesela,

19:02.900 --> 19:04.280
x artı eşitleri bir,

19:05.240 --> 19:05.680
arkadaşlar,

19:05.860 --> 19:06.360
yalnız bakın,

19:06.440 --> 19:07.980
çok sık yapılan bir hata var,

19:07.980 --> 19:09.260
normalde,

19:09.960 --> 19:11.520
x artı eşit bir ile,

19:12.260 --> 19:13.020
x eşit,

19:13.440 --> 19:14.280
x artı bir,

19:14.460 --> 19:15.200
aynı şeydir,

19:15.280 --> 19:15.580
değil mi,

19:16.580 --> 19:18.340
atomik olmayan türler için,

19:19.140 --> 19:20.040
bunların arasında,

19:20.180 --> 19:20.780
bir fark yok,

19:20.940 --> 19:21.460
ama bakın,

19:21.620 --> 19:22.720
atomik türler için,

19:22.860 --> 19:23.460
böyle değil,

19:24.320 --> 19:24.640
neden,

19:25.140 --> 19:25.840
tahmin ediniz,

19:26.180 --> 19:26.560
neden,

19:26.800 --> 19:28.040
atomik türler için,

19:28.640 --> 19:29.320
böyle değil,

19:29.320 --> 19:31.340
bu arada,

19:31.420 --> 19:32.100
Alihan'ın sorusu,

19:32.200 --> 19:32.960
yaygın kullanım,

19:33.040 --> 19:34.500
türeş isimleri ile olan mı,

19:34.840 --> 19:35.040
hayır,

19:35.280 --> 19:36.520
gerçekten de,

19:36.580 --> 19:37.440
türeş isimleri,

19:37.600 --> 19:38.200
tuhaf bir şekilde,

19:38.380 --> 19:39.240
daha az kullanılıyor,

19:40.300 --> 19:40.620
bravo,

19:40.800 --> 19:42.480
önce toplama operatörü ile,

19:42.600 --> 19:43.380
işlem yapıyorsunuz,

19:43.440 --> 19:43.660
ben,

19:44.240 --> 19:45.380
toplama işleminin,

19:45.380 --> 19:46.240
atomik olduğunu,

19:46.240 --> 19:47.160
söylemedim ki,

19:47.960 --> 19:48.260
zaten,

19:48.420 --> 19:49.540
ilerleyen dakikalarda,

19:49.700 --> 19:51.000
buna yönelik bir örnek yapacağım,

19:51.120 --> 19:51.300
bakın,

19:51.300 --> 19:51.740
burada,

19:52.420 --> 19:52.940
arkadaşlar,

19:53.880 --> 19:54.040
o,

19:54.180 --> 19:56.580
uninterruptible,

19:57.060 --> 19:57.360
ya da,

19:57.460 --> 19:58.660
undivisible olması,

19:59.160 --> 20:00.800
burada söz konusu,

20:00.980 --> 20:01.600
ama burada,

20:01.800 --> 20:02.860
öyle bir şey söz konusu değil,

20:02.940 --> 20:03.500
burada aslında,

20:03.760 --> 20:04.860
iki tane ayrı işlem var,

20:04.960 --> 20:05.980
ama burada bu işlem,

20:06.460 --> 20:07.700
atomik olarak yapılıyor,

20:08.420 --> 20:08.940
anlaşıldı,

20:09.020 --> 20:09.300
değil mi,

20:10.040 --> 20:11.040
şimdi burada,

20:11.580 --> 20:12.380
bizi ilgilendiren,

20:12.500 --> 20:13.800
fonksiyonlardan biri,

20:14.440 --> 20:14.920
arkadaşlar,

20:15.660 --> 20:16.100
strong,

20:16.260 --> 20:17.800
store fonksiyonu,

20:17.860 --> 20:19.060
uzun derece basit,

20:19.620 --> 20:20.780
değeri değiştiriyor,

20:20.780 --> 20:21.220
ama,

20:21.580 --> 20:22.940
exchange fonksiyonu,

20:23.140 --> 20:23.420
bakın,

20:24.220 --> 20:26.200
x'in exchange fonksiyonu,

20:26.880 --> 20:27.860
dikkat ederseniz,

20:28.160 --> 20:28.740
bizden,

20:29.020 --> 20:29.500
arkadaşlar,

20:30.420 --> 20:32.820
set edilecek değeri istiyor,

20:33.340 --> 20:34.400
buna İngilizce'de,

20:34.600 --> 20:34.980
tipik,

20:34.980 --> 20:35.920
topik olarak,

20:36.140 --> 20:37.220
desired deniyor,

20:37.360 --> 20:38.380
yani istenen değer,

20:39.140 --> 20:39.640
ama bir de,

20:39.800 --> 20:41.420
memory order parametresi var,

20:42.300 --> 20:42.660
arkadaşlar,

20:42.960 --> 20:44.440
ama geri dönüş değeri de,

20:44.660 --> 20:46.220
set işleminden önceki değer,

20:47.040 --> 20:48.100
yani örneğin biz,

20:48.860 --> 20:49.740
şöyle bir,

20:49.740 --> 20:51.940
atomik nesne oluştursaydık,

20:52.760 --> 20:53.140
auto,

20:53.900 --> 20:55.620
val eşittir,

20:55.840 --> 20:56.300
arkadaşlar,

20:57.240 --> 20:57.660
efendim,

20:58.700 --> 20:59.980
x nokta,

21:00.360 --> 21:01.240
exchange,

21:01.560 --> 21:02.320
deseydik,

21:03.380 --> 21:03.940
99,

21:04.520 --> 21:05.300
x'in değerini,

21:05.380 --> 21:06.640
99 yapıyoruz,

21:07.580 --> 21:07.920
ama,

21:08.420 --> 21:09.700
geri dönüş değeri de,

21:10.560 --> 21:10.840
değeri,

21:10.900 --> 21:12.060
99 olmadan,

21:12.160 --> 21:12.760
önceki,

21:13.120 --> 21:13.440
değer,

21:13.700 --> 21:14.080
yani,

21:14.380 --> 21:14.740
45,

21:14.740 --> 21:16.380
şimdi ben,

21:16.780 --> 21:18.800
val'in değerini yazdırdığım zaman,

21:21.440 --> 21:24.400
görün,

21:28.400 --> 21:30.220
bir de,

21:30.360 --> 21:32.080
x'in değerini yazdırayım,

21:32.080 --> 21:38.720
yaz burada bakın,

21:38.780 --> 21:40.060
çok önemli bir nokta daha var,

21:40.180 --> 21:40.600
Oğuzhan,

21:41.800 --> 21:43.260
x atomik bir değişken,

21:43.700 --> 21:43.920
peki,

21:44.000 --> 21:45.060
nasıl oluyor da ben,

21:45.280 --> 21:45.820
x'i,

21:46.160 --> 21:47.380
bu şekilde kullanıp,

21:47.620 --> 21:49.200
x'in değerini yazdırabiliyorum,

21:49.320 --> 21:50.500
geçen dersi hatırlayın,

21:50.500 --> 21:54.040
normalde,

21:54.120 --> 21:55.940
x'in değerini elde etmem için,

21:56.400 --> 21:56.720
benim,

21:57.040 --> 21:59.000
load fonksiyonunu çağırmam lazım,

21:59.960 --> 22:00.180
yani,

22:00.260 --> 22:01.220
load adı üstünde,

22:01.380 --> 22:02.040
değeri yüklüyor,

22:02.160 --> 22:02.900
değeri alıyor,

22:03.960 --> 22:04.360
peki,

22:05.120 --> 22:06.080
nasıl oluyor da,

22:06.360 --> 22:06.580
ben,

22:07.180 --> 22:08.800
burada x'i kullandığımda,

22:08.960 --> 22:09.520
adeta,

22:10.080 --> 22:11.320
load etkisi yapıyor,

22:11.460 --> 22:11.940
bravo,

22:12.700 --> 22:13.820
tür dönüştürme,

22:14.180 --> 22:15.540
operatör fonksiyonu var,

22:15.540 --> 22:16.460
yani,

22:16.680 --> 22:17.300
atomik'in,

22:17.520 --> 22:18.620
int açılımının,

22:18.820 --> 22:19.620
atomik'in,

22:19.620 --> 22:20.380
değil mi artık,

22:20.540 --> 22:21.200
burada Türkçe'nin,

22:22.020 --> 22:22.520
doğaflığı,

22:22.640 --> 22:23.420
İngilizce ismi,

22:23.580 --> 22:24.740
Türkçeleştirdiğimiz için,

22:25.480 --> 22:26.680
atomik'in,

22:26.760 --> 22:27.480
atomik'in,

22:27.840 --> 22:28.320
arkadaşlar,

22:28.780 --> 22:29.700
int açılımının,

22:29.900 --> 22:31.380
operatör int fonksiyonu var,

22:31.560 --> 22:32.740
atomik'in,

22:33.280 --> 22:34.240
long açılımının,

22:34.460 --> 22:35.860
operatör,

22:35.980 --> 22:37.140
long fonksiyonu var,

22:37.920 --> 22:38.580
dolayısıyla,

22:39.400 --> 22:40.460
x'in kendisini,

22:40.560 --> 22:41.900
bu şekilde kullanmak,

22:42.660 --> 22:43.540
uygun bağlamda,

22:43.540 --> 22:43.780
yani,

22:43.880 --> 22:45.400
bu tür dönüşümünü,

22:45.700 --> 22:47.340
gerektiren bir bağlamda,

22:48.180 --> 22:48.400
ile,

22:48.400 --> 22:50.320
load fonksiyonunu,

22:50.420 --> 22:51.080
çağırmak,

22:52.080 --> 22:53.040
aynı şey,

22:53.700 --> 22:54.000
ama,

22:54.360 --> 22:55.200
yine arada aslında,

22:55.320 --> 22:56.040
bir fark var,

22:56.440 --> 22:56.640
yine,

22:56.940 --> 22:57.920
aradaki fark ne,

22:58.180 --> 22:58.940
tahmin edin,

22:59.820 --> 23:00.020
yine,

23:00.160 --> 23:00.800
memory order,

23:01.800 --> 23:04.560
memory order,

23:04.680 --> 23:05.880
demekten iyi kastediyorum,

23:06.040 --> 23:06.220
evet,

23:06.360 --> 23:06.520
evet,

23:06.700 --> 23:06.960
şimdi,

23:07.260 --> 23:07.820
load'un,

23:08.260 --> 23:09.140
memory order,

23:09.440 --> 23:10.380
parametrisi var,

23:11.080 --> 23:11.320
mesela,

23:11.320 --> 23:12.220
ben load'u,

23:12.440 --> 23:12.980
arkadaşlar,

23:14.120 --> 23:15.380
şöyle çağırabilirim,

23:15.380 --> 23:16.000
stut,

23:16.760 --> 23:17.700
memory order,

23:18.120 --> 23:18.820
diyelim ki,

23:19.800 --> 23:20.360
ne olsun,

23:21.000 --> 23:21.680
o gayrı,

23:22.880 --> 23:24.060
ama,

23:25.260 --> 23:26.580
tür dönüştürme operatör,

23:27.400 --> 23:28.300
fonksiyonunda,

23:29.060 --> 23:30.900
böyle bir parametre alma imkanı,

23:31.080 --> 23:32.060
olmadığına göre,

23:33.060 --> 23:34.480
memory order'lardan,

23:34.600 --> 23:35.440
birini kullanıyor,

23:35.580 --> 23:36.020
hep işte,

23:36.180 --> 23:37.000
bu tür durumlarda,

23:37.120 --> 23:38.360
default memory order,

23:38.980 --> 23:39.840
her zaman,

23:40.160 --> 23:40.960
memory order,

23:40.960 --> 23:44.280
sequential consistency,

23:45.180 --> 23:45.960
ya da consistent,

23:46.700 --> 23:47.060
peki,

23:47.600 --> 23:48.900
exchange'i de gördük,

23:49.080 --> 23:49.440
arkadaşlar,

23:49.680 --> 23:51.320
önce şu fonksiyonları bir bitirelim,

23:52.100 --> 23:53.280
en zor olanı,

23:53.300 --> 23:54.120
compare exchange,

23:54.260 --> 23:54.820
strong'ı,

23:55.300 --> 23:56.240
en sona bırakacağız,

23:56.720 --> 23:57.100
arkadaşlar,

23:57.640 --> 23:58.060
işte bu,

23:58.480 --> 23:59.140
isminde,

23:59.700 --> 24:00.840
patch geçenler,

24:01.580 --> 24:02.440
patch add,

24:02.800 --> 24:03.660
patch end,

24:03.960 --> 24:04.780
patch or,

24:05.140 --> 24:05.840
patch sub,

24:06.480 --> 24:07.600
bunların her biri,

24:08.640 --> 24:10.220
atama operatörlerinden,

24:10.220 --> 24:10.960
aslında,

24:11.380 --> 24:12.840
birinin karşılığı,

24:13.180 --> 24:13.460
değil mi?

24:13.900 --> 24:14.660
Yani örneğin,

24:14.900 --> 24:16.640
x artı eşit,

24:17.660 --> 24:19.260
while yazmakla,

24:20.020 --> 24:20.440
arkadaşlar,

24:20.800 --> 24:21.220
x,

24:21.680 --> 24:22.740
şöyle göstereyim,

24:23.400 --> 24:23.780
x,

24:24.280 --> 24:25.440
patch add,

24:26.520 --> 24:26.980
efendim,

24:27.460 --> 24:28.340
while yazmak,

24:28.840 --> 24:29.660
aynı anlamda.

24:30.460 --> 24:31.140
Yine aynı şekilde,

24:31.280 --> 24:31.720
mesela bu,

24:31.720 --> 24:33.260
eksi eşit olsaydı,

24:34.160 --> 24:34.580
bu da,

24:34.980 --> 24:35.340
patch,

24:35.820 --> 24:37.880
sabah karşılık gelecekti.

24:38.600 --> 24:39.000
Efendim,

24:39.000 --> 24:39.440
bu,

24:39.900 --> 24:41.740
bitsel v eşit olsaydı,

24:42.400 --> 24:42.760
patch,

24:43.080 --> 24:44.560
end eşit olacaktı.

24:45.320 --> 24:45.720
Efendim,

24:45.860 --> 24:45.960
bu,

24:46.160 --> 24:47.080
Necati anladık.

24:47.380 --> 24:48.620
Yalnız bir şeye dikkat.

24:49.180 --> 24:49.700
Arkadaşlar,

24:49.780 --> 24:50.000
bakın,

24:50.120 --> 24:51.400
toplama çıkarma var,

24:51.640 --> 24:51.780
ama,

24:51.980 --> 24:52.340
patch,

24:52.540 --> 24:52.980
div,

24:53.680 --> 24:54.080
patch,

24:54.380 --> 24:55.420
multiply diye,

24:55.800 --> 24:57.360
bir fonksiyon yok.

24:58.220 --> 24:58.860
Bu da önemli,

24:59.140 --> 25:00.260
niçin önemli olduğunu,

25:00.980 --> 25:02.400
birazdan göreceğiz.

25:02.400 --> 25:03.860
Yine o zaman,

25:04.180 --> 25:04.620
örneğin,

25:04.820 --> 25:06.580
şöyle bir soru sorulsaydı bize,

25:07.360 --> 25:09.120
x artı eşit,

25:10.020 --> 25:10.940
while ile,

25:11.300 --> 25:11.540
while,

25:11.800 --> 25:13.880
bir uygun ifade,

25:14.620 --> 25:14.960
arkadaşlar,

25:15.260 --> 25:15.620
x,

25:16.300 --> 25:17.640
patch add,

25:18.200 --> 25:19.220
while arasında,

25:19.460 --> 25:21.240
fark nedir diye sorulsaydı,

25:22.080 --> 25:22.940
bunun yine,

25:23.180 --> 25:23.620
arkadaşlar,

25:23.840 --> 25:24.080
bakın,

25:24.260 --> 25:24.920
patch add'i,

25:25.020 --> 25:25.780
bir göstereyim,

25:26.400 --> 25:26.800
x,

25:26.800 --> 25:27.800
patch,

25:27.800 --> 25:29.300
add,

25:29.300 --> 25:31.380
izleyin,

25:32.400 --> 25:32.740
3,

25:33.320 --> 25:34.000
isminde,

25:34.320 --> 25:35.940
patch geçen fonksiyonlar,

25:36.100 --> 25:37.640
hep eski değeri get ediyor,

25:38.720 --> 25:39.180
arkadaşlar,

25:39.440 --> 25:40.200
yeni değeri,

25:40.740 --> 25:41.040
yani,

25:41.280 --> 25:42.120
arttırıyor,

25:42.220 --> 25:42.740
set ediyor,

25:43.040 --> 25:43.280
mesela,

25:43.360 --> 25:44.140
patch add 3,

25:44.620 --> 25:45.020
diyelim ki,

25:45.060 --> 25:46.460
x'in değeri 45'si,

25:46.720 --> 25:48.880
x'in değerini 48 yapacak,

25:49.440 --> 25:49.660
ama,

25:49.760 --> 25:50.740
geri dönüş değeri,

25:51.100 --> 25:52.360
yine 45 olacak,

25:53.060 --> 25:53.300
yani,

25:53.300 --> 25:53.780
içinde,

25:53.980 --> 25:54.900
patch geçenlerin,

25:55.020 --> 25:56.320
hepsinin ortak özelliği,

25:56.800 --> 25:57.580
eski değeri,

25:58.280 --> 25:58.900
get etmesi,

25:58.900 --> 25:59.220
ama,

25:59.340 --> 26:00.660
atama operatörlerinin,

26:01.380 --> 26:02.560
ürettiği değer,

26:02.700 --> 26:03.180
dolayısıyla,

26:03.420 --> 26:03.620
orada,

26:03.740 --> 26:04.800
çarpılan fonksiyonların,

26:04.880 --> 26:05.760
geri dönüş değeri,

26:05.940 --> 26:06.540
nesneye,

26:07.120 --> 26:08.360
yüklenen değer,

26:08.920 --> 26:09.940
takip edebiliyor muyuz,

26:10.060 --> 26:10.260
evet,

26:11.340 --> 26:11.740
peki,

26:11.940 --> 26:12.120
şimdi,

26:12.220 --> 26:13.420
patch'leri de geçtik,

26:13.720 --> 26:14.700
geriye kaldı,

26:14.920 --> 26:16.000
şu fonksiyonlar,

26:16.220 --> 26:16.740
izleyin,

26:17.420 --> 26:17.840
arkadaşlar,

26:18.140 --> 26:18.940
is lock free,

26:19.940 --> 26:20.360
load,

26:20.720 --> 26:21.500
onu gördük,

26:21.500 --> 26:22.500
bir de,

26:22.680 --> 26:22.880
işte,

26:23.000 --> 26:23.460
meşhur,

26:23.980 --> 26:25.040
compare exchange,

26:25.280 --> 26:26.620
strong fonksiyonu,

26:27.460 --> 26:27.820
arkadaşlar,

26:28.020 --> 26:28.180
şimdi,

26:28.180 --> 26:28.480
önce,

26:28.580 --> 26:29.940
compare exchange strong'a,

26:30.260 --> 26:31.140
bir geri dönelim,

26:31.800 --> 26:33.300
bunun nasıl bir işlem olduğunu,

26:33.640 --> 26:34.940
tekrar hatırlayalım,

26:35.760 --> 26:36.440
diyelim ki,

26:36.980 --> 26:37.440
atomic,

26:38.380 --> 26:38.720
int,

26:40.000 --> 26:40.520
şimdi,

26:40.700 --> 26:41.080
recusing,

26:41.160 --> 26:42.720
direktifini kullanıyorum,

26:43.560 --> 26:44.040
atomic,

26:45.040 --> 26:45.440
int,

26:46.160 --> 26:46.580
x,

26:47.580 --> 26:48.020
on,

26:50.520 --> 26:52.040
sadece izleyin,

26:52.040 --> 26:53.960
ya da şöyle,

26:54.380 --> 26:54.760
sitat,

26:56.120 --> 26:56.440
şimdi,

26:56.500 --> 26:56.900
bakınız,

26:57.420 --> 26:57.900
izleyin,

26:59.760 --> 27:00.200
x,

27:02.580 --> 27:04.220
compare exchange strong,

27:06.000 --> 27:07.200
iki tane parametre var,

27:07.520 --> 27:10.400
birinci parametrenin referans olduğuna dikkat edin,

27:10.660 --> 27:11.660
l value referans,

27:11.660 --> 27:12.560
yani,

27:12.560 --> 27:13.440
örneğin ben,

27:14.300 --> 27:14.700
int,

27:15.240 --> 27:16.000
expected,

27:17.080 --> 27:17.580
arkadaşlar,

27:17.980 --> 27:18.720
eşittir,

27:19.000 --> 27:19.440
20,

27:20.400 --> 27:23.500
bu değişkeni fonksiyonun birinci parametresine göndersem,

27:24.400 --> 27:24.740
x,

27:25.120 --> 27:26.280
expected özür dilerim,

27:26.420 --> 27:26.940
expected,

27:28.340 --> 27:28.800
efendim,

27:29.120 --> 27:30.700
ikinci parametresine de,

27:31.780 --> 27:32.480
ne bileyim,

27:32.560 --> 27:34.440
99 değerini göndersem,

27:34.440 --> 27:35.760
şimdi,

27:36.120 --> 27:37.200
geri dönüş değerinde,

27:37.840 --> 27:38.120
bir,

27:38.520 --> 27:39.980
bull değişkeni de tutsam,

27:40.400 --> 27:41.940
fotoyu özellikle kullanmıyorum,

27:43.040 --> 27:44.120
siz görün diye,

27:44.760 --> 27:45.540
şimdi izleyin,

27:45.840 --> 27:46.960
iki tane ihtimal var,

27:47.640 --> 27:47.900
biri,

27:48.980 --> 27:51.380
bu işlem atomik olarak yapıldığında,

27:52.500 --> 27:53.900
expected'ın değeri,

27:54.180 --> 27:54.600
arkadaşlar,

27:54.860 --> 27:56.140
expected'ın değeri,

27:59.460 --> 28:01.780
atomik değişkenin değerine eşit,

28:01.780 --> 28:05.040
yani atomik değişkenin değeri,

28:05.280 --> 28:06.820
örneğin burada zaten 20,

28:07.020 --> 28:08.440
ama bu burada değil değil mi,

28:09.800 --> 28:10.220
eğer,

28:10.600 --> 28:12.340
expected değeri ise,

28:12.700 --> 28:14.360
önce onu göstereyim isterseniz,

28:14.700 --> 28:14.920
10,

28:16.060 --> 28:16.880
bu durumda,

28:17.120 --> 28:18.140
x'in değerini,

28:18.460 --> 28:20.140
desired olarak değiştiriyor,

28:20.400 --> 28:22.440
buradaki terminolojisi de hep aynı,

28:23.240 --> 28:23.840
expected,

28:24.100 --> 28:25.740
ben değişkenimin ismini öyle yaptım,

28:25.820 --> 28:27.440
hatta şöyle göstereyim,

28:27.520 --> 28:28.320
daha da güzel olsun,

28:28.900 --> 28:29.240
int,

28:30.040 --> 28:30.680
desired,

28:31.140 --> 28:31.700
eşitti,

28:31.780 --> 28:33.500
arkadaşlar,

28:34.000 --> 28:34.360
20,

28:35.660 --> 28:36.360
şimdi bakınız,

28:37.160 --> 28:38.840
atomik değişkenin değeri 10,

28:39.140 --> 28:40.160
expected 10,

28:40.960 --> 28:41.820
desired 20,

28:42.520 --> 28:43.140
eşit mi,

28:43.380 --> 28:46.500
expected ile atomik değişkenimizin değeri eşit,

28:47.280 --> 28:47.820
o zaman,

28:48.580 --> 28:50.500
set işlemi başarılı olacak mı,

28:50.580 --> 28:50.920
olacak,

28:51.480 --> 28:52.520
bu işlemden sonra,

28:52.780 --> 28:54.200
x'imizin değeri ne olacak,

28:54.920 --> 28:56.020
99 olacak,

28:56.220 --> 28:57.040
ve fonksiyon,

28:57.320 --> 28:59.120
true değer dönecek,

28:59.120 --> 29:00.100
şimdi,

29:00.100 --> 29:02.320
tek tek bir yazdırmak istiyorum,

29:02.860 --> 29:03.220
arkadaşlar,

29:03.540 --> 29:03.940
önce,

29:05.080 --> 29:06.860
result'un değerini yazdırayım,

29:06.860 --> 29:11.920
burayı anlamamız çok önemli,

29:11.920 --> 29:14.000
biraz karmaşık bir konu çünkü,

29:15.600 --> 29:15.880
evet,

29:16.880 --> 29:18.900
önce rizaltın değerini yazdırıyorum,

29:19.740 --> 29:21.480
tabi burada gördüğümüz gibi,

29:21.860 --> 29:22.960
rizaltın değeri,

29:23.460 --> 29:23.980
arkadaşlar,

29:24.240 --> 29:24.460
true,

29:24.460 --> 29:26.340
ikinci olarak,

29:27.280 --> 29:30.420
benim atomik değişkenimin değerini yazdırıyorum,

29:31.240 --> 29:32.260
x eşittir,

29:33.880 --> 29:34.280
x,

29:35.020 --> 29:36.660
atomik değişkenimin değeri ne olacak,

29:36.760 --> 29:37.360
bu durumda,

29:38.120 --> 29:38.840
değeri değişecek,

29:38.940 --> 29:39.940
99 olacak,

29:43.980 --> 29:48.040
ve expected değişkenimin değeri de değişmeyecek,

29:48.180 --> 29:48.660
arkadaşlar,

29:49.500 --> 29:50.600
onu da yazdıralım,

29:50.600 --> 29:53.500
expected,

29:54.500 --> 29:56.080
yani beklenen,

29:56.200 --> 29:57.400
umulan anlamında,

29:59.580 --> 30:00.280
görüyoruz,

30:00.580 --> 30:01.980
expected'in değeri de,

30:02.180 --> 30:02.940
yine 10,

30:03.800 --> 30:04.180
arkadaşlar,

30:04.460 --> 30:06.020
ama şimdi durumu değiştirelim,

30:06.140 --> 30:07.800
ve expected'in değerini,

30:08.800 --> 30:09.800
ne yapalım,

30:10.120 --> 30:11.000
7 yapalım,

30:11.000 --> 30:12.900
bu durumda,

30:13.100 --> 30:15.240
atomik değişkenimizin değeri 10,

30:15.560 --> 30:17.160
ama expected 7,

30:17.480 --> 30:18.160
eşit değil,

30:19.280 --> 30:20.100
bu durumda,

30:20.300 --> 30:21.220
bir kere fonksiyon,

30:21.360 --> 30:22.260
false dönecek,

30:23.280 --> 30:24.040
buraya dikkat,

30:24.540 --> 30:27.580
değişkenimizin değeri set edilmeyecek,

30:28.680 --> 30:29.160
fakat,

30:29.400 --> 30:31.060
expected değişkenine,

30:31.980 --> 30:34.060
bu atomik değişkenimizin,

30:34.220 --> 30:34.640
arkadaşlar,

30:35.060 --> 30:35.940
değeri yazılacak,

30:36.120 --> 30:37.560
şimdi aradaki parka bakın,

30:38.680 --> 30:39.220
izleyin,

30:39.220 --> 30:43.520
arkadaşlar,

30:43.720 --> 30:43.940
bakın,

30:44.040 --> 30:44.980
result false,

30:45.960 --> 30:46.920
x'in değeri,

30:47.520 --> 30:48.120
yine 10,

30:48.340 --> 30:48.940
değişmedi,

30:49.240 --> 30:51.460
ama expected'in değeri 10 oldu,

30:52.580 --> 30:53.360
yani eğer,

30:53.680 --> 30:54.600
expected'la,

30:54.820 --> 30:56.660
atomik değişkenimizin değeri,

30:56.980 --> 30:57.900
farklıysa,

30:58.800 --> 31:00.960
compare exchange strong fonksiyonu,

31:00.960 --> 31:01.960
bizim,

31:01.960 --> 31:03.900
referans semantiğiyle,

31:03.980 --> 31:05.780
fonksiyonun birinci parametresine,

31:05.880 --> 31:06.700
geçtiğimiz,

31:07.440 --> 31:07.960
arkadaşlar,

31:07.960 --> 31:09.860
değişkene,

31:10.100 --> 31:11.320
atomik değişkenin,

31:11.540 --> 31:12.960
değerini yazıyor,

31:13.600 --> 31:14.840
ve atomik değişkenin,

31:14.900 --> 31:15.440
değerini,

31:15.660 --> 31:16.700
değiştirmiyor,

31:17.500 --> 31:17.880
arkadaşlar,

31:18.060 --> 31:18.260
bakın,

31:18.360 --> 31:18.860
şimdi bu,

31:18.940 --> 31:19.480
C++,

31:20.060 --> 31:21.100
camiasının,

31:21.740 --> 31:22.320
yine böyle,

31:22.860 --> 31:23.280
önemli,

31:23.660 --> 31:24.480
tiplerinden,

31:25.540 --> 31:26.740
konferans konuşmalarında,

31:26.740 --> 31:27.100
falan,

31:27.100 --> 31:28.860
görmüşsünüzdür,

31:29.600 --> 31:30.020
P4,

31:30.240 --> 31:30.540
P4,

31:30.540 --> 31:30.640
P4,

31:30.640 --> 31:31.140
P4,

31:31.140 --> 31:31.640
P4,

31:31.640 --> 31:32.520
şöyle yazayım ki,

31:32.660 --> 31:33.780
derlenmeyecek çünkü,

31:34.780 --> 31:35.600
bir sunumunda,

31:36.320 --> 31:36.980
açık bir şekilde,

31:37.140 --> 31:37.980
şöyle gösteriyor,

31:38.100 --> 31:38.640
diyor ki,

31:39.400 --> 31:40.500
compare exchange,

31:40.880 --> 31:41.720
strong,

31:41.840 --> 31:43.100
aslında şöyle bir işlem,

31:43.760 --> 31:44.720
T türünden,

31:44.920 --> 31:46.360
bunun bir template olduğunu düşünün,

31:46.640 --> 31:47.300
herhangi bir tür,

31:47.820 --> 31:48.320
expected,

31:48.520 --> 31:49.300
T türünden,

31:49.300 --> 31:49.840
design,

31:50.620 --> 31:51.120
bu işlem,

31:51.200 --> 31:51.560
sanki,

31:51.740 --> 31:52.920
tabi böyle aslında değil,

31:53.080 --> 31:55.220
sanki bir kilit varmış gibi yapılıyor,

31:55.380 --> 31:57.120
atomik olduğunu göstermek için,

31:58.000 --> 31:58.600
ama bakın,

31:59.220 --> 32:00.400
atomik değişkenin,

32:00.740 --> 32:01.560
buradaki value,

32:01.660 --> 32:03.300
atomik değişkenimizin değeri,

32:04.080 --> 32:05.660
atomik değişkenimizin değeri,

32:05.760 --> 32:06.200
ne oluyor,

32:06.640 --> 32:07.100
arkadaşlar,

32:08.020 --> 32:08.360
eğer,

32:08.520 --> 32:10.280
expected'a eşit değilse,

32:10.620 --> 32:11.540
expected'ın,

32:11.800 --> 32:12.380
değerini,

32:12.580 --> 32:13.860
atomik değişkenimizin,

32:13.960 --> 32:14.540
değeri yapıyor,

32:14.700 --> 32:15.540
ve false dönüyor,

32:15.540 --> 32:19.200
ama değişkenin değeri,

32:19.700 --> 32:20.660
expected'sa,

32:20.800 --> 32:21.700
görüyorsunuz,

32:22.420 --> 32:23.160
value burada,

32:23.340 --> 32:23.820
atomik,

32:24.040 --> 32:24.220
yani,

32:24.320 --> 32:25.520
this of value anlamında,

32:25.900 --> 32:26.680
bu sonuçta,

32:26.760 --> 32:27.540
üye fonksiyon,

32:28.200 --> 32:29.020
desire't yapıyor,

32:29.480 --> 32:30.620
ve true dönüyor,

32:31.420 --> 32:32.320
burayı anladık mı,

32:32.940 --> 32:34.220
şimdi diyeceksiniz ki,

32:34.620 --> 32:35.660
başlangıçta,

32:35.660 --> 32:37.360
bu ne işe yarar,

32:37.980 --> 32:39.220
bir kere şurası açık,

32:39.620 --> 32:40.080
arkadaşlar,

32:41.000 --> 32:41.560
örneğin,

32:41.880 --> 32:42.160
ben,

32:42.160 --> 32:47.060
belirli bir koşul oluştuğunda,

32:47.260 --> 32:47.720
sadece,

32:48.320 --> 32:49.460
atomik değişkenimin,

32:49.640 --> 32:51.780
değerini değiştirmek istiyorsam,

32:52.660 --> 32:53.560
yani örneğin,

32:55.800 --> 32:56.640
atomikin,

32:57.360 --> 32:58.660
int açılımı,

32:59.620 --> 33:00.000
x,

33:00.380 --> 33:00.840
12,

33:01.780 --> 33:02.260
arkadaşlar,

33:03.200 --> 33:03.520
efendim,

33:03.960 --> 33:04.820
x'in değeri,

33:04.940 --> 33:05.900
şu değerse,

33:06.180 --> 33:07.240
x'in değerini,

33:07.240 --> 33:10.880
bu değer yapmak istiyorsam,

33:10.880 --> 33:13.060
böyle bir if deyimine ihtiyacım var,

33:13.280 --> 33:13.560
if,

33:15.060 --> 33:15.560
x,

33:17.240 --> 33:18.740
compare exchange strong,

33:20.080 --> 33:20.620
arkadaşlar,

33:21.300 --> 33:21.880
expected,

33:23.260 --> 33:23.660
int,

33:24.560 --> 33:25.280
e diyelim,

33:26.520 --> 33:27.280
eşittir,

33:27.700 --> 33:28.100
5,

33:31.320 --> 33:31.640
e,

33:32.680 --> 33:34.040
ve,

33:34.040 --> 33:34.920
diyelim ki,

33:35.440 --> 33:35.720
10,

33:35.720 --> 33:38.280
eğer işte,

33:38.760 --> 33:40.060
bu koşul doğruysa,

33:40.740 --> 33:40.960
yani,

33:41.060 --> 33:42.040
true dönerse,

33:42.740 --> 33:43.320
demek ki,

33:43.920 --> 33:44.200
benim,

33:44.420 --> 33:45.080
bu noktada,

33:45.240 --> 33:46.240
trade'in çalışmasında,

33:46.320 --> 33:46.940
bu noktada,

33:47.100 --> 33:48.020
atomik değişkenimin,

33:48.220 --> 33:48.540
değeri,

33:48.780 --> 33:49.420
5'miş,

33:50.020 --> 33:50.440
ve onu,

33:50.780 --> 33:52.160
10 yaptığımdan eminim,

33:53.800 --> 33:55.040
ifin doğru kısmına,

33:55.120 --> 33:55.660
girmiyorsa,

33:56.020 --> 33:56.540
demek ki,

33:56.580 --> 33:56.760
benim,

33:56.760 --> 33:58.380
10'u okuduğum noktada,

33:58.580 --> 33:59.300
onun değeri,

34:00.020 --> 34:00.740
ne değilmiş,

34:00.940 --> 34:01.420
arkadaşlar,

34:01.720 --> 34:02.080
5,

34:02.400 --> 34:03.000
değilmiş,

34:03.000 --> 34:04.280
fakat,

34:04.540 --> 34:05.840
asıl kritik nokta,

34:05.920 --> 34:06.640
burası değil,

34:07.680 --> 34:08.040
arkadaşlar,

34:08.320 --> 34:09.660
asıl kritik nokta,

34:10.840 --> 34:11.080
şu,

34:11.600 --> 34:11.880
bakın,

34:12.260 --> 34:13.020
şimdi ben sizden,

34:13.100 --> 34:14.100
şöyle bir şey istesem,

34:14.400 --> 34:15.900
atomik bir değişkeniniz var,

34:16.000 --> 34:16.720
buraya dikkat,

34:19.340 --> 34:20.600
atomik değişkenin,

34:22.300 --> 34:23.660
değerini,

34:24.320 --> 34:25.420
5 katına çıkarın,

34:27.480 --> 34:28.440
yani,

34:28.600 --> 34:29.280
12 ise,

34:29.860 --> 34:30.360
arkadaşlar,

34:30.560 --> 34:31.780
60 yapacaksınız,

34:31.780 --> 34:33.720
20 ise,

34:34.860 --> 34:36.220
100 yapacaksınız,

34:37.840 --> 34:38.280
o zaman,

34:38.500 --> 34:38.920
tabii,

34:39.020 --> 34:40.000
değerin ne olduğunda,

34:40.100 --> 34:40.920
bilmiyorsunuz,

34:41.080 --> 34:42.180
şöyle bir şey yazmanız,

34:42.240 --> 34:42.620
gerekir,

34:42.700 --> 34:43.000
değil mi,

34:43.940 --> 34:44.280
int,

34:44.600 --> 34:45.380
diyelim ki,

34:46.600 --> 34:47.860
val,

34:48.660 --> 34:49.420
eşittir,

34:49.800 --> 34:51.380
x'in load'u,

34:52.960 --> 34:53.440
arkadaşlar,

34:54.860 --> 34:55.680
ondan sonra,

34:57.080 --> 34:57.960
söyleyin,

34:57.960 --> 34:59.180
x,

34:59.180 --> 34:59.240
x,

34:59.240 --> 35:01.500
store,

35:01.500 --> 35:03.520
kaç,

35:04.640 --> 35:05.180
efendim,

35:05.700 --> 35:06.320
1,

35:06.820 --> 35:08.100
çarpı 5,

35:08.360 --> 35:08.680
hatta,

35:08.740 --> 35:09.220
isterseniz,

35:09.340 --> 35:09.840
şöyle yapan,

35:10.580 --> 35:11.240
intemp,

35:12.680 --> 35:13.000
ya da,

35:13.080 --> 35:13.660
belki zaten,

35:14.060 --> 35:15.020
atomik değişken değil,

35:15.380 --> 35:15.680
x,

35:15.760 --> 35:16.040
store,

35:17.040 --> 35:17.360
1,

35:17.420 --> 35:18.020
çarpı,

35:18.720 --> 35:18.920
5,

35:19.000 --> 35:20.780
böyle bir işlem yaptığınızı düşünelim,

35:20.780 --> 35:22.260
arkadaşlar,

35:22.480 --> 35:23.640
şimdi şöyle bir şey olabilir,

35:23.820 --> 35:24.100
değil mi,

35:25.000 --> 35:26.240
bu load'la,

35:27.340 --> 35:28.260
store arasına,

35:28.640 --> 35:29.420
buraya dikkat,

35:30.420 --> 35:31.480
ayrı bir thread'in,

35:31.560 --> 35:32.720
bir işlemi gelse,

35:33.900 --> 35:35.700
o valin değerini,

35:36.060 --> 35:36.880
değiştirse,

35:37.540 --> 35:38.620
takip edebiliyor muyuz,

35:38.900 --> 35:39.360
özür dilerim,

35:39.420 --> 35:40.380
atomik değişkenin,

35:40.440 --> 35:41.520
değerini değiştirse,

35:41.520 --> 35:43.680
bu durumda,

35:44.000 --> 35:45.880
sizin yaptığınız işlemin,

35:46.160 --> 35:47.680
lojik yapısı açısından,

35:48.780 --> 35:50.220
en son değeri neyse,

35:50.920 --> 35:53.080
onun 5 katına çıkartmanız gerekir,

35:53.900 --> 35:55.220
ama şimdi diyelim ki,

35:55.540 --> 35:57.080
x'in değeri 12 iken,

35:57.800 --> 36:00.460
eğer araya herhangi bir thread girmezse,

36:01.160 --> 36:02.760
x'in değeri 60 olacak,

36:02.900 --> 36:03.440
öyle değil mi,

36:04.120 --> 36:05.820
ama araya bir thread girdi,

36:06.820 --> 36:09.160
atomik değişkenin değerini değiştirdi,

36:09.160 --> 36:10.540
bakınız bu işlem atomik,

36:10.620 --> 36:11.560
bu işlem atomik,

36:11.700 --> 36:11.960
ama,

36:12.780 --> 36:14.700
bu ikisi birden atomik değil ki,

36:15.200 --> 36:15.540
burada,

36:16.460 --> 36:19.180
araya bir thread girdi,

36:20.020 --> 36:20.280
ve,

36:20.640 --> 36:22.220
x'in değerini,

36:22.840 --> 36:23.480
diyelim ki,

36:24.340 --> 36:25.700
20 yaptı,

36:27.360 --> 36:28.140
bu durumda,

36:28.480 --> 36:30.180
bizim yaptığımız store işlemi,

36:30.180 --> 36:32.260
x'in değerini 60 değil,

36:32.580 --> 36:33.760
ne yapması gerekir,

36:34.780 --> 36:36.220
100 yapması gerekir,

36:36.940 --> 36:37.380
arkadaşlar,

36:37.380 --> 36:39.880
basit bir problem gibi görünüyor ama,

36:40.300 --> 36:42.020
bu atomik değişkenler de,

36:42.120 --> 36:43.980
en çok veri yapılarında kullanılıyor,

36:44.620 --> 36:46.260
lock free veri yapılarında,

36:47.000 --> 36:48.720
orada bu büyük önem kazanacak,

36:49.360 --> 36:49.660
yani,

36:49.980 --> 36:52.440
eğer işte böyle araya bir thread girerse,

36:52.680 --> 36:53.780
siz bir pointerı,

36:53.940 --> 36:56.240
dandling pointer olarak kullanabilirsiniz,

36:57.060 --> 36:57.440
efendim,

36:57.620 --> 36:59.520
düğümü eklediğiniz düğüm,

36:59.780 --> 37:00.980
eklenmemiş olabilir,

37:01.140 --> 37:01.380
vs.

37:01.380 --> 37:03.140
burayı anladık mı,

37:03.740 --> 37:04.520
şimdi soru,

37:05.100 --> 37:05.460
peki,

37:05.800 --> 37:06.960
ne olacak da,

37:07.240 --> 37:07.540
ben,

37:08.340 --> 37:10.940
araya başka bir thread girse dahi,

37:11.160 --> 37:11.860
buraya dikkat,

37:12.480 --> 37:13.320
ne olacak ki,

37:13.400 --> 37:13.620
ben,

37:13.840 --> 37:16.660
araya başka bir thread girse dahi,

37:16.720 --> 37:17.440
burada,

37:17.880 --> 37:18.360
arkadaşlar,

37:18.580 --> 37:19.360
değişkenimin,

37:20.120 --> 37:20.720
değerini,

37:21.020 --> 37:21.960
eski değerinin,

37:22.200 --> 37:22.520
örneğin,

37:22.600 --> 37:23.820
iki katı yaptığıma,

37:24.060 --> 37:24.700
emin olayım,

37:24.700 --> 37:26.520
hocam,

37:26.620 --> 37:27.600
atomik değişkenlere,

37:27.680 --> 37:29.560
critical section gibi bakmak lazım,

37:29.680 --> 37:30.540
o zaten açık,

37:31.260 --> 37:31.460
yani,

37:31.580 --> 37:32.920
atomik değişken üstünde,

37:33.360 --> 37:34.900
bir işlem yapılırken,

37:34.980 --> 37:36.560
atomik bir işlem yapılırken,

37:37.060 --> 37:38.380
araya başka bir şey giremiyor,

37:38.500 --> 37:40.100
ama şimdi artık onu geçtik zaten,

37:40.300 --> 37:41.840
anlaşıldı değil mi,

37:41.860 --> 37:42.880
o zaten garanti,

37:43.060 --> 37:44.180
ilerleyen dakikalarda,

37:44.940 --> 37:45.400
göreceğiz,

37:46.020 --> 37:46.880
arkadaşlar bakın,

37:46.880 --> 37:48.700
şöyle bir kod yazsam,

37:51.260 --> 37:51.720
önce,

37:53.180 --> 37:54.540
ben bu değişkenin değerini,

37:54.540 --> 37:55.220
get etsem,

37:56.220 --> 37:56.660
mesela,

37:57.620 --> 37:57.960
auto,

37:58.480 --> 37:59.040
arkadaşlar,

37:59.520 --> 38:00.260
old value,

38:01.660 --> 38:02.460
eşittir,

38:02.820 --> 38:04.280
x'in load'u,

38:05.700 --> 38:06.820
takip edebiliyor muyuz,

38:07.320 --> 38:07.580
evet,

38:08.220 --> 38:10.040
şimdi buraya şöyle bir döngü koysam,

38:10.460 --> 38:10.820
while,

38:12.960 --> 38:14.460
birazdan yazacağım kodu,

38:14.460 --> 38:17.200
hemen kavramakta zorluk çekeceksiniz,

38:17.320 --> 38:19.020
o yüzden dikkatli izlemeniz gerekiyor,

38:19.120 --> 38:19.600
ama hemen,

38:20.160 --> 38:21.440
anlamadım diye üzülmeyin,

38:22.160 --> 38:23.460
burada da şöyle bir şey arasın,

38:23.720 --> 38:24.260
x'in,

38:24.540 --> 38:26.240
arkadaşlar,

38:26.960 --> 38:28.800
compare exchange strong,

38:29.160 --> 38:31.120
old value,

38:34.020 --> 38:34.280
ve,

38:35.280 --> 38:36.000
diyelim ki,

38:36.340 --> 38:36.760
arkadaşlar,

38:37.300 --> 38:38.660
old value,

38:39.660 --> 38:40.360
çarpı,

38:40.880 --> 38:41.180
2,

38:42.220 --> 38:43.740
takip edebiliyor muyuz,

38:44.260 --> 38:44.520
evet,

38:44.920 --> 38:45.280
arkadaşlar,

38:45.460 --> 38:46.400
döngünün gövdesini,

38:46.460 --> 38:48.060
özellikle null statement yaptım,

38:48.060 --> 38:52.520
şu var döngüsünü,

38:52.520 --> 38:53.520
şu var döngüsünü,

38:53.520 --> 38:55.920
bir adam akıllı inceleyelim,

38:56.520 --> 38:56.940
bir kere,

38:57.540 --> 39:00.520
bu ifade yanlış olduğu sürece dönen bir döngü değil mi?

39:00.520 --> 39:01.980
kesinlikle,

39:01.980 --> 39:05.980
bu ifade yanlış olduğu sürece dönen bir döngü,

39:05.980 --> 39:09.440
o zaman bu ifade yanlış olduğu sürece,

39:10.220 --> 39:14.400
aslında benim atomik değişkenimin değeri değişmemiş demektir,

39:14.400 --> 39:15.680
çünkü değişseydi,

39:16.620 --> 39:18.780
yani atomik değişkenimin değerini,

39:18.980 --> 39:20.940
old value çarpı 2 yapsa,

39:21.080 --> 39:22.180
yapmış olsaydı,

39:22.740 --> 39:23.060
yiğit,

39:23.140 --> 39:25.400
o zaman zaten true dönecekti değil mi?

39:25.640 --> 39:26.800
herkes takip ediyor mu?

39:26.800 --> 39:29.060
ama çok önemli bir şey var,

39:29.420 --> 39:29.920
o da şu,

39:31.080 --> 39:33.540
bu işlem atomik olarak yapılıyor bir,

39:33.860 --> 39:34.540
ikincisi,

39:35.500 --> 39:37.580
eğer expected'ın değeri,

39:37.920 --> 39:38.480
bakın,

39:38.680 --> 39:39.820
expected'ın değeri,

39:40.540 --> 39:44.300
atomik değişkenin değerine eşit değilse,

39:45.240 --> 39:46.980
expected'a neyi yazıyordu?

39:47.340 --> 39:49.600
atomik değişkenin değerini yazıyordu,

39:50.660 --> 39:52.160
o zaman diyelim ki,

39:52.460 --> 39:54.600
atomik değişkenin araya bir thread girdi,

39:54.600 --> 39:57.820
atomik değişkenin değerini 20 yaptı,

39:58.620 --> 40:00.560
o zaman başarısız olduktan sonra,

40:00.900 --> 40:01.360
arkadaşlar,

40:02.200 --> 40:03.680
başarısız olduktan sonra,

40:03.960 --> 40:05.240
bu değişkenin değeri,

40:05.460 --> 40:06.260
izleyin,

40:06.840 --> 40:08.140
bu değişkenin değeri,

40:08.800 --> 40:09.320
arkadaşlar,

40:10.020 --> 40:12.260
bu durumda 20 olacak değil mi?

40:13.080 --> 40:14.820
o zaman döngünün bir sonraki,

40:14.920 --> 40:15.920
ve post dönecek,

40:16.680 --> 40:18.460
döngünün bir sonraki turunda,

40:19.240 --> 40:21.060
atomik değişkenimizin değeri,

40:21.400 --> 40:22.520
halen 20 ise,

40:22.520 --> 40:23.920
o zaman,

40:24.600 --> 40:26.420
bu set işlemi,

40:26.660 --> 40:28.740
onun değerini 40 yapacak,

40:30.280 --> 40:31.540
old value eşittir,

40:31.640 --> 40:33.740
x nokta load demem gerekmiyor,

40:34.140 --> 40:36.460
zaten kredit noktada orayı anlamanız,

40:37.060 --> 40:39.600
çünkü compare exchange strong fonksiyonu,

40:40.500 --> 40:42.980
zaten set işlemi yapılmadığında,

40:43.660 --> 40:45.980
o sizin load dediğiniz değeri,

40:46.080 --> 40:47.700
zaten old value'ya yazıyor,

40:47.700 --> 40:49.260
şimdi anladınız mı?

40:50.780 --> 40:52.380
herkes bir kere baksın,

40:53.100 --> 40:54.560
biraz gerçekten,

40:54.720 --> 40:55.740
bu atomik işlemlerle,

40:55.840 --> 40:56.900
ilk tanıştığımızda,

40:57.040 --> 40:58.300
hep tuhaf geliyor bu,

40:58.660 --> 40:59.420
kas işlemi,

41:00.000 --> 41:00.420
arkadaşlar,

41:00.860 --> 41:01.760
gördüğümüz gibi,

41:02.440 --> 41:03.360
aslında burada,

41:03.860 --> 41:05.360
ben ne garantisini,

41:05.480 --> 41:06.560
elde etmiş oluyorum,

41:06.560 --> 41:09.180
bu atomik işlem yapıldığında,

41:09.180 --> 41:11.500
bir önceki atomik işlemle,

41:11.700 --> 41:13.280
araya başka bir threadin,

41:13.420 --> 41:16.180
örneğin bir atomik işlemi girse dahi,

41:16.940 --> 41:21.180
yani benim atomik değişkenimin değeri değişse dahi,

41:21.800 --> 41:22.140
ben,

41:22.620 --> 41:23.220
arkadaşlar,

41:23.720 --> 41:25.840
o değişmiş değer üstünden,

41:25.980 --> 41:26.940
bu işlemi yapacağım,

41:27.060 --> 41:27.860
yapmış olacağım,

41:27.860 --> 41:29.440
anlaşıldı mı?

41:30.260 --> 41:30.520
Evet.

41:33.440 --> 41:34.240
Peki,

41:34.900 --> 41:35.300
arkadaşlar,

41:35.460 --> 41:36.020
bakın şimdi,

41:36.580 --> 41:38.160
bu compare exchange,

41:38.660 --> 41:40.040
strong ile ilgili,

41:41.120 --> 41:42.020
geçen yazdığımız,

41:42.260 --> 41:43.020
spinlock'u,

41:43.320 --> 41:43.800
bu sefer,

41:44.100 --> 41:45.160
compare exchange,

41:45.820 --> 41:46.480
strong ile,

41:46.840 --> 41:47.940
implement ettim,

41:48.800 --> 41:49.040
ve,

41:49.700 --> 41:50.660
o koda bir bakalım,

41:53.560 --> 41:54.560
şimdi bakın,

41:54.680 --> 41:55.500
yine spinlock,

41:56.340 --> 41:57.260
neydi spinlock?

41:57.860 --> 41:59.740
Hocam,

41:59.820 --> 42:00.620
bu while döngüsü,

42:00.660 --> 42:02.100
maksimum iki defa mı döner,

42:02.220 --> 42:03.940
araya başka bir thread girmez ise,

42:04.900 --> 42:05.360
bakalım,

42:05.780 --> 42:06.920
soruyu anlamaya çalışayım.

42:08.740 --> 42:10.980
Araya başka bir thread girmezse,

42:11.540 --> 42:12.000
arkadaşlar,

42:13.260 --> 42:15.280
x'in değeri,

42:16.360 --> 42:17.340
bu old value,

42:17.760 --> 42:19.360
eğer değişmemişse,

42:20.500 --> 42:21.060
zaten,

42:22.140 --> 42:23.660
bu döngünün gövdesine,

42:23.660 --> 42:25.180
bir kere bile girmeyecek,

42:25.300 --> 42:26.540
hemen döngüden çıkacak.

42:26.540 --> 42:28.540
ama değişmişse,

42:29.820 --> 42:31.260
old value yazılacak.

42:32.080 --> 42:32.720
Anlaşıldı mı?

42:34.160 --> 42:34.460
Evet.

42:37.820 --> 42:40.340
Araya başka bir thread girse dahi,

42:40.720 --> 42:41.620
zaten yine,

42:42.000 --> 42:42.840
biz bu sefer,

42:43.640 --> 42:44.100
old value,

42:44.280 --> 42:45.260
x'in değeri,

42:45.340 --> 42:46.420
otomik değişkenin değeri,

42:46.540 --> 42:47.300
değişse dahi,

42:47.460 --> 42:49.340
yine onu yazmış oluyoruz,

42:49.840 --> 42:51.420
birinci parametre değişkenine,

42:51.540 --> 42:52.540
geçtiğimiz nesneye.

42:52.540 --> 42:53.160
nesneye.

42:54.980 --> 42:55.240
Evet,

42:55.380 --> 42:56.080
şimdi bakalım,

42:57.520 --> 42:57.940
tekrar,

43:01.740 --> 43:02.680
buraya geri döneyim,

43:02.760 --> 43:03.640
biraz bekleteceğim.

43:08.140 --> 43:08.800
Arkadaşlar,

43:08.860 --> 43:09.520
bazı kodlarının,

43:09.600 --> 43:10.620
üstünden çok hızlı geçeceğim,

43:10.700 --> 43:10.960
çünkü,

43:11.280 --> 43:12.540
vakit problemi var.

43:13.880 --> 43:14.540
Bakın,

43:14.580 --> 43:14.780
yine,

43:15.160 --> 43:15.580
burada,

43:15.780 --> 43:16.240
bizim bir,

43:16.460 --> 43:18.020
atomik değişkenimiz var,

43:18.740 --> 43:19.180
flag,

43:20.000 --> 43:21.340
post değeriyle başlıyor,

43:21.340 --> 43:22.780
aslında,

43:23.040 --> 43:24.540
lag fonksiyonu,

43:24.640 --> 43:25.020
önce,

43:25.460 --> 43:26.060
expected,

43:26.800 --> 43:27.620
değişkeninin,

43:27.980 --> 43:28.560
değerini,

43:30.660 --> 43:31.920
false yapıyor.

43:33.620 --> 43:34.620
Arkadaşlar,

43:34.700 --> 43:35.320
takip edin.

43:36.380 --> 43:36.660
Ve,

43:37.400 --> 43:39.040
compare action strong'u,

43:39.300 --> 43:40.820
çağırarak,

43:41.180 --> 43:42.180
onun değerini,

43:42.580 --> 43:44.200
true yapmaya çalışıyor.

43:45.080 --> 43:46.160
Takip edebiliyor muyuz?

43:47.200 --> 43:47.920
Arkadaşlar,

43:48.100 --> 43:48.580
o zaman,

43:49.420 --> 43:49.720
eğer,

43:49.720 --> 43:51.340
true yapamadıysa,

43:51.580 --> 43:52.680
tekrar false yapıyor.

43:53.260 --> 43:53.920
O zaman,

43:54.060 --> 43:54.300
şimdi,

43:54.580 --> 43:55.380
söyleyin bakalım,

43:55.840 --> 43:56.620
diyelim ki,

43:57.420 --> 43:58.340
tahmin edin,

43:58.440 --> 43:58.720
burada,

44:00.680 --> 44:01.540
false olması,

44:01.840 --> 44:03.080
kilidin alınabileceği,

44:03.080 --> 44:03.840
anlamına geliyor,

44:04.020 --> 44:04.240
değil mi?

44:04.320 --> 44:05.860
Bizim flag değişkenimizin,

44:06.640 --> 44:06.940
yani,

44:07.300 --> 44:08.400
şu değişkenimizin,

44:09.040 --> 44:09.500
flag'in.

44:10.340 --> 44:11.000
Takip edin,

44:11.200 --> 44:11.940
arkadaşlar.

44:12.780 --> 44:13.000
Evet,

44:13.720 --> 44:14.240
o zaman,

44:14.680 --> 44:15.860
flag değişkeni,

44:16.040 --> 44:17.740
bu döngüden çıkması için,

44:17.740 --> 44:19.000
arkadaşlar,

44:19.960 --> 44:21.560
bu döngüden çıkması için,

44:21.760 --> 44:22.780
true yapması lazım.

44:22.980 --> 44:23.860
True yaptığı zaman,

44:23.940 --> 44:24.840
döngüden çıkacak.

44:25.560 --> 44:25.720
E,

44:25.780 --> 44:26.700
true yaptığı zaman,

44:26.800 --> 44:28.200
döngüden çıkacağına göre,

44:29.000 --> 44:29.540
o zaman,

44:30.240 --> 44:32.480
false değeriyle gelenler,

44:32.960 --> 44:33.280
burada,

44:33.800 --> 44:34.420
sürekli,

44:34.960 --> 44:35.480
dönecek.

44:35.680 --> 44:35.980
Çünkü,

44:36.380 --> 44:37.800
hiçbir zaman eşit olmayacak.

44:38.500 --> 44:39.440
Ne zamanki,

44:39.740 --> 44:40.780
unlock fonksiyonu,

44:40.840 --> 44:41.440
çağrılacak.

44:41.940 --> 44:42.880
Unlock fonksiyonu,

44:42.940 --> 44:44.060
flag değişkenimizin,

44:44.120 --> 44:44.560
değerini,

44:44.640 --> 44:45.840
tekrar false yapacak.

44:45.840 --> 44:47.160
O zaman,

44:47.880 --> 44:49.120
herhangi bir thread,

44:49.560 --> 44:50.900
bizim spin lock'ımızın,

44:51.020 --> 44:51.920
lock fonksiyonunu,

44:52.020 --> 44:52.740
çağırdığında,

44:53.480 --> 44:53.940
o zaman,

44:54.300 --> 44:54.760
tekrar,

44:55.480 --> 44:56.920
bu flag değişkeni,

44:57.060 --> 44:58.160
false olduğu için,

44:58.900 --> 44:59.200
onu,

44:59.480 --> 45:00.700
true yapma şansı,

45:00.900 --> 45:01.540
elde edecek.

45:01.680 --> 45:02.120
Arkadaşlar,

45:02.180 --> 45:02.380
bakın,

45:02.480 --> 45:02.760
gerçi,

45:03.120 --> 45:03.980
buraya da yazmışım,

45:04.080 --> 45:04.840
false olması,

45:04.960 --> 45:05.420
unlocked,

45:06.300 --> 45:06.960
true olması,

45:07.080 --> 45:07.280
locked.

45:07.800 --> 45:09.300
Biraz karmaşık gibi görünüyor.

45:09.880 --> 45:10.800
Zaten bu kodlar,

45:10.980 --> 45:11.460
dedim ya,

45:11.600 --> 45:12.420
biraz zihinsel,

45:12.660 --> 45:14.620
açıdan karmaşık geliyor her zaman.

45:14.620 --> 45:18.600
ama bir alıcı gözüyle bakıp,

45:19.600 --> 45:20.380
spin lock'ın,

45:20.700 --> 45:21.820
lock fonksiyonunun,

45:22.780 --> 45:23.280
arkadaşlar,

45:23.700 --> 45:25.200
kilidi nasıl,

45:25.680 --> 45:27.340
kilitlediğini,

45:28.340 --> 45:29.800
nasıl kilidi aldığını,

45:29.940 --> 45:30.980
anlamaya çalışın.

45:32.260 --> 45:32.840
Burada,

45:33.720 --> 45:35.540
biz flag değişkenimizin,

45:35.600 --> 45:36.040
değerini,

45:36.160 --> 45:37.660
true yapabilmemiz için,

45:38.020 --> 45:39.120
bir önceki değerinin,

45:39.220 --> 45:40.260
false olması lazım.

45:40.260 --> 45:43.240
bir önceki değerin,

45:43.360 --> 45:44.040
false olması,

45:44.200 --> 45:45.020
zaten kilidin,

45:45.080 --> 45:46.160
boşta olması demek,

45:46.380 --> 45:47.560
unlocked olması demek.

45:48.740 --> 45:49.040
O zaman,

45:49.140 --> 45:50.260
herhangi bir noktada,

45:51.120 --> 45:51.960
eğer ben onu,

45:52.180 --> 45:53.820
false olarak yakalarsam,

45:54.780 --> 45:55.020
ve,

45:55.420 --> 45:56.120
bu döngüde,

45:56.340 --> 45:57.540
sürekli spin atacağım,

45:57.680 --> 45:58.900
sürekli spin atacağım.

45:59.660 --> 46:00.020
Yani,

46:00.300 --> 46:01.500
false olduğu için,

46:02.220 --> 46:03.500
true olduğu için,

46:03.500 --> 46:04.960
buradan çıkamayacak.

46:04.960 --> 46:07.860
ama ne zamanki,

46:08.380 --> 46:08.840
arkadaşlar,

46:09.520 --> 46:09.840
tekrar,

46:10.000 --> 46:10.680
false'dayken,

46:10.800 --> 46:11.740
burada yakalarsa,

46:12.680 --> 46:13.860
bu döngüden çıkacak,

46:14.140 --> 46:14.720
vekili de,

46:14.820 --> 46:15.480
sahip olacak.

46:15.660 --> 46:16.320
Anlock'ta,

46:17.040 --> 46:17.500
tekrar,

46:17.820 --> 46:18.220
sınıfın,

46:18.280 --> 46:19.040
veri elemanından,

46:19.200 --> 46:20.480
statik veri elemanı olan,

46:20.620 --> 46:21.060
flag'i,

46:21.320 --> 46:22.460
false değere çekecek.

46:24.800 --> 46:25.560
Arkadaşlar,

46:25.640 --> 46:26.460
dikkat ederseniz,

46:26.660 --> 46:26.920
burada,

46:27.100 --> 46:28.060
daha önceki örnekte,

46:28.060 --> 46:28.960
olduğu gibi,

46:29.340 --> 46:30.300
atomic flag'de de,

46:30.380 --> 46:31.140
bunu yapmıştık.

46:33.080 --> 46:33.920
Birini yok,

46:33.920 --> 46:35.940
thread'in bloke olması,

46:36.020 --> 46:36.840
söz konusu değil.

46:37.840 --> 46:38.520
Sürekli,

46:39.180 --> 46:39.720
arkadaşlar,

46:40.000 --> 46:41.120
bu programın,

46:41.260 --> 46:41.880
akışı,

46:41.940 --> 46:43.400
thread'i buraya geldiğinde,

46:44.200 --> 46:45.200
sürekli aslında,

46:45.780 --> 46:46.040
burada,

46:47.080 --> 46:47.780
bizim,

46:48.140 --> 46:49.220
lag fonksiyonu,

46:50.480 --> 46:51.440
flag'in,

46:51.520 --> 46:52.220
compare'e,

46:52.360 --> 46:53.820
strong fonksiyonunu çağırıyor.

46:54.560 --> 46:55.060
Arkadaşlar,

46:55.140 --> 46:55.540
gerçekten,

46:56.060 --> 46:56.840
bir bug var mı,

46:56.840 --> 46:57.320
yok mu,

46:57.520 --> 46:58.800
onu göstermek için,

46:59.700 --> 47:00.180
bir tane,

47:00.520 --> 47:01.760
shared data oluşturdum.

47:01.880 --> 47:02.500
Inktur'dan,

47:02.600 --> 47:03.460
değeri sıfır.

47:03.920 --> 47:05.580
10.000 kez dönen,

47:05.740 --> 47:07.100
bir döngü görüyorsunuz.

47:07.320 --> 47:07.820
Döngünün,

47:07.880 --> 47:08.580
her turunda,

47:09.620 --> 47:10.260
spin lag,

47:10.700 --> 47:12.220
şu global değişkeni mi,

47:12.960 --> 47:13.380
arkadaşlar,

47:13.580 --> 47:13.820
bu da,

47:13.940 --> 47:15.340
adeta bir mutex değil mi?

47:16.840 --> 47:17.620
Önce,

47:17.760 --> 47:19.160
lag fonksiyonunu çağırarak,

47:19.700 --> 47:20.360
kilitledim.

47:21.100 --> 47:21.860
Kilit altında,

47:22.020 --> 47:23.200
shared data'yı arttırdım.

47:23.280 --> 47:23.520
Bakın,

47:23.660 --> 47:24.440
eğer programın,

47:24.440 --> 47:25.600
akışı buradaysa,

47:26.480 --> 47:27.220
buraya gelen,

47:27.460 --> 47:28.600
bütün thread'ler,

47:29.540 --> 47:31.520
lag fonksiyonunu çağırdığımda,

47:31.520 --> 47:32.840
o zaman,

47:33.160 --> 47:34.240
lag fonksiyonu,

47:34.380 --> 47:34.800
arkadaşlar,

47:35.060 --> 47:35.420
burada,

47:36.620 --> 47:37.180
dönmeye,

47:37.640 --> 47:38.340
devam ediyor.

47:38.680 --> 47:39.080
Dolayısıyla,

47:39.200 --> 47:40.640
onların beklemesi demek,

47:40.820 --> 47:41.220
aslında,

47:41.660 --> 47:43.060
bu döngünün,

47:43.180 --> 47:43.800
sürekli,

47:43.800 --> 47:45.040
çalışması demek.

47:46.500 --> 47:48.740
Beşerit data'yı arttırdıktan sonra,

47:49.580 --> 47:50.980
an lag fonksiyonunu çağırıyorum.

47:51.980 --> 47:52.600
Eğer bakın,

47:53.380 --> 47:54.180
herhangi bir,

47:54.400 --> 47:54.780
eğer,

47:54.940 --> 47:55.480
hediyelim,

47:55.920 --> 47:56.580
bug varsa,

47:56.800 --> 47:57.920
tabii o da garanti değil,

47:57.920 --> 47:59.720
başka durumlar da olabilir,

47:59.860 --> 48:00.820
yeni bizi yanıltabilir.

48:01.680 --> 48:02.580
Ama en azından,

48:02.960 --> 48:04.240
buradaki kod çalıştığında,

48:04.360 --> 48:04.680
Necati,

48:04.780 --> 48:05.500
buradaki kod ne?

48:05.660 --> 48:07.200
10 tane thread oluşturdum.

48:07.940 --> 48:08.780
10 thread data,

48:09.080 --> 48:10.040
yukarıdaki increment,

48:10.240 --> 48:12.160
shared data fonksiyonunu çağırdım.

48:12.780 --> 48:13.160
O zaman,

48:13.340 --> 48:14.240
10 çarpı,

48:14.400 --> 48:14.960
10 bin,

48:15.180 --> 48:16.420
100 bin olması lazım.

48:21.040 --> 48:21.640
Evet,

48:21.760 --> 48:22.400
takip edin.

48:22.400 --> 48:25.500
Evet,

48:25.600 --> 48:26.340
görüyorsunuz,

48:26.420 --> 48:27.180
shared data,

48:27.500 --> 48:28.020
arkadaşlar,

48:28.360 --> 48:28.840
100 bin.

48:29.640 --> 48:29.920
Peki,

48:30.460 --> 48:31.120
şimdi biz,

48:31.400 --> 48:32.900
compare exchange strong'ı,

48:33.280 --> 48:33.760
öğrendik.

48:34.160 --> 48:34.620
Arkadaşlar,

48:34.720 --> 48:36.040
compare exchange weak,

48:36.760 --> 48:38.660
daha az çağırdığımız bir fonksiyon,

48:39.120 --> 48:40.060
ama neyle ilgili?

48:40.260 --> 48:41.180
Aradaki fark şu,

48:41.400 --> 48:41.740
bakınız.

48:42.600 --> 48:43.280
Şimdi ben,

48:43.920 --> 48:45.160
şöyle bir kod yazsam,

48:45.980 --> 48:46.540
izleyin,

48:46.960 --> 48:47.540
atomic,

48:48.740 --> 48:49.180
int,

48:49.180 --> 48:52.940
yukarıdaki kod da sileyim artık,

48:53.100 --> 48:53.980
geçti hükmü.

48:57.020 --> 48:58.440
Şöyle bir kod yazsam,

48:59.180 --> 48:59.640
atomic,

49:00.320 --> 49:00.680
int,

49:01.140 --> 49:01.540
x,

49:02.360 --> 49:02.680
on,

49:04.120 --> 49:04.380
ve,

49:05.600 --> 49:06.940
az önceki örnekle olduğu gibi,

49:07.060 --> 49:08.400
buraya bir deyimi koysam,

49:09.120 --> 49:09.520
x,

49:10.780 --> 49:11.720
compare,

49:11.720 --> 49:12.060
compare,

49:13.260 --> 49:14.060
exchange,

49:14.340 --> 49:14.880
strong,

49:15.940 --> 49:16.700
efendim işte,

49:17.640 --> 49:18.000
int,

49:18.000 --> 49:19.680
expected,

49:20.940 --> 49:21.540
eşittir,

49:21.700 --> 49:21.920
on,

49:22.980 --> 49:23.620
expected,

49:26.720 --> 49:27.760
sadece beni izleyin,

49:28.460 --> 49:28.680
ve,

49:29.360 --> 49:29.920
arkadaşlar,

49:31.060 --> 49:31.980
efendim,

49:33.480 --> 49:33.940
ne diyelim,

49:34.020 --> 49:34.300
20.

49:35.980 --> 49:37.860
Şimdi sadece soruyu anlamaya çalışın.

49:38.560 --> 49:40.500
İpin doğru kısmına girmişse,

49:41.340 --> 49:42.660
compare exchange strong,

49:42.960 --> 49:44.440
pro değer döndürmüştür.

49:45.380 --> 49:46.060
Bu durumda,

49:46.240 --> 49:47.700
artık atomik değişkenimizin,

49:47.700 --> 49:49.440
değerinin değiştiğinden eminiz.

49:49.560 --> 49:51.140
Yani if'in doğru kısmında biz,

49:51.560 --> 49:53.100
atomik değişkenin değerinin,

49:53.820 --> 49:55.540
değiştiğini varsayarak,

49:56.060 --> 49:57.500
işimizi yapabiliriz.

49:57.580 --> 49:58.620
Buraya kadar tamam mı?

49:59.640 --> 50:00.380
Fakat şimdi,

50:00.920 --> 50:01.440
izleyin,

50:01.680 --> 50:02.920
host dönmesi demek,

50:04.020 --> 50:04.580
aslında,

50:04.960 --> 50:06.540
expected'in değerinin,

50:07.500 --> 50:08.820
x'in değerine,

50:08.820 --> 50:10.460
eşit olmaması demek.

50:11.180 --> 50:11.820
Öyle değil mi?

50:11.820 --> 50:13.360
işte bakın,

50:13.360 --> 50:13.440
işte bakın,

50:13.560 --> 50:15.980
compared exchange week'de,

50:16.460 --> 50:17.600
şöyle bir problem var.

50:17.740 --> 50:17.920
Yine,

50:18.260 --> 50:20.440
spurious wake up vardı ya,

50:20.560 --> 50:21.780
adeta oradaki gibi.

50:22.740 --> 50:23.500
Arkadaşlar,

50:24.460 --> 50:25.000
burada,

50:25.680 --> 50:27.160
false dönse dahi,

50:27.920 --> 50:28.420
aslında,

50:28.820 --> 50:29.660
ya da şöyle diyelim,

50:29.860 --> 50:31.200
expected'in değeri,

50:31.380 --> 50:33.820
atomik'in değerine eşit olsa dahi,

50:33.820 --> 50:36.520
yine fonksiyon ne dönebiliyor?

50:37.180 --> 50:38.780
False dönebiliyor.

50:39.500 --> 50:40.140
Normalde,

50:40.560 --> 50:41.960
true dönmesi lazım değil mi?

50:42.860 --> 50:43.860
İşte bu da,

50:44.100 --> 50:44.520
arkadaşlar,

50:44.900 --> 50:46.760
spurious değer değişikliği,

50:47.360 --> 50:48.680
sahte değer değişikliği,

50:48.880 --> 50:49.800
artık ne derseniz.

50:50.640 --> 50:51.020
İşte,

50:51.500 --> 50:52.200
bu da şu demek,

50:53.100 --> 50:53.520
eğer,

50:54.280 --> 50:55.540
böyle bir ihtimal yoksa,

50:55.600 --> 50:57.020
çalıştığınız sistemde,

50:57.540 --> 50:58.980
doğrudan bunu kullanabilirsiniz.

50:58.980 --> 50:59.600
ya da,

51:00.200 --> 51:00.980
bunu kullanıp,

51:01.080 --> 51:02.980
bunu döngüsel bir yapı içinde,

51:03.540 --> 51:03.980
kullanabilirsiniz.

51:04.760 --> 51:05.000
Yani,

51:05.820 --> 51:06.460
diyelim ki,

51:07.060 --> 51:09.120
değerin illa değişmesi gerekiyor,

51:09.240 --> 51:10.920
eşit olması durumunda.

51:11.520 --> 51:11.820
Yine,

51:12.280 --> 51:13.980
homebillere exchange week'i kullanın.

51:15.220 --> 51:15.580
Ama,

51:16.480 --> 51:16.820
bunu,

51:17.200 --> 51:19.180
bir döngü içinde kullanın.

51:20.200 --> 51:20.780
Arkadaşlar,

51:21.340 --> 51:21.740
bu kadar.

51:22.500 --> 51:23.320
Aradaki fark,

51:23.620 --> 51:23.780
bu.

51:24.660 --> 51:25.120
Arkadaşlar,

51:25.200 --> 51:25.460
şimdi,

51:26.020 --> 51:27.180
atomik değişkenlerin,

51:27.840 --> 51:28.880
kullanımı üstünde,

51:28.980 --> 51:31.380
bir iki tane kod daha inceleyeceğiz.

51:31.540 --> 51:31.680
Fakat,

51:31.800 --> 51:32.500
ondan sonra,

51:32.680 --> 51:32.880
şu,

51:33.200 --> 51:35.040
memory order konusuna gireceğiz.

51:35.560 --> 51:35.740
Yani,

51:35.840 --> 51:37.240
asıl bizi zorlayacak olan,

51:37.340 --> 51:38.260
doğrusu isterseniz,

51:38.880 --> 51:40.000
memory order konusu.

51:40.740 --> 51:41.400
Ama şimdi,

51:43.520 --> 51:44.080
şuna bakın,

51:44.160 --> 51:45.340
çok güzel bir kod.

51:45.980 --> 51:46.580
Arkadaşlar,

51:47.560 --> 51:49.560
bir counter sınıfı oluşturdum.

51:50.240 --> 51:50.520
Fakat,

51:50.680 --> 51:51.760
counter sınıfı,

51:52.000 --> 51:52.880
atomic counter.

51:54.140 --> 51:54.420
Yani,

51:54.420 --> 51:54.800
ben,

51:55.120 --> 51:55.880
normalde,

51:55.960 --> 51:57.260
intürden bir değişkeni,

51:57.340 --> 51:58.960
counter olarak kullansaydım,

51:58.980 --> 52:00.180
burada,

52:00.460 --> 52:01.020
birden fa,

52:01.120 --> 52:01.320
hatta,

52:01.380 --> 52:02.500
onu bir daha gösterelim.

52:02.600 --> 52:02.860
Bakın,

52:02.960 --> 52:04.200
atomic counter değil,

52:06.640 --> 52:07.160
normal,

52:07.400 --> 52:08.700
counter yapıyorum.

52:10.100 --> 52:10.800
Takip edin.

52:11.800 --> 52:12.620
Bu fonksiyonu,

52:12.660 --> 52:14.000
bir milyon kez dönüyor.

52:14.600 --> 52:15.360
Arkadaşlar,

52:16.260 --> 52:17.160
biraz bekleteceğim.

52:17.160 --> 52:21.620
bu fonksiyonu,

52:21.620 --> 52:23.300
bir milyon kez dönüyor.

52:24.060 --> 52:26.760
10 tane thread çalıştırıyorum.

52:27.540 --> 52:27.700
Ve,

52:27.920 --> 52:29.060
10 tane thread de,

52:29.440 --> 52:29.680
yine,

52:29.980 --> 52:30.540
değerinin,

52:31.120 --> 52:32.600
10 milyon olması gerekiyor.

52:32.700 --> 52:32.940
Değil mi?

52:33.180 --> 52:33.600
Hatta,

52:33.800 --> 52:34.100
hatta,

52:35.040 --> 52:36.580
biraz belki daha güzel kod.

52:37.100 --> 52:37.740
İzleyin.

52:40.240 --> 52:40.540
Şimdi,

52:40.620 --> 52:41.900
daha da güzel bir kod yazacağım.

52:42.620 --> 52:43.700
Sorumunu test edeceğiz.

52:43.700 --> 52:45.700
void var.

52:48.180 --> 52:48.900
Arkadaşlar,

52:49.700 --> 52:50.500
bu döngü de,

52:51.420 --> 52:52.480
1 milyonmuş bu arada,

52:52.620 --> 52:53.840
1 milyon kez dönüyor.

52:53.840 --> 52:57.960
fakat burada da,

52:57.960 --> 52:59.300
eksi eksi count var.

53:00.580 --> 53:01.440
Şimdi soru,

53:02.520 --> 53:03.000
ben,

53:04.000 --> 53:04.440
şunu,

53:05.200 --> 53:06.260
20 yapsam,

53:07.220 --> 53:07.680
arkadaşlar,

53:10.640 --> 53:12.120
ben şöyle bir kod yazsam,

53:12.960 --> 53:13.300
for,

53:14.860 --> 53:15.960
i eşittir,

53:16.840 --> 53:17.180
0,

53:17.760 --> 53:18.340
i küçük,

53:18.800 --> 53:19.220
20,

53:20.620 --> 53:21.660
artı artı i,

53:21.660 --> 53:26.720
oraya da bir if koysam,

53:29.500 --> 53:29.880
if,

53:32.300 --> 53:33.820
i mod 2,

53:36.660 --> 53:37.220
arkadaşlar,

53:39.140 --> 53:39.360
e,

53:39.540 --> 53:41.220
a köşeli parantez,

53:41.380 --> 53:41.620
i,

53:42.200 --> 53:43.040
eşittir,

53:43.980 --> 53:44.820
stu thread,

53:45.760 --> 53:46.220
biri fu,

53:46.300 --> 53:47.140
biri var değil mi?

53:47.580 --> 53:47.800
u,

53:47.800 --> 53:47.940
u,

53:47.940 --> 53:53.660
çeğitir et,

54:00.660 --> 54:01.060
as,

54:04.060 --> 54:05.680
h köşeli parantez,

54:05.860 --> 54:06.060
i,

54:07.500 --> 54:08.300
çeğitir et,

54:08.940 --> 54:09.240
var.

54:10.620 --> 54:11.880
Şimdi yavaş yavaş gidiyorum.

54:13.720 --> 54:13.940
Bu,

54:13.940 --> 54:16.420
hüküme parantezini sildim.

54:17.940 --> 54:20.680
şu nest scope'tan sonra,

54:21.820 --> 54:24.700
j-thread nesnelerin destraktörü,

54:24.800 --> 54:26.060
threadleri join etti.

54:27.080 --> 54:27.580
Ve ben,

54:28.240 --> 54:28.860
arkadaşlar,

54:29.820 --> 54:31.300
global değişken olan,

54:31.660 --> 54:33.620
cnt'nin değerini,

54:33.820 --> 54:35.000
sıfırla başlayacak ama,

54:35.900 --> 54:36.540
yazdırayım.

54:37.980 --> 54:39.580
cnt eşittir,

54:41.580 --> 54:42.100
cnt.

54:42.100 --> 54:45.280
burada tabi ki,

54:45.340 --> 54:46.260
data race var.

54:46.800 --> 54:47.280
İzleyin.

54:53.920 --> 54:54.960
Evet arkadaşlar,

54:55.160 --> 54:55.760
burada bakın,

54:56.900 --> 54:58.380
data race olduğu için,

54:59.160 --> 54:59.740
sıfır değil.

54:59.920 --> 55:00.960
Mesela ben bunu,

55:01.140 --> 55:02.960
atomik değişken yapsaydım,

55:04.960 --> 55:07.100
atomic int,

55:07.100 --> 55:12.420
eğer kodda herhangi bir hata yapmadıysam,

55:13.140 --> 55:13.500
arkadaşlar,

55:13.820 --> 55:16.000
kesinlikle ne olması gerekir?

55:16.800 --> 55:17.340
Değerin,

55:17.980 --> 55:19.100
sıfır olması gerekir,

55:19.160 --> 55:19.440
değil mi?

55:23.960 --> 55:25.280
Görüyor musunuz?

55:25.940 --> 55:26.940
Neden sıfır oldu?

55:27.740 --> 55:27.860
E,

55:27.920 --> 55:29.780
çünkü işlemler atomik olduğu için,

55:29.920 --> 55:31.020
data race olmadı.

55:31.020 --> 55:32.200
Evet,

55:32.340 --> 55:33.540
işte 5 tane thread,

55:33.840 --> 55:35.200
1 milyon kere arttırırken,

55:35.280 --> 55:36.120
5 tane thread de,

55:36.160 --> 55:37.800
1 milyon kere eksiltti.

55:38.740 --> 55:39.280
Sonuçta,

55:39.700 --> 55:40.240
sıfır oldu.

55:40.880 --> 55:42.120
Bunu neden söyledim?

55:42.400 --> 55:43.240
Yukarıdaki kodu,

55:43.340 --> 55:44.680
şöyle test edeceğim şimdi.

55:45.280 --> 55:45.820
İzleyin.

55:46.640 --> 55:47.100
Bu sefer,

55:47.220 --> 55:47.940
değişkenim,

55:49.180 --> 55:51.120
atomic counter türünden olacak.

55:53.220 --> 55:53.560
Zaten,

55:53.720 --> 55:55.000
default constructorı,

55:55.360 --> 55:56.240
görüyorsunuz.

55:57.140 --> 55:58.340
VL elemanı olan,

55:58.340 --> 55:59.560
atomic inti,

55:59.560 --> 56:01.500
sıfır değeriyle başlatıyor.

56:02.060 --> 56:02.300
Şimdi,

56:02.400 --> 56:03.860
sınıfın interface'ine bakalım.

56:04.880 --> 56:05.400
Arkadaşlar,

56:05.560 --> 56:06.840
operatör artı artı,

56:07.460 --> 56:07.720
bu,

56:08.640 --> 56:10.160
önek artı artı,

56:10.300 --> 56:11.200
operatörü,

56:11.780 --> 56:13.500
MC'nin değerini bir arttırıyor,

56:13.600 --> 56:15.100
ve artmış değeri döndürüyor.

56:16.160 --> 56:16.620
Efendim,

56:17.260 --> 56:19.100
son ek artı artı operatörü,

56:19.740 --> 56:19.980
yine,

56:20.560 --> 56:22.080
bizim atomik değişkenimizin,

56:22.160 --> 56:23.360
değerini bir arttırıyor,

56:24.040 --> 56:24.520
arkadaşlar,

56:24.940 --> 56:26.720
ama eski değerini döndürüyor.

56:27.040 --> 56:28.120
Eksi ekse,

56:28.200 --> 56:29.320
açıklamaya gerek yok.

56:29.320 --> 56:30.660
get fonksiyonu da,

56:31.340 --> 56:31.820
aslında,

56:32.240 --> 56:33.780
load fonksiyonunu çağırıyor,

56:33.960 --> 56:35.060
atomik değişkenin.

56:35.800 --> 56:37.500
Operatör int fonksiyonu da,

56:37.600 --> 56:38.080
işte bakın,

56:38.720 --> 56:39.140
az önce,

56:39.460 --> 56:39.800
normal,

56:39.920 --> 56:40.940
atomik sınıfının da,

56:41.020 --> 56:42.640
operatör int fonksiyonu vardı ya,

56:43.440 --> 56:43.780
efendim,

56:44.140 --> 56:46.060
operatör int fonksiyonu da,

56:47.340 --> 56:48.240
yine,

56:49.240 --> 56:50.500
load fonksiyonunu çağırıyor.

56:50.620 --> 56:51.140
Burada tabii,

56:51.660 --> 56:52.080
arkadaşlar,

56:52.260 --> 56:52.660
return,

56:53.140 --> 56:54.320
MC'de diyebilirim.

56:55.260 --> 56:55.740
Şimdi,

56:56.440 --> 56:57.040
o zaman,

56:57.580 --> 56:58.160
bu sefer,

56:58.460 --> 56:58.920
kodda,

56:59.100 --> 56:59.620
yine hiçbir,

56:59.840 --> 57:00.960
sentaks hatası yok,

57:01.060 --> 57:01.980
ama ilginç bir şekilde.

57:02.920 --> 57:03.160
Neden?

57:03.600 --> 57:03.920
Çünkü,

57:04.660 --> 57:04.920
aslında,

57:05.040 --> 57:05.420
cnt,

57:05.740 --> 57:06.700
bu sınıf türünden,

57:08.340 --> 57:08.880
ama,

57:08.880 --> 57:10.440
sınıfın artı artı operatörü var,

57:10.520 --> 57:11.920
eksi ekse operatörü var.

57:12.780 --> 57:13.220
Üstelik,

57:13.300 --> 57:13.960
operatör,

57:14.200 --> 57:15.940
int fonksiyonu da olduğu için,

57:16.280 --> 57:17.000
burada da,

57:17.640 --> 57:18.100
int'e,

57:18.100 --> 57:19.080
dönüşecek.

57:19.240 --> 57:19.700
O zaman,

57:20.020 --> 57:20.260
yine,

57:20.500 --> 57:21.780
eğer bir problem yoksa,

57:21.960 --> 57:22.200
yine,

57:22.920 --> 57:24.180
sıfır olması gerekecek.

57:26.300 --> 57:26.700
Bir.

57:27.480 --> 57:28.200
Evet.

57:29.320 --> 57:29.960
Görüyorsunuz,

57:30.020 --> 57:30.280
değil mi?

57:31.240 --> 57:31.880
İşlemlerin,

57:32.000 --> 57:33.540
atomik olarak yapılmasının,

57:34.180 --> 57:35.360
ne anlama geldiğini,

57:35.720 --> 57:36.460
göstermek için.

57:36.860 --> 57:37.380
Arkadaşlar,

57:37.660 --> 57:38.640
biraz da şundan,

57:38.880 --> 57:39.560
bahsedelim.

57:40.320 --> 57:40.780
Neyin?

57:43.980 --> 57:45.380
Pointer açılımı.

57:45.380 --> 57:48.040
neden Pointer açılımına,

57:48.100 --> 57:49.240
bu kadar önem veriyoruz?

57:50.000 --> 57:50.480
Çünkü,

57:51.040 --> 57:52.240
veri yapılarında,

57:53.100 --> 57:53.460
arkadaşlar,

57:53.700 --> 57:54.380
özellikle bu,

57:54.680 --> 57:55.260
lock-free,

57:55.600 --> 57:56.540
veri yapılarında,

57:57.540 --> 57:57.800
yani,

57:57.920 --> 57:58.600
hiç mutex,

57:58.840 --> 57:59.260
doğrudan,

57:59.380 --> 58:00.140
kullanmadan,

58:00.500 --> 58:01.240
oluşturulan,

58:01.440 --> 58:01.680
ama,

58:01.820 --> 58:02.800
thread safe olan,

58:03.520 --> 58:05.020
data race oluşturmayan,

58:05.600 --> 58:06.500
veri yapılarında,

58:07.660 --> 58:08.380
tipik olarak,

58:08.700 --> 58:09.280
Pointer'ın,

58:09.280 --> 58:10.720
atomik olması gerekiyor.

58:11.760 --> 58:11.940
İşte,

58:12.020 --> 58:13.660
bizim standart kötü bahanemiz,

58:13.800 --> 58:14.240
bu yüzden,

58:14.240 --> 58:16.160
atomik sınıfının,

58:16.500 --> 58:19.380
Pointer specialization'ı da veriyor.

58:20.100 --> 58:20.400
Hatta,

58:20.520 --> 58:20.720
hatta,

58:21.040 --> 58:21.700
C++,

58:22.240 --> 58:23.560
arkadaşlar,

58:24.040 --> 58:25.420
20 ile birlikte,

58:25.560 --> 58:26.220
yanlış söylemeyeyim,

58:26.300 --> 58:26.780
20-23,

58:26.900 --> 58:27.720
bazen karıştırıyorum,

58:27.800 --> 58:28.300
20 tabii,

58:29.220 --> 58:30.520
atomik sınıfının,

58:30.780 --> 58:33.260
Shell PTR specialization'da geldi.

58:34.260 --> 58:34.460
Evet.

58:35.220 --> 58:35.700
Arkadaşlar,

58:35.780 --> 58:36.620
burada amaç,

58:36.620 --> 58:37.880
sadece bu işlemlerin,

58:38.060 --> 58:39.680
atomik olarak yapıldığını,

58:40.260 --> 58:41.260
bir örnek üstünde,

58:41.620 --> 58:42.340
göstermek.

58:42.840 --> 58:43.560
Mesela bakın,

58:43.560 --> 58:45.240
atomik PTR'ye,

58:46.140 --> 58:46.540
dizinin,

58:46.740 --> 58:47.560
ilk elemanının,

58:47.820 --> 58:48.440
adresiyle,

58:48.520 --> 58:49.460
ilk değer verdim.

58:50.320 --> 58:50.560
Sonra,

58:50.680 --> 58:52.040
Pointer'ı 1 arttırdım.

58:52.320 --> 58:52.920
Bu işlem,

58:53.140 --> 58:54.160
Atomic Operation,

58:54.720 --> 58:55.260
her ne kadar,

58:55.380 --> 58:56.800
burada bir önemi olmasa da,

58:57.940 --> 58:58.280
sonra,

58:58.820 --> 59:00.460
load fonksiyonunu çağırarak,

59:00.460 --> 59:01.340
değerinin,

59:01.340 --> 59:01.360
değerinin,

59:01.680 --> 59:02.780
ar artı 1,

59:03.460 --> 59:04.240
yani dizinin,

59:04.340 --> 59:05.580
pointer aritmetine göre,

59:05.840 --> 59:07.480
bir ingilizce elemanı olduğunu,

59:08.480 --> 59:09.620
assert ettim.

59:09.760 --> 59:10.560
Burada kullandım,

59:10.640 --> 59:11.420
C'den bildiğiniz,

59:11.500 --> 59:12.200
assert makrosu.

59:12.260 --> 59:12.400
Yani,

59:12.460 --> 59:13.940
bu assert'ın fail olursa,

59:14.480 --> 59:15.820
stud abort çağırılacak,

59:15.960 --> 59:16.780
siz de göreceksiniz.

59:16.880 --> 59:17.100
Sonra,

59:17.680 --> 59:18.640
artı eşitle,

59:19.280 --> 59:20.340
PTR'nin değerini,

59:20.420 --> 59:21.180
bir arttırdım.

59:21.360 --> 59:21.600
Yine,

59:21.800 --> 59:23.160
ar artı 2 olacak.

59:24.000 --> 59:25.040
Eksi eksi dedim.

59:25.640 --> 59:26.300
Arkadaşlar,

59:26.500 --> 59:27.740
ar artı,

59:27.740 --> 59:28.760
1 olacak.

59:28.920 --> 59:30.360
Hatta şunu diyebilir miyim?

59:30.920 --> 59:31.920
Bir de onu da göstereyim.

59:32.040 --> 59:33.180
PTR'nin,

59:34.160 --> 59:34.700
arkadaşlar,

59:35.240 --> 59:37.700
patch add fonksiyonu,

59:38.480 --> 59:39.440
ve burada da,

59:40.920 --> 59:41.920
şu anda,

59:41.920 --> 59:43.280
ar artı 1'di,

59:44.120 --> 59:44.920
3 toplarsam,

59:46.160 --> 59:46.500
o zaman,

59:46.620 --> 59:48.640
ar artı 4 olması lazım.

59:48.820 --> 59:49.040
Değil mi?

59:49.100 --> 59:49.920
Bu assert'ın,

59:50.800 --> 59:52.600
fail olmaması gerekir.

59:55.180 --> 59:55.400
O,

59:55.480 --> 59:55.880
sana ise,

59:56.120 --> 59:57.680
user defined type içinde,

59:57.740 --> 59:59.560
pointer kullanımı,

59:59.660 --> 01:00:00.160
save oluyor.

01:00:00.280 --> 01:00:00.700
Kesinlikle.

01:00:00.860 --> 01:00:01.400
Pointer'ın,

01:00:01.480 --> 01:00:02.580
neyi point ettiğinden,

01:00:02.720 --> 01:00:03.340
bağımsız.

01:00:04.520 --> 01:00:05.440
Anlaşıldı değil mi?

01:00:05.680 --> 01:00:06.100
Pointer,

01:00:06.360 --> 01:00:07.760
hangi türden,

01:00:07.840 --> 01:00:08.700
nesneyi gösterirse,

01:00:08.840 --> 01:00:09.460
göstersin.

01:00:09.960 --> 01:00:10.220
Burada,

01:00:10.700 --> 01:00:11.440
atomik olan,

01:00:11.720 --> 01:00:12.060
pointer.

01:00:12.340 --> 01:00:12.780
Dolayısıyla,

01:00:13.400 --> 01:00:14.000
pointer'ın,

01:00:14.700 --> 01:00:15.740
pointinin,

01:00:16.140 --> 01:00:16.660
türünün,

01:00:16.840 --> 01:00:17.620
ne olduğunun,

01:00:18.240 --> 01:00:18.780
doğrudan,

01:00:19.000 --> 01:00:19.760
bir önemi,

01:00:20.980 --> 01:00:22.080
yok.

01:00:22.560 --> 01:00:22.780
Evet.

01:00:24.020 --> 01:00:24.320
Peki,

01:00:24.980 --> 01:00:25.300
devam.

01:00:25.300 --> 01:00:26.760
arkadaşlar,

01:00:26.960 --> 01:00:27.220
bakın,

01:00:27.220 --> 01:00:27.520
yine,

01:00:27.520 --> 01:00:29.360
burada,

01:00:30.140 --> 01:00:31.280
temaların,

01:00:31.360 --> 01:00:32.600
çok büyük çoğunluğunda,

01:00:33.280 --> 01:00:33.500
biz,

01:00:33.820 --> 01:00:34.100
hep,

01:00:34.360 --> 01:00:35.140
data race,

01:00:35.400 --> 01:00:36.220
olmaması,

01:00:36.400 --> 01:00:37.480
üstünde durduk.

01:00:37.980 --> 01:00:38.200
Yani,

01:00:38.300 --> 01:00:38.660
işlemin,

01:00:38.760 --> 01:00:39.660
atomik olması,

01:00:40.360 --> 01:00:41.220
data race'i,

01:00:41.340 --> 01:00:41.840
engeliyor.

01:00:42.180 --> 01:00:42.580
Bu arada,

01:00:43.240 --> 01:00:44.120
C++'da,

01:00:44.220 --> 01:00:45.260
kullanmasak da,

01:00:46.080 --> 01:00:47.320
biraz tuhaf bir şekilde,

01:00:47.320 --> 01:00:49.820
C ile,

01:00:50.160 --> 01:00:52.240
tabi C'nin daha sonraki standartlarıyla,

01:00:53.040 --> 01:00:54.560
bir uyum sağlasın diye,

01:00:55.080 --> 01:00:55.580
arkadaşlar,

01:00:56.440 --> 01:00:57.280
bazı,

01:00:57.280 --> 01:00:59.200
global fonksiyonlar da var.

01:01:01.600 --> 01:01:02.440
İşte buradaki,

01:01:03.100 --> 01:01:03.540
örneğin,

01:01:04.280 --> 01:01:04.720
arkadaşlar,

01:01:05.280 --> 01:01:07.800
store ve load fonksiyonları yerine,

01:01:09.200 --> 01:01:10.700
global fonksiyon olan,

01:01:10.960 --> 01:01:11.900
atomik store'a,

01:01:12.160 --> 01:01:14.180
atomik değişkenin adresi,

01:01:14.960 --> 01:01:16.540
ve değeri veriyorum.

01:01:16.540 --> 01:01:17.000
Yine,

01:01:17.400 --> 01:01:19.080
atomik load fonksiyonlar da,

01:01:19.180 --> 01:01:20.440
değişkenin adresini veriyorum.

01:01:21.100 --> 01:01:21.360
Yani,

01:01:21.560 --> 01:01:23.500
C ile uyum sağlamak için,

01:01:23.660 --> 01:01:25.540
oluşturulmuş bu fonksiyonlar,

01:01:25.720 --> 01:01:27.080
global fonksiyonlar,

01:01:28.100 --> 01:01:29.740
ve isimleri,

01:01:30.300 --> 01:01:31.320
işte burada görüyorum,

01:01:32.500 --> 01:01:33.700
atomik underscore,

01:01:34.400 --> 01:01:34.900
arkadaşlar,

01:01:35.700 --> 01:01:37.640
hangi işlem yapılacaksa,

01:01:38.380 --> 01:01:39.520
o işlem,

01:01:39.820 --> 01:01:41.220
ve bunlar bizden,

01:01:41.340 --> 01:01:42.660
atomik değişkenimizin,

01:01:42.840 --> 01:01:44.280
adresini istiyor.

01:01:44.280 --> 01:01:48.680
biraz da şundan bahsedeyim,

01:01:48.760 --> 01:01:50.160
geçen derste konuşmuştuk.

01:01:50.720 --> 01:01:51.160
Arkadaşlar,

01:01:51.220 --> 01:01:52.500
şimdi standart diyor ki,

01:01:53.280 --> 01:01:54.560
lock free olması,

01:01:54.920 --> 01:01:56.220
garanti altında olan,

01:01:56.500 --> 01:01:58.000
sadece tek atomik tür,

01:01:58.160 --> 01:01:59.200
atomik flag türü.

01:01:59.200 --> 01:02:01.420
onun dışındaki,

01:02:01.420 --> 01:02:03.040
atomik türlerin,

01:02:03.840 --> 01:02:05.080
herhangi biri için,

01:02:05.640 --> 01:02:07.060
tam sayı türleri dahil,

01:02:07.900 --> 01:02:09.620
user defined türler dahil,

01:02:10.420 --> 01:02:11.060
işlemin,

01:02:11.480 --> 01:02:12.380
atomisitinin,

01:02:13.120 --> 01:02:15.220
mutex kullanılarak mı yapıldığı,

01:02:15.520 --> 01:02:17.100
yoksa mutex kullanmadan,

01:02:17.660 --> 01:02:18.200
doğrudan,

01:02:18.980 --> 01:02:21.260
instruction'ın atomik olması nedeniyle mi,

01:02:21.420 --> 01:02:21.980
yapıldığını,

01:02:21.980 --> 01:02:23.340
test etmek için de,

01:02:24.080 --> 01:02:24.700
sınıfın,

01:02:25.900 --> 01:02:26.160
a,

01:02:26.400 --> 01:02:28.060
is lock free fonksiyonu var.

01:02:28.220 --> 01:02:28.400
Bu,

01:02:28.520 --> 01:02:29.860
runtime'da çalışıyor.

01:02:30.840 --> 01:02:32.680
Burası bir karmaşık mevzu ama,

01:02:33.420 --> 01:02:33.800
arkadaşlar,

01:02:34.880 --> 01:02:36.060
bazen,

01:02:36.260 --> 01:02:37.860
compile time'da,

01:02:40.380 --> 01:02:41.900
atomik değişkenin,

01:02:42.460 --> 01:02:44.280
lock free olup olmadığı,

01:02:44.540 --> 01:02:45.840
compile time'da değil de,

01:02:45.940 --> 01:02:47.380
runtime'da saptanabiliyor.

01:02:47.380 --> 01:02:50.460
belirli parametrelerle ilgili,

01:02:50.680 --> 01:02:51.440
sistemdeki.

01:02:52.300 --> 01:02:52.780
Bu yüzden,

01:02:52.920 --> 01:02:54.140
kısaca şöyle söyleyelim.

01:02:54.900 --> 01:02:55.600
Eğer siz,

01:02:55.920 --> 01:02:58.240
runtime'da sınanmasını istiyorsanız,

01:02:59.600 --> 01:03:01.580
örneğin bir atomik değişkeniniz var.

01:03:01.900 --> 01:03:02.520
Atomic,

01:03:03.300 --> 01:03:03.780
int,

01:03:04.220 --> 01:03:04.620
x,

01:03:06.900 --> 01:03:07.340
if,

01:03:08.020 --> 01:03:08.480
x,

01:03:09.400 --> 01:03:11.140
is lock free.

01:03:12.260 --> 01:03:13.660
Bu fonksiyonu çağırıyorsunuz.

01:03:14.500 --> 01:03:14.840
Yani,

01:03:14.840 --> 01:03:16.400
eğer runtime'da,

01:03:16.400 --> 01:03:17.520
herhangi bir şekilde,

01:03:18.380 --> 01:03:18.660
bunun,

01:03:18.940 --> 01:03:19.460
işlemin,

01:03:19.780 --> 01:03:22.400
bir mutex altında yapılıp yapılmayacağı,

01:03:22.940 --> 01:03:24.360
bilgisini get etmek için.

01:03:25.220 --> 01:03:27.400
Eğer böyle bir değişme ihtimali varsa.

01:03:27.660 --> 01:03:29.940
Ama compile time'da kontrol etmek için,

01:03:31.060 --> 01:03:31.680
doğrudan,

01:03:31.900 --> 01:03:32.300
arkadaşlar,

01:03:32.500 --> 01:03:32.900
sınıfın,

01:03:32.960 --> 01:03:33.740
constexpr,

01:03:34.060 --> 01:03:35.600
statik veri elemanı var.

01:03:36.640 --> 01:03:37.040
Yani,

01:03:38.000 --> 01:03:38.620
atomic,

01:03:39.180 --> 01:03:39.740
intin,

01:03:42.740 --> 01:03:44.280
atomic int bu tür,

01:03:44.280 --> 01:03:45.880
statik veri elemanına,

01:03:46.400 --> 01:03:47.520
ulaşmak için,

01:03:48.380 --> 01:03:50.180
çözünürlük operatörünü kullanıyorum.

01:03:50.720 --> 01:03:53.000
Is always lock free.

01:03:53.660 --> 01:03:53.900
Bu,

01:03:54.240 --> 01:03:55.160
boolean bir,

01:03:55.400 --> 01:03:58.060
statik veri elemanı,

01:03:58.520 --> 01:03:59.320
constexpr,

01:04:00.180 --> 01:04:00.740
arkadaşlar,

01:04:00.740 --> 01:04:03.280
ve bunun değeri,

01:04:04.000 --> 01:04:04.600
true ise,

01:04:05.320 --> 01:04:06.740
lock free her zaman,

01:04:07.020 --> 01:04:07.520
değil ise,

01:04:08.240 --> 01:04:09.280
lock free değil.

01:04:09.420 --> 01:04:09.600
Yani,

01:04:09.660 --> 01:04:11.020
mutex kullanılıyor olabilir.

01:04:11.680 --> 01:04:12.180
Arkadaşlar,

01:04:12.240 --> 01:04:12.400
şimdi,

01:04:12.500 --> 01:04:13.720
atomik işlemlerle ilgili,

01:04:14.320 --> 01:04:14.880
çok böyle,

01:04:14.940 --> 01:04:16.360
mülakatlarda da sorulan,

01:04:16.860 --> 01:04:17.880
klasik bir soru var.

01:04:18.040 --> 01:04:19.640
Ben de o soruyu size soracağım.

01:04:20.420 --> 01:04:20.800
Şimdi,

01:04:21.040 --> 01:04:22.400
bir atomik değişkenim var.

01:04:24.400 --> 01:04:24.920
Atomic,

01:04:26.140 --> 01:04:26.580
int,

01:04:26.580 --> 01:04:29.820
x0.

01:04:32.040 --> 01:04:33.080
Takip edin.

01:04:34.220 --> 01:04:34.640
Burada,

01:04:36.060 --> 01:04:37.160
bir fonksiyon var,

01:04:37.700 --> 01:04:38.000
bank,

01:04:40.360 --> 01:04:41.500
bank fonksiyonun içinde,

01:04:41.660 --> 01:04:42.440
bir döngü var.

01:04:43.320 --> 01:04:44.040
Diyelim ki,

01:04:44.680 --> 01:04:45.220
arkadaşlar,

01:04:45.220 --> 01:04:47.340
10.000 kez dönüyor.

01:04:48.800 --> 01:04:49.700
Döngünün içine,

01:04:50.900 --> 01:04:51.700
ayrı ayrı,

01:04:51.840 --> 01:04:52.760
kodlar yazacağım.

01:04:52.940 --> 01:04:54.320
Şimdilik burayı kapatıyorum.

01:04:55.360 --> 01:04:55.580
Ve,

01:04:56.080 --> 01:04:57.780
şöyle bir main fonksiyonu yazalım.

01:04:59.020 --> 01:04:59.380
Main,

01:05:00.600 --> 01:05:02.060
vektör başlık dosyasını,

01:05:02.140 --> 01:05:03.160
yine dahil edelim.

01:05:04.240 --> 01:05:04.440
Bir,

01:05:04.540 --> 01:05:05.660
c-thread vektörü,

01:05:05.660 --> 01:05:06.440
oluşturalım.

01:05:09.440 --> 01:05:10.200
Arkadaşlar,

01:05:11.040 --> 01:05:12.140
stut vektörün,

01:05:12.140 --> 01:05:17.480
stut c-thread açılımı,

01:05:19.920 --> 01:05:21.280
thread başlık dosyası,

01:05:27.080 --> 01:05:27.720
ne diyelim,

01:05:28.480 --> 01:05:29.360
thread vektörü,

01:05:29.420 --> 01:05:29.920
t-vek,

01:05:32.640 --> 01:05:33.380
diyelim ki,

01:05:35.380 --> 01:05:37.140
20 kere dönen bir döngü,

01:05:38.100 --> 01:05:39.280
döngünün her turunda,

01:05:41.000 --> 01:05:41.940
and place back,

01:05:41.940 --> 01:05:43.260
ve,

01:05:44.060 --> 01:05:45.420
word load olarak da,

01:05:46.000 --> 01:05:46.460
who'yu,

01:05:46.940 --> 01:05:47.440
geçiyorum,

01:05:47.600 --> 01:05:47.960
full mu,

01:05:48.040 --> 01:05:48.800
harf neymiştik,

01:05:48.880 --> 01:05:49.660
pank'a geçiyorum.

01:05:51.500 --> 01:05:51.960
Süper.

01:05:52.780 --> 01:05:53.100
Şimdi,

01:05:53.200 --> 01:05:54.700
bu döngü çalıştıktan sonra,

01:05:55.820 --> 01:05:56.040
ve,

01:05:56.520 --> 01:05:58.100
bu nested scope'un sonunda,

01:05:58.400 --> 01:05:59.020
bu da ne demek,

01:05:59.260 --> 01:06:01.020
threadler join ettikten sonra,

01:06:01.020 --> 01:06:01.840
buna dikkat,

01:06:03.060 --> 01:06:04.240
özellikle bu amaçla,

01:06:04.320 --> 01:06:05.800
nested scope'u kullanıyorum ki,

01:06:05.920 --> 01:06:07.000
artık bütün threadlerin,

01:06:07.120 --> 01:06:08.020
burada join ettiği,

01:06:08.740 --> 01:06:09.600
garantisi var.

01:06:09.600 --> 01:06:10.520
ve,

01:06:10.520 --> 01:06:12.640
atomik değişkenimize ne ismi vermiştik,

01:06:12.760 --> 01:06:13.040
x,

01:06:13.720 --> 01:06:14.420
x'in,

01:06:14.920 --> 01:06:16.520
değerini yazdırıyorum.

01:06:19.900 --> 01:06:20.700
Şimdi,

01:06:20.840 --> 01:06:21.300
soru,

01:06:23.200 --> 01:06:23.760
arkadaşlar,

01:06:23.760 --> 01:06:26.980
artı artı,

01:06:26.980 --> 01:06:27.540
artı artı,

01:06:27.880 --> 01:06:28.220
x,

01:06:29.960 --> 01:06:31.780
10.000 çarpı,

01:06:32.160 --> 01:06:32.520
10,

01:06:32.660 --> 01:06:33.420
100.000,

01:06:34.040 --> 01:06:34.360
değil mi?

01:06:34.360 --> 01:06:38.320
20 thread olduğuna göre,

01:06:38.420 --> 01:06:39.880
200.000 mi olması gerekiyor.

01:06:40.820 --> 01:06:41.020
Evet,

01:06:41.140 --> 01:06:42.620
10.000 kez arttırdığına göre,

01:06:42.720 --> 01:06:43.660
20 x 10.000,

01:06:43.760 --> 01:06:45.160
ben de aritmetik biraz dayıp.

01:06:45.660 --> 01:06:45.840
Evet,

01:06:46.240 --> 01:06:46.580
burada,

01:06:46.900 --> 01:06:47.840
herhangi bir şekilde,

01:06:48.420 --> 01:06:50.660
200.000 olmama ihtimali var mı?

01:06:50.880 --> 01:06:52.180
Bir data race var mı?

01:06:53.320 --> 01:06:53.820
Cevap,

01:06:54.280 --> 01:06:55.380
neden var Kaan Can?

01:06:56.080 --> 01:06:57.220
Değişkeni mi atomik?

01:06:58.140 --> 01:06:58.720
Anladınız değil mi?

01:06:58.760 --> 01:06:59.820
Atomik olduğu için,

01:07:00.280 --> 01:07:01.200
böyle bir risk yok.

01:07:01.200 --> 01:07:02.700
Bu birinci soru.

01:07:03.560 --> 01:07:04.960
Şüphesiz bu değişken,

01:07:05.120 --> 01:07:06.400
atomik olmasaydı,

01:07:07.140 --> 01:07:09.000
onu göstermeme gerek var mı bilmiyorum.

01:07:09.880 --> 01:07:10.600
Arkadaşlar,

01:07:11.080 --> 01:07:12.840
böyle bir garanti veremezdim.

01:07:12.940 --> 01:07:13.200
Yani,

01:07:13.620 --> 01:07:14.700
şöyle olsaydı,

01:07:17.100 --> 01:07:17.640
bu artık,

01:07:17.800 --> 01:07:18.940
hepimiz biliyoruz,

01:07:19.040 --> 01:07:20.220
defalarca konuştuk.

01:07:22.780 --> 01:07:22.940
Evet,

01:07:23.340 --> 01:07:24.260
A necat yine,

01:07:24.420 --> 01:07:25.860
200.000 çıktı demeyin,

01:07:26.140 --> 01:07:27.060
o tamamen,

01:07:27.480 --> 01:07:28.360
çıkmaya da bilir.

01:07:28.560 --> 01:07:28.700
Yani,

01:07:28.820 --> 01:07:29.880
onu biliyoruz ki,

01:07:29.880 --> 01:07:31.180
daha önceki örneklerde,

01:07:31.200 --> 01:07:32.420
gördük.

01:07:33.060 --> 01:07:33.340
Mesela,

01:07:33.440 --> 01:07:35.120
biraz arttırdığım zaman,

01:07:36.120 --> 01:07:36.840
o bozabilir.

01:07:39.420 --> 01:07:40.740
Ya da bazen,

01:07:40.900 --> 01:07:41.220
bakın,

01:07:41.660 --> 01:07:42.580
tamamen değişti,

01:07:42.660 --> 01:07:43.420
görüyorsunuz değil mi?

01:07:43.780 --> 01:07:44.040
Peki,

01:07:44.280 --> 01:07:44.880
şimdi devam.

01:07:46.900 --> 01:07:48.140
Zaten bunu 100.000 yapalım.

01:07:49.140 --> 01:07:49.860
Bunu yine,

01:07:50.400 --> 01:07:51.260
atomik yapalım.

01:07:54.660 --> 01:07:55.140
Tut,

01:07:56.100 --> 01:07:56.800
atomik,

01:07:58.280 --> 01:07:58.600
int.

01:07:58.600 --> 01:08:00.600
Evet,

01:08:01.200 --> 01:08:02.540
şimdi ikinci soru.

01:08:03.200 --> 01:08:04.340
Önce basit sorular.

01:08:05.180 --> 01:08:06.760
X artı artı deseydim,

01:08:07.480 --> 01:08:08.440
herhangi bir şekilde,

01:08:09.680 --> 01:08:12.560
data race olmayacağı garantisi var mı yine?

01:08:14.160 --> 01:08:14.800
Cevap,

01:08:15.260 --> 01:08:15.560
var.

01:08:15.560 --> 01:08:17.420
çünkü bu işlem de atomik.

01:08:18.020 --> 01:08:18.460
Yani,

01:08:18.460 --> 01:08:20.240
bunu işlerleyip çalıştırmıyorum,

01:08:20.340 --> 01:08:20.720
bu basit.

01:08:21.720 --> 01:08:23.480
Bunun cevabını da bugün verdim ama,

01:08:24.200 --> 01:08:24.540
belki,

01:08:25.880 --> 01:08:27.680
onu konuşmadan sorsaydım,

01:08:28.780 --> 01:08:29.280
burada,

01:08:29.700 --> 01:08:31.200
data race olabilir mi diye,

01:08:32.280 --> 01:08:33.140
cevap ne?

01:08:33.620 --> 01:08:34.140
Evet.

01:08:34.880 --> 01:08:35.120
Çünkü,

01:08:35.280 --> 01:08:36.660
X artı bir işlemi,

01:08:37.100 --> 01:08:38.440
atomik değil.

01:08:38.440 --> 01:08:39.440
bakın,

01:08:39.440 --> 01:08:39.900
bakın şimdi.

01:08:47.580 --> 01:08:48.840
O değer olmadı.

01:08:48.920 --> 01:08:50.060
İki ayrı operasyon var,

01:08:50.140 --> 01:08:50.460
bravo.

01:08:51.080 --> 01:08:51.340
Peki,

01:08:52.120 --> 01:08:52.940
X eşit,

01:08:53.160 --> 01:08:53.640
arkadaşlar,

01:08:53.900 --> 01:08:54.780
böyle değil de,

01:08:55.300 --> 01:08:57.420
X artı eşit bir yazsaydım,

01:09:00.420 --> 01:09:02.080
cevap,

01:09:02.500 --> 01:09:04.040
bu yine atomik olacaktı.

01:09:04.040 --> 01:09:05.460
çünkü artı eşit,

01:09:06.260 --> 01:09:07.280
atomik işlem yine.

01:09:09.680 --> 01:09:10.760
Görüyoruz değil mi?

01:09:11.360 --> 01:09:11.800
Devam.

01:09:12.920 --> 01:09:13.340
Burada,

01:09:13.940 --> 01:09:15.620
Hatch Ed'i çağırsaydım,

01:09:19.860 --> 01:09:21.860
argüman olarak da bir geçseydim,

01:09:22.920 --> 01:09:23.140
yine,

01:09:23.640 --> 01:09:25.100
bunu da söylemeye gerek yok,

01:09:25.920 --> 01:09:26.180
değer,

01:09:26.180 --> 01:09:26.880
yine,

01:09:27.720 --> 01:09:31.180
iki milyon olma garantisini taşıyordu.

01:09:31.760 --> 01:09:31.980
Peki,

01:09:32.080 --> 01:09:32.680
şimdi bakın,

01:09:33.180 --> 01:09:33.820
ayrı soru.

01:09:34.040 --> 01:09:36.120
X change fonksiyonunu çağırıyorum.

01:09:37.920 --> 01:09:39.200
X exchange,

01:09:39.780 --> 01:09:40.680
X artı bir.

01:09:44.120 --> 01:09:44.880
Evet,

01:09:45.200 --> 01:09:46.360
işlem atomik mi?

01:09:50.920 --> 01:09:52.240
X'in storu,

01:09:52.280 --> 01:09:53.260
X artı bir ile,

01:09:54.180 --> 01:09:54.480
evet,

01:09:54.920 --> 01:09:55.740
cevap hayır,

01:09:56.000 --> 01:09:56.740
atomik değil.

01:09:58.000 --> 01:09:58.920
Atomik değil,

01:09:59.020 --> 01:09:59.320
çünkü,

01:09:59.800 --> 01:10:00.080
bakın,

01:10:00.220 --> 01:10:00.780
X yine,

01:10:01.580 --> 01:10:02.140
arkadaşlar,

01:10:02.140 --> 01:10:04.120
nasıl bir değişken,

01:10:04.220 --> 01:10:05.160
atomik değişken.

01:10:05.300 --> 01:10:05.580
O zaman,

01:10:05.660 --> 01:10:07.240
bu işlem atomik değil ki,

01:10:08.100 --> 01:10:09.140
arayan anlaşıldı mı?

01:10:10.060 --> 01:10:10.880
Genelde burada,

01:10:11.200 --> 01:10:11.700
nedense,

01:10:12.620 --> 01:10:12.940
evet,

01:10:13.300 --> 01:10:15.080
data race yok cevabı geliyor,

01:10:15.180 --> 01:10:16.580
ama burada data race var.

01:10:16.580 --> 01:10:22.440
yine araya o toplama işlemi girdiği için.

01:10:23.660 --> 01:10:24.360
Gördük değil mi?

01:10:24.360 --> 01:10:25.260
Evet,

01:10:26.140 --> 01:10:26.580
peki,

01:10:26.960 --> 01:10:28.700
biraz daha tuhaf hale getirelim.

01:10:30.700 --> 01:10:31.740
Int expected,

01:10:31.740 --> 01:10:38.060
eşittir,

01:10:38.060 --> 01:10:39.800
x,

01:10:39.800 --> 01:10:42.640
while,

01:10:45.020 --> 01:10:45.560
arkadaşlar,

01:10:47.380 --> 01:10:48.120
x'in,

01:10:48.780 --> 01:10:50.040
compare exchange,

01:10:50.280 --> 01:10:51.020
strong'u,

01:10:53.480 --> 01:10:54.120
expected,

01:10:54.120 --> 01:10:59.620
ve x artı bir.

01:11:02.940 --> 01:11:03.920
Takip edin.

01:11:05.420 --> 01:11:06.180
Burada da,

01:11:07.640 --> 01:11:08.840
döngünün gövdesi,

01:11:09.040 --> 01:11:09.740
null statement.

01:11:11.100 --> 01:11:11.440
Evet,

01:11:11.520 --> 01:11:11.980
hadi bakalım,

01:11:12.140 --> 01:11:13.580
burada data race var mı,

01:11:13.780 --> 01:11:14.180
yok mu?

01:11:18.400 --> 01:11:19.000
Cevap,

01:11:19.000 --> 01:11:23.280
yok.

01:11:24.000 --> 01:11:24.900
Data race yok.

01:11:25.540 --> 01:11:26.220
Çünkü zaten,

01:11:26.320 --> 01:11:27.100
compare exchange,

01:11:27.220 --> 01:11:27.520
strong.

01:11:29.140 --> 01:11:29.740
Arkadaşlar,

01:11:30.080 --> 01:11:31.840
bu amaçla yapılan bir işlem değil mi?

01:11:32.180 --> 01:11:32.880
Bir daha soruyorum,

01:11:32.960 --> 01:11:33.280
var mı,

01:11:33.320 --> 01:11:33.660
yok mu?

01:11:34.880 --> 01:11:35.160
Evet.

01:11:35.920 --> 01:11:36.360
Peki.

01:11:44.660 --> 01:11:45.660
Neden var?

01:11:45.940 --> 01:11:46.980
Yine x artı bir.

01:11:47.140 --> 01:11:47.320
Ama,

01:11:47.320 --> 01:11:49.140
şöyle yazsaydım,

01:11:49.720 --> 01:11:50.240
arkadaşlar,

01:11:50.560 --> 01:11:51.120
izleyin,

01:11:51.820 --> 01:11:52.220
x,

01:11:53.460 --> 01:11:55.780
ne diyelim,

01:11:56.280 --> 01:11:57.480
değişkenimizin ismi neydi?

01:11:57.660 --> 01:11:58.420
x load,

01:12:02.340 --> 01:12:02.620
bakın,

01:12:02.700 --> 01:12:03.800
x load,

01:12:06.100 --> 01:12:06.540
bu da,

01:12:07.400 --> 01:12:07.800
int,

01:12:08.320 --> 01:12:08.640
while,

01:12:12.000 --> 01:12:13.240
buraya da,

01:12:13.240 --> 01:12:15.160
while artı bir koysaydım,

01:12:15.160 --> 01:12:19.340
şimdi,

01:12:19.340 --> 01:12:22.920
cevabınızı verin yine,

01:12:24.340 --> 01:12:25.040
olur muydu?

01:12:26.880 --> 01:12:27.240
Yani,

01:12:27.580 --> 01:12:29.080
2 milyon olur muydu?

01:12:30.220 --> 01:12:31.360
Data race var mı?

01:12:33.260 --> 01:12:33.840
Cevap,

01:12:33.840 --> 01:12:39.380
evet,

01:12:39.380 --> 01:12:39.620
yine,

01:12:39.620 --> 01:12:39.660
yine,

01:12:39.660 --> 01:12:41.820
data race var.

01:12:42.760 --> 01:12:43.820
Takip edebiliyor muyuz?

01:12:44.240 --> 01:12:44.500
Peki,

01:12:44.640 --> 01:12:45.080
soru,

01:12:45.940 --> 01:12:46.560
burada,

01:12:47.720 --> 01:12:48.660
compare exchange,

01:12:48.760 --> 01:12:50.000
strong'u kullanarak,

01:12:51.160 --> 01:12:51.620
bunu,

01:12:52.360 --> 01:12:52.820
şuraya,

01:12:52.920 --> 01:12:53.740
kod yazarak,

01:12:54.380 --> 01:12:55.840
x değişkeninin değerini,

01:12:55.940 --> 01:12:57.600
hadi bu da soru açık kalsın size,

01:12:57.800 --> 01:12:59.300
x değişkeninin değerini,

01:12:59.300 --> 01:13:01.220
garantili olarak,

01:13:01.700 --> 01:13:02.920
data race olmadan,

01:13:03.280 --> 01:13:04.460
bir arttırmak için,

01:13:05.240 --> 01:13:05.920
nasıl bir,

01:13:06.260 --> 01:13:07.680
kod yazabilirdim?

01:13:08.940 --> 01:13:09.240
Evet,

01:13:10.140 --> 01:13:10.500
bu da,

01:13:10.700 --> 01:13:11.660
sorumuz.

01:13:12.980 --> 01:13:13.840
Bir düşünün bakalım.

01:13:14.760 --> 01:13:15.640
Siz düşünürken,

01:13:16.180 --> 01:13:16.680
ben de,

01:13:16.880 --> 01:13:17.120
şimdi,

01:13:17.480 --> 01:13:18.200
yavaş yavaş,

01:13:19.020 --> 01:13:19.520
arkadaşlar,

01:13:20.900 --> 01:13:21.300
konuyu,

01:13:21.860 --> 01:13:22.760
değiştireyim ve,

01:13:22.980 --> 01:13:23.200
şu,

01:13:23.680 --> 01:13:24.680
memory order,

01:13:25.040 --> 01:13:25.580
konusuna,

01:13:25.940 --> 01:13:26.360
gelelim.

01:13:26.360 --> 01:13:28.160
Arkadaşlar,

01:13:28.640 --> 01:13:28.960
önce,

01:13:29.540 --> 01:13:30.800
memory order ne demek?

01:13:31.600 --> 01:13:33.460
Biraz bundan bahsetmemiz gerekiyor.

01:13:33.560 --> 01:13:33.740
Yani,

01:13:33.800 --> 01:13:35.120
memory order demekle,

01:13:35.300 --> 01:13:36.120
kast edilen ne?

01:13:37.220 --> 01:13:38.520
Memory order demekle,

01:13:38.600 --> 01:13:39.300
kast edilen,

01:13:40.220 --> 01:13:41.500
birden fazla thread,

01:13:41.800 --> 01:13:42.900
çalıştığı zaman,

01:13:43.860 --> 01:13:44.620
bir thread'in,

01:13:44.960 --> 01:13:45.460
örneğin,

01:13:45.820 --> 01:13:46.860
bellek üstünde,

01:13:47.220 --> 01:13:48.500
yaptığı işlemlerin,

01:13:49.420 --> 01:13:50.420
sonuçlarının,

01:13:50.960 --> 01:13:52.840
başka bir thread tarafından,

01:13:52.840 --> 01:13:55.020
görülme garantisi var mı,

01:13:55.380 --> 01:13:55.860
yok mu?

01:13:56.360 --> 01:13:56.820
Yani,

01:13:56.980 --> 01:13:59.040
işlemlerde böyle bir sıralama,

01:13:59.440 --> 01:14:00.320
söz konusu mu,

01:14:00.660 --> 01:14:01.080
değil mi?

01:14:01.760 --> 01:14:02.020
Yani,

01:14:02.160 --> 01:14:02.760
threadler,

01:14:03.500 --> 01:14:05.120
değişkenlerin değerlerini,

01:14:06.020 --> 01:14:08.240
hangi sırayla görecek,

01:14:08.600 --> 01:14:09.960
böyle bir garanti var mı,

01:14:10.300 --> 01:14:10.800
yok mu?

01:14:11.580 --> 01:14:12.060
Bu konuya,

01:14:12.180 --> 01:14:13.460
genel olarak,

01:14:13.940 --> 01:14:15.840
memory order deniyor.

01:14:16.980 --> 01:14:17.740
Arkadaşlar,

01:14:18.100 --> 01:14:18.260
şimdi,

01:14:18.640 --> 01:14:20.200
az önce gösterdiğim,

01:14:20.320 --> 01:14:21.140
fonksiyonların,

01:14:21.140 --> 01:14:22.320
aslında,

01:14:22.760 --> 01:14:23.420
hepsinin,

01:14:23.420 --> 01:14:26.520
bir memory order nesi var,

01:14:26.780 --> 01:14:27.720
parametresi var.

01:14:28.440 --> 01:14:28.660
Şimdi,

01:14:29.160 --> 01:14:31.140
bu memory order parametreleri,

01:14:31.680 --> 01:14:32.740
bunlardan biri olacak,

01:14:32.900 --> 01:14:34.460
ama biri deprecate edildi.

01:14:34.460 --> 01:14:35.860
İzleyin,

01:14:35.920 --> 01:14:38.040
evet,

01:14:38.880 --> 01:14:39.400
arkadaşlar,

01:14:40.200 --> 01:14:41.880
memory order relaxed,

01:14:42.260 --> 01:14:43.700
memory order consume,

01:14:44.540 --> 01:14:45.940
memory order acquire,

01:14:46.360 --> 01:14:48.180
memory order release,

01:14:48.900 --> 01:14:51.240
memory order acquire release,

01:14:51.800 --> 01:14:54.800
memory order sequential consistent.

01:14:54.800 --> 01:14:56.220
Arkadaşlar,

01:14:56.300 --> 01:14:57.060
dikkat ederseniz,

01:14:57.380 --> 01:14:58.920
buradaki memory order,

01:14:59.080 --> 01:15:00.580
bir inum dürü.

01:15:01.820 --> 01:15:02.580
Dolayısıyla,

01:15:03.220 --> 01:15:04.680
bu az önce söylediğim,

01:15:04.920 --> 01:15:05.200
arada,

01:15:06.060 --> 01:15:08.000
underscore olan isimler,

01:15:08.680 --> 01:15:08.980
bunlar,

01:15:09.620 --> 01:15:10.420
aslında ne?

01:15:12.620 --> 01:15:13.420
Sabitler,

01:15:13.700 --> 01:15:15.280
numaralandırma sabitleri.

01:15:15.800 --> 01:15:16.800
Takip edebiliyor muyuz?

01:15:16.880 --> 01:15:17.700
Bunların her biri,

01:15:18.000 --> 01:15:18.660
aslında bir,

01:15:19.300 --> 01:15:20.720
enumeration constant.

01:15:21.680 --> 01:15:22.460
Ama şimdi,

01:15:22.460 --> 01:15:24.640
bir şeye dikkat etmenizi istiyorum.

01:15:24.800 --> 01:15:25.420
Bu türün,

01:15:25.740 --> 01:15:27.060
type def ismi neymiş?

01:15:27.700 --> 01:15:28.380
Memory order,

01:15:28.680 --> 01:15:29.000
değil mi?

01:15:29.200 --> 01:15:29.420
Yani,

01:15:29.480 --> 01:15:30.780
türün ismi memory order.

01:15:31.440 --> 01:15:32.920
Az önceki fonksiyonlardan,

01:15:33.700 --> 01:15:34.800
herhangi birine bakın.

01:15:35.620 --> 01:15:36.180
İzleyin.

01:15:40.260 --> 01:15:41.060
Mesela,

01:15:42.520 --> 01:15:43.180
atomic,

01:15:44.620 --> 01:15:45.000
int,

01:15:46.480 --> 01:15:47.040
arkadaşlar,

01:15:47.460 --> 01:15:47.820
x,

01:15:50.480 --> 01:15:51.240
x'in örneği,

01:15:51.240 --> 01:15:52.880
store fonksiyonunu çağırayın.

01:15:52.880 --> 01:15:55.680
x'in store fonksiyonunun,

01:15:56.440 --> 01:15:57.260
gördüğünüz gibi,

01:15:57.760 --> 01:15:59.100
ikinci parametresinin,

01:16:00.180 --> 01:16:02.580
memory order türünden olduğunu görüyorsunuz.

01:16:02.980 --> 01:16:04.040
Yani diyor ki,

01:16:04.500 --> 01:16:05.180
sen buraya,

01:16:05.720 --> 01:16:07.380
az önceki sabitlerden,

01:16:08.060 --> 01:16:09.060
birini geçeceksin.

01:16:10.700 --> 01:16:11.360
Arkadaşlar,

01:16:11.480 --> 01:16:12.060
işte bu,

01:16:12.560 --> 01:16:14.400
sabitlerden hangisinin,

01:16:14.400 --> 01:16:15.380
geçildiği,

01:16:16.480 --> 01:16:17.880
benlik üstünde yapılan,

01:16:17.880 --> 01:16:18.580
işlemin,

01:16:19.160 --> 01:16:20.320
hangi garantilere,

01:16:20.680 --> 01:16:21.460
verdiğine,

01:16:21.980 --> 01:16:22.800
karşılık geliyor.

01:16:23.660 --> 01:16:24.820
Burada tekrar söylüyorum,

01:16:24.960 --> 01:16:26.100
şu memory order,

01:16:26.220 --> 01:16:26.760
konsum,

01:16:26.860 --> 01:16:28.280
2020 ile eklendi,

01:16:28.400 --> 01:16:29.800
sonra pek de mantıklı olmadı,

01:16:29.880 --> 01:16:30.820
ortaya çıkınca,

01:16:31.660 --> 01:16:32.600
yanlış hatırlamıyorsam,

01:16:32.680 --> 01:16:33.860
2023 ile,

01:16:34.720 --> 01:16:35.760
deprecate edildi.

01:16:36.300 --> 01:16:37.740
Şimdi tekrar buraya bir dönelim.

01:16:37.740 --> 01:16:38.880
Önce,

01:16:39.360 --> 01:16:40.280
memory order,

01:16:40.660 --> 01:16:41.480
relax'den,

01:16:41.800 --> 01:16:42.400
başlayalım.

01:16:43.420 --> 01:16:44.140
Arkadaşlar,

01:16:44.640 --> 01:16:45.600
en gevşek,

01:16:45.980 --> 01:16:46.980
memory order,

01:16:47.400 --> 01:16:48.300
memory order,

01:16:48.440 --> 01:16:49.020
relax'd.

01:16:49.720 --> 01:16:51.220
Sadece ve sadece,

01:16:52.200 --> 01:16:52.840
işlemin,

01:16:53.220 --> 01:16:55.120
atomik olma garantisini veriyor.

01:16:56.060 --> 01:16:57.160
Herhangi bir şekilde,

01:16:58.160 --> 01:16:59.400
bir threadte yapılan,

01:16:59.400 --> 01:17:01.140
işlemlerin sonucunun,

01:17:02.160 --> 01:17:03.440
aynı atomik değişken,

01:17:03.500 --> 01:17:04.000
üstünde,

01:17:04.240 --> 01:17:05.140
ondan bahsediyorum.

01:17:05.140 --> 01:17:06.440
bir başka threadte,

01:17:07.200 --> 01:17:09.060
görülür olması garantisi yok.

01:17:09.180 --> 01:17:10.060
Yani bu ne demek?

01:17:10.900 --> 01:17:11.760
Memory order,

01:17:11.900 --> 01:17:12.640
relax'di,

01:17:13.140 --> 01:17:14.440
ne ile kullanamazsınız?

01:17:15.300 --> 01:17:16.660
Senkronizasyon amaçlı,

01:17:17.400 --> 01:17:18.160
kullanamazsınız.

01:17:18.260 --> 01:17:18.760
Demiştik ya,

01:17:18.840 --> 01:17:19.980
atomik değişkenlerin,

01:17:20.640 --> 01:17:21.400
bizi ilgilendiren,

01:17:21.480 --> 01:17:22.780
iki tane önemli özelliği var.

01:17:22.880 --> 01:17:23.040
Bir,

01:17:23.560 --> 01:17:24.560
atomik işlemlerin,

01:17:24.640 --> 01:17:25.600
bölünemez olması,

01:17:25.900 --> 01:17:27.280
yani data res olmaması.

01:17:28.620 --> 01:17:29.720
Ama iki,

01:17:31.980 --> 01:17:33.240
ordering sağlaması.

01:17:33.300 --> 01:17:33.620
Ama tabii,

01:17:33.700 --> 01:17:35.060
ordering sağlaması derken,

01:17:35.140 --> 01:17:36.880
işte onu sağlayacak mı,

01:17:36.980 --> 01:17:37.940
sağlamayacak mı,

01:17:38.760 --> 01:17:41.260
fonksiyona geçtiğimiz argümanın,

01:17:41.880 --> 01:17:43.980
bu memory order kategorilerinden,

01:17:44.240 --> 01:17:45.520
hangisi olduğu ile ilgili.

01:17:46.640 --> 01:17:47.200
Arkadaşlar,

01:17:48.340 --> 01:17:50.260
diğer taraftan,

01:17:50.320 --> 01:17:51.420
bu da herhalde,

01:17:51.880 --> 01:17:52.120
bir,

01:17:53.120 --> 01:17:53.600
ne diyelim,

01:17:53.780 --> 01:17:54.840
sürpriz olmayacak.

01:17:55.920 --> 01:17:57.760
Ne kadar çok garanti verirse,

01:17:59.000 --> 01:18:00.380
maliyet o kadar fazla.

01:18:01.300 --> 01:18:02.000
Buraya dikkat.

01:18:02.000 --> 01:18:04.540
yani bu çok genel bir ilke programlamada,

01:18:04.540 --> 01:18:06.540
özellikle multi-track programlamada.

01:18:07.940 --> 01:18:10.340
Bendek üstünde yapılan işlemlerde,

01:18:10.340 --> 01:18:19.300
ne kadar fazla garanti verilirse,

01:18:21.800 --> 01:18:23.960
maliyet o kadar,

01:18:24.080 --> 01:18:25.300
o denli fazla.

01:18:25.300 --> 01:18:29.480
mesela,

01:18:29.480 --> 01:18:30.420
ben hem,

01:18:31.420 --> 01:18:32.920
birazdan bahsedeceğimiz,

01:18:33.000 --> 01:18:34.680
bir ordering garantisi,

01:18:35.680 --> 01:18:35.940
ver,

01:18:36.040 --> 01:18:36.600
istiyorum.

01:18:37.260 --> 01:18:37.820
Ama,

01:18:38.080 --> 01:18:38.400
yine,

01:18:38.640 --> 01:18:39.420
bununla beraber,

01:18:39.900 --> 01:18:41.940
bir visibility garantisi de,

01:18:42.140 --> 01:18:43.060
elde etmek istiyorum,

01:18:43.200 --> 01:18:43.780
diyorsanız,

01:18:43.780 --> 01:18:44.920
en pahalısı bu.

01:18:46.420 --> 01:18:47.300
Ama,

01:18:47.400 --> 01:18:48.240
en ucusu da,

01:18:48.840 --> 01:18:50.840
relaxed memory order.

01:18:52.200 --> 01:18:53.400
Memory order,

01:18:53.560 --> 01:18:54.560
relaxed olunca,

01:18:54.780 --> 01:18:55.760
şu anlama geliyor,

01:18:57.140 --> 01:18:57.900
işlemin,

01:18:58.660 --> 01:19:00.640
bölünemez olmasının dışında,

01:19:01.200 --> 01:19:02.480
hiçbir garanti yok.

01:19:03.980 --> 01:19:05.380
Ama olabilecek,

01:19:05.480 --> 01:19:06.720
en düşük maliyette bu.

01:19:07.820 --> 01:19:08.340
Arkadaşlar,

01:19:08.400 --> 01:19:09.480
bu son derece önemli.

01:19:09.640 --> 01:19:09.860
Neden?

01:19:10.200 --> 01:19:10.440
Çünkü,

01:19:10.520 --> 01:19:11.820
çok sık yapılan bir hata.

01:19:11.820 --> 01:19:14.880
Fakat siz böyle bir atomik değişkende,

01:19:15.700 --> 01:19:17.600
gidip de store fonksiyonunu,

01:19:18.520 --> 01:19:19.260
bu şekilde,

01:19:19.620 --> 01:19:20.980
ya da store ne diyelim,

01:19:21.400 --> 01:19:21.760
patch,

01:19:22.320 --> 01:19:23.460
add fonksiyonunu,

01:19:24.680 --> 01:19:28.820
bu şekilde çağırırsanız,

01:19:29.560 --> 01:19:30.440
aslında burada,

01:19:31.680 --> 01:19:33.920
memory order değeri,

01:19:34.300 --> 01:19:36.900
olabilecek en yüksek garanti seviyesi.

01:19:36.900 --> 01:19:37.420
Yani,

01:19:37.720 --> 01:19:38.280
buradaki,

01:19:39.260 --> 01:19:41.800
şu sabiti geçmiş oluyorsunuz fonksiyonlar.

01:19:41.820 --> 01:19:42.480
neredeydi?

01:19:42.920 --> 01:19:43.920
Şuradaydı değil mi?

01:19:44.060 --> 01:19:44.240
Evet.

01:19:44.820 --> 01:19:46.540
Bu sabiti geçmiş oluyorsunuz.

01:19:46.900 --> 01:19:47.600
Memory order,

01:19:47.880 --> 01:19:49.080
sequential consistent.

01:19:50.060 --> 01:19:50.760
Oysa,

01:19:51.400 --> 01:19:52.140
eğer burada,

01:19:52.600 --> 01:19:52.900
bir,

01:19:53.320 --> 01:19:55.240
sıralama talebi yoksa,

01:19:55.920 --> 01:19:58.400
örneğin bunu bir sayıç olarak kullanacaksanız,

01:19:58.540 --> 01:19:59.540
en tipi görmeyiz.

01:20:00.700 --> 01:20:01.640
Atomik değişken,

01:20:01.820 --> 01:20:03.000
üstünde yapılan,

01:20:03.200 --> 01:20:03.920
işlemden,

01:20:04.120 --> 01:20:05.680
önceki işlemlerin,

01:20:05.680 --> 01:20:08.280
bu değişkenin değerinin,

01:20:08.280 --> 01:20:10.100
get edilmesinden sonra,

01:20:10.500 --> 01:20:11.640
görülebilir olması,

01:20:11.960 --> 01:20:12.540
gibi bir,

01:20:13.040 --> 01:20:13.620
arkadaşlar,

01:20:14.560 --> 01:20:16.240
default her zaman en pahalı olan,

01:20:16.340 --> 01:20:17.020
Alihan Bostra,

01:20:17.100 --> 01:20:17.220
evet,

01:20:17.660 --> 01:20:19.540
default her zaman en pahalı olan,

01:20:19.620 --> 01:20:20.640
en pahalı olan da,

01:20:21.600 --> 01:20:21.940
arkadaşlar,

01:20:22.100 --> 01:20:22.340
bu arada,

01:20:22.480 --> 01:20:23.460
buradaki terimler,

01:20:23.680 --> 01:20:25.440
C++'ın terimleri değil,

01:20:26.020 --> 01:20:27.880
bunlar genel programlama terimleri,

01:20:28.000 --> 01:20:28.220
bakın,

01:20:28.780 --> 01:20:29.020
bir,

01:20:29.460 --> 01:20:30.940
sequential consistency,

01:20:30.940 --> 01:20:32.900
yani Java'da da,

01:20:33.400 --> 01:20:34.120
o diye alsanız,

01:20:34.480 --> 01:20:36.240
mesela Java'da direkt model bu,

01:20:37.460 --> 01:20:39.520
yani Java'da multi-track programlamada,

01:20:39.660 --> 01:20:42.360
zaten sequential consistency hazır geliyor,

01:20:42.500 --> 01:20:43.500
bütün işlemler,

01:20:44.180 --> 01:20:45.280
sequential consistency,

01:20:45.900 --> 01:20:46.060
bu,

01:20:46.800 --> 01:20:50.140
sequential consistency,

01:20:52.840 --> 01:20:53.280
arkadaşlar,

01:20:53.900 --> 01:20:54.980
ikinci terim,

01:20:55.520 --> 01:20:56.060
acquire,

01:20:59.060 --> 01:20:59.600
acquire,

01:20:59.600 --> 01:21:02.540
tıpkı bu kelimeyi yazmakta zorlanmışımdır,

01:21:03.020 --> 01:21:04.620
release semantik,

01:21:06.140 --> 01:21:06.800
deflar söylüyorum,

01:21:06.880 --> 01:21:08.320
bunlar C++ terim mi,

01:21:08.600 --> 01:21:09.080
ne alaka,

01:21:09.220 --> 01:21:11.480
bunlar genel programlama terimi,

01:21:12.700 --> 01:21:14.040
aslında bizi ilgilendiren,

01:21:14.680 --> 01:21:15.280
bu ikisi,

01:21:15.980 --> 01:21:18.180
sequential consistency mi olacak,

01:21:18.800 --> 01:21:20.700
acquire release semantik mi olacak,

01:21:20.860 --> 01:21:21.300
yoksa,

01:21:22.080 --> 01:21:22.740
relaxed,

01:21:24.280 --> 01:21:25.020
semantik mi,

01:21:25.020 --> 01:21:29.040
şimdi biz,

01:21:29.040 --> 01:21:31.800
relaxed semantik'i konuşuyoruz,

01:21:32.500 --> 01:21:34.000
relaxed semantik demek,

01:21:34.740 --> 01:21:38.480
sadece bölünemezlik garantisi veriliyor demek,

01:21:39.360 --> 01:21:41.860
yani sıralama ilişkin hiçbir garanti yok,

01:21:42.940 --> 01:21:45.820
visibility'ye ilişkin hiçbir garanti yok,

01:21:46.560 --> 01:21:47.280
bu da ne demek,

01:21:47.280 --> 01:21:48.700
mesela,

01:21:48.700 --> 01:21:49.280
sizin,

01:21:50.700 --> 01:21:52.260
bir atomik sayıcınız var,

01:21:52.460 --> 01:21:53.280
bugün yazdığımız kodlardan,

01:21:54.020 --> 01:21:55.320
herhangi birini almanız,

01:21:55.560 --> 01:21:56.020
arkadaşlar,

01:21:58.020 --> 01:22:00.220
sizin bir atomik sayıcınız var,

01:22:00.220 --> 01:22:07.900
nasıl o koda geri dönsek daha iyi olacak ama,

01:22:08.280 --> 01:22:08.940
neyse yazayım,

01:22:10.040 --> 01:22:10.920
ve diyelim ki,

01:22:11.580 --> 01:22:12.540
farklı threadler,

01:22:13.260 --> 01:22:14.700
bunu arttırıyor,

01:22:14.820 --> 01:22:15.400
azaltıyor,

01:22:16.580 --> 01:22:17.980
yani art artı count yapıyor,

01:22:18.080 --> 01:22:19.220
eksi eksi count yapıyor,

01:22:20.120 --> 01:22:20.440
ama,

01:22:20.980 --> 01:22:22.400
sizin için önemli olan,

01:22:22.960 --> 01:22:23.440
arkadaşlar,

01:22:24.380 --> 01:22:25.140
bu işlemin,

01:22:25.780 --> 01:22:26.700
data release'e,

01:22:27.380 --> 01:22:28.940
sebep olmaması,

01:22:28.940 --> 01:22:31.440
yani sonuçta herhangi bir thread,

01:22:31.540 --> 01:22:32.700
bin kere arttıracaksa,

01:22:32.760 --> 01:22:34.000
yine bin kere arttıracak,

01:22:35.100 --> 01:22:37.700
araya başka bir işlemin girmesini istemiyorsunuz,

01:22:38.300 --> 01:22:39.920
ama hangi thread'in daha önce,

01:22:40.720 --> 01:22:42.340
bu değişkeni değiştirdi,

01:22:42.640 --> 01:22:43.540
sonra o,

01:22:44.080 --> 01:22:45.160
bir takım değişkenlerin,

01:22:45.300 --> 01:22:46.400
değerin başka bir thread,

01:22:46.560 --> 01:22:47.860
bu garantiyle okudu falan,

01:22:47.960 --> 01:22:48.720
böyle bir şey yok,

01:22:49.360 --> 01:22:50.160
anlaşıldı değil mi,

01:22:50.540 --> 01:22:51.200
bu da şu demek,

01:22:51.200 --> 01:22:53.200
mesela böyle durumda,

01:22:53.380 --> 01:22:54.840
programcılar yine gidiyor,

01:22:55.240 --> 01:22:55.760
arkadaşlar,

01:22:56.440 --> 01:22:58.600
relax semantiyi kullanmak yerine,

01:22:58.940 --> 01:22:59.860
efendim,

01:23:00.040 --> 01:23:02.220
daha maliyetli bir semantiyi,

01:23:02.300 --> 01:23:02.620
örneğin,

01:23:02.720 --> 01:23:04.120
akaryoliniz semantini,

01:23:04.200 --> 01:23:04.980
ya da,

01:23:05.100 --> 01:23:05.460
efendim,

01:23:06.260 --> 01:23:08.440
sequential consistency kullanıyor,

01:23:09.400 --> 01:23:10.040
biraz bu arada,

01:23:10.220 --> 01:23:11.220
tabii şöyle bir şey de var,

01:23:11.320 --> 01:23:12.160
şunu da söyleyelim,

01:23:12.760 --> 01:23:13.200
arkadaşlar,

01:23:13.200 --> 01:23:18.980
belirli işlemcilerde,

01:23:19.420 --> 01:23:20.840
belirli işlemlerin,

01:23:21.460 --> 01:23:22.680
hani sıra dışı şekilde,

01:23:22.840 --> 01:23:24.780
ilave verdiği garantiler de var,

01:23:25.080 --> 01:23:28.020
onu işlemcinin kendi dokumentasyonuna bakacaksınız,

01:23:28.740 --> 01:23:30.880
mesela bir işlemcide şöyle bir şey olabilir mi,

01:23:31.620 --> 01:23:34.100
intürü üstünde yapılan bütün işlemler,

01:23:34.100 --> 01:23:38.540
sanki atomik bir türmüş gibi bölünemez,

01:23:39.320 --> 01:23:39.920
bu olabilir,

01:23:40.620 --> 01:23:42.920
ama genel olarak böyle bir garanti yok,

01:23:43.200 --> 01:23:44.000
anlaşıldı değil mi,

01:23:44.480 --> 01:23:44.820
peki,

01:23:45.360 --> 01:23:46.800
biz şimdi buraya geri dönelim,

01:23:47.040 --> 01:23:47.720
ve gerçekten,

01:23:48.080 --> 01:23:49.160
biraz hızlı bir şekilde,

01:23:50.020 --> 01:23:50.500
arkadaşlar,

01:23:51.100 --> 01:23:53.320
relaxed semantiyi kullanarak,

01:23:54.320 --> 01:23:57.580
counter değişkenimizin değerini arttıralım,

01:23:58.160 --> 01:23:59.720
ya da eksiltelim,

01:23:59.720 --> 01:24:01.720
mesela full fonksiyonu,

01:24:02.700 --> 01:24:02.960
yine,

01:24:04.300 --> 01:24:07.400
yüz bin kez dönen bir döngüde,

01:24:08.940 --> 01:24:11.560
yüz bin kez dönen bir döngüde,

01:24:12.620 --> 01:24:14.000
altın değerini,

01:24:16.540 --> 01:24:19.280
patch add fonksiyonuna çağrı yaparak,

01:24:20.240 --> 01:24:20.800
ama bakalım,

01:24:21.020 --> 01:24:24.120
memory order parametresi olarak,

01:24:25.120 --> 01:24:25.600
slot,

01:24:27.140 --> 01:24:28.600
memory order,

01:24:29.720 --> 01:24:31.800
relaxed bunu kullandı,

01:24:32.940 --> 01:24:33.180
ve,

01:24:34.920 --> 01:24:36.180
bir diğerini geçti,

01:24:40.180 --> 01:24:40.980
ters yazdık,

01:24:42.280 --> 01:24:42.620
bir,

01:24:43.960 --> 01:24:44.460
stood,

01:24:45.180 --> 01:24:46.220
memory order,

01:24:46.880 --> 01:24:47.360
relaxed,

01:24:47.500 --> 01:24:48.020
şimdi oldu,

01:24:49.500 --> 01:24:50.720
bar fonksiyonu,

01:24:50.720 --> 01:25:01.020
bu da patch subtract,

01:25:02.020 --> 01:25:04.180
ama bu da arkadaşlar,

01:25:05.180 --> 01:25:05.720
relax,

01:25:09.720 --> 01:25:11.060
ve ben yine,

01:25:14.060 --> 01:25:15.800
tane vektör olayım,

01:25:15.800 --> 01:25:20.260
vektörün,

01:25:20.260 --> 01:25:20.660
vektörün,

01:25:24.500 --> 01:25:25.860
c-thread açılımı,

01:25:29.860 --> 01:25:30.260
vek,

01:25:34.260 --> 01:25:36.540
20 kez dönen bir döngü içinde,

01:25:36.540 --> 01:25:38.540
if,

01:25:38.540 --> 01:25:39.240
if,

01:25:40.240 --> 01:25:40.700
i,

01:25:41.700 --> 01:25:42.540
mod 2,

01:25:44.220 --> 01:25:44.980
bu durumda,

01:25:45.620 --> 01:25:46.200
which,

01:25:47.200 --> 01:25:48.320
and place back,

01:25:50.100 --> 01:25:51.000
c-thread,

01:25:53.400 --> 01:25:53.740
bu,

01:25:53.740 --> 01:26:13.480
arkadaşlar,

01:26:13.480 --> 01:26:13.820
ve,

01:26:13.820 --> 01:26:16.020
buraya geldiğinde programın akışı,

01:26:16.780 --> 01:26:18.820
fredler join edilmiş olacağı için,

01:26:18.820 --> 01:26:20.300
ben,

01:26:20.540 --> 01:26:21.820
değişkenimin ismi neydi,

01:26:22.580 --> 01:26:23.140
c-net,

01:26:23.820 --> 01:26:24.880
değerini yazdırayım,

01:26:26.940 --> 01:26:27.320
işte bu,

01:26:27.540 --> 01:26:28.880
en gevşek garanti,

01:26:29.880 --> 01:26:30.240
yine,

01:26:30.500 --> 01:26:32.900
burada bölünemezlik sağladığı için,

01:26:33.500 --> 01:26:34.120
burada ben,

01:26:34.720 --> 01:26:36.040
en düşük maliyetle,

01:26:36.340 --> 01:26:36.780
arkadaşlar,

01:26:36.980 --> 01:26:37.480
gördünüz,

01:26:37.800 --> 01:26:38.380
ne yaptım,

01:26:39.040 --> 01:26:39.580
otomik,

01:26:39.780 --> 01:26:40.620
bu işlemleri,

01:26:41.100 --> 01:26:42.100
gerçekleştirdim,

01:26:42.900 --> 01:26:44.000
takip edebiliyor muyuz,

01:26:44.000 --> 01:26:46.000
arkadaşlar,

01:26:46.920 --> 01:26:47.580
bakın şimdi,

01:26:48.780 --> 01:26:49.000
izleyin,

01:26:52.560 --> 01:26:54.000
gelelim ikinci garantiye,

01:26:55.620 --> 01:26:58.000
bu arada çok güzel bir kod daha var,

01:26:58.280 --> 01:26:58.760
yazdığım,

01:26:58.940 --> 01:27:00.480
konuyu çok güzel anlatıyor bence,

01:27:01.480 --> 01:27:01.780
bakın,

01:27:03.040 --> 01:27:04.880
bu kod aslında gerçekten,

01:27:05.420 --> 01:27:07.740
konuyu çok güzel anlatan bir kod,

01:27:08.400 --> 01:27:09.380
hangi garanti verilmiyor,

01:27:09.460 --> 01:27:10.400
hangi garanti verilmiyor,

01:27:11.660 --> 01:27:12.060
arkadaşlar,

01:27:12.720 --> 01:27:13.060
burada,

01:27:13.060 --> 01:27:15.880
long-long türünden bir değişken var,

01:27:16.180 --> 01:27:16.680
atomik,

01:27:16.780 --> 01:27:17.860
long-long da olabilirdi,

01:27:18.000 --> 01:27:19.000
int de olabilirdi,

01:27:19.800 --> 01:27:21.020
orası çok da önemli değil,

01:27:22.040 --> 01:27:22.980
ismi de data,

01:27:24.920 --> 01:27:26.420
blue work fonksiyonu,

01:27:28.060 --> 01:27:28.400
bu,

01:27:28.960 --> 01:27:31.320
parametreye thread'in id'si yenecek,

01:27:31.520 --> 01:27:32.700
yani benim verdiğim id,

01:27:34.380 --> 01:27:36.560
önce id'yi yazdıracak,

01:27:36.940 --> 01:27:37.340
arkadaşlar,

01:27:37.920 --> 01:27:38.320
sonra,

01:27:39.400 --> 01:27:41.480
patch add fonksiyonunun,

01:27:41.480 --> 01:27:43.420
geri dönüş değerini yazdıracak,

01:27:45.420 --> 01:27:46.680
patch add,

01:27:47.060 --> 01:27:47.820
biliyorsunuz,

01:27:48.060 --> 01:27:49.720
atomik değişkenin değerini,

01:27:50.240 --> 01:27:51.720
bu kadar miktar arttırıyor,

01:27:52.720 --> 01:27:53.100
bu da,

01:27:53.540 --> 01:27:55.260
memory order parametresi,

01:27:56.040 --> 01:27:57.480
ve geri dönüş değeri de,

01:27:58.460 --> 01:27:59.900
bu işlemden önceki değer,

01:27:59.900 --> 01:28:03.580
ve bu işlem,

01:28:04.080 --> 01:28:04.580
arkadaşlar,

01:28:04.960 --> 01:28:05.480
atomik,

01:28:07.480 --> 01:28:07.840
şimdi,

01:28:09.620 --> 01:28:11.400
8 tane thread oluşturdum,

01:28:12.360 --> 01:28:12.760
hatta,

01:28:13.140 --> 01:28:14.760
daha da fazla yapabilirdim,

01:28:14.840 --> 01:28:15.880
neyse böyle kalsın,

01:28:17.560 --> 01:28:19.860
ve ekran çıktısını görmenizi istiyorum,

01:28:20.520 --> 01:28:20.900
arkadaşlar,

01:28:20.900 --> 01:28:21.140
arkadaşlar,

01:28:25.780 --> 01:28:26.160
arkadaşlar,

01:28:26.360 --> 01:28:26.840
bakın şimdi,

01:28:26.960 --> 01:28:27.620
thread id,

01:28:28.020 --> 01:28:28.400
6,

01:28:29.500 --> 01:28:30.580
thread id'de,

01:28:31.220 --> 01:28:31.940
6'da,

01:28:32.320 --> 01:28:32.860
görülen,

01:28:33.620 --> 01:28:34.420
değer 5,

01:28:35.880 --> 01:28:40.000
bunun ne olduğunu anladınız mı,

01:28:40.920 --> 01:28:41.260
yani,

01:28:42.160 --> 01:28:43.040
değeri aslında,

01:28:43.400 --> 01:28:44.300
6 yapmış,

01:28:45.260 --> 01:28:45.760
fakat,

01:28:46.180 --> 01:28:46.400
bu,

01:28:47.100 --> 01:28:48.160
fetch add fonksiyonunda,

01:28:48.260 --> 01:28:49.260
geri dönüş değeri,

01:28:49.680 --> 01:28:50.000
5,

01:28:50.000 --> 01:28:52.060
alttakine bakın,

01:28:52.220 --> 01:28:52.540
4,

01:28:52.780 --> 01:28:53.040
1,

01:28:54.140 --> 01:28:54.540
arkadaşlar,

01:28:54.740 --> 01:28:56.420
biz bunu bu sırayla görüyoruz,

01:28:56.560 --> 01:28:57.440
ama sonuçta,

01:28:58.260 --> 01:29:00.000
bir tanesi onu 0 yaptı,

01:29:00.360 --> 01:29:01.400
biri 1 yaptı,

01:29:01.680 --> 01:29:02.600
diğeri 2 yaptı,

01:29:02.700 --> 01:29:03.240
3 yaptı,

01:29:03.300 --> 01:29:03.800
4 yaptı,

01:29:03.880 --> 01:29:04.380
5 yaptı,

01:29:04.440 --> 01:29:05.240
6 yaptı,

01:29:06.000 --> 01:29:07.380
ve 7 yaptı,

01:29:08.500 --> 01:29:10.460
burada bir sıralama söz konusu değil,

01:29:10.460 --> 01:29:11.700
ama işlemin,

01:29:12.040 --> 01:29:14.040
atomik olması garantisi var,

01:29:15.160 --> 01:29:15.860
gelelim,

01:29:16.600 --> 01:29:18.320
acquire release semantini,

01:29:18.580 --> 01:29:19.300
şimdi burası,

01:29:19.300 --> 01:29:21.120
biraz zor anlaşılan kısım,

01:29:22.460 --> 01:29:22.980
arkadaşlar,

01:29:23.400 --> 01:29:24.980
acquire release semantiyi,

01:29:25.480 --> 01:29:26.180
şunu sağlıyor,

01:29:27.160 --> 01:29:29.060
bizim bir atomik değişkenimiz var,

01:29:29.700 --> 01:29:30.360
atomik,

01:29:30.860 --> 01:29:31.280
x,

01:29:32.860 --> 01:29:34.760
atomik x değişkeni üstünde,

01:29:35.160 --> 01:29:36.700
bir store işlemi yapılıyor,

01:29:37.580 --> 01:29:39.020
store işlemi ne demek,

01:29:39.360 --> 01:29:41.640
değişkenin değerini değiştiren bir işlem,

01:29:41.640 --> 01:29:42.020
yani,

01:29:42.360 --> 01:29:44.260
illa store fonksiyonu olması gerekmiyor,

01:29:44.260 --> 01:29:45.380
arkadaşlar,

01:29:46.380 --> 01:29:47.540
eşittir olabilir,

01:29:47.800 --> 01:29:48.540
store olabilir,

01:29:48.940 --> 01:29:49.220
efendim,

01:29:49.380 --> 01:29:50.540
fetch add olabilir,

01:29:51.660 --> 01:29:53.120
fetch sub olabilir,

01:29:53.520 --> 01:29:54.180
önemli olan,

01:29:54.820 --> 01:29:56.340
bir store işlemi olması,

01:29:57.620 --> 01:29:58.280
diyelim ki,

01:29:59.440 --> 01:30:00.160
fetch add,

01:30:02.340 --> 01:30:03.760
bu atomik bir işlem değil mi,

01:30:04.600 --> 01:30:05.360
ya da store,

01:30:06.920 --> 01:30:07.740
embosik örnek,

01:30:10.260 --> 01:30:10.500
bu,

01:30:11.000 --> 01:30:11.840
atomik x'in,

01:30:11.940 --> 01:30:13.740
başlangıçtaki değeri de,

01:30:14.260 --> 01:30:14.980
efendim,

01:30:15.640 --> 01:30:16.320
dört olsun,

01:30:17.700 --> 01:30:18.060
eğer,

01:30:18.240 --> 01:30:19.800
şimdi buraya çok dikkatli izleyin,

01:30:20.340 --> 01:30:20.700
eğer,

01:30:21.160 --> 01:30:24.080
atomik değişkenin üstünde yapılan store işlemi,

01:30:25.680 --> 01:30:26.820
memory order,

01:30:27.100 --> 01:30:28.080
bellek sıralaması,

01:30:28.160 --> 01:30:29.200
diye Türkçe'ye çeviriyorlar,

01:30:29.300 --> 01:30:31.240
bellek sıralama düzeni olarak,

01:30:32.660 --> 01:30:34.520
memory order acquire ise,

01:30:34.520 --> 01:30:36.240
biz de yapalım o zaman,

01:30:36.720 --> 01:30:38.400
memory order,

01:30:39.400 --> 01:30:41.920
acquire,

01:30:41.920 --> 01:30:45.140
yani deminki sabitlerden,

01:30:45.760 --> 01:30:46.540
akaryo olan,

01:30:47.120 --> 01:30:48.220
takip etmeye çalışan,

01:30:48.900 --> 01:30:49.200
tamam,

01:30:50.200 --> 01:30:50.700
şimdi,

01:30:51.460 --> 01:30:52.600
çok dikkatli izleyin,

01:30:52.740 --> 01:30:53.740
şu garanti var,

01:30:54.700 --> 01:30:55.300
diyelim ki,

01:30:55.300 --> 01:30:58.660
bu thread'te yapılan bir takım işlemler var,

01:30:58.900 --> 01:31:00.000
bu değişkenlerin,

01:31:00.640 --> 01:31:02.200
atomik olması da gerekmiyor,

01:31:02.780 --> 01:31:03.020
mesela,

01:31:03.160 --> 01:31:04.160
A değişkenine,

01:31:04.620 --> 01:31:05.820
10 değeri atandı,

01:31:06.620 --> 01:31:07.760
B değişkenine,

01:31:08.340 --> 01:31:09.020
bunların türü,

01:31:09.260 --> 01:31:10.120
beni ilgilendirmiyor,

01:31:10.240 --> 01:31:12.120
Necati Ergin değeri atandı,

01:31:13.020 --> 01:31:14.080
C değişkenine,

01:31:14.520 --> 01:31:17.580
3.467 değeri atandı,

01:31:18.880 --> 01:31:19.360
arkadaşlar,

01:31:19.700 --> 01:31:20.820
takip edebiliyor musunuz,

01:31:21.180 --> 01:31:21.420
evet,

01:31:21.420 --> 01:31:22.880
şimdi,

01:31:23.980 --> 01:31:24.580
izleyin,

01:31:25.400 --> 01:31:25.840
eğer,

01:31:26.200 --> 01:31:27.760
aynı atomik değişken,

01:31:27.840 --> 01:31:28.380
üstünde,

01:31:29.720 --> 01:31:30.200
bu sefer,

01:31:30.300 --> 01:31:31.560
bir okuma işlemi,

01:31:31.780 --> 01:31:32.640
mesela load,

01:31:33.020 --> 01:31:34.380
tipik bir okuma işlemi,

01:31:35.980 --> 01:31:36.620
onun da,

01:31:36.980 --> 01:31:37.460
arkadaşlar,

01:31:38.140 --> 01:31:38.640
özür dilerim,

01:31:38.720 --> 01:31:39.540
burada acquire,

01:31:39.660 --> 01:31:40.980
benim release diyecektim,

01:31:41.700 --> 01:31:42.440
acquire olur mu,

01:31:42.500 --> 01:31:42.920
release,

01:31:43.760 --> 01:31:45.640
benim acquire release diye okuduğum için,

01:31:45.960 --> 01:31:46.860
buraya yanlış yazdım,

01:31:46.920 --> 01:31:47.380
önemli değil,

01:31:47.860 --> 01:31:48.060
evet,

01:31:48.060 --> 01:31:48.980
şimdi,

01:31:49.440 --> 01:31:49.800
eğer,

01:31:50.020 --> 01:31:50.840
store işlemi,

01:31:51.120 --> 01:31:51.520
acquire,

01:31:51.940 --> 01:31:54.200
memory order release ile yapılıyorsa,

01:31:55.400 --> 01:31:57.060
aynı atomik değişkeni,

01:31:57.180 --> 01:31:58.500
okuyan thread de,

01:31:59.260 --> 01:32:00.900
oradaki okuma işlemi ne,

01:32:01.180 --> 01:32:01.940
buraya dikkat,

01:32:02.340 --> 01:32:02.740
arkadaşlar,

01:32:03.700 --> 01:32:05.220
memory order,

01:32:05.600 --> 01:32:06.880
acquire ile yapıyorsa,

01:32:07.300 --> 01:32:07.560
mesela,

01:32:07.700 --> 01:32:08.000
burada,

01:32:08.960 --> 01:32:09.780
başka bir thread,

01:32:10.640 --> 01:32:12.240
orada da şöyle bir kod var,

01:32:13.040 --> 01:32:14.240
atomik eksin,

01:32:14.360 --> 01:32:14.540
bakın,

01:32:14.540 --> 01:32:15.920
aynı atomik değişkeni olacak,

01:32:15.920 --> 01:32:18.460
atomik eksin,

01:32:20.100 --> 01:32:20.940
load'u,

01:32:22.560 --> 01:32:23.640
memory order,

01:32:26.460 --> 01:32:26.900
acquire,

01:32:29.060 --> 01:32:29.460
arkadaşlar,

01:32:29.660 --> 01:32:30.140
zaten bakın,

01:32:30.260 --> 01:32:30.700
release,

01:32:31.020 --> 01:32:31.720
publish demek,

01:32:31.880 --> 01:32:32.780
bazen ben de demin,

01:32:32.860 --> 01:32:33.800
ismi yanlış yazdım,

01:32:33.880 --> 01:32:34.740
nasıl anlattığım için,

01:32:36.000 --> 01:32:36.300
değil mi,

01:32:36.440 --> 01:32:37.760
yani serbest bırakmak,

01:32:37.940 --> 01:32:39.320
anlamında,

01:32:39.460 --> 01:32:40.640
acquire'da edinmek,

01:32:41.820 --> 01:32:42.640
çok dikkat bilinize,

01:32:42.640 --> 01:32:43.800
bu durumda,

01:32:43.980 --> 01:32:46.020
şöyle bir senkronizasyon garantisi,

01:32:46.120 --> 01:32:47.080
elde ediyorsunuz,

01:32:47.860 --> 01:32:48.520
buradaki,

01:32:49.180 --> 01:32:50.220
atomik değişkeni,

01:32:50.220 --> 01:32:51.240
üstünde yapılan,

01:32:51.980 --> 01:32:52.240
ama,

01:32:52.460 --> 01:32:53.180
memory order,

01:32:53.280 --> 01:32:53.760
acquire,

01:32:53.980 --> 01:32:55.000
bellek düzeniyle,

01:32:56.000 --> 01:32:57.620
okuma işleminden sonra,

01:32:58.320 --> 01:32:59.920
buradaki store işleminden,

01:33:00.120 --> 01:33:00.820
önceki,

01:33:01.020 --> 01:33:02.640
bütün yazma işlemleri,

01:33:03.280 --> 01:33:03.780
artık,

01:33:04.240 --> 01:33:05.040
visible olacak,

01:33:06.420 --> 01:33:06.800
yani,

01:33:07.600 --> 01:33:08.120
artık,

01:33:08.500 --> 01:33:09.380
hangi koşulla,

01:33:09.380 --> 01:33:10.840
kod üretilmek zorunda,

01:33:10.840 --> 01:33:11.860
arkadaşlar,

01:33:12.800 --> 01:33:14.100
buradaki işlemler,

01:33:15.060 --> 01:33:15.680
buraya,

01:33:16.140 --> 01:33:16.840
geçemez,

01:33:17.380 --> 01:33:18.240
burayı anladık mı,

01:33:19.020 --> 01:33:19.220
yani,

01:33:19.340 --> 01:33:20.460
buradaki işlemler,

01:33:21.000 --> 01:33:22.600
bu load'dan sonrasına,

01:33:22.900 --> 01:33:23.540
geçemez,

01:33:24.280 --> 01:33:24.940
dolayısıyla,

01:33:25.780 --> 01:33:27.320
neden emin olarak,

01:33:27.440 --> 01:33:28.580
bu kodu yazabiliriz,

01:33:29.200 --> 01:33:30.580
artık load'dan sonra,

01:33:30.860 --> 01:33:32.100
store'dan önceki,

01:33:32.460 --> 01:33:33.300
işlemlerin,

01:33:34.100 --> 01:33:35.020
sonucunun,

01:33:35.480 --> 01:33:37.060
buradaki load'dan sonra,

01:33:37.520 --> 01:33:38.760
görülme garantisine,

01:33:38.980 --> 01:33:39.580
güvenerek,

01:33:39.580 --> 01:33:41.080
kod yazabiliriz,

01:33:42.100 --> 01:33:42.560
işte bakın,

01:33:42.660 --> 01:33:43.100
producer,

01:33:43.320 --> 01:33:43.820
consumer,

01:33:44.700 --> 01:33:45.300
modeli,

01:33:45.580 --> 01:33:46.600
zaten tamamen,

01:33:46.680 --> 01:33:47.080
bu demek,

01:33:47.960 --> 01:33:49.460
gerçekten bunu deneyelim mi,

01:33:49.760 --> 01:33:50.980
bir kod yazalım beraber,

01:33:51.460 --> 01:33:52.580
birazdan ara vereceğim,

01:33:53.260 --> 01:33:53.720
gerçekten,

01:33:53.920 --> 01:33:55.300
acquire release semantiyi,

01:33:55.380 --> 01:33:55.940
tutuyor mu,

01:33:56.500 --> 01:33:56.900
arkadaşlar,

01:33:57.100 --> 01:33:57.660
şimdiye kadar,

01:33:57.760 --> 01:33:59.120
bir senkronizasyonu,

01:34:00.080 --> 01:34:00.820
yani,

01:34:00.900 --> 01:34:01.780
bu happens before,

01:34:01.860 --> 01:34:02.460
ilişkisini,

01:34:02.640 --> 01:34:04.180
senkronize with ilişkisini,

01:34:04.280 --> 01:34:05.000
geçen derste,

01:34:05.580 --> 01:34:06.460
tek tek saydım,

01:34:06.460 --> 01:34:08.180
hangi durumlarda var,

01:34:08.840 --> 01:34:09.740
arkadaşlar,

01:34:10.480 --> 01:34:10.620
onu,

01:34:10.740 --> 01:34:12.080
hayır load satırı dahil değil,

01:34:12.180 --> 01:34:13.040
load'dan sonra,

01:34:14.100 --> 01:34:15.540
onu tek tek söylemiştim,

01:34:15.700 --> 01:34:16.420
ama bakın şimdi,

01:34:16.800 --> 01:34:17.460
başka bir,

01:34:17.560 --> 01:34:19.000
synchronized with durumu,

01:34:19.140 --> 01:34:19.820
daha oluşuyor,

01:34:20.480 --> 01:34:21.040
izleyin,

01:34:21.240 --> 01:34:21.940
word for,

01:34:23.680 --> 01:34:24.900
burada değişkenler var,

01:34:25.000 --> 01:34:25.400
bakın bunlar,

01:34:25.460 --> 01:34:26.860
otomik olmak zorunda da değil,

01:34:27.780 --> 01:34:28.740
index eşittir,

01:34:28.880 --> 01:34:29.140
0,

01:34:29.140 --> 01:34:31.520
suit string,

01:34:31.520 --> 01:34:33.520
suit string,

01:34:33.520 --> 01:34:37.520
suit string,

01:34:38.060 --> 01:34:38.580
str,

01:34:40.140 --> 01:34:40.620
arkadaşlar,

01:34:40.900 --> 01:34:41.680
eşittir,

01:34:42.240 --> 01:34:42.900
necati,

01:34:48.520 --> 01:34:49.000
efendim,

01:34:49.560 --> 01:34:50.080
ne olsun,

01:34:50.600 --> 01:34:51.180
yeter mi,

01:34:51.260 --> 01:34:52.140
bir tane daha mı koyalım,

01:34:52.280 --> 01:34:52.520
tamam,

01:34:53.600 --> 01:34:53.960
int,

01:34:54.320 --> 01:34:54.540
ye,

01:34:55.140 --> 01:34:55.880
eşittir,

01:34:56.520 --> 01:34:56.840
0,

01:34:56.840 --> 01:34:58.940
şimdi,

01:34:59.080 --> 01:34:59.800
fu'ya bakın,

01:35:02.160 --> 01:35:03.300
önce bu değişkenlerin,

01:35:03.380 --> 01:35:04.500
değerini değiştirecek,

01:35:05.440 --> 01:35:06.620
x eşit,

01:35:06.980 --> 01:35:07.840
9,99,

01:35:09.600 --> 01:35:11.100
str eşit,

01:35:12.220 --> 01:35:12.720
Alihan,

01:35:14.600 --> 01:35:15.480
ye eşit,

01:35:16.240 --> 01:35:17.500
3333,

01:35:18.500 --> 01:35:19.020
ve sonra,

01:35:19.020 --> 01:35:19.880
buraya dikkat,

01:35:20.140 --> 01:35:22.100
benim bir atomik değişkenim var,

01:35:22.920 --> 01:35:23.340
suit,

01:35:24.260 --> 01:35:25.020
atomik,

01:35:25.020 --> 01:35:26.580
arkadaşlar,

01:35:27.800 --> 01:35:28.320
ne,

01:35:28.640 --> 01:35:29.060
bool,

01:35:31.660 --> 01:35:32.160
flag,

01:35:35.480 --> 01:35:36.080
eşittir,

01:35:36.180 --> 01:35:36.520
false,

01:35:40.720 --> 01:35:41.320
ve şimdi,

01:35:42.720 --> 01:35:44.380
atomik değişkeninin değerini,

01:35:44.860 --> 01:35:45.640
true'ya çekiyor,

01:35:46.680 --> 01:35:47.720
flag eşittir,

01:35:48.320 --> 01:35:48.540
true,

01:35:49.540 --> 01:35:50.240
ama bunu,

01:35:50.980 --> 01:35:52.080
bu şekilde değil de,

01:35:52.260 --> 01:35:52.900
nasıl yapıyor,

01:35:52.900 --> 01:35:56.260
memori order release,

01:35:56.560 --> 01:35:57.480
kullanmak için,

01:35:58.220 --> 01:35:59.040
x nokta,

01:35:59.820 --> 01:36:00.400
x miydi,

01:36:01.020 --> 01:36:01.360
flag,

01:36:01.640 --> 01:36:03.360
flag nokta,

01:36:04.200 --> 01:36:04.600
arkadaşlar,

01:36:04.860 --> 01:36:05.400
store,

01:36:07.280 --> 01:36:07.540
ve,

01:36:09.020 --> 01:36:10.580
boolean value,

01:36:11.860 --> 01:36:12.460
izleyin,

01:36:14.680 --> 01:36:15.040
true,

01:36:16.580 --> 01:36:16.960
ve,

01:36:18.400 --> 01:36:19.360
stut,

01:36:19.680 --> 01:36:20.420
memori order,

01:36:20.420 --> 01:36:24.340
release ediyorum,

01:36:25.580 --> 01:36:25.800
şimdi,

01:36:25.860 --> 01:36:26.460
bu ne demek,

01:36:27.240 --> 01:36:27.740
bir başka,

01:36:27.880 --> 01:36:28.380
thread de,

01:36:29.400 --> 01:36:31.160
aynı atomik değişkenden,

01:36:31.580 --> 01:36:32.920
değeri okuduğumuzda,

01:36:33.920 --> 01:36:34.340
arkadaşlar,

01:36:35.660 --> 01:36:36.160
değerin,

01:36:37.200 --> 01:36:39.380
değeri okuduğumuzda,

01:36:39.540 --> 01:36:41.040
değeri okuduktan sonra,

01:36:41.500 --> 01:36:42.760
buradaki işlemlerin,

01:36:43.100 --> 01:36:44.680
görülür olma garantisini,

01:36:44.800 --> 01:36:45.480
elde ediyoruz,

01:36:45.480 --> 01:36:47.520
takip edebiliyor muyuz,

01:36:47.940 --> 01:36:48.220
yani,

01:36:48.280 --> 01:36:48.820
bu şu demek,

01:36:49.500 --> 01:36:49.720
ben,

01:36:49.800 --> 01:36:50.740
diğer thread de,

01:36:51.220 --> 01:36:52.940
buradaki flag değişkenini,

01:36:53.280 --> 01:36:54.300
true olarak,

01:36:54.460 --> 01:36:55.680
okuduğum noktada,

01:36:56.740 --> 01:36:57.220
aslında,

01:36:57.940 --> 01:36:58.900
ne garantim var,

01:36:59.720 --> 01:37:00.940
buradaki işlemlerin,

01:37:01.260 --> 01:37:02.620
görülme garantisi var,

01:37:03.480 --> 01:37:04.140
ve arkadaşlar,

01:37:04.640 --> 01:37:05.420
buraya dikkat,

01:37:06.380 --> 01:37:07.980
buradaki işlemler,

01:37:08.980 --> 01:37:10.320
sıralama olarak,

01:37:11.220 --> 01:37:11.700
derleyici,

01:37:11.760 --> 01:37:12.020
mesela,

01:37:12.140 --> 01:37:14.020
şöyle bir optimizasyon yapabilir mi,

01:37:14.020 --> 01:37:15.220
kritik yer burası,

01:37:15.360 --> 01:37:16.300
ordering ile ilgili,

01:37:17.460 --> 01:37:17.700
ee,

01:37:17.820 --> 01:37:18.400
normalde,

01:37:18.480 --> 01:37:18.620
hani,

01:37:18.800 --> 01:37:19.420
derleyici,

01:37:20.080 --> 01:37:22.220
kodun daha hızlı çalıştığını düşünerek,

01:37:22.940 --> 01:37:24.380
observable behavior,

01:37:24.780 --> 01:37:25.900
değişmiyor diye,

01:37:26.660 --> 01:37:29.260
işlemlerin sırasını değiştirebilir,

01:37:29.400 --> 01:37:29.700
değil mi,

01:37:30.500 --> 01:37:31.100
ama şimdi,

01:37:31.380 --> 01:37:31.720
örneğin,

01:37:31.800 --> 01:37:33.080
buradaki işlemleri,

01:37:33.340 --> 01:37:34.820
buraya alabilir mi,

01:37:35.080 --> 01:37:35.700
cevap hayır,

01:37:36.660 --> 01:37:37.260
artık bu,

01:37:37.440 --> 01:37:38.700
yasaklanmış durumda,

01:37:38.800 --> 01:37:39.120
çünkü,

01:37:39.780 --> 01:37:41.060
buradaki store işlemi,

01:37:41.320 --> 01:37:42.340
bu garantiyi veriyor,

01:37:42.340 --> 01:37:43.280
şimdi,

01:37:43.280 --> 01:37:45.940
diğer thread'e yazacağız,

01:37:46.160 --> 01:37:46.620
arkadaşlar,

01:37:47.580 --> 01:37:47.820
mesela,

01:37:47.960 --> 01:37:49.020
diğer thread'de de,

01:37:49.340 --> 01:37:50.320
şöyle bir kod olsun,

01:37:51.260 --> 01:37:51.940
void bar,

01:37:56.520 --> 01:37:57.120
bu da aslında,

01:37:57.240 --> 01:37:58.520
consumer'a karşılık geliyor,

01:37:58.680 --> 01:37:58.980
değil mi,

01:38:01.560 --> 01:38:04.980
void bar,

01:38:04.980 --> 01:38:10.400
buraya dikkat şimdi,

01:38:11.600 --> 01:38:12.560
load edecek,

01:38:13.420 --> 01:38:13.940
arkadaşlar,

01:38:15.360 --> 01:38:16.700
neydi değişkenin ismi,

01:38:17.980 --> 01:38:19.320
bir var döngüsü içinde,

01:38:20.420 --> 01:38:20.820
while,

01:38:24.820 --> 01:38:25.900
flag'in,

01:38:27.320 --> 01:38:28.060
load'u,

01:38:28.060 --> 01:38:29.440
ama,

01:38:29.440 --> 01:38:31.940
bellek düzeni olarak ne kullanacak,

01:38:32.680 --> 01:38:33.520
memory order,

01:38:33.740 --> 01:38:34.940
acquire kullanacak,

01:38:35.840 --> 01:38:36.260
stud,

01:38:37.180 --> 01:38:38.320
memory order,

01:38:39.940 --> 01:38:40.400
acquire,

01:38:46.400 --> 01:38:47.200
arkadaşlar,

01:38:47.960 --> 01:38:48.120
evet,

01:38:48.340 --> 01:38:49.640
false döndüğü sürece,

01:38:49.640 --> 01:38:53.520
false döndüğü sürece,

01:38:53.940 --> 01:38:54.960
bu döngü dönsün,

01:38:55.980 --> 01:38:56.700
şimdi artık,

01:38:57.520 --> 01:38:58.740
programın akışı,

01:38:59.080 --> 01:39:00.460
load'tan sonraki,

01:39:00.740 --> 01:39:01.720
koda geldiğinde,

01:39:02.940 --> 01:39:04.160
yani artık burası,

01:39:04.520 --> 01:39:05.580
bizim flag'imizi,

01:39:05.740 --> 01:39:07.180
true olarak gördüğünde,

01:39:08.220 --> 01:39:08.680
arkadaşlar,

01:39:09.100 --> 01:39:10.180
şu işlemlerin,

01:39:10.580 --> 01:39:11.880
yapılma garantisi var,

01:39:12.380 --> 01:39:13.880
şimdi bana şöyle diyebilirsiniz,

01:39:14.480 --> 01:39:15.340
belki şöyle olduğunu,

01:39:15.440 --> 01:39:15.640
zannediyordunuz,

01:39:15.640 --> 01:39:16.240
ediyordunuz,

01:39:16.840 --> 01:39:18.640
Necati zaten böyle diyeyim,

01:39:18.780 --> 01:39:19.440
değil işte,

01:39:20.220 --> 01:39:21.180
yani bu garantinin,

01:39:21.300 --> 01:39:21.620
mesela,

01:39:21.760 --> 01:39:22.960
relax modeli olsaydı,

01:39:23.080 --> 01:39:23.320
burada,

01:39:23.920 --> 01:39:24.940
bunlar memory order,

01:39:25.040 --> 01:39:26.180
relaxed olsaydı,

01:39:27.000 --> 01:39:27.320
ben,

01:39:27.620 --> 01:39:28.660
buradaki kodda,

01:39:28.960 --> 01:39:30.140
artık bu değişkenlerin,

01:39:30.280 --> 01:39:31.780
değerinin değiştirildiği,

01:39:32.020 --> 01:39:32.700
garantisine,

01:39:32.920 --> 01:39:33.780
onu da göstereceğim,

01:39:33.880 --> 01:39:34.900
güvenebilir miydim,

01:39:35.760 --> 01:39:36.180
cevap,

01:39:36.800 --> 01:39:37.100
hayır,

01:39:37.560 --> 01:39:38.300
güvenemezdim,

01:39:38.820 --> 01:39:40.020
hatta bakın şimdi,

01:39:40.380 --> 01:39:41.640
bunu göstermek için,

01:39:41.640 --> 01:39:42.860
şöyle bir kod yazayım,

01:39:43.780 --> 01:39:45.020
biraz arayı geciktirdim,

01:39:45.020 --> 01:39:47.600
assert başlık dosyasını da aynı edeyim,

01:39:51.000 --> 01:39:51.220
ve,

01:39:52.060 --> 01:39:53.560
buraya assertion'lar koyayım,

01:39:54.760 --> 01:39:55.220
assert,

01:39:55.840 --> 01:39:56.420
arkadaşlar,

01:40:00.420 --> 01:40:00.800
neydi,

01:40:01.740 --> 01:40:02.800
x eşittir,

01:40:04.980 --> 01:40:05.660
9,

01:40:05.800 --> 01:40:06.280
99,

01:40:09.160 --> 01:40:09.720
assert,

01:40:09.720 --> 01:40:11.320
y eşittir,

01:40:11.320 --> 01:40:14.740
3.333,

01:40:16.740 --> 01:40:17.520
assert,

01:40:18.060 --> 01:40:19.640
str eşittir,

01:40:21.640 --> 01:40:22.100
Alihan,

01:40:22.100 --> 01:40:31.220
bakın şimdi,

01:40:31.220 --> 01:40:41.340
bir derleyim buraya kadar,

01:40:44.340 --> 01:40:44.580
evet,

01:40:45.140 --> 01:40:46.080
şimdi izleyin,

01:40:48.000 --> 01:40:49.420
main fonksiyonu içinde,

01:40:49.420 --> 01:40:56.420
bin kez dönen bir döngüde,

01:40:57.580 --> 01:40:59.000
önce döngüye girmeden,

01:40:59.660 --> 01:41:01.060
şu değerleri yükleyeyim,

01:41:01.580 --> 01:41:02.280
hatta bunlar,

01:41:04.820 --> 01:41:06.820
default construct edilmiş de olabilir,

01:41:07.020 --> 01:41:07.660
problem değil,

01:41:08.240 --> 01:41:08.840
mesela bakın,

01:41:09.000 --> 01:41:09.740
x eşittir,

01:41:09.840 --> 01:41:10.300
sıfır,

01:41:11.880 --> 01:41:12.340
arkadaşlar,

01:41:12.660 --> 01:41:13.500
y eşittir,

01:41:13.620 --> 01:41:14.200
sıfır,

01:41:14.200 --> 01:41:18.020
str eşittir,

01:41:19.020 --> 01:41:19.680
null string,

01:41:20.480 --> 01:41:20.960
şimdi,

01:41:21.660 --> 01:41:22.820
iki thread oluşturayım,

01:41:23.200 --> 01:41:23.840
c thread,

01:41:26.320 --> 01:41:28.020
c thread,

01:41:30.900 --> 01:41:31.600
jt,

01:41:32.000 --> 01:41:32.920
ya da t1,

01:41:34.220 --> 01:41:34.840
bununla,

01:41:34.840 --> 01:41:36.660
uyu çalıştırayım,

01:41:38.200 --> 01:41:39.320
bununla,

01:41:39.860 --> 01:41:40.840
barı çalıştırayım,

01:41:40.840 --> 01:41:42.900
arkadaşlar,

01:41:43.220 --> 01:41:45.240
eğer benim söylediğim garanti,

01:41:45.560 --> 01:41:46.560
olmasaydı,

01:41:47.340 --> 01:41:49.700
e-code'da ben yanlışlık yapmamışsam,

01:41:50.420 --> 01:41:50.980
izleyin,

01:41:51.620 --> 01:41:52.260
buradaki,

01:41:52.820 --> 01:41:53.300
assert,

01:41:53.560 --> 01:41:56.280
yeni değer görüyorsunuz,

01:41:56.920 --> 01:41:58.440
yani şurada yüklenen değer,

01:41:59.260 --> 01:42:00.300
buradaki assert,

01:42:00.300 --> 01:42:00.800
assert'unlar,

01:42:01.020 --> 01:42:02.460
fail olabilirdi değil mi,

01:42:02.620 --> 01:42:04.180
çünkü yeteri kadar da deniyorum,

01:42:05.160 --> 01:42:07.220
yani o görünürlük garantisi,

01:42:07.780 --> 01:42:09.600
bir kere olsa tesadüf dersiniz,

01:42:09.600 --> 01:42:11.440
iki kere olsa tesadüf dersiniz,

01:42:12.020 --> 01:42:13.340
ama bin kerede de,

01:42:13.840 --> 01:42:16.140
bunun tesadüf olma ihtimali yok,

01:42:16.260 --> 01:42:16.520
değil mi,

01:42:17.060 --> 01:42:19.740
önce sentax hatasını düzeltelim,

01:42:20.560 --> 01:42:21.040
t2,

01:42:25.980 --> 01:42:26.660
evet,

01:42:26.740 --> 01:42:28.000
bir yerde bir hata yaptık,

01:42:28.060 --> 01:42:29.120
oraya bakalım şimdi,

01:42:30.320 --> 01:42:30.520
evet,

01:42:32.100 --> 01:42:32.740
flag,

01:42:33.180 --> 01:42:33.880
load,

01:42:34.540 --> 01:42:35.340
x eşittir,

01:42:35.420 --> 01:42:35.640
9,

01:42:35.800 --> 01:42:36.380
99,

01:42:37.660 --> 01:42:38.220
str,

01:42:38.220 --> 01:42:40.160
hem de ara vermiş oluruz,

01:42:40.660 --> 01:42:41.580
str eşittir,

01:42:41.700 --> 01:42:42.200
Alihan,

01:42:42.400 --> 01:42:43.000
y eşittir,

01:42:43.080 --> 01:42:44.440
3333,

01:42:45.540 --> 01:42:46.460
flag'i,

01:42:47.460 --> 01:42:47.700
true,

01:42:47.940 --> 01:42:48.880
false yapmamışız,

01:42:48.960 --> 01:42:49.720
anlaşıldı değil mi,

01:42:50.400 --> 01:42:51.000
flag,

01:42:53.080 --> 01:42:53.760
eşittir,

01:42:53.860 --> 01:42:54.180
false,

01:42:54.680 --> 01:42:54.880
tamam,

01:42:55.840 --> 01:42:56.900
hatayı çabuk bulduk,

01:42:57.020 --> 01:42:58.160
başka bir hata yoksa,

01:42:59.600 --> 01:43:01.000
şunu da kapatalım,

01:43:01.000 --> 01:43:03.060
evet,

01:43:03.200 --> 01:43:04.020
demeyelim şimdi,

01:43:06.280 --> 01:43:07.060
gördünüz mü,

01:43:07.920 --> 01:43:08.660
assertion,

01:43:08.860 --> 01:43:10.400
bir kere bile fail olmadı,

01:43:11.100 --> 01:43:12.020
ama şimdi bakın,

01:43:12.660 --> 01:43:13.220
izleyin,

01:43:13.940 --> 01:43:14.680
ben burada,

01:43:15.100 --> 01:43:15.960
memory order,

01:43:16.120 --> 01:43:17.260
acquire yerine,

01:43:18.380 --> 01:43:19.500
memory order,

01:43:19.860 --> 01:43:21.400
relaxed'i kullansaydım,

01:43:21.400 --> 01:43:26.980
takip edebiliyor muyuz,

01:43:27.340 --> 01:43:27.920
yine burada,

01:43:29.060 --> 01:43:29.940
memory order,

01:43:30.940 --> 01:43:35.100
relax'i kullansaydım,

01:43:35.800 --> 01:43:36.280
relax,

01:43:37.520 --> 01:43:39.100
demin yanlışlıkla atmışım,

01:43:39.240 --> 01:43:39.940
relax,

01:43:42.340 --> 01:43:42.580
evet,

01:43:46.300 --> 01:43:47.060
memory order,

01:43:47.180 --> 01:43:48.120
acquire relax değil,

01:43:48.240 --> 01:43:48.900
sadece relax,

01:43:48.900 --> 01:43:50.440
evet,

01:43:50.500 --> 01:43:51.800
sabitler birbirine karışmaz,

01:43:52.040 --> 01:43:53.560
şimdi böyle bir garanti var mı,

01:43:55.220 --> 01:43:56.780
belki böyle bir garanti olduğunu,

01:43:56.880 --> 01:43:58.260
düşünüyor olabilirsiniz,

01:43:58.460 --> 01:43:59.120
genelde de,

01:43:59.360 --> 01:44:00.360
özellikle böyle,

01:44:00.460 --> 01:44:00.680
Java,

01:44:00.820 --> 01:44:02.640
C-Shark gibi dillerden gelenler,

01:44:02.780 --> 01:44:04.400
bu garantinin sürekli olduğunu,

01:44:04.580 --> 01:44:05.200
düşünüyorlar,

01:44:05.640 --> 01:44:06.040
ama hayır,

01:44:06.160 --> 01:44:07.560
burada böyle bir garanti yok,

01:44:08.060 --> 01:44:08.580
yani şimdi,

01:44:08.700 --> 01:44:10.340
assertion fail olabilir mi,

01:44:11.200 --> 01:44:11.800
cevap evet,

01:44:15.740 --> 01:44:16.640
yani şu anda,

01:44:16.760 --> 01:44:17.360
memory order,

01:44:17.620 --> 01:44:18.880
relax olması,

01:44:18.900 --> 01:44:20.560
artık burada bir,

01:44:20.760 --> 01:44:22.280
ne garantisi vermiyor,

01:44:22.940 --> 01:44:24.400
görünürlük garantisi vermiyor,

01:44:24.480 --> 01:44:25.260
bir ara verelim,

01:44:25.380 --> 01:44:26.140
aradan sonra,

01:44:26.740 --> 01:44:27.760
tekrar devam edeceğiz,

01:44:28.340 --> 01:44:30.800
21.35'de devam ediyoruz,

01:44:38.040 --> 01:44:38.440
arkadaşlar,

01:44:38.580 --> 01:44:39.560
şimdi şu koda bakın,

01:44:40.100 --> 01:44:40.540
dikkat,

01:44:41.500 --> 01:44:42.580
üç tane atomik,

01:44:42.740 --> 01:44:43.760
buğul değişken var,

01:44:43.960 --> 01:44:44.300
yani,

01:44:45.000 --> 01:44:46.360
atomik ve atomik,

01:44:46.360 --> 01:44:47.100
templatinin,

01:44:47.220 --> 01:44:48.000
bul açılımı,

01:44:49.120 --> 01:44:49.980
üçünün de değeri,

01:44:50.080 --> 01:44:50.400
false,

01:44:51.740 --> 01:44:53.760
bir de string değişkeni var,

01:44:54.500 --> 01:44:55.880
az önce kodun benzeri,

01:44:56.680 --> 01:44:57.520
ama şimdi konuyu,

01:44:57.620 --> 01:44:58.740
biraz daha iyi gösteriyor,

01:44:59.800 --> 01:45:00.180
arkadaşlar,

01:45:00.360 --> 01:45:01.160
full fonksiyonu,

01:45:01.220 --> 01:45:02.240
çağırdığı zaman,

01:45:02.680 --> 01:45:04.200
name string değişkenine,

01:45:04.560 --> 01:45:05.960
necati yazısını atıyor,

01:45:05.960 --> 01:45:08.000
ve ondan sonra,

01:45:08.000 --> 01:45:09.340
flag 1'i,

01:45:10.340 --> 01:45:12.540
store işlemiyle,

01:45:12.800 --> 01:45:14.020
true değere getiriyor,

01:45:14.220 --> 01:45:16.020
ama memory order release ile,

01:45:17.360 --> 01:45:19.500
takip edebiliyor muyuz,

01:45:19.500 --> 01:45:22.300
arkadaşlar,

01:45:23.220 --> 01:45:24.500
bar fonksiyonu ise,

01:45:25.580 --> 01:45:27.600
önce döngüsel bir yapı içinde,

01:45:27.860 --> 01:45:28.420
az önceki,

01:45:28.600 --> 01:45:30.280
benim yazdığım kodda olduğu gibi,

01:45:31.520 --> 01:45:32.120
sürekli,

01:45:32.360 --> 01:45:33.560
flag 1'in değerini,

01:45:33.800 --> 01:45:34.400
load ediyor,

01:45:34.680 --> 01:45:36.240
false olduğu sürece dönüyor,

01:45:37.360 --> 01:45:38.640
ve artık programın akışı,

01:45:38.720 --> 01:45:39.700
buraya geldiğinde,

01:45:39.940 --> 01:45:40.700
buraya dikkat,

01:45:40.800 --> 01:45:41.560
programın akışı,

01:45:41.600 --> 01:45:42.500
buraya geldiğinde,

01:45:43.640 --> 01:45:44.840
neden eminiz,

01:45:45.780 --> 01:45:47.380
diğer thread'in,

01:45:47.380 --> 01:45:49.120
aynı otomik değişkeni üstünde,

01:45:49.240 --> 01:45:50.540
yani flag 1 üstünde,

01:45:51.280 --> 01:45:53.760
set işlemi yapan,

01:45:54.200 --> 01:45:54.960
thread'in,

01:45:56.620 --> 01:45:57.840
o store işleminden,

01:45:57.920 --> 01:45:59.100
önceki operasyonu,

01:45:59.140 --> 01:46:01.100
artık burada görülür olmak zorunda,

01:46:01.220 --> 01:46:01.380
bakın,

01:46:01.520 --> 01:46:02.540
zamansal olarak,

01:46:02.540 --> 01:46:04.540
işlemin daha önce yapılması başka,

01:46:05.600 --> 01:46:06.720
visible olması,

01:46:07.280 --> 01:46:07.700
başka,

01:46:08.400 --> 01:46:09.460
takip edebiliyor muyuz,

01:46:09.580 --> 01:46:09.780
evet,

01:46:10.720 --> 01:46:11.620
bu durumda,

01:46:11.960 --> 01:46:12.280
burada,

01:46:13.100 --> 01:46:14.740
bar fonksiyonu içinde,

01:46:15.680 --> 01:46:17.000
name artı eşittir,

01:46:17.000 --> 01:46:18.700
ergin yazısı,

01:46:19.220 --> 01:46:19.680
yazıyı,

01:46:20.060 --> 01:46:21.400
necati ergin yapacak,

01:46:23.420 --> 01:46:23.720
fakat,

01:46:23.780 --> 01:46:24.280
bu da bir,

01:46:24.780 --> 01:46:26.020
atomik değişkeni üstünde,

01:46:26.160 --> 01:46:26.600
store yapıyor,

01:46:26.700 --> 01:46:27.060
ama bakın,

01:46:27.120 --> 01:46:28.600
buradaki atomik değişken başka,

01:46:29.020 --> 01:46:29.580
flag 2,

01:46:30.580 --> 01:46:31.640
takip edebiliyor muyuz,

01:46:31.780 --> 01:46:32.020
evet,

01:46:33.320 --> 01:46:34.760
ve flag 2 üstünde,

01:46:34.860 --> 01:46:35.200
bu sefer,

01:46:35.320 --> 01:46:36.480
store işlemi yaptı,

01:46:37.120 --> 01:46:37.680
onu da,

01:46:38.100 --> 01:46:38.500
arkadaşlar,

01:46:39.280 --> 01:46:40.440
release'e yaptı,

01:46:40.440 --> 01:46:41.520
bu arada,

01:46:42.060 --> 01:46:42.940
barda önce,

01:46:43.200 --> 01:46:44.420
load işlemi yapıldığını,

01:46:44.560 --> 01:46:45.620
tekrar gösterelim,

01:46:45.620 --> 01:46:46.720
ve,

01:46:47.080 --> 01:46:47.820
sonra ergin,

01:46:48.020 --> 01:46:49.360
sonra tekrar store,

01:46:49.480 --> 01:46:49.820
fakat,

01:46:49.920 --> 01:46:51.100
bas fonksiyonu da,

01:46:52.060 --> 01:46:53.320
flag 2'nin değeri,

01:46:54.040 --> 01:46:54.880
load'da yine,

01:46:55.100 --> 01:46:55.740
memory order,

01:46:55.860 --> 01:46:57.640
ekayer kullandığına dikkat edin,

01:46:58.460 --> 01:46:59.840
flag 2'nin değeri,

01:47:00.580 --> 01:47:01.800
false olduğu sürece,

01:47:02.140 --> 01:47:02.680
dönecek,

01:47:03.440 --> 01:47:03.740
ama,

01:47:04.400 --> 01:47:05.640
aynı atomik değişkeni,

01:47:05.640 --> 01:47:07.080
üstünde işlem yapıldığı için,

01:47:07.160 --> 01:47:09.480
bir senkronizasyon ilişkisi olduğu için,

01:47:09.480 --> 01:47:12.020
artık bu store'dan önceki,

01:47:12.280 --> 01:47:13.080
bu kodun da,

01:47:14.340 --> 01:47:15.140
sonucunun,

01:47:15.500 --> 01:47:17.580
yani bellek üstünde yapılan değişikliğin,

01:47:17.720 --> 01:47:20.060
artık visible olma garantisi var,

01:47:20.860 --> 01:47:21.800
yani bu ne demek,

01:47:22.640 --> 01:47:23.020
ben,

01:47:24.020 --> 01:47:24.580
fuyu,

01:47:24.940 --> 01:47:25.300
barı,

01:47:25.580 --> 01:47:26.080
bazı,

01:47:26.300 --> 01:47:28.220
3 ayrı thread'te çalıştırsam,

01:47:29.380 --> 01:47:29.760
sonra,

01:47:30.000 --> 01:47:30.760
bu threadleri,

01:47:30.980 --> 01:47:31.760
join etsem,

01:47:32.140 --> 01:47:33.240
programın akışı,

01:47:33.520 --> 01:47:35.760
test fonksiyonunun sonuna geldiğimde,

01:47:35.760 --> 01:47:37.020
name'in,

01:47:37.380 --> 01:47:39.480
Necati Ergincan olması gerekiyor,

01:47:40.160 --> 01:47:40.540
arkadaşlar,

01:47:40.700 --> 01:47:41.540
bir şeye dikkat edin,

01:47:41.700 --> 01:47:42.240
testte,

01:47:42.680 --> 01:47:43.420
her defa bunu,

01:47:43.680 --> 01:47:44.460
bir döngü içinde,

01:47:44.640 --> 01:47:45.480
test fonksiyonunu,

01:47:46.080 --> 01:47:46.800
çalıştıracağım,

01:47:47.520 --> 01:47:48.580
ve her defasında,

01:47:49.140 --> 01:47:50.140
şu flag'leri,

01:47:50.340 --> 01:47:51.500
false değeri çektim,

01:47:52.000 --> 01:47:53.060
ve name'i de,

01:47:53.300 --> 01:47:54.320
null string yaptım,

01:47:55.000 --> 01:47:56.080
şimdi takip edin,

01:47:56.980 --> 01:47:58.220
100 bin kere,

01:47:58.660 --> 01:47:59.700
testi çağırıyorum,

01:48:00.400 --> 01:48:02.180
eğer bu garanti olmasaydı,

01:48:02.180 --> 01:48:02.660
burada,

01:48:02.660 --> 01:48:06.640
Akire Relief Semantik'i kullanılmasaydı,

01:48:07.720 --> 01:48:08.100
burada,

01:48:08.620 --> 01:48:10.460
bu döngüden çıktıktan sonra,

01:48:10.940 --> 01:48:11.800
şu işlemin,

01:48:11.960 --> 01:48:13.800
görülür olma garantisi yoktu,

01:48:14.520 --> 01:48:14.880
çünkü,

01:48:15.660 --> 01:48:16.640
herhangi bir şekilde,

01:48:17.000 --> 01:48:17.600
ne yapabilir,

01:48:17.860 --> 01:48:19.080
bunu sıralayabilir,

01:48:19.240 --> 01:48:20.440
tamamen derleyicinin,

01:48:21.100 --> 01:48:22.260
ürettiği koda bağlı,

01:48:22.400 --> 01:48:24.400
yani derleyicinin yaptığı optimizasyondan,

01:48:24.480 --> 01:48:26.340
ya da işlemci tarafında yapılabilecek,

01:48:26.440 --> 01:48:27.520
optimizasyonlardan,

01:48:28.200 --> 01:48:29.160
etkilenecekti,

01:48:29.160 --> 01:48:30.440
işte arkadaşlar,

01:48:30.720 --> 01:48:32.040
bu da bir senkronizasyon,

01:48:32.040 --> 01:48:32.260
şimdi,

01:48:32.400 --> 01:48:34.560
synchronized bit ilişkisini hatırlayın,

01:48:35.380 --> 01:48:35.620
hani,

01:48:36.460 --> 01:48:38.700
thread'i çalıştıran kodla,

01:48:38.940 --> 01:48:39.900
çalışan thread,

01:48:40.800 --> 01:48:42.360
thread'i çalıştıran kod,

01:48:43.120 --> 01:48:43.600
arkadaşlar,

01:48:43.860 --> 01:48:45.120
thread çalışmadan önce,

01:48:45.280 --> 01:48:46.080
benlik üstünde,

01:48:46.240 --> 01:48:47.700
hangi işlemleri yaptıysa,

01:48:48.460 --> 01:48:50.340
thread'in çalışmaya başlamasıyla,

01:48:50.600 --> 01:48:51.440
o işlemler,

01:48:51.620 --> 01:48:52.560
görülür durumda,

01:48:53.220 --> 01:48:56.060
senkronizasyon ilişkisi bir,

01:48:56.540 --> 01:48:57.440
hatırlıyor musunuz,

01:48:57.440 --> 01:48:58.300
iki,

01:48:58.620 --> 01:48:59.080
dedik,

01:48:59.740 --> 01:49:00.240
arkadaşlar,

01:49:01.020 --> 01:49:01.840
lock unlock,

01:49:02.040 --> 01:49:05.520
lock ve unlock arasında,

01:49:06.000 --> 01:49:08.080
bellek üstünde yapılan işlemler,

01:49:09.100 --> 01:49:11.720
aynı mutex üstünde çalışan thread'lerde,

01:49:12.060 --> 01:49:13.060
unlock'tan sonra,

01:49:13.320 --> 01:49:14.700
o kritik bölgedeki,

01:49:15.380 --> 01:49:16.380
değişikliklerin,

01:49:16.620 --> 01:49:18.720
ya da kritik bölgede çalışan kodların,

01:49:18.980 --> 01:49:19.880
sonuçlarının,

01:49:19.940 --> 01:49:20.960
unlock'tan sonra,

01:49:21.960 --> 01:49:22.380
arkadaşlar,

01:49:22.380 --> 01:49:25.860
o kodda,

01:49:26.300 --> 01:49:26.720
ne olur,

01:49:26.880 --> 01:49:27.640
ne olması demek,

01:49:27.760 --> 01:49:28.860
görülür olması demek,

01:49:30.360 --> 01:49:31.100
başka neydi,

01:49:31.480 --> 01:49:33.700
future promise de vardı,

01:49:33.800 --> 01:49:34.200
böyle bir,

01:49:34.280 --> 01:49:35.780
senkronizasyon ilişkisi,

01:49:36.840 --> 01:49:37.060
evet,

01:49:37.660 --> 01:49:37.980
hocam,

01:49:38.060 --> 01:49:39.100
anlayamadığım bir yer var,

01:49:39.300 --> 01:49:39.900
her release,

01:49:39.980 --> 01:49:41.540
bir recovery ile eşleşmeli mi,

01:49:41.540 --> 01:49:42.660
kesinlikle,

01:49:43.160 --> 01:49:43.860
kesinlikle,

01:49:44.640 --> 01:49:45.080
arkadaşlar,

01:49:45.660 --> 01:49:47.400
sentax hatası olmasa bile,

01:49:47.560 --> 01:49:49.240
o zaman bu garanti kayboluyor,

01:49:49.520 --> 01:49:50.540
aynen dediğiniz gibi,

01:49:50.840 --> 01:49:51.820
her release,

01:49:52.460 --> 01:49:53.520
bir acquire ile,

01:49:53.760 --> 01:49:54.940
eşlenmek zorunda,

01:49:56.000 --> 01:49:56.200
evet,

01:49:56.560 --> 01:49:56.820
hocam,

01:49:56.880 --> 01:49:58.020
anlayamadığım bir yer var,

01:49:58.560 --> 01:49:59.080
her release,

01:49:59.180 --> 01:50:00.880
bir acquire ile eşleşmeli mi,

01:50:01.020 --> 01:50:02.220
eğer durum böyleyse,

01:50:02.320 --> 01:50:03.260
bir sorun daha var,

01:50:03.340 --> 01:50:03.920
durum böyle,

01:50:04.680 --> 01:50:06.220
aynı atomik değişkende,

01:50:06.520 --> 01:50:07.620
iki defa release,

01:50:08.220 --> 01:50:09.220
iki defa acquire,

01:50:09.220 --> 01:50:10.400
kullanılabiliyor mu,

01:50:10.600 --> 01:50:10.880
hayır,

01:50:11.960 --> 01:50:12.300
hayır,

01:50:12.840 --> 01:50:13.300
arkadaşlar,

01:50:13.820 --> 01:50:14.520
yani iki kere,

01:50:14.700 --> 01:50:15.040
release,

01:50:15.120 --> 01:50:16.720
iki kere acquire kullanılabiliyor mu,

01:50:16.800 --> 01:50:17.280
derken,

01:50:18.040 --> 01:50:19.620
şunu kastediyorsunuz,

01:50:20.100 --> 01:50:20.340
eğer,

01:50:20.620 --> 01:50:21.920
tabii ki kullanılabilir,

01:50:22.280 --> 01:50:22.440
ama,

01:50:23.440 --> 01:50:24.600
tekrar aynı değerine,

01:50:25.040 --> 01:50:26.360
getirmek kaydıyla,

01:50:26.900 --> 01:50:27.560
yani iki kere,

01:50:27.620 --> 01:50:28.700
on kere kullanmanız,

01:50:28.760 --> 01:50:29.920
soruyu doğru anladıysam,

01:50:30.000 --> 01:50:31.400
hiçbir kötü etkisi yok,

01:50:31.540 --> 01:50:31.720
evet,

01:50:33.240 --> 01:50:33.940
hangi release,

01:50:34.060 --> 01:50:35.540
hangi acquire ile eşlenecek,

01:50:35.760 --> 01:50:37.700
belki ben soruyu anlamamış olabilirim,

01:50:37.760 --> 01:50:38.040
Alian,

01:50:38.800 --> 01:50:39.160
şimdi,

01:50:39.220 --> 01:50:41.360
yani kapamda söylediğiniz senaryoyu,

01:50:41.440 --> 01:50:42.300
kuramadım,

01:50:42.880 --> 01:50:44.420
eğer bir kodla gösterirseniz,

01:50:44.480 --> 01:50:45.460
beraber bakarız,

01:50:46.560 --> 01:50:47.160
önemli olan,

01:50:47.260 --> 01:50:48.260
atomik değişkenin,

01:50:48.320 --> 01:50:48.960
aynı olması,

01:50:49.420 --> 01:50:50.080
işte burada,

01:50:51.180 --> 01:50:53.640
bu döngüden çıktığı anda,

01:50:54.560 --> 01:50:54.780
evet,

01:50:54.880 --> 01:50:55.060
bakın,

01:50:55.140 --> 01:50:56.500
bu döngüden çıktığı anda,

01:50:57.320 --> 01:50:57.960
ben,

01:50:59.100 --> 01:51:00.460
flag 1'in değerinin,

01:51:00.640 --> 01:51:01.920
true olduğunu biliyorum,

01:51:02.780 --> 01:51:03.640
o problem değil,

01:51:03.820 --> 01:51:05.260
o garanti zaten var,

01:51:05.780 --> 01:51:06.820
ama problem şu,

01:51:07.400 --> 01:51:08.700
true olduğunu biliyorum da,

01:51:08.700 --> 01:51:10.300
buradaki işlemler,

01:51:10.420 --> 01:51:10.800
burada,

01:51:11.520 --> 01:51:13.300
sonuçları görünür durumda mı,

01:51:14.020 --> 01:51:14.880
burayı anladık mı,

01:51:15.620 --> 01:51:18.080
görünür durumda olması garantisi için,

01:51:18.240 --> 01:51:19.140
işte bir tarafın,

01:51:19.520 --> 01:51:20.460
release etmesi,

01:51:21.300 --> 01:51:22.140
diğer tarafında,

01:51:22.260 --> 01:51:23.840
atomik değişkenin değerini,

01:51:24.600 --> 01:51:25.460
arkadaşlar,

01:51:26.240 --> 01:51:27.140
okurken,

01:51:27.440 --> 01:51:28.120
akı ayrı,

01:51:28.360 --> 01:51:29.640
kullanması gerekiyor,

01:51:29.640 --> 01:51:30.640
memori order olarak,

01:51:31.860 --> 01:51:32.320
ama tabi,

01:51:32.400 --> 01:51:32.960
hem okuma,

01:51:33.080 --> 01:51:34.320
hem yazma işlemi ise,

01:51:34.960 --> 01:51:35.340
o zaman,

01:51:35.500 --> 01:51:36.460
zaten hatırlayın,

01:51:36.520 --> 01:51:38.120
şurada bir sabit daha vardı,

01:51:38.960 --> 01:51:39.340
o da,

01:51:40.040 --> 01:51:40.580
bazı,

01:51:40.740 --> 01:51:41.600
atomik işlemler,

01:51:41.660 --> 01:51:42.200
hem okuma,

01:51:42.320 --> 01:51:43.840
hem yazma işlemi yapıyor ya,

01:51:44.000 --> 01:51:44.920
işte orada da,

01:51:45.460 --> 01:51:46.460
şunu kullanıyorsunuz,

01:51:46.520 --> 01:51:47.200
memori order,

01:51:47.360 --> 01:51:47.860
akı ayrı,

01:51:47.860 --> 01:51:48.320
release,

01:51:49.580 --> 01:51:51.020
yani akı ayrı ile release,

01:51:51.160 --> 01:51:52.740
birbiriyle ilişkili olarak,

01:51:52.880 --> 01:51:54.040
kullanılmak zorunda mı,

01:51:54.180 --> 01:51:55.160
kesinlikle evet,

01:51:56.140 --> 01:51:57.440
store işlemini yapan,

01:51:58.040 --> 01:51:59.580
onu publish etmek için,

01:51:59.580 --> 01:52:01.580
store işlemini,

01:52:01.580 --> 01:52:03.000
release ile yapacak,

01:52:03.700 --> 01:52:04.620
diğer tarafta,

01:52:04.780 --> 01:52:06.000
o değişikliklerden,

01:52:06.260 --> 01:52:07.380
faydalanmak için,

01:52:08.020 --> 01:52:08.580
load işlemini,

01:52:09.580 --> 01:52:11.000
akı ayrı ile yapacak,

01:52:11.000 --> 01:52:12.860
yani aslında bu,

01:52:13.480 --> 01:52:14.920
eğer daha alt seviyeli,

01:52:15.000 --> 01:52:16.720
programlama ile uğraştıysanız,

01:52:17.360 --> 01:52:19.120
memori bariyer kullanılıyor,

01:52:19.260 --> 01:52:20.600
arka planda tipik olarak,

01:52:21.460 --> 01:52:21.780
peki,

01:52:22.320 --> 01:52:23.360
şimdi devam edelim,

01:52:24.220 --> 01:52:25.140
bu sanıyorum,

01:52:25.240 --> 01:52:27.320
burası artık net olarak anlaşıldı,

01:52:27.880 --> 01:52:28.940
böylece yeni bir,

01:52:28.940 --> 01:52:31.300
senkronizasyon biçimi daha gördük,

01:52:31.420 --> 01:52:32.980
atomik değişkenleri kullanarak,

01:52:33.080 --> 01:52:34.700
gördüğünüz gibi atomik değişkenler,

01:52:34.700 --> 01:52:36.700
sadece ne sağlamıyor,

01:52:37.360 --> 01:52:39.360
sadece işlemlerin,

01:52:39.360 --> 01:52:41.940
bölünemez olmasını sağlamıyor,

01:52:42.180 --> 01:52:44.380
uygun bellek düzeni,

01:52:44.780 --> 01:52:47.620
kategorisini kullanırsanız,

01:52:48.620 --> 01:52:50.560
senkronizasyon ilişkisi de sağlıyor.

01:52:52.440 --> 01:52:55.060
Hocam, çok thread olması durumunda,

01:52:55.160 --> 01:52:56.700
bir akı ayrı yapıldıktan sonra,

01:52:56.820 --> 01:52:58.740
tüm threadlerde visible oluyor mu?

01:52:59.860 --> 01:53:02.200
Tüm threadlerde visible olması için,

01:53:02.200 --> 01:53:05.440
yine aynı neyin kullanılması gerekiyor?

01:53:06.040 --> 01:53:06.680
Arkadaşlar,

01:53:06.840 --> 01:53:09.340
aynı atomik değişkenler,

01:53:09.360 --> 01:53:11.440
load işleminin yapılması gerekiyor.

01:53:13.780 --> 01:53:14.680
Anlaşıldı mı?

01:53:15.140 --> 01:53:15.320
Evet.

01:53:15.780 --> 01:53:17.020
Yani siz aynı şekilde,

01:53:17.160 --> 01:53:17.920
aynı döngüyü,

01:53:17.960 --> 01:53:20.120
birden fazla threadde oluşturursanız,

01:53:20.640 --> 01:53:21.500
yine herhangi bir şekilde,

01:53:21.620 --> 01:53:22.440
bir problem yok.

01:53:23.260 --> 01:53:23.480
Evet.

01:53:24.100 --> 01:53:24.620
Arkadaşlar,

01:53:24.740 --> 01:53:25.000
şimdi,

01:53:26.460 --> 01:53:28.080
burada bir örneği göstereceğim,

01:53:28.160 --> 01:53:28.580
çok güzel,

01:53:28.700 --> 01:53:30.500
yine bir arkadaşın sunumundan,

01:53:30.580 --> 01:53:31.120
bakın şimdi,

01:53:31.780 --> 01:53:32.920
memory order'ı,

01:53:32.960 --> 01:53:34.360
çok güzel gösteren bir örnek.

01:53:34.360 --> 01:53:35.520
şimdi,

01:53:36.060 --> 01:53:38.500
bu tabii kolun tamamını göstermiyor ama,

01:53:39.260 --> 01:53:41.340
bu kısmını anlamanız yeterli olacak.

01:53:43.380 --> 01:53:44.020
Arkadaşlar,

01:53:44.140 --> 01:53:45.980
bu için herhangi bir sınıf anlamında,

01:53:47.240 --> 01:53:50.060
McUnique fonksiyonunu zaten biliyorsunuz,

01:53:50.240 --> 01:53:51.640
McUnique fonksiyonu,

01:53:51.640 --> 01:53:54.680
Unique PTR döndürüyor ama,

01:53:54.760 --> 01:53:55.200
içeride,

01:53:55.420 --> 01:53:58.140
dinamik ömürlü bir,

01:53:58.500 --> 01:53:59.580
nesne oluşturuyor,

01:53:59.680 --> 01:53:59.920
değil mi?

01:54:00.000 --> 01:54:01.020
Niv ifadesiyle.

01:54:02.340 --> 01:54:03.100
Ama bakın şimdi,

01:54:03.260 --> 01:54:03.640
bu threadde,

01:54:05.140 --> 01:54:05.740
Reddy'de,

01:54:06.100 --> 01:54:06.640
bir değişken,

01:54:07.300 --> 01:54:08.300
atomik değişken,

01:54:09.160 --> 01:54:09.680
Reddy'nin,

01:54:09.920 --> 01:54:11.520
store fonksiyonunu çağırıyor,

01:54:11.520 --> 01:54:14.540
ve başlangıç değeri sıfır olan,

01:54:14.740 --> 01:54:16.440
bir atomik değişkenin değerini,

01:54:16.700 --> 01:54:17.240
bir yapıyor.

01:54:18.760 --> 01:54:20.240
Ve ondan sonra,

01:54:21.280 --> 01:54:23.520
yine burada store'da,

01:54:23.740 --> 01:54:24.320
bellek,

01:54:25.080 --> 01:54:26.540
sıralama düzeni olarak,

01:54:26.680 --> 01:54:29.260
memory order release kullanıldığını görüyorsunuz.

01:54:29.940 --> 01:54:30.760
Bu ne demek?

01:54:31.420 --> 01:54:31.800
Bakın,

01:54:31.900 --> 01:54:33.320
aslında çok önemli bir garanti.

01:54:33.320 --> 01:54:34.320
Şimdi,

01:54:34.560 --> 01:54:36.720
eğer ben buna karşılık gelen,

01:54:37.560 --> 01:54:40.320
acquire işleminde yaparsam,

01:54:40.500 --> 01:54:41.380
load işlemini,

01:54:41.520 --> 01:54:43.980
memory order acquire ile yaparsam,

01:54:44.900 --> 01:54:45.340
artık,

01:54:46.320 --> 01:54:48.260
store'dan önceki,

01:54:49.000 --> 01:54:50.260
bu işlemin sonucu,

01:54:50.420 --> 01:54:51.080
görülür olacak.

01:54:51.220 --> 01:54:52.360
Görülür olması ne demek?

01:54:53.020 --> 01:54:55.020
Yani artık bu nesnenin,

01:54:55.080 --> 01:54:57.940
hayata gelmemiş olması gibi bir ihtimal,

01:54:58.180 --> 01:54:59.340
söz konusu olmayacak.

01:54:59.840 --> 01:55:00.960
Burada da onu gösteriyor.

01:55:01.760 --> 01:55:02.220
Şimdi bakın,

01:55:02.220 --> 01:55:03.220
diğer threadde,

01:55:04.080 --> 01:55:06.220
Reddy'nin load fonksiyonu,

01:55:06.600 --> 01:55:07.940
load'un geri dönüş değeri,

01:55:08.200 --> 01:55:09.780
sıfır olduğu sürece dönüyor.

01:55:09.780 --> 01:55:11.180
arkadaşlar,

01:55:11.560 --> 01:55:13.840
ama döngüden çıktıktan sonra,

01:55:14.740 --> 01:55:15.240
artık,

01:55:16.160 --> 01:55:17.160
acquire release,

01:55:17.300 --> 01:55:18.120
release acquire,

01:55:18.200 --> 01:55:18.820
acquire release,

01:55:18.880 --> 01:55:19.960
aynı anlamda kullanıyorum,

01:55:20.080 --> 01:55:21.660
semantik kullanıldığı için,

01:55:22.640 --> 01:55:24.480
o store'dan önceki işlem,

01:55:24.700 --> 01:55:26.340
gerçekleşmiş olmak zorunda.

01:55:26.340 --> 01:55:29.080
eğer böyle bir garanti olmasaydı,

01:55:29.800 --> 01:55:31.920
burada biz nesne hayata gelmeden,

01:55:32.720 --> 01:55:35.480
o unique PTR,

01:55:35.800 --> 01:55:37.380
unique PTR'dı değil mi?

01:55:37.860 --> 01:55:38.040
Evet,

01:55:38.080 --> 01:55:40.360
unique PTR nesnesiyle,

01:55:40.920 --> 01:55:43.800
dangling pointer ile belki erişmiş olacaktık.

01:55:43.800 --> 01:55:46.420
bu garantinin verilmesinin nedeni,

01:55:46.960 --> 01:55:49.140
acquire release semantiği.

01:55:50.100 --> 01:55:50.700
Arkadaşlar,

01:55:51.620 --> 01:55:52.140
izleyin,

01:55:52.240 --> 01:55:53.120
zaten bakın burada,

01:55:53.260 --> 01:55:56.080
acquire memory published by other threads.

01:55:56.080 --> 01:55:58.640
yani,

01:55:59.360 --> 01:56:01.260
eğer acquire ile okuma yapıyorsam,

01:56:01.500 --> 01:56:02.620
diğer thread'lerdeki,

01:56:02.720 --> 01:56:04.200
aynı atomik değişkeni kullanan,

01:56:04.280 --> 01:56:05.540
diğer thread'te,

01:56:06.140 --> 01:56:06.560
arkadaşlar,

01:56:06.900 --> 01:56:08.040
oradaki işlemler,

01:56:08.500 --> 01:56:09.000
görülür.

01:56:09.720 --> 01:56:10.320
Release de,

01:56:10.480 --> 01:56:11.320
ne anlama geliyor?

01:56:11.320 --> 01:56:12.360
biz,

01:56:12.800 --> 01:56:14.080
adeta,

01:56:14.400 --> 01:56:15.160
diğer tarafa,

01:56:15.280 --> 01:56:16.980
şöyle bir sinyal vermiş oluyoruz.

01:56:17.200 --> 01:56:17.840
Artık benim,

01:56:18.160 --> 01:56:19.220
sen bunu okursan,

01:56:19.840 --> 01:56:20.080
tabii,

01:56:20.760 --> 01:56:21.240
acquire,

01:56:21.880 --> 01:56:22.880
bellek düzeniyle,

01:56:23.020 --> 01:56:25.320
benim yaptığım değişikliklerin sonucunu,

01:56:25.600 --> 01:56:26.160
alırsın.

01:56:26.920 --> 01:56:27.400
Arkadaşlar,

01:56:27.460 --> 01:56:28.700
bu durumda dikkatli izleyin,

01:56:28.780 --> 01:56:31.420
bir condition variable falan kullanmadım.

01:56:32.180 --> 01:56:32.760
Doğrudan,

01:56:32.860 --> 01:56:33.860
herhangi bir şekilde,

01:56:34.580 --> 01:56:34.940
arkadaşlar,

01:56:35.120 --> 01:56:36.920
condition variable kullanmadan,

01:56:37.180 --> 01:56:39.200
ve bir kilit sistemi de kullanmadan,

01:56:39.320 --> 01:56:39.840
görüyorsunuz,

01:56:39.840 --> 01:56:41.240
kodlarda bir mutex falan,

01:56:41.320 --> 01:56:41.660
da yok.

01:56:42.700 --> 01:56:43.000
Ama,

01:56:43.240 --> 01:56:43.720
yine de,

01:56:44.260 --> 01:56:45.580
iki thread arasında,

01:56:46.040 --> 01:56:47.420
koordinasyonu sağladık.

01:56:48.120 --> 01:56:49.040
Şimdi gelelim,

01:56:49.740 --> 01:56:50.520
nereye gelelim?

01:56:50.780 --> 01:56:51.000
Şu,

01:56:51.900 --> 01:56:54.220
sequential consistency'ye.

01:56:55.240 --> 01:56:55.780
Arkadaşlar,

01:56:55.880 --> 01:56:57.180
sequential consistency,

01:56:57.560 --> 01:56:59.800
olabilecek en büyük garanti.

01:57:00.460 --> 01:57:02.360
İşte bazı programlama dillerinde,

01:57:03.000 --> 01:57:04.400
sequential consistency,

01:57:04.680 --> 01:57:05.780
zaten default,

01:57:05.940 --> 01:57:07.980
başka bir seçeneğe izin vermiyor.

01:57:07.980 --> 01:57:08.900
Tabii,

01:57:09.000 --> 01:57:11.300
sequest plus verim odaklı bir dili olduğu için,

01:57:11.320 --> 01:57:12.280
diyor ki,

01:57:12.280 --> 01:57:13.380
relaxed yetiyorsa,

01:57:13.640 --> 01:57:14.580
relaxed'i kullan.

01:57:15.500 --> 01:57:16.840
Senin istediğin sadece,

01:57:16.980 --> 01:57:18.480
senkronizasyonsa,

01:57:19.180 --> 01:57:19.660
o zaman,

01:57:19.820 --> 01:57:21.800
acquire release semantini kullan.

01:57:22.620 --> 01:57:22.980
Ama,

01:57:23.380 --> 01:57:23.780
eğer,

01:57:24.060 --> 01:57:25.020
aynı zamanda,

01:57:25.520 --> 01:57:27.320
total order istiyorsan,

01:57:27.460 --> 01:57:29.120
şimdi onun ne olduğunu anlatacağım,

01:57:30.000 --> 01:57:30.520
o zaman,

01:57:30.880 --> 01:57:32.300
sequential consistency,

01:57:32.660 --> 01:57:33.500
olmak zorunda.

01:57:34.160 --> 01:57:34.920
Arkadaşlar,

01:57:35.000 --> 01:57:35.500
ne demek,

01:57:35.700 --> 01:57:37.060
sequential consistency?

01:57:37.060 --> 01:57:38.900
şimdi anlaşılması,

01:57:39.020 --> 01:57:39.940
biraz başlangıçta,

01:57:40.060 --> 01:57:42.540
zor olan kavramlardan biri de bu.

01:57:43.180 --> 01:57:44.480
Şimdi çok dikkatli izleyin.

01:57:44.900 --> 01:57:45.220
Sadece,

01:57:45.800 --> 01:57:47.760
benim söylediklerime odaklanın.

01:57:48.580 --> 01:57:49.120
Arkadaşlar,

01:57:49.200 --> 01:57:50.580
iki tane thread var,

01:57:50.580 --> 01:57:51.540
ve,

01:57:51.540 --> 01:57:51.620
ve,

01:57:51.620 --> 01:57:52.520
x'de,

01:57:52.840 --> 01:57:53.400
y'de,

01:57:53.800 --> 01:57:55.000
atomik değişkenler.

01:57:56.360 --> 01:57:57.380
Thread 1'de,

01:57:58.080 --> 01:58:00.680
x değişkeni üstünde bir store işlemi yapılıyor.

01:58:02.260 --> 01:58:03.020
Ve,

01:58:03.240 --> 01:58:04.020
ondan sonra,

01:58:04.180 --> 01:58:04.380
yani,

01:58:04.480 --> 01:58:06.760
o thread'teki fonksiyonun sırasıyla,

01:58:07.760 --> 01:58:09.960
burada da bir load işlemi yapılıyor.

01:58:10.320 --> 01:58:11.520
Takip edebiliyor musunuz?

01:58:11.520 --> 01:58:12.320
Yani,

01:58:12.480 --> 01:58:13.460
y'nin değeri,

01:58:14.660 --> 01:58:15.320
load ediliyor.

01:58:15.500 --> 01:58:15.700
Yani,

01:58:15.780 --> 01:58:17.100
y'nin değeri okunuyor.

01:58:17.180 --> 01:58:17.340
O da,

01:58:17.420 --> 01:58:18.940
res bir değişkenine yazılıyor.

01:58:19.540 --> 01:58:19.740
Önce,

01:58:19.820 --> 01:58:21.120
burayı bir anlamaya çalışın.

01:58:21.200 --> 01:58:21.320
Çünkü,

01:58:21.380 --> 01:58:22.220
her şey burayla ilgili.

01:58:23.180 --> 01:58:24.200
Thread 2'de ise,

01:58:25.080 --> 01:58:25.560
arkadaşlar,

01:58:26.080 --> 01:58:26.480
önce,

01:58:26.700 --> 01:58:28.360
y store ediliyor.

01:58:28.640 --> 01:58:28.860
Yani,

01:58:28.940 --> 01:58:30.340
y'ye bir değeri yazılıyor.

01:58:31.140 --> 01:58:31.880
Ondan sonra,

01:58:32.380 --> 01:58:33.600
x'in değeri okunuyor.

01:58:34.580 --> 01:58:34.980
Şimdi,

01:58:35.220 --> 01:58:36.280
çok dikkatli izleyin.

01:58:36.960 --> 01:58:37.600
Soru 1,

01:58:38.060 --> 01:58:38.680
soru 1,

01:58:39.840 --> 01:58:40.240
eğer,

01:58:40.440 --> 01:58:40.980
burada,

01:58:40.980 --> 01:58:42.280
bu işlemler,

01:58:42.640 --> 01:58:44.420
sequential consistency,

01:58:44.960 --> 01:58:46.780
bellek düzeniyle yapılıyorsa,

01:58:48.060 --> 01:58:49.420
şu iki işlemin,

01:58:49.760 --> 01:58:51.780
sırasında bir değişiklik olabilir mi?

01:58:52.540 --> 01:58:52.800
Yani,

01:58:52.860 --> 01:58:53.680
derleyici mesela,

01:58:54.520 --> 01:58:54.780
bunu,

01:58:55.140 --> 01:58:55.720
daha yukarı,

01:58:55.860 --> 01:58:57.540
diğerini daha aşağıya alabilir mi?

01:58:57.640 --> 01:58:58.000
Cevap,

01:58:58.080 --> 01:58:58.380
hayır.

01:58:59.160 --> 01:58:59.700
Derleyici,

01:59:00.000 --> 01:59:01.980
böyle bir optimizasyon yapamaz.

01:59:02.680 --> 01:59:03.220
Arkadaşlar,

01:59:03.340 --> 01:59:03.760
ama tabii,

01:59:03.860 --> 01:59:04.040
bakın,

01:59:04.140 --> 01:59:05.980
sequential consistency'den bahsediyorum.

01:59:06.160 --> 01:59:06.880
Aynı şekilde,

01:59:07.920 --> 01:59:08.640
burada da,

01:59:09.360 --> 01:59:10.500
bu iki işlem arasında,

01:59:10.500 --> 01:59:13.740
atomik değişkenler üstünde yapılan işlemler arasında,

01:59:13.860 --> 01:59:15.600
bir sırasal değişiklik yapamaz.

01:59:16.300 --> 01:59:16.760
Ama şimdi,

01:59:16.820 --> 01:59:17.880
çok dikkatli izleyin.

01:59:18.720 --> 01:59:19.020
Peki,

01:59:19.740 --> 01:59:20.620
bu threadler,

01:59:20.680 --> 01:59:22.000
beraber koştuğunda,

01:59:23.320 --> 01:59:23.800
bu işlemler,

01:59:23.800 --> 01:59:26.900
bu işlemler hangi sırayla yapılacak?

01:59:27.540 --> 01:59:29.620
Hangi sırayla yapılacak demekte,

01:59:29.860 --> 01:59:30.740
kastettiğim şu,

01:59:31.240 --> 01:59:33.020
sadece senkronizasyon değil.

01:59:34.180 --> 01:59:34.820
Arkadaşlar,

01:59:35.040 --> 01:59:36.100
yani threadler,

01:59:36.300 --> 01:59:37.200
bu işlemleri,

01:59:37.640 --> 01:59:39.540
aynı sırayla mı görecek?

01:59:40.540 --> 01:59:40.920
Cevap,

01:59:41.060 --> 01:59:41.300
evet.

01:59:41.500 --> 01:59:41.640
İşte,

01:59:41.720 --> 01:59:43.880
sequential consistency bunu sağlıyor.

01:59:44.600 --> 01:59:45.200
Bu şu demek,

01:59:45.200 --> 01:59:46.320
mesela,

01:59:46.320 --> 01:59:47.640
şöyle olabilir mi?

01:59:48.440 --> 01:59:49.480
Şöyle göstereyim.

01:59:50.240 --> 01:59:51.140
Önce bu işlem,

01:59:51.960 --> 01:59:53.240
sonra bu işlem,

01:59:53.580 --> 01:59:54.700
sonra bu işlem,

01:59:55.020 --> 01:59:56.480
sonra bu işlem olabilir mi?

01:59:56.660 --> 01:59:56.860
Evet.

01:59:57.920 --> 01:59:58.480
Önce bu,

01:59:58.580 --> 01:59:59.120
sonra bu,

01:59:59.900 --> 02:00:00.400
sonra bu,

02:00:00.500 --> 02:00:01.580
sonra bu olabilir mi?

02:00:01.720 --> 02:00:02.100
Evet.

02:00:03.100 --> 02:00:03.680
Arkadaşlar,

02:00:03.740 --> 02:00:04.560
ya da şuna bakın.

02:00:05.520 --> 02:00:06.220
Önce bu,

02:00:06.780 --> 02:00:07.380
sonra bu,

02:00:07.660 --> 02:00:08.260
sonra bu,

02:00:08.520 --> 02:00:09.720
sonra bu olabilir mi?

02:00:09.880 --> 02:00:10.140
Evet.

02:00:10.140 --> 02:00:13.780
yani buradaki bütün kombinasyonlar olabilir.

02:00:14.020 --> 02:00:15.240
Sadece ne olamaz?

02:00:16.160 --> 02:00:18.720
Bunların kendi içindeki yeri değişemez.

02:00:19.420 --> 02:00:20.280
Arkadaşlar bakın,

02:00:20.640 --> 02:00:22.920
yine bir arkadaşın slide'ından,

02:00:23.060 --> 02:00:24.320
slide'ı ben hazırlamadım.

02:00:24.840 --> 02:00:26.340
Ama gayet güzel gösteriyor.

02:00:26.640 --> 02:00:27.160
İzleyin.

02:00:27.860 --> 02:00:28.320
Diyor ki,

02:00:29.220 --> 02:00:30.420
eğer bu thread'te,

02:00:30.660 --> 02:00:32.520
ve bu thread'te bu işlemler varsa,

02:00:33.700 --> 02:00:34.880
bunların sırası,

02:00:34.880 --> 02:00:37.300
şu kombinasyonlardan biri olabilir.

02:00:37.420 --> 02:00:38.360
Bakın burada time,

02:00:38.560 --> 02:00:39.280
zaman ilerliyor.

02:00:40.140 --> 02:00:41.260
X-Store,

02:00:41.600 --> 02:00:42.200
bu yapıldı.

02:00:43.300 --> 02:00:44.020
Y-Lot,

02:00:44.300 --> 02:00:45.620
arkadaşlar bu yapıldı.

02:00:46.380 --> 02:00:47.100
Y-Store,

02:00:47.200 --> 02:00:47.760
bu yapıldı.

02:00:48.660 --> 02:00:49.340
X-Lot,

02:00:49.600 --> 02:00:50.160
bu yapıldı.

02:00:50.480 --> 02:00:50.640
Ama,

02:00:51.260 --> 02:00:51.540
şimdi,

02:00:52.280 --> 02:00:52.820
şuna bakın.

02:00:53.220 --> 02:00:53.920
X-Store,

02:00:54.720 --> 02:00:55.640
Y-Store,

02:00:55.760 --> 02:00:56.260
bu yapıldı,

02:00:56.360 --> 02:00:56.960
bu yapıldı.

02:00:57.840 --> 02:00:58.500
Ondan sonra,

02:00:58.620 --> 02:00:59.300
Y-Lot,

02:00:59.520 --> 02:01:00.040
bu yapıldı,

02:01:00.140 --> 02:01:00.600
bu yapıldı.

02:01:00.740 --> 02:01:01.480
Gördüğünüz gibi,

02:01:02.160 --> 02:01:03.560
bütün kombinasyonlar var.

02:01:03.720 --> 02:01:04.880
Ya da mesela şuna bakalım.

02:01:04.880 --> 02:01:06.080
Y-Store,

02:01:06.160 --> 02:01:07.020
önce bu yapıldı.

02:01:07.940 --> 02:01:08.540
X-Store,

02:01:08.640 --> 02:01:09.500
sonra bu yapıldı.

02:01:10.140 --> 02:01:11.200
Y-Lot,

02:01:11.540 --> 02:01:12.520
sonra bu yapıldı.

02:01:13.300 --> 02:01:13.960
X-Lot,

02:01:14.260 --> 02:01:15.120
sonra bu yapıldı.

02:01:15.340 --> 02:01:16.360
Buraya kadar tamam mı?

02:01:16.840 --> 02:01:17.040
Tamam.

02:01:17.560 --> 02:01:18.240
Ama şimdi,

02:01:18.660 --> 02:01:19.980
sequential consistency,

02:01:20.300 --> 02:01:21.720
ne garantisini veriyor?

02:01:22.880 --> 02:01:24.300
Bu kombinasyonlardan,

02:01:24.520 --> 02:01:25.520
herhangi biri olabilir.

02:01:25.520 --> 02:01:25.640
olabilir.

02:01:26.640 --> 02:01:28.300
Ama bütün threadler,

02:01:29.180 --> 02:01:31.400
aynı sırayla bunları görecekler.

02:01:32.140 --> 02:01:32.520
Yani,

02:01:32.740 --> 02:01:33.340
örneğin,

02:01:34.080 --> 02:01:34.520
eğer,

02:01:34.900 --> 02:01:38.420
runtime'da sıra böyle gerçekleşmişse,

02:01:39.220 --> 02:01:39.960
threadlerin,

02:01:40.500 --> 02:01:41.600
hepsinde,

02:01:42.140 --> 02:01:42.700
arkadaşlar,

02:01:43.560 --> 02:01:45.880
aynı sıra söz konusu olacak.

02:01:46.440 --> 02:01:46.680
Yani,

02:01:46.900 --> 02:01:47.740
buna güvenerek,

02:01:48.280 --> 02:01:49.260
kod yazabilirsiniz,

02:01:49.400 --> 02:01:50.140
anlamı çıkıyor.

02:01:50.140 --> 02:01:51.700
bakın,

02:01:51.700 --> 02:01:53.580
Akire Release semantiğinde,

02:01:54.160 --> 02:01:54.920
herhangi bir şekilde,

02:01:55.060 --> 02:01:56.260
böyle bir garanti yok.

02:01:57.040 --> 02:01:57.200
İşte,

02:01:57.280 --> 02:01:58.460
buna total order,

02:01:58.720 --> 02:01:58.960
yani,

02:01:59.320 --> 02:02:00.520
bütün threadlerin,

02:02:01.160 --> 02:02:02.540
aynı sırayı,

02:02:02.660 --> 02:02:03.600
gözlemlemesi,

02:02:03.860 --> 02:02:05.020
garantisi olması için,

02:02:05.120 --> 02:02:07.080
bir total ordering olması için,

02:02:07.960 --> 02:02:08.980
ne olması gerekiyor?

02:02:09.240 --> 02:02:11.420
Sequential Consistency olması gerekiyor.

02:02:12.140 --> 02:02:12.500
Bu arada,

02:02:12.880 --> 02:02:13.660
yanlış anlaşılmasın,

02:02:13.760 --> 02:02:15.140
sequential consistency,

02:02:15.540 --> 02:02:17.240
neyi de kapsıyor tabii ki?

02:02:17.920 --> 02:02:19.220
Akire Release'i de,

02:02:19.220 --> 02:02:19.900
kapsıyor.

02:02:20.140 --> 02:02:20.440
Çünkü,

02:02:21.040 --> 02:02:21.920
bütün threadler,

02:02:22.120 --> 02:02:23.600
o sırayla görmek zorunda.

02:02:23.720 --> 02:02:24.180
Ama tabii,

02:02:24.940 --> 02:02:26.580
şurası deterministlik değil.

02:02:27.140 --> 02:02:28.040
Böyle mi olacak?

02:02:28.800 --> 02:02:29.680
Böyle mi olacak?

02:02:30.020 --> 02:02:30.880
Böyle mi olacak?

02:02:31.440 --> 02:02:32.200
Böyle mi olacak?

02:02:32.460 --> 02:02:34.200
O deterministlik değil.

02:02:34.900 --> 02:02:35.400
Arkadaşlar,

02:02:35.820 --> 02:02:36.140
şimdi,

02:02:36.680 --> 02:02:39.060
sequential consistency'i anlatmak için,

02:02:39.780 --> 02:02:40.220
verilen,

02:02:40.720 --> 02:02:42.140
bazı örnek kodlar var.

02:02:42.500 --> 02:02:44.060
Başlangıçta karmaşık.

02:02:44.060 --> 02:02:45.280
Ama ben,

02:02:45.640 --> 02:02:46.140
bir tane,

02:02:46.660 --> 02:02:47.060
kendi seçimim,

02:02:48.200 --> 02:02:49.060
kodu bulmaya çalışıyorum.

02:02:49.220 --> 02:02:50.600
biraz bekleteceğim sizi.

02:02:58.200 --> 02:02:59.040
Yani,

02:02:59.540 --> 02:03:00.580
şunu göstermek de,

02:03:00.680 --> 02:03:01.560
biraz zor olduğu için,

02:03:01.680 --> 02:03:02.940
örnekler karmaşık oluyor.

02:03:03.080 --> 02:03:04.180
Bütün threadlerin,

02:03:05.020 --> 02:03:06.480
aynı sırayla,

02:03:07.000 --> 02:03:07.560
gördüğünü,

02:03:07.680 --> 02:03:09.320
sequential consistency'de,

02:03:09.960 --> 02:03:11.560
aynı sırayla gördüğünü,

02:03:12.280 --> 02:03:13.580
göstermek için de,

02:03:13.780 --> 02:03:14.920
biraz dikkatli bir örnek,

02:03:14.920 --> 02:03:16.100
kurgulamak gerekiyor.

02:03:16.240 --> 02:03:16.540
O yüzden,

02:03:16.680 --> 02:03:17.900
biraz bekletiyorum sizi.

02:03:25.540 --> 02:03:26.180
Evet.

02:03:26.560 --> 02:03:27.020
Arkadaşlar,

02:03:27.080 --> 02:03:27.540
bakın şimdi,

02:03:27.660 --> 02:03:29.340
karmaşık örneklerden biri şu.

02:03:29.480 --> 02:03:29.620
Bu,

02:03:29.780 --> 02:03:30.460
standardın,

02:03:30.520 --> 02:03:31.660
kendi verdiği örnek.

02:03:33.000 --> 02:03:34.540
Yanlış hatırlamıyorsam.

02:03:34.540 --> 02:03:36.660
İzleyin.

02:03:40.660 --> 02:03:41.920
Ya bu örneğin,

02:03:42.000 --> 02:03:43.920
şimdi üstünden geçmemiz de zor olacak.

02:03:44.120 --> 02:03:44.560
Mutlaka,

02:03:44.760 --> 02:03:45.400
gitapta,

02:03:45.900 --> 02:03:46.540
bir kere bakın.

02:03:46.680 --> 02:03:47.920
Çünkü anlatmak da zor,

02:03:48.500 --> 02:03:48.640
şey,

02:03:48.820 --> 02:03:50.200
anlaşılması da zor.

02:03:51.620 --> 02:03:52.280
Arkadaşlar,

02:03:52.440 --> 02:03:52.760
burada,

02:03:53.320 --> 02:03:55.100
setx isimli bir fonksiyon var.

02:03:55.820 --> 02:03:57.680
Sety isimli bir fonksiyon var.

02:03:57.680 --> 02:04:02.080
readx deny isimli bir fonksiyon var.

02:04:02.780 --> 02:04:05.660
ready denx isimli bir fonksiyon var.

02:04:06.500 --> 02:04:06.640
Ve,

02:04:07.640 --> 02:04:08.140
bir de,

02:04:08.460 --> 02:04:10.660
şu atomik değişkenler var.

02:04:10.880 --> 02:04:11.520
Atomic ball,

02:04:11.660 --> 02:04:12.160
x flag,

02:04:12.280 --> 02:04:12.880
y flag,

02:04:13.600 --> 02:04:14.500
atomic int,

02:04:14.740 --> 02:04:14.940
y.

02:04:15.940 --> 02:04:16.160
Şimdi,

02:04:16.240 --> 02:04:17.800
bu fonksiyonların ne yaptığına bakalım.

02:04:17.980 --> 02:04:18.540
Setx,

02:04:19.460 --> 02:04:20.300
x flag'i,

02:04:20.600 --> 02:04:21.620
true değere çekiyor.

02:04:22.620 --> 02:04:23.140
Sety,

02:04:23.580 --> 02:04:24.320
y flag'i,

02:04:24.320 --> 02:04:25.420
true değere çekiyor.

02:04:25.420 --> 02:04:27.800
readx deny,

02:04:28.020 --> 02:04:28.360
yani,

02:04:28.760 --> 02:04:29.740
önce x'i,

02:04:29.860 --> 02:04:31.040
sonra y'yi oku.

02:04:31.840 --> 02:04:32.360
Önce,

02:04:32.960 --> 02:04:33.320
x,

02:04:33.600 --> 02:04:34.360
x'i okuyor,

02:04:34.560 --> 02:04:35.800
true olduğunu görüyor.

02:04:36.940 --> 02:04:37.840
Ondan sonra,

02:04:38.220 --> 02:04:39.280
eğer y'yi,

02:04:39.680 --> 02:04:40.700
load ettiğinde,

02:04:41.520 --> 02:04:42.260
y flag,

02:04:42.580 --> 02:04:42.960
o da,

02:04:43.340 --> 02:04:43.900
true ise,

02:04:44.280 --> 02:04:46.100
burada döngü olmadığına dikkat edin,

02:04:46.780 --> 02:04:47.800
ivali bir arttırıyor.

02:04:47.920 --> 02:04:48.160
Yani,

02:04:48.240 --> 02:04:49.220
burada bir döngü var.

02:04:49.980 --> 02:04:51.560
Buradaki döngünün olması ne demek?

02:04:51.860 --> 02:04:52.780
Yani,

02:04:53.340 --> 02:04:55.260
bu döngüyü geçtikten sonra,

02:04:55.420 --> 02:04:56.580
efendim,

02:04:56.960 --> 02:04:58.280
x flag'in,

02:04:58.900 --> 02:04:59.740
true olduğu,

02:05:00.200 --> 02:05:01.100
garanti altında.

02:05:02.160 --> 02:05:02.820
Dolayısıyla,

02:05:03.140 --> 02:05:04.900
buradaki işlem yapıldığında,

02:05:05.240 --> 02:05:06.440
artık x flag'in,

02:05:06.660 --> 02:05:08.100
true olma garantisi var,

02:05:08.180 --> 02:05:08.460
değil mi?

02:05:09.400 --> 02:05:09.700
Evet.

02:05:10.380 --> 02:05:10.700
Peki,

02:05:11.520 --> 02:05:12.240
x flag,

02:05:12.600 --> 02:05:13.940
true olduktan sonra,

02:05:14.820 --> 02:05:16.240
aşağıdaki işleme bakın,

02:05:16.600 --> 02:05:17.620
y'nin değeri,

02:05:17.900 --> 02:05:19.600
true olarak load edilirse,

02:05:19.920 --> 02:05:22.220
ivalin değerini bir arttırıyorum.

02:05:23.220 --> 02:05:24.120
Burayı anladık mı?

02:05:24.800 --> 02:05:24.960
Evet.

02:05:25.420 --> 02:05:26.320
Arkadaşlar,

02:05:26.380 --> 02:05:26.860
bu ne demek?

02:05:26.980 --> 02:05:27.320
Bakınız,

02:05:27.980 --> 02:05:28.280
ben,

02:05:28.700 --> 02:05:30.020
bu set x'i,

02:05:30.080 --> 02:05:30.720
set y'yi,

02:05:31.180 --> 02:05:32.400
read x,

02:05:32.620 --> 02:05:34.200
then y'yi çalıştırırsam,

02:05:34.840 --> 02:05:36.400
diğer fonksiyon olmasaydı,

02:05:37.280 --> 02:05:39.540
burada sequential consistency varsa,

02:05:39.960 --> 02:05:40.120
ki,

02:05:40.960 --> 02:05:41.480
default,

02:05:41.840 --> 02:05:43.920
zaten sequential consistency idi,

02:05:45.000 --> 02:05:46.600
şu söz konusu değil mi?

02:05:47.460 --> 02:05:49.280
Programın akışı buraya geldiğinde,

02:05:49.280 --> 02:05:50.680
zaten,

02:05:50.680 --> 02:05:52.860
zaten x'i okumuş olacak,

02:05:52.980 --> 02:05:53.580
true olarak,

02:05:54.580 --> 02:05:56.900
x'i true olarak okumuş olması demek,

02:05:57.300 --> 02:06:00.380
set x'deki bu işlemin,

02:06:01.240 --> 02:06:02.540
daha önce yapılması,

02:06:02.840 --> 02:06:04.340
ve sonucunun alınması demek,

02:06:05.680 --> 02:06:06.100
eğer,

02:06:06.440 --> 02:06:08.620
burada da true değer okursa,

02:06:09.300 --> 02:06:09.860
izleyin,

02:06:10.080 --> 02:06:10.620
o zaman,

02:06:11.260 --> 02:06:12.960
burada true değer okunması demek,

02:06:13.680 --> 02:06:14.900
set y'de de,

02:06:15.060 --> 02:06:16.280
store işleminin,

02:06:16.280 --> 02:06:18.080
tamamlanmış olması demek,

02:06:18.400 --> 02:06:18.860
ama bakın,

02:06:18.940 --> 02:06:20.080
bu false da döndürebilir,

02:06:20.200 --> 02:06:20.440
yani,

02:06:21.140 --> 02:06:22.420
buradan çıktığında,

02:06:23.340 --> 02:06:24.040
y flag,

02:06:24.300 --> 02:06:25.440
halen false olabilir,

02:06:25.680 --> 02:06:25.860
değil mi?

02:06:25.920 --> 02:06:26.460
y flag,

02:06:26.560 --> 02:06:27.580
halen false ise,

02:06:28.040 --> 02:06:28.980
ibal artmayacak,

02:06:29.640 --> 02:06:30.840
buraya kadar anladınız mı?

02:06:31.560 --> 02:06:31.760
Evet,

02:06:32.220 --> 02:06:32.440
yani,

02:06:32.540 --> 02:06:34.200
bu fonksiyon çağrıldığında,

02:06:35.000 --> 02:06:35.400
eğer,

02:06:36.320 --> 02:06:37.820
bu noktaya geldiğinde,

02:06:38.140 --> 02:06:38.820
x flag,

02:06:39.220 --> 02:06:40.040
true durumda,

02:06:40.040 --> 02:06:41.060
ondan eminiz,

02:06:41.700 --> 02:06:42.780
ama y flag,

02:06:42.920 --> 02:06:43.740
true durumda,

02:06:44.360 --> 02:06:45.160
olmayabilir,

02:06:45.160 --> 02:06:46.500
true durumdaysa,

02:06:47.260 --> 02:06:47.860
o da ne demek,

02:06:48.000 --> 02:06:49.400
set y'deki bu işlem,

02:06:49.600 --> 02:06:50.880
daha önce yapılmışsa,

02:06:51.300 --> 02:06:51.960
ibalin değeri,

02:06:52.040 --> 02:06:52.680
bir artacak.

02:06:53.680 --> 02:06:54.320
Ama şimdi,

02:06:54.980 --> 02:06:56.220
diğer fonksiyona bakalım,

02:06:56.440 --> 02:06:57.740
read y'den x,

02:06:58.520 --> 02:07:00.000
burada da tam tersi,

02:07:00.920 --> 02:07:03.300
önce y'yi true olarak okuyoruz,

02:07:04.320 --> 02:07:04.760
sonra,

02:07:05.580 --> 02:07:06.200
x'in,

02:07:06.740 --> 02:07:07.760
x flag'in,

02:07:07.900 --> 02:07:09.060
x diyorum ben kısaca,

02:07:09.060 --> 02:07:11.120
onun değerini yet ediyoruz,

02:07:11.360 --> 02:07:12.060
o true ise,

02:07:12.260 --> 02:07:12.740
ibali,

02:07:13.540 --> 02:07:14.460
bir arttırıyoruz.

02:07:15.160 --> 02:07:16.560
takip edebiliyor muyuz?

02:07:17.140 --> 02:07:17.680
Arkadaşlar,

02:07:17.760 --> 02:07:18.380
şimdi bakın,

02:07:18.840 --> 02:07:20.500
4 thread'i de çalıştırıyorum,

02:07:20.740 --> 02:07:22.060
4'ünü de join ediyorum,

02:07:22.220 --> 02:07:23.380
funk fonksiyonu içinde.

02:07:24.080 --> 02:07:24.680
Soru,

02:07:25.340 --> 02:07:25.860
ibalin,

02:07:26.020 --> 02:07:28.320
halen sıfır olma ihtimali var mı?

02:07:29.060 --> 02:07:29.440
İşte bakın,

02:07:29.520 --> 02:07:31.660
sequential consistency'i anlatmak için,

02:07:31.720 --> 02:07:33.100
biraz karmaşık olsa da,

02:07:33.580 --> 02:07:34.600
her yerde kullanılan,

02:07:34.760 --> 02:07:35.820
klasik örnek bu.

02:07:36.680 --> 02:07:37.800
Bir düşünün şimdi,

02:07:37.800 --> 02:07:38.640
dedim ya,

02:07:38.720 --> 02:07:39.980
zihinsel olarak kavramak,

02:07:40.060 --> 02:07:40.940
hemen hakim olmak,

02:07:41.080 --> 02:07:42.500
biraz zor olabilir.

02:07:42.500 --> 02:07:43.740
burada,

02:07:44.560 --> 02:07:46.460
funk fonksiyonu çağrıldığında,

02:07:47.180 --> 02:07:48.460
ibalin değerinin,

02:07:48.720 --> 02:07:51.120
halen sıfır olma ihtimali var mı?

02:07:51.620 --> 02:07:52.120
Cevap,

02:07:52.220 --> 02:07:52.500
hayır.

02:07:53.360 --> 02:07:53.680
Neden?

02:07:54.600 --> 02:07:55.400
E çünkü bakın,

02:07:56.160 --> 02:07:56.580
eğer,

02:07:57.020 --> 02:07:58.700
bu noktaya gelmişse,

02:07:59.500 --> 02:07:59.900
zaten,

02:08:00.120 --> 02:08:01.800
x flag set edilmiştir.

02:08:02.660 --> 02:08:03.320
Dolayısıyla,

02:08:03.800 --> 02:08:05.120
y flag'in değeri,

02:08:05.560 --> 02:08:06.140
arkadaşlar,

02:08:07.100 --> 02:08:08.280
load edildiğinde,

02:08:08.600 --> 02:08:09.080
true ise,

02:08:09.180 --> 02:08:09.920
ibal artacak.

02:08:09.920 --> 02:08:12.740
iki tane ihtimal var.

02:08:12.980 --> 02:08:13.120
Ya,

02:08:13.220 --> 02:08:14.400
x flag daha önce,

02:08:14.980 --> 02:08:15.920
çalışmış olacak.

02:08:16.360 --> 02:08:16.520
Yani,

02:08:16.600 --> 02:08:17.500
x flag daha önce,

02:08:17.640 --> 02:08:18.700
true edilmiş olacak.

02:08:19.420 --> 02:08:19.680
Ya da,

02:08:19.760 --> 02:08:20.320
y flag.

02:08:20.840 --> 02:08:21.420
Öyle değil mi?

02:08:22.300 --> 02:08:22.600
Ama,

02:08:22.760 --> 02:08:23.260
e zaten,

02:08:23.840 --> 02:08:24.860
bu fonksiyonu da,

02:08:25.160 --> 02:08:26.200
biri için bekliyoruz.

02:08:26.260 --> 02:08:27.020
Bu fonksiyonun içine,

02:08:27.100 --> 02:08:28.720
biri için bekliyoruz.

02:08:28.720 --> 02:08:30.120
E madem,

02:08:30.560 --> 02:08:32.100
sequential consistency,

02:08:33.040 --> 02:08:33.720
bütün threadlerin,

02:08:34.680 --> 02:08:36.720
aynı sırayı görmesi demekse,

02:08:36.720 --> 02:08:38.540
o zaman,

02:08:38.660 --> 02:08:39.680
şu garanti altında,

02:08:39.820 --> 02:08:40.120
değil mi?

02:08:40.840 --> 02:08:41.780
Hangisi daha önce,

02:08:41.860 --> 02:08:43.160
çalışırsa çalışsın,

02:08:43.820 --> 02:08:44.540
bu durumda,

02:08:45.000 --> 02:08:45.600
ikisi de,

02:08:45.800 --> 02:08:47.080
aynı total order'ı,

02:08:47.180 --> 02:08:47.980
göreceğine göre,

02:08:48.760 --> 02:08:49.120
burada,

02:08:49.440 --> 02:08:49.960
ibal'in,

02:08:50.240 --> 02:08:51.600
artmama ihtimali,

02:08:52.020 --> 02:08:52.260
yok.

02:08:53.080 --> 02:08:53.700
Dolayısıyla,

02:08:54.100 --> 02:08:54.480
buradaki,

02:08:54.580 --> 02:08:55.460
assertion'ın,

02:08:56.060 --> 02:08:57.500
payl olma ihtimali yok.

02:08:57.980 --> 02:08:58.620
İsterseniz,

02:08:58.980 --> 02:08:59.780
deneyelim şimdi.

02:09:00.460 --> 02:09:00.920
Ama bakın,

02:09:01.000 --> 02:09:01.620
nasıl deniyorum,

02:09:01.760 --> 02:09:02.740
test koduna da bakın.

02:09:03.580 --> 02:09:04.720
10 bin kez deniyorum,

02:09:04.720 --> 02:09:06.520
çünkü bir kere tesadüf olabilir,

02:09:06.700 --> 02:09:08.080
iki kere tesadüf olabilir.

02:09:09.940 --> 02:09:11.240
Şimdi şöyle olsaydı,

02:09:11.560 --> 02:09:13.400
öyle bir senaryo olsaydı ki,

02:09:15.020 --> 02:09:16.120
buraya geldiğinde,

02:09:17.080 --> 02:09:18.060
ibal'in değerinin,

02:09:18.340 --> 02:09:19.320
sıfır olması demek,

02:09:20.160 --> 02:09:20.700
arkadaşlar,

02:09:21.640 --> 02:09:22.220
şuraya,

02:09:22.680 --> 02:09:23.960
bu kod da hiç çalışmadı,

02:09:24.060 --> 02:09:25.120
bu kod da hiç çalışmadı,

02:09:25.220 --> 02:09:26.000
ama bu kodlardan,

02:09:26.160 --> 02:09:27.800
en az bir tanesi çalışırsa,

02:09:28.840 --> 02:09:30.760
ibal'in değerinin,

02:09:30.980 --> 02:09:31.780
bir olması demek.

02:09:31.780 --> 02:09:33.020
ama bunlar,

02:09:33.180 --> 02:09:34.800
aynı sırayı gördüğüne göre,

02:09:35.200 --> 02:09:35.340
bu,

02:09:35.500 --> 02:09:36.600
böyle bir ihtimal yok.

02:09:39.840 --> 02:09:41.160
Takip edebiliyor muyuz?

02:09:42.920 --> 02:09:43.120
Evet.

02:09:43.640 --> 02:09:44.120
Arkadaşlar,

02:09:44.200 --> 02:09:44.420
bakın,

02:09:44.540 --> 02:09:44.940
örneğin,

02:09:45.020 --> 02:09:46.600
daha da basitleştirilmiş hali,

02:09:46.800 --> 02:09:48.280
biraz daha iyi kavrayın diye.

02:09:49.680 --> 02:09:50.260
İzleyin.

02:09:50.260 --> 02:09:57.840
Şimdi,

02:09:58.340 --> 02:10:00.300
ben örneği çok daha basit hale getirdim,

02:10:00.400 --> 02:10:02.280
en azından bir garantiyi görmeniz için.

02:10:03.540 --> 02:10:03.860
Burada,

02:10:04.500 --> 02:10:05.860
bütün store işlemleri,

02:10:06.760 --> 02:10:07.840
ve load işlemleri,

02:10:08.260 --> 02:10:09.140
memory order,

02:10:09.480 --> 02:10:10.820
sequential consistent,

02:10:10.960 --> 02:10:12.400
bellek düzeninde yapılıyor ki,

02:10:13.340 --> 02:10:15.620
zaten bu argümanları koymasaydım,

02:10:16.000 --> 02:10:16.520
default,

02:10:16.720 --> 02:10:17.440
öyle olacaktı,

02:10:17.500 --> 02:10:19.080
dikkat çeksin diye böyle yazdım.

02:10:19.080 --> 02:10:20.900
Arkadaşlar,

02:10:21.340 --> 02:10:21.640
şimdi,

02:10:22.320 --> 02:10:25.200
uyu ve barı ayrı threadlerde çalıştıracağım.

02:10:25.660 --> 02:10:27.280
Yavaş yavaş takip etmeye çalışın.

02:10:28.200 --> 02:10:28.700
O zaman,

02:10:29.420 --> 02:10:30.160
az önceki,

02:10:30.580 --> 02:10:32.860
benim gösterdiğim resmi hatırlayın.

02:10:33.100 --> 02:10:34.700
Hatta o resme geri dönelim.

02:10:35.600 --> 02:10:36.860
Dört tane işlem var ya,

02:10:37.000 --> 02:10:37.700
şu sıradan,

02:10:37.860 --> 02:10:39.820
herhangi birinde olmak zorunda değil mi?

02:10:39.820 --> 02:10:40.820
Ama,

02:10:41.660 --> 02:10:43.560
ikisi de aynı sırayı görecek değil mi?

02:10:43.980 --> 02:10:44.940
Şimdi koda bakın,

02:10:44.940 --> 02:10:46.500
buradaki işlemde,

02:10:46.500 --> 02:10:47.180
buradaki işlemde,

02:10:47.880 --> 02:10:49.780
önce x'i set ettim.

02:10:50.260 --> 02:10:51.700
Yani x'i bir yaptım.

02:10:52.660 --> 02:10:53.740
Ondan sonra,

02:10:53.860 --> 02:10:55.800
y'nin değerini r1'e okudum.

02:10:57.000 --> 02:10:58.680
Diğer fonksiyonda ise,

02:10:58.780 --> 02:11:00.040
bar fonksiyonda ise,

02:11:00.980 --> 02:11:03.040
önce y'nin değerini bir okudum.

02:11:04.020 --> 02:11:05.580
Bir olarak set ettim.

02:11:05.920 --> 02:11:06.340
Sonra,

02:11:07.020 --> 02:11:08.060
x'in değerini,

02:11:08.600 --> 02:11:09.220
arkadaşlar,

02:11:09.220 --> 02:11:10.080
okudum.

02:11:10.740 --> 02:11:11.860
Yani okudum derken,

02:11:12.540 --> 02:11:13.660
o load işlemlerinin,

02:11:13.820 --> 02:11:14.700
geri dönüş değerini,

02:11:14.780 --> 02:11:17.040
r1 ve r2 değişkenlerine yazdım.

02:11:18.000 --> 02:11:18.840
Şimdi soru,

02:11:19.700 --> 02:11:21.040
x'in değeri sıfır,

02:11:21.320 --> 02:11:22.720
y'nin değeri sıfır.

02:11:24.060 --> 02:11:25.180
Takip edebiliyor muyuz?

02:11:25.380 --> 02:11:25.600
Evet.

02:11:26.460 --> 02:11:26.700
Ve,

02:11:27.060 --> 02:11:28.480
iki thread'i çalıştırıyorum.

02:11:29.420 --> 02:11:29.760
Burada,

02:11:30.420 --> 02:11:32.060
r1'in ve r2'nin,

02:11:32.380 --> 02:11:34.980
ikisinin birden sıfır olma ihtimali var mı?

02:11:36.120 --> 02:11:36.800
Bir düşünün.

02:11:36.800 --> 02:11:39.480
İkisinin birden sıfır olma ihtimali var mı?

02:11:40.220 --> 02:11:40.740
Cevap,

02:11:41.660 --> 02:11:43.020
buradaki sıra,

02:11:43.100 --> 02:11:44.640
kendi içinde değişmeyecek.

02:11:45.700 --> 02:11:46.080
Yani,

02:11:46.520 --> 02:11:48.260
az önceki kombinasyonlardan,

02:11:48.620 --> 02:11:49.980
hangisi olursa olsun,

02:11:50.800 --> 02:11:51.400
bu işlem,

02:11:51.580 --> 02:11:52.540
bu işlemden,

02:11:53.180 --> 02:11:54.740
önce yapılacak.

02:11:54.900 --> 02:11:55.560
Bu işlem de,

02:11:55.640 --> 02:11:57.080
bu işlemden önce yapılacak.

02:11:57.360 --> 02:11:58.900
Buraya kadar takip edebiliyor muyuz?

02:11:59.480 --> 02:11:59.740
Evet.

02:12:00.700 --> 02:12:01.100
Ama,

02:12:01.440 --> 02:12:03.200
ikisi de aynı sırayı görecek.

02:12:04.060 --> 02:12:04.460
O zaman,

02:12:04.600 --> 02:12:06.780
oluşabilecek bütün kombinasyonlara var.

02:12:06.800 --> 02:12:07.080
bakın.

02:12:07.740 --> 02:12:08.100
Mesela,

02:12:08.200 --> 02:12:09.960
doğrudan bu sırayla olsaydı,

02:12:10.620 --> 02:12:10.840
yani,

02:12:11.000 --> 02:12:11.720
önce bir,

02:12:12.380 --> 02:12:13.020
sonra iki,

02:12:13.500 --> 02:12:14.140
sonra üç,

02:12:14.400 --> 02:12:15.140
sonra dört.

02:12:16.040 --> 02:12:16.600
O zaman,

02:12:17.420 --> 02:12:19.400
x'in değerini bir yapacaktı.

02:12:20.340 --> 02:12:21.400
r1'in,

02:12:21.640 --> 02:12:23.400
değeri sıfır olacaktı.

02:12:23.820 --> 02:12:24.080
Çünkü,

02:12:24.140 --> 02:12:25.340
y daha set edilmedi.

02:12:26.220 --> 02:12:27.300
y'nin değeri,

02:12:27.580 --> 02:12:28.140
bir olacak.

02:12:28.140 --> 02:12:29.540
ama burada arkadaşlar,

02:12:29.540 --> 02:12:32.960
r2 eşittir.

02:12:33.220 --> 02:12:33.500
x,

02:12:33.860 --> 02:12:35.380
daha önce set edildiğine göre,

02:12:35.680 --> 02:12:35.980
x,

02:12:36.480 --> 02:12:37.020
1 olacak.

02:12:37.980 --> 02:12:38.220
Yani,

02:12:38.360 --> 02:12:38.840
özür dilerim,

02:12:38.900 --> 02:12:39.360
r2,

02:12:39.580 --> 02:12:40.320
1 olacak.

02:12:41.160 --> 02:12:41.420
Yani,

02:12:41.480 --> 02:12:41.660
bakın,

02:12:41.720 --> 02:12:42.800
bu kombinasyonlardan,

02:12:43.020 --> 02:12:44.240
hangisini seçerseniz,

02:12:44.400 --> 02:12:44.800
seçin.

02:12:45.460 --> 02:12:46.080
İkisi de,

02:12:46.440 --> 02:12:47.800
aynı sırayı gördüğüne göre,

02:12:47.980 --> 02:12:49.740
total bir order olduğuna göre,

02:12:50.740 --> 02:12:52.340
istediğiniz kombinasyonu,

02:12:52.540 --> 02:12:52.980
seçin.

02:12:52.980 --> 02:12:54.760
mutlaka hiçbir şekilde,

02:12:55.360 --> 02:12:56.100
hem x'in,

02:12:56.300 --> 02:12:56.960
hem y'nin,

02:12:57.460 --> 02:12:58.860
ne olma ihtimali yok.

02:12:59.480 --> 02:13:00.260
Sıfır olma,

02:13:00.560 --> 02:13:01.400
ihtimali yok.

02:13:03.380 --> 02:13:04.180
İkisinde,

02:13:04.340 --> 02:13:05.300
ikisinde de,

02:13:05.400 --> 02:13:06.100
her seferinde,

02:13:06.220 --> 02:13:07.980
bir yazmasını istersek,

02:13:08.640 --> 02:13:09.180
ne yapmalıyız?

02:13:09.260 --> 02:13:09.700
Arkadaşlar,

02:13:09.780 --> 02:13:11.460
örneği yanlış anlamış olabilirsiniz.

02:13:12.120 --> 02:13:12.580
Bu örnek,

02:13:12.700 --> 02:13:13.600
neyi göstermeye,

02:13:13.600 --> 02:13:14.900
bir şey yapmayı,

02:13:15.280 --> 02:13:16.200
hedeflemiyor.

02:13:17.000 --> 02:13:17.580
Bu örnek,

02:13:17.760 --> 02:13:19.600
sequential consistency'nin,

02:13:19.900 --> 02:13:21.420
neyi sağladığını anlatıyor.

02:13:22.240 --> 02:13:22.580
Yani,

02:13:22.580 --> 02:13:23.400
burada örneğin,

02:13:23.960 --> 02:13:24.820
memori düzeni,

02:13:25.180 --> 02:13:27.700
sequential consistency olmasaydı,

02:13:28.400 --> 02:13:29.620
deneyip çalıştırıyorum.

02:13:33.240 --> 02:13:34.200
Mesela,

02:13:34.520 --> 02:13:35.560
şöyle olsaydı,

02:13:36.680 --> 02:13:37.620
memori order,

02:13:38.800 --> 02:13:39.360
arkadaşlar,

02:13:39.560 --> 02:13:39.920
bırakın,

02:13:39.960 --> 02:13:42.080
sequential consistency'yi,

02:13:42.080 --> 02:13:43.420
bakın bunları,

02:13:43.820 --> 02:13:44.980
acquire yapsaydım,

02:13:45.040 --> 02:13:46.280
release yapsaydım.

02:13:47.920 --> 02:13:49.200
Memori order,

02:13:50.520 --> 02:13:51.160
release,

02:13:51.160 --> 02:13:53.480
release,

02:13:53.480 --> 02:13:55.620
memori order,

02:13:56.220 --> 02:13:56.700
acquire,

02:13:59.700 --> 02:14:00.280
acquire,

02:14:02.280 --> 02:14:03.420
memori order,

02:14:05.200 --> 02:14:05.900
release,

02:14:08.220 --> 02:14:09.140
memori order,

02:14:09.700 --> 02:14:10.200
acquire,

02:14:12.400 --> 02:14:12.780
arkadaşlar,

02:14:12.980 --> 02:14:13.160
bu arada,

02:14:13.280 --> 02:14:13.940
şu da yanıtıyor.

02:14:13.940 --> 02:14:14.260
yani,

02:14:14.260 --> 02:14:15.160
şimdi testte,

02:14:15.600 --> 02:14:18.260
assertion fail olmadı demeniz,

02:14:19.060 --> 02:14:21.420
bu garantinin olduğu anlamına gelmiyor.

02:14:22.000 --> 02:14:22.260
Çünkü,

02:14:22.340 --> 02:14:22.940
tamamen,

02:14:23.060 --> 02:14:24.080
terleyici tarafında,

02:14:24.160 --> 02:14:25.120
ya da işlemci tarafında,

02:14:25.180 --> 02:14:26.960
yapılan optimizasyonlara bağlı.

02:14:26.960 --> 02:14:28.640
şimdi artık,

02:14:28.900 --> 02:14:31.340
bu seçeneklerden biri olmak zorunda değil.

02:14:32.020 --> 02:14:33.180
Reordering de olabilir.

02:14:34.120 --> 02:14:34.920
Reordering,

02:14:35.120 --> 02:14:36.080
yeniden sıralama,

02:14:36.800 --> 02:14:38.920
derlecinin yaptığı optimizasyonda olabilir,

02:14:39.140 --> 02:14:40.500
işlemci tarafında olabilir.

02:14:41.160 --> 02:14:41.380
Yani,

02:14:41.420 --> 02:14:43.000
bu total order garantisi,

02:14:43.740 --> 02:14:44.240
verilmiyor.

02:14:44.240 --> 02:14:46.560
işlemlerin sonucunun,

02:14:46.560 --> 02:14:48.920
birbiri tarafından görülebileceği,

02:14:49.020 --> 02:14:49.900
verilmiyor.

02:14:50.480 --> 02:14:50.740
Yani,

02:14:50.800 --> 02:14:51.540
böyle olması,

02:14:51.740 --> 02:14:53.780
bunun bir garanti altında olması demek değil.

02:14:53.900 --> 02:14:53.980
Tabi,

02:14:54.040 --> 02:14:55.040
arada başka kodlar,

02:14:55.120 --> 02:14:56.300
bunlar olsaydı,

02:14:56.840 --> 02:14:57.440
belki onu,

02:14:57.560 --> 02:14:58.560
doğrudan,

02:14:58.560 --> 02:15:01.380
gözlemleme şansına da sahip olacaktık.

02:15:02.920 --> 02:15:03.560
Arkadaşlar,

02:15:03.620 --> 02:15:04.500
şimdi kursla ilgili,

02:15:04.960 --> 02:15:06.240
genel bir takım notlar,

02:15:06.520 --> 02:15:07.500
ve ondan sonra,

02:15:07.600 --> 02:15:10.100
biraz diğer C++ kursundan bahsedeceğim.

02:15:10.860 --> 02:15:11.040
Şimdi,

02:15:11.140 --> 02:15:11.320
bir,

02:15:11.900 --> 02:15:12.980
bazı konular,

02:15:13.380 --> 02:15:16.180
C++ o kadar büyük bir programlama değil ki,

02:15:16.820 --> 02:15:19.160
iki üç saate her şeye sığdırmak mümkün değil.

02:15:19.160 --> 02:15:19.680
Mesela,

02:15:20.400 --> 02:15:21.000
bu,

02:15:21.480 --> 02:15:22.880
concurrency konusunda,

02:15:23.540 --> 02:15:24.940
eksik kalan yerler var.

02:15:25.740 --> 02:15:26.200
Mesela,

02:15:26.940 --> 02:15:27.500
semafor,

02:15:27.620 --> 02:15:27.960
binary,

02:15:27.960 --> 02:15:29.840
counting semafor,

02:15:29.940 --> 02:15:31.000
binary semafor,

02:15:31.300 --> 02:15:31.960
latchler,

02:15:32.800 --> 02:15:33.700
daha önemlisi,

02:15:34.440 --> 02:15:34.660
bu,

02:15:34.800 --> 02:15:36.880
paralel algoritmalar.

02:15:37.480 --> 02:15:38.040
Ama şimdi,

02:15:38.400 --> 02:15:39.620
zamanda azaldığı için,

02:15:39.780 --> 02:15:41.180
onlara ayrı bir ders yapıp,

02:15:41.320 --> 02:15:41.840
ekleyeceğim.

02:15:42.020 --> 02:15:42.460
En azından,

02:15:42.680 --> 02:15:43.980
paralel algoritmalar,

02:15:44.500 --> 02:15:45.020
konusu,

02:15:45.660 --> 02:15:47.060
ve semafor konusu,

02:15:47.200 --> 02:15:47.920
bunlar önemli.

02:15:47.920 --> 02:15:48.160
Çünkü,

02:15:48.240 --> 02:15:49.780
semaforlar da çok kullanılıyor.

02:15:50.880 --> 02:15:51.620
Onun dışında,

02:15:52.120 --> 02:15:52.780
bu kursda,

02:15:53.320 --> 02:15:54.120
ele almadığımız,

02:15:54.280 --> 02:15:55.200
ama üretimde,

02:15:55.560 --> 02:15:56.320
önemli olan,

02:15:56.320 --> 02:15:58.880
standart kütüphane üyelerini,

02:15:59.160 --> 02:16:01.200
ileri C++ kursunda anlatıyorum.

02:16:01.940 --> 02:16:02.820
Yine aynı şekilde,

02:16:02.900 --> 02:16:04.640
o kursun içeriğine bakarsanız,

02:16:05.260 --> 02:16:05.560
orada,

02:16:06.020 --> 02:16:07.340
yine bu kursa anlatmadığımız,

02:16:07.440 --> 02:16:09.000
C++ 20 ile gelen,

02:16:09.340 --> 02:16:10.380
önemli araçları,

02:16:10.380 --> 02:16:10.980
mesela,

02:16:10.980 --> 02:16:12.880
onlar da böyle çok,

02:16:13.340 --> 02:16:13.840
bir saatte,

02:16:13.900 --> 02:16:14.520
iki saatte,

02:16:14.720 --> 02:16:16.100
anlaşılacak konular değil.

02:16:16.780 --> 02:16:17.300
Örneğin,

02:16:17.560 --> 02:16:19.000
Ranges kütüphanesini,

02:16:19.260 --> 02:16:19.420
ki,

02:16:19.660 --> 02:16:20.360
popüler olarak,

02:16:20.500 --> 02:16:22.760
STL 2.0 diyorlar artık.

02:16:23.760 --> 02:16:25.500
Ranges kütüphanesindeki üyeleri,

02:16:25.660 --> 02:16:26.840
Ranges kütüphanesinin,

02:16:27.000 --> 02:16:27.680
kullanılması,

02:16:28.580 --> 02:16:29.360
konseptler,

02:16:29.620 --> 02:16:31.140
konseptlerin kullanılması,

02:16:31.380 --> 02:16:32.520
ki bunlar birbirleriyle,

02:16:32.680 --> 02:16:34.300
ilişkili halde de kullanılıyor.

02:16:35.160 --> 02:16:35.580
Efendim,

02:16:35.740 --> 02:16:36.480
korutinler,

02:16:36.660 --> 02:16:38.160
korutinlerin kullanılması,

02:16:38.160 --> 02:16:39.180
bir kere,

02:16:39.380 --> 02:16:40.740
C++ 20 ile gelen,

02:16:40.840 --> 02:16:41.940
bu önemli araçlar,

02:16:42.040 --> 02:16:42.880
o kursun konusu.

02:16:43.020 --> 02:16:43.300
Burada,

02:16:44.080 --> 02:16:45.120
anlatmadığımız,

02:16:45.480 --> 02:16:46.420
zaman kalmayan,

02:16:47.040 --> 02:16:48.640
jenerik programlamayla ilgili,

02:16:48.840 --> 02:16:49.980
bazı konular,

02:16:50.280 --> 02:16:51.760
burada zaman yetmediği için,

02:16:51.860 --> 02:16:53.380
mesela az önce bir tanesini söyleyeyim,

02:16:53.460 --> 02:16:54.560
deduction guides'a,

02:16:55.220 --> 02:16:56.000
hiç değinmedim.

02:16:56.980 --> 02:16:57.260
Yine,

02:16:57.840 --> 02:16:59.040
bunun dışında,

02:16:59.320 --> 02:17:00.540
şöyle bir hatırlamaya çalışayım,

02:17:00.740 --> 02:17:00.860
evet,

02:17:01.820 --> 02:17:03.280
ideomlar ve teknikler,

02:17:03.400 --> 02:17:05.140
bence en önemli kısmı bu.

02:17:05.140 --> 02:17:05.900
Yani,

02:17:06.060 --> 02:17:06.660
üretimde,

02:17:06.880 --> 02:17:08.140
C++ programcılık,

02:17:08.160 --> 02:17:09.840
çok sık kullandığı,

02:17:10.440 --> 02:17:11.840
ideomlar ve teknikler,

02:17:11.960 --> 02:17:13.520
görmediğimiz bazı sınıflar,

02:17:13.700 --> 02:17:13.960
mesela,

02:17:14.080 --> 02:17:15.380
Regex'e hiç değinmedim.

02:17:16.500 --> 02:17:17.320
Bazı kurslarda,

02:17:17.420 --> 02:17:17.960
vakit yetiyor,

02:17:18.040 --> 02:17:18.520
anlatıyorum,

02:17:18.660 --> 02:17:19.620
bazılarında yetmiyor.

02:17:20.300 --> 02:17:20.800
Regex,

02:17:20.980 --> 02:17:21.840
her programcının,

02:17:22.000 --> 02:17:23.300
bilmesi gereken bir konu.

02:17:23.880 --> 02:17:24.500
Hem Regex,

02:17:24.560 --> 02:17:25.820
notasyonunu anlatıyorum,

02:17:26.020 --> 02:17:26.740
tipik bir Regex,

02:17:26.800 --> 02:17:27.360
notasyonunu,

02:17:27.440 --> 02:17:27.800
hem de,

02:17:28.380 --> 02:17:29.140
C++'a,

02:17:29.220 --> 02:17:30.860
standart kütüphanesindeki,

02:17:31.520 --> 02:17:32.020
arkadaşlar,

02:17:32.440 --> 02:17:34.340
Regex ile ilişkin,

02:17:34.340 --> 02:17:35.620
öğeleri anlatıyorum.

02:17:35.620 --> 02:17:36.340
onun dışında,

02:17:37.000 --> 02:17:38.140
stud yine çok önemli,

02:17:38.340 --> 02:17:40.080
stud format kütüphanesi,

02:17:41.200 --> 02:17:41.620
efendim,

02:17:42.320 --> 02:17:42.520
yani,

02:17:42.620 --> 02:17:44.200
bu kursta olmayan,

02:17:44.520 --> 02:17:44.960
ama,

02:17:45.300 --> 02:17:47.240
C++ 20 ile gelen,

02:17:47.580 --> 02:17:48.400
önemli öğeler,

02:17:49.080 --> 02:17:49.300
bilir,

02:17:49.360 --> 02:17:50.940
C++ kursunda anlatılıyor.

02:17:51.040 --> 02:17:51.800
Ama onun dışında,

02:17:52.040 --> 02:17:52.560
dediğim gibi,

02:17:52.560 --> 02:17:53.820
videomlar,

02:17:53.940 --> 02:17:54.560
teknikler,

02:17:54.720 --> 02:17:56.500
işte bu taşıma semantiği ile ilgili,

02:17:56.700 --> 02:17:57.580
daha detaylı,

02:17:58.180 --> 02:17:59.520
konuların incelenmesi,

02:17:59.800 --> 02:18:00.820
Perfect Boarding,

02:18:01.680 --> 02:18:02.860
Moo Semantics vs.

02:18:03.160 --> 02:18:04.520
bunlardan faydalanmak,

02:18:04.940 --> 02:18:06.320
maalesef o kursta katılıyor.

02:18:06.400 --> 02:18:06.640
Ama,

02:18:06.840 --> 02:18:08.120
söz vermemekle beraber,

02:18:08.920 --> 02:18:09.200
buraya,

02:18:09.960 --> 02:18:10.620
bir,

02:18:10.880 --> 02:18:11.120
iki,

02:18:11.520 --> 02:18:12.000
maksimum,

02:18:12.080 --> 02:18:13.560
üç ders daha ekleyebilirim,

02:18:13.600 --> 02:18:15.080
ama onlar canlı olmayacak.

02:18:15.800 --> 02:18:16.000
Yani,

02:18:16.040 --> 02:18:17.780
onları kayıt olarak yükleyeceğim.

02:18:18.640 --> 02:18:19.740
Telegram grubunu,

02:18:19.960 --> 02:18:20.800
bir anı bir süre,

02:18:21.020 --> 02:18:21.900
açık tutacağım.

02:18:21.900 --> 02:18:23.280
Hatta hiç kapatmıyorum.

02:18:23.940 --> 02:18:24.200
Yani,

02:18:24.400 --> 02:18:25.760
kurs bittikten sonra da,

02:18:25.880 --> 02:18:26.980
Telegram grubu üstünden,

02:18:27.160 --> 02:18:28.160
soru sorabilirsiniz.

02:18:29.220 --> 02:18:29.920
Hocam,

02:18:29.980 --> 02:18:30.500
bundan sonra,

02:18:30.620 --> 02:18:31.880
hangi kitapları okumalıyız,

02:18:31.960 --> 02:18:33.380
sırayla söyleyebilir misiniz?

02:18:34.140 --> 02:18:34.620
Nereden,

02:18:34.720 --> 02:18:35.960
testler işleyelim?

02:18:36.060 --> 02:18:36.620
Hangi,

02:18:36.620 --> 02:18:37.760
platformu,

02:18:37.840 --> 02:18:39.080
ya da kitapları önersiniz?

02:18:39.740 --> 02:18:40.820
Bunların hepsini,

02:18:41.000 --> 02:18:41.400
Resul,

02:18:41.920 --> 02:18:43.000
Telegram grubunda,

02:18:43.300 --> 02:18:43.920
bana sorun.

02:18:44.060 --> 02:18:44.440
Orada,

02:18:44.940 --> 02:18:45.140
şimdi,

02:18:45.380 --> 02:18:45.680
çünkü,

02:18:46.240 --> 02:18:47.200
kitap isimleri,

02:18:47.200 --> 02:18:48.640
hemen aklıma gelmeyebilir.

02:18:48.860 --> 02:18:49.580
Ya da sırasını,

02:18:49.680 --> 02:18:51.300
kafamda heyecanlandıramayabilirim.

02:18:51.900 --> 02:18:52.740
Ama özellikle,

02:18:53.060 --> 02:18:54.260
bu kurs bittikten sonra,

02:18:54.360 --> 02:18:56.080
artık temel kurs bittikten sonra,

02:18:56.740 --> 02:18:57.860
daha ilerlemek için,

02:18:58.060 --> 02:18:59.080
neler yapabilirsiniz?

02:18:59.320 --> 02:18:59.760
Onları,

02:19:00.500 --> 02:19:01.760
açıklarım olur mu?

02:19:01.860 --> 02:19:02.320
En azından,

02:19:02.520 --> 02:19:03.760
kendi fikrimi söylerim.

02:19:03.900 --> 02:19:05.500
Nasıl ilerlemek daha kolay?

02:19:07.400 --> 02:19:07.720
Evet,

02:19:07.820 --> 02:19:08.620
ondan sonra,

02:19:08.760 --> 02:19:09.080
başka,

02:19:09.620 --> 02:19:11.260
neleri söylemek istiyorum?

02:19:11.260 --> 02:19:14.760
bu en çok sorulan sorulardan biri,

02:19:15.680 --> 02:19:17.600
kurs kayıtlarının,

02:19:17.600 --> 02:19:18.860
hangi sürece,

02:19:19.180 --> 02:19:19.680
arkadaşlar,

02:19:20.480 --> 02:19:21.440
açık kalacağı?

02:19:22.940 --> 02:19:23.540
Şimdi,

02:19:25.320 --> 02:19:26.600
Temmuz ayında başladı,

02:19:26.940 --> 02:19:27.840
çok uzun sürdü,

02:19:27.900 --> 02:19:29.360
haftada iki gün olduğu için,

02:19:30.420 --> 02:19:30.860
şu anda,

02:19:31.120 --> 02:19:31.920
Şubat ayı bitti.

02:19:32.100 --> 02:19:32.280
Yani,

02:19:32.420 --> 02:19:32.780
Temmuz,

02:19:32.900 --> 02:19:33.340
Ağustos,

02:19:33.460 --> 02:19:33.760
Eylül,

02:19:33.860 --> 02:19:34.100
Ekim,

02:19:34.220 --> 02:19:34.520
Kasım,

02:19:34.660 --> 02:19:35.020
Aralık,

02:19:35.140 --> 02:19:35.460
Ocak,

02:19:35.600 --> 02:19:36.200
Şubat,

02:19:36.460 --> 02:19:36.720
şimdi,

02:19:36.920 --> 02:19:38.180
Mart'ta geleceğiz.

02:19:38.760 --> 02:19:39.400
Bu da ne demek?

02:19:39.400 --> 02:19:41.080
7 aya yakın,

02:19:41.280 --> 02:19:42.380
kurs sürmüş.

02:19:43.060 --> 02:19:43.420
Tabi,

02:19:44.340 --> 02:19:45.740
bütün arkadaşların,

02:19:46.020 --> 02:19:47.420
bütün dersleri izlediğini,

02:19:47.620 --> 02:19:48.380
düşünemiyoruz.

02:19:48.720 --> 02:19:49.080
O yüzden,

02:19:49.840 --> 02:19:50.940
dersleri tamamlamamış,

02:19:51.000 --> 02:19:51.760
arkadaşlar olabilir.

02:19:51.940 --> 02:19:53.440
Normalde bizim kuralımız şu,

02:19:53.660 --> 02:19:54.440
kurumun kuralı,

02:19:55.260 --> 02:19:56.720
kurs bittikten sonra,

02:19:56.960 --> 02:19:57.880
3 ay boyunca,

02:19:57.960 --> 02:19:58.760
erişime açık.

02:19:59.040 --> 02:20:00.880
Ama kesinlikle ve kesinlikle,

02:20:01.600 --> 02:20:02.120
arkadaşlar,

02:20:02.360 --> 02:20:03.440
kopyalanmaması,

02:20:04.160 --> 02:20:06.420
ve başkalarıyla paylaşılmaması gerekiyor.

02:20:06.540 --> 02:20:07.000
Diyelim ki,

02:20:07.040 --> 02:20:07.940
o 3 ay bitti.

02:20:07.940 --> 02:20:09.620
fakat siz,

02:20:10.060 --> 02:20:11.740
yani kendiniz tekrar etmek,

02:20:11.880 --> 02:20:12.980
ya da dinlemediğiniz,

02:20:13.260 --> 02:20:14.940
bitiremediğiniz dersler olabilir.

02:20:15.680 --> 02:20:17.840
O zaman bana yazarsanız,

02:20:17.940 --> 02:20:20.280
ben yine erişim hakkı veriyorum.

02:20:20.420 --> 02:20:22.400
Yani orada bir sıkıntı çıkacağını zannetmiyorum.

02:20:22.500 --> 02:20:24.360
Herhangi bir kötü niyet olmadığı sürece,

02:20:24.940 --> 02:20:26.000
tabi ki amacımız,

02:20:26.200 --> 02:20:27.300
isteğimiz herkesin,

02:20:27.820 --> 02:20:29.340
kursu bitirmiş olması.

02:20:30.120 --> 02:20:31.900
Bütün dersleri izleyen arkadaşlar,

02:20:32.300 --> 02:20:33.220
sertifika için,

02:20:33.900 --> 02:20:35.020
başvurabilirler.

02:20:35.020 --> 02:20:36.980
doğrudan bana yazabilirsiniz.

02:20:37.380 --> 02:20:39.180
Yani bütün dersleri bitirdiğinizi,

02:20:39.420 --> 02:20:41.860
kişisel beyanda bulunursanız,

02:20:42.740 --> 02:20:43.440
onlar hemen,

02:20:43.680 --> 02:20:46.380
bu katılım sertifikasını da,

02:20:46.920 --> 02:20:48.120
arkadaşlara iletiriz.

02:20:48.200 --> 02:20:49.080
Telegram üstünde.

02:20:49.080 --> 02:20:50.700
Mehmet Ali İkici,

02:20:51.480 --> 02:20:56.920
C++ networkingle ilgili bir library ya da spesifikasyon var mı?

02:20:57.080 --> 02:20:58.940
Bu konuya dair bir dersiniz var mı?

02:20:59.620 --> 02:21:00.160
Arkadaşlar,

02:21:00.240 --> 02:21:02.560
bu konuya dair kurs kapsamında bir dersim yok.

02:21:03.760 --> 02:21:05.280
Networking standart değil.

02:21:05.280 --> 02:21:08.540
Şimdi en çok tartışılan konulardan biri bu.

02:21:09.200 --> 02:21:12.780
Sürekli de bu standart toplantılarında,

02:21:12.880 --> 02:21:13.960
komiklerinde konuşuluyor.

02:21:14.060 --> 02:21:15.300
Hazır çalışma grubu var,

02:21:15.400 --> 02:21:15.720
şu var,

02:21:15.800 --> 02:21:16.140
bu var.

02:21:16.740 --> 02:21:17.500
İşte C++,

02:21:18.200 --> 02:21:22.460
daha 20'ye bile yetişmesi söz konusuydu.

02:21:22.740 --> 02:21:24.380
En azından onun konuşması yapılıyordu.

02:21:24.480 --> 02:21:25.180
20 geçti,

02:21:25.260 --> 02:21:26.260
23 geçti.

02:21:26.880 --> 02:21:31.060
Şimdi 26 artık sonuçlanmaya çok yakın.

02:21:31.060 --> 02:21:34.520
Ama halen networking ne değil?

02:21:34.760 --> 02:21:35.440
Arkadaşlar,

02:21:35.980 --> 02:21:38.900
standart kütüphanenin bir parçası değil.

02:21:40.220 --> 02:21:44.560
Networkingle ilgili kullanılan ana kütüphane,

02:21:45.220 --> 02:21:45.740
arkadaşlar,

02:21:45.940 --> 02:21:47.260
Boost'un SEO'su.

02:21:47.980 --> 02:21:49.760
Yani asla şunu bile yapsalar,

02:21:49.860 --> 02:21:51.340
büyük iyilik yapmış olacaklar.

02:21:51.440 --> 02:21:56.800
Boost SEO'yu standart kütüphanenin bir bileşeni yapsalar.

02:21:57.820 --> 02:21:58.320
Arkadaşlar,

02:21:58.400 --> 02:22:00.640
bu arada tabii bu kursta doğal olarak

02:22:00.640 --> 02:22:02.340
Boost'tan da hiç bahsetmedim.

02:22:03.320 --> 02:22:07.600
Boost adeta standart kütüphanenin bir devamı gibi.

02:22:08.860 --> 02:22:12.000
Zaten standart kütüphanedeki bazı öğeler,

02:22:12.700 --> 02:22:15.700
tamamen Boost'tan alınma küçük değişikliklerle.

02:22:16.320 --> 02:22:17.280
Yani örneğin,

02:22:17.720 --> 02:22:19.600
Studeray daha önce Boost'ta vardı,

02:22:19.700 --> 02:22:21.880
Studeray'ın Boost'ta vardı.

02:22:23.260 --> 02:22:24.580
Boost'ta olan,

02:22:24.580 --> 02:22:27.880
C++'ın standart kütüphanesinde olmayan,

02:22:28.020 --> 02:22:29.620
örneğin konteynerler var.

02:22:30.640 --> 02:22:34.200
Template meta programlamaya ilişkin çok güzel araçlar var.

02:22:35.400 --> 02:22:36.040
Dolayısıyla,

02:22:36.440 --> 02:22:38.560
üretimde büyük ihtimalle,

02:22:38.680 --> 02:22:42.880
ya zaten kullanmışsınızdır Boost'un herhangi bir alt kütüphanesini,

02:22:43.540 --> 02:22:46.100
ya da ileride kullanacak olabilirsiniz.

02:22:46.100 --> 02:22:49.480
Tekrar bu networking konusuna gelecek olursak,

02:22:50.060 --> 02:22:52.560
C++'da networking standart değil.

02:22:52.740 --> 02:22:54.140
Ya Boost SEO kullanıyor,

02:22:54.240 --> 02:22:55.980
ne yapmak istediğinize bağlı olarak.

02:22:56.700 --> 02:22:59.140
Ama Boost SEO'da çok büyük bir kütüphane,

02:22:59.240 --> 02:23:00.920
biraz da karmaşık olduğu için,

02:23:01.120 --> 02:23:02.800
çünkü tamamen template bazlı,

02:23:03.720 --> 02:23:06.740
zaten biliyorsunuz networking konusu yeterince karmaşık.

02:23:06.740 --> 02:23:10.400
O yüzden bu SEO'yu sarmalayan,

02:23:11.140 --> 02:23:13.140
daha light kütüphaneler var.

02:23:13.820 --> 02:23:14.720
Onlar da yine,

02:23:15.020 --> 02:23:16.800
bunların hemen hepsi,

02:23:16.860 --> 02:23:17.660
arkadaşlar,

02:23:18.940 --> 02:23:20.600
header only library'ler.

02:23:20.800 --> 02:23:22.900
Mesela Boost Beast diye bir kütüphane var.

02:23:23.020 --> 02:23:23.540
Yine Boost,

02:23:23.540 --> 02:23:31.740
ama bu SEO'nun biraz daha kolay kullanılan hale getirilmiş biçimi,

02:23:32.640 --> 02:23:34.900
o Boost Beast'i de kullanabilirsiniz.

02:23:35.440 --> 02:23:38.740
Ama tabii bunun dışında başka networking kütüphaneleri de mutlaka var.

02:23:38.740 --> 02:23:44.740
Ama Boost hemen hemen neredeyse standart gibi arkadaşlar algılanıyor.

02:23:46.100 --> 02:23:47.740
Rasul Mehmetov,

02:23:47.960 --> 02:23:49.500
hocam öncelikle teşekkür ederim,

02:23:49.560 --> 02:23:51.700
ben teşekkür ederim derslere katıldığınız için.

02:23:52.480 --> 02:23:53.460
Tüm dersleri izledim,

02:23:53.540 --> 02:23:56.200
buradaki arkadaşların çoğu programlamadan gelenler,

02:23:56.340 --> 02:23:57.960
ama bende domen farklıydı.

02:23:58.600 --> 02:24:01.440
İlk defa bir programlama dilini bu kadar iyi öğrendim sonunda.

02:24:02.080 --> 02:24:07.320
Aslında ilk defa programlamaya tanışmışsanız,

02:24:07.320 --> 02:24:09.140
C++'da başlamak,

02:24:09.280 --> 02:24:11.380
hani İngilizcesi de çok büyük bir challenge.

02:24:12.560 --> 02:24:14.000
Yani programlamada,

02:24:14.440 --> 02:24:18.600
bakın mesela bu birçok yerde tartışılan konu,

02:24:18.720 --> 02:24:21.460
programlamaya C++'da başlamak,

02:24:21.460 --> 02:24:51.460
birçok kişinin motivasyonunu

02:24:51.460 --> 02:24:53.160
programlama dilleri.

02:24:53.160 --> 02:24:55.980
Mesela C onun için çok uygun.

02:24:56.600 --> 02:25:00.720
Ya da fonksiyonel programlama dillerinden Python uygun.

02:25:01.320 --> 02:25:04.680
NS önemli programlama dillerinden Java çok uygun.

02:25:04.800 --> 02:25:06.620
Mesela Java ile başlasaydınız,

02:25:06.760 --> 02:25:09.700
büyük ihtimalle daha ne bileyim,

02:25:09.920 --> 02:25:11.380
daha kolay ilerlerdiniz,

02:25:11.600 --> 02:25:13.520
daha hızlı giderdiniz.

02:25:13.520 --> 02:25:16.820
Belki zorlandığınız yerler daha az olurdu.

02:25:17.680 --> 02:25:17.900
Evet.

02:25:18.760 --> 02:25:22.080
Secure Code Review ile ilgili neler önerebilirsiniz?

02:25:22.300 --> 02:25:24.580
Onunla ilgili kitapları da paylaşabilir misiniz?

02:25:25.280 --> 02:25:27.460
Arkadaşlar şimdi bu Code Review konusu da,

02:25:27.560 --> 02:25:30.760
hatta ben bu ileri C++ kursuna,

02:25:30.860 --> 02:25:31.840
iyi ki hatırlattınız,

02:25:32.520 --> 02:25:33.320
onu da alacağım.

02:25:33.540 --> 02:25:37.800
Yani 3-4 tane projeyi Code Review yapacağım,

02:25:37.800 --> 02:25:39.700
arkadaşlarla birlikte canlı olarak.

02:25:40.380 --> 02:25:43.060
Yani burada bu neden kötü,

02:25:43.160 --> 02:25:44.000
bu neden iyi?

02:25:45.120 --> 02:25:47.960
Onları kursa eklemeyi düşünüyorum.

02:25:48.680 --> 02:25:50.040
Alihan, emeğiniz büyük.

02:25:50.160 --> 02:25:52.620
Sizinle tanışmadan önce bir Türkçe kaynak olarak da,

02:25:52.680 --> 02:25:54.840
C++'da bu kadar ilerleyeceğimi bilemezdim.

02:25:54.940 --> 02:25:56.520
Teşekkür ederim, çok naziksiniz.

02:25:57.180 --> 02:25:59.200
Evet, bu Code Review'yu,

02:25:59.200 --> 02:26:03.680
C++, ileri C++ kursuna ekleyelim.

02:26:03.680 --> 02:26:07.080
Arkadaşlar çünkü gerçekten benim gözlemim şu,

02:26:07.360 --> 02:26:09.940
ben şimdi hem Türkiye'de hem yurt dışında

02:26:09.940 --> 02:26:13.460
bazı şirketlere Code Review hizmeti de veriyorum.

02:26:13.860 --> 02:26:16.280
Şu anda azaldı biraz ama geçmişte çok verdim.

02:26:17.100 --> 02:26:22.620
Yani üretimde böyle kullanıcı gözüyle baktığınızda

02:26:22.620 --> 02:26:24.880
dehşet verici projeler,

02:26:25.200 --> 02:26:28.160
neler yapıyor bu program falan dediğiniz projelerin

02:26:28.160 --> 02:26:29.700
kodlarına baktığınızda

02:26:29.700 --> 02:26:33.080
kod kalitesinin çok iyi olmadığını görüyorsunuz.

02:26:33.680 --> 02:26:36.960
Gerçekten, mesela şimdi ben firma ismi de vermeyeyim.

02:26:37.040 --> 02:26:39.760
Bir firmanın kodlarına bakıyoruz.

02:26:40.380 --> 02:26:45.540
Ya yapay zekayla görüntü işlemeyi öyle bir birleştirmişler ki,

02:26:45.800 --> 02:26:49.080
zaten ekipte çalışanların hepsi

02:26:49.080 --> 02:26:52.080
uzmanlığı yapay zeka olan kişiler.

02:26:52.080 --> 02:26:55.620
Yani C++ birinci bir şeyleri değil, ne diyelim.

02:26:56.300 --> 02:26:58.240
Birinci bir uzmanlık alanları değil.

02:26:58.940 --> 02:26:59.900
Ya program çalışıyor.

02:26:59.900 --> 02:27:04.680
Çalışan programa baksanız gerçekten böyle hayran oluyorsunuz.

02:27:04.740 --> 02:27:06.240
Ya görüntüyü yakalıyor,

02:27:06.460 --> 02:27:08.280
oradan yapay zekayı kullanıyor,

02:27:08.440 --> 02:27:09.740
analiz yapıyor vesaire.

02:27:10.640 --> 02:27:14.600
Ama koda baktığınızda kodlar o kadar kötü C++ kodu ki,

02:27:15.560 --> 02:27:20.260
e şimdi üretimde C++'ı böyle kullananlar çoğunlukta.

02:27:20.260 --> 02:27:22.260
Yani sonuç odaklı.

02:27:22.820 --> 02:27:24.960
Ben kısa sürede işimi bitireyim,

02:27:25.580 --> 02:27:26.900
çalışan bir ürün olsun,

02:27:27.200 --> 02:27:28.940
müşteriye zamanında yetişsin.

02:27:29.540 --> 02:27:31.100
Ama ondan sonraki süreç,

02:27:31.240 --> 02:27:33.740
tabii biraz problemli olacak.

02:27:33.940 --> 02:27:36.320
O kodlara bir ekleme yapmak istediğinizde,

02:27:36.840 --> 02:27:39.360
orada bug aradığınızda falan işiniz çok zor olacak.

02:27:39.480 --> 02:27:43.080
O da başlangıçta kişilerin birinci kaygısı olmuyor.

02:27:43.080 --> 02:27:45.880
Tabii ki çok düzgün, çok iyi,

02:27:46.040 --> 02:27:48.260
kaliteli kod yazan firmalar da çok.

02:27:48.920 --> 02:27:52.460
Ama ortalama biraz kalite düşüktüğü tarafında.

02:27:53.240 --> 02:27:55.440
Çünkü C++'ı da işte görüyorsunuz,

02:27:55.500 --> 02:27:57.800
o kadar araç, o kadar fazla,

02:27:58.440 --> 02:27:59.500
kütüphane öğesi,

02:28:00.360 --> 02:28:03.660
farklı programlama paradigmaları bir arada kullanılıyor.

02:28:04.100 --> 02:28:05.500
Fonksiyonel programlama,

02:28:05.600 --> 02:28:07.000
nesne yönelimli programlama,

02:28:07.120 --> 02:28:08.240
jenerik programlama.

02:28:08.240 --> 02:28:13.440
Dolayısıyla bütün bunları zaten öğrenmek bir zaman oluyor.

02:28:13.660 --> 02:28:16.020
Standart kütüphaneyi öğrenmek bir zaman oluyor.

02:28:16.740 --> 02:28:19.460
Ve insanlar niye de çok fazla zaman ayırmıyorlar?

02:28:20.220 --> 02:28:21.060
İyi kod nedir?

02:28:21.160 --> 02:28:22.140
Kötü kod nedir?

02:28:22.800 --> 02:28:24.940
Önemli olan işini görmesi.

02:28:25.220 --> 02:28:26.620
Bu anlayış çok yaygın.

02:28:26.800 --> 02:28:30.960
Ama tabii bu anlayışın hakim olmadığı firmalarda var.

02:28:31.920 --> 02:28:34.620
Evet arkadaşlar bugün 10 dakika erken bitireceğim.

02:28:34.620 --> 02:28:35.880
Deniz Akkuş.

02:28:36.380 --> 02:28:37.920
İnsan olarak çok şık birisiniz.

02:28:37.920 --> 02:28:39.140
Ben çok teşekkür ediyorum.

02:28:39.280 --> 02:28:40.780
4-5 ders kaçırmışımdır.

02:28:40.940 --> 02:28:45.780
Ama her dersinize zevkle ve canlı izletebilecek yetkinlikte

02:28:45.780 --> 02:28:47.360
ve yetkinlikte biri olduğunu düşünüyorum.

02:28:47.460 --> 02:28:48.100
Teşekkür ederim.

02:28:49.120 --> 02:28:52.320
Arkadaşlar nazik sözleriniz için çok teşekkür ediyorum.

02:28:52.560 --> 02:28:53.560
Bir soru daha var.

02:28:53.680 --> 02:28:54.740
Onu da cevap vereyim.

02:28:55.440 --> 02:28:56.420
Ona da cevap vereyim.

02:28:59.180 --> 02:29:00.340
Soruyu okumuyorum.

02:29:00.480 --> 02:29:01.440
Soru biraz uzun.

02:29:01.440 --> 02:29:05.340
Ama zaten cevabımı verirken sorunun ne olduğu anlaşılacak.

02:29:06.020 --> 02:29:06.760
Şimdi arkadaşlar,

02:29:06.760 --> 02:29:10.000
üretimde en önemli konulardan biri de

02:29:10.000 --> 02:29:13.360
üretimde çalışan kişi açısından bakarsak tool'lar.

02:29:14.620 --> 02:29:18.780
Fakat tool'ları ben genel olarak C++ kurslarına almıyorum.

02:29:18.980 --> 02:29:20.160
İki nedenden almıyorum.

02:29:20.920 --> 02:29:23.800
Bir, arkadaşlar çok fazla zaman gidiyor.

02:29:24.200 --> 02:29:26.840
Bir de tool anlatmayı ben sevmiyorum.

02:29:26.980 --> 02:29:28.960
Yani bana uygun bir konu değil.

02:29:28.960 --> 02:29:36.920
Yani mesela şimdi bazen arkadaşlar rica ediyor C kursunda bu Visual Studio ID'sini anlatır mısın?

02:29:37.060 --> 02:29:44.500
Başkasının yazdığı, geliştirdiği programın anlatmak bana çok iyi bir fikir gelmiyor.

02:29:44.620 --> 02:29:46.360
Bir de zaten bu seviyeye gelmiş arkadaşlar.

02:29:46.360 --> 02:29:50.220
Bu tool'ları kendileri de öğrenebiliyorlar.

02:29:50.220 --> 02:29:52.140
Belki şu eklenebilir.

02:29:52.780 --> 02:29:59.520
Yani bir tool'un kendisini öğretmek yerine genel olarak tool kategorileri neler yapıyor?

02:29:59.520 --> 02:30:00.960
Onların önemi ne?

02:30:01.620 --> 02:30:03.640
Yani mesela sanitizer ne demek?

02:30:04.340 --> 02:30:06.840
Hangi sanitizer olduğundan bağımsız olarak?

02:30:07.580 --> 02:30:12.180
Efendim ya da statik kod analizi dediğimiz programlar ne yapıyor?

02:30:12.860 --> 02:30:15.220
Profiler programlar ne yapıyor?

02:30:15.340 --> 02:30:17.260
Üretimde neden önemli?

02:30:17.460 --> 02:30:19.640
Build tool'ları neden önemli?

02:30:19.640 --> 02:30:27.320
Vesaire ama şimdilik tool'ların kendisini anlatmak çok bana uygun bir iş değil.

02:30:27.500 --> 02:30:28.660
Belki gerekiyor olabilir.

02:30:29.340 --> 02:30:30.640
Hatta şunu bile düşünüyorum.

02:30:31.280 --> 02:30:36.980
Bundan sonraki kursları bu tool'ları da iyi anlatan başka bir arkadaşımdan rica etsem

02:30:36.980 --> 02:30:47.040
böyle efendim Google testi, şunu bunu, sanitizer'ları, Walgreens'i, şunu bunu anlatsa iyi olur aslında.

02:30:47.040 --> 02:30:55.780
Ama benim burada birinci tercihim önce C++ dili, programlama tarafı, iyi kod, kötü kod tarafı ki

02:30:55.780 --> 02:31:00.220
ileri C++ kursunda onlara daha fazla değineceğim.

02:31:01.080 --> 02:31:04.600
Peki o zaman ben de kursa katılan herkese çok teşekkür ediyorum.

02:31:04.720 --> 02:31:08.860
Dediğim gibi halen Telegram grubundan sorularınızı sorabilirsiniz.

02:31:09.500 --> 02:31:12.260
Arkadaşlar bazen mesajları kaçırıyorum.

02:31:12.260 --> 02:31:16.400
İnsanlık hali çok sizin gibi ben de çok yoğun çalıştığım için.

02:31:17.040 --> 02:31:19.580
Arkadaşlar da alınganlık gösteriyorlar.

02:31:20.460 --> 02:31:24.020
Yani sanki ben kasti olarak cevap vermemişim gibi.

02:31:24.660 --> 02:31:27.780
O yüzden derslerde en az bir iki kere söylüyorum.

02:31:28.380 --> 02:31:35.780
Eğer bana bir mesaj yazmışsanız Telegram üstünde WhatsApp'tan ya da LinkedIn'den bir cevap alamamışsanız

02:31:35.780 --> 02:31:41.080
lütfen lütfen lütfen lütfen bir daha hani ayıp olur mu falan diye de düşünmeyin.

02:31:41.200 --> 02:31:42.020
Tekrar yazın.

02:31:42.480 --> 02:31:48.440
Yani belirli bir süre, makul bir süre içinde cevap vermemişsem onu atlamışım demektir.

02:31:49.140 --> 02:31:54.560
Dolayısıyla tekrar bana hatırlatırsanız o zaman mutlaka cevap veririm.

02:31:55.440 --> 02:31:55.760
Evet.

02:31:55.760 --> 02:31:58.080
Herkese iyi akşamlar diliyorum.

02:31:58.420 --> 02:32:00.860
Hayırlı Ramazanlar diliyorum arkadaşlar.

02:32:01.740 --> 02:32:05.900
İnşallah bazı arkadaşlarla belki ileri C++ kursunda da birlikte olacağız.

02:32:06.480 --> 02:32:12.100
Eğer bu 200 saat sizi yeteri kadar yormadıysa o zaman orada görüşeceğiz.

02:32:12.640 --> 02:32:13.240
Hoşçakalın.

02:32:13.240 --> 02:32:43.220
Altyazı M.K.

