WEBVTT

00:00.000 --> 00:10.320
İyi akşamlar arkadaşlar. 30 Ekim 2024 çarşamba günü 36. ders günümüz saat 19.31.

00:11.880 --> 00:16.600
Pazartesi gününkü ders için özür diliyorum. Hiç beklenmedik bir şekilde olaylar gelişti.

00:16.700 --> 00:19.940
Son anda iptal etmek zorunda kaldım. Kusura bakmayın.

00:21.160 --> 00:23.740
Dersimize başlayacağız. Kaldığınız yerden devam edeceğiz.

00:23.860 --> 00:27.800
Ses ya da görüntüde problem olursa bildirin lütfen değerler arkadaşlar.

00:27.800 --> 00:33.680
Şimdi efendim nerede kaldığımızı şöyle bir hatırlayalım.

00:34.740 --> 00:40.240
Konu başlığımız halen templitler, halen templitler konusunda devam ediyoruz.

00:41.020 --> 00:51.280
Jenerik programlama paradigmasında modern C++'la dile eklenen en önemli araçlardan biri variatik templitler.

00:51.280 --> 00:58.420
Her ne kadar kullanılan terim bu olsa da, konuya hemen kaldığımız yerden bir giriş yapalım.

00:58.560 --> 01:05.000
Burada kast edilen templitlerin parametrelerinin bir paket şeklinde olması.

01:06.040 --> 01:07.200
Buna ne deniyordu?

01:07.560 --> 01:09.500
Templit parametre paketi.

01:09.500 --> 01:20.980
Bir template parametre paketi küre ilişkin, type'a ilişkin yani type parametre pak,

01:22.260 --> 01:28.440
değeri ilişkin non-type parametre pak ya da template-templit parametre pak olabilir.

01:28.440 --> 01:36.180
Yani her template parametre tipi için bir parametre paketi oluşturmak mümkün.

01:36.820 --> 01:38.040
Sandbox nasıldı?

01:39.320 --> 01:47.080
Type name ya da class anahtar sözcüğünden sonra elipsiz ve pakete verilen isim.

01:47.080 --> 02:04.600
Eğer burada type name ya da class anahtar sözcüğünü kullanırsanız, type parametre pak yine eğer bir tür kullanırsanız örneğin int bu non-type parametre pak.

02:05.100 --> 02:06.840
Ne demek bir parametre paketi?

02:07.960 --> 02:15.340
Yani bu parametre paketinde sıfır dahil en tane template parametresi olabilir.

02:15.340 --> 02:21.900
Örneğin buraya class anahtar sözcüğünü yazarsam, ilk örneğe geri dönelim.

02:22.660 --> 02:26.140
Bu bir sınıf şablonu olsun, class, my class.

02:27.040 --> 02:36.160
Şimdi my class sınıf şablonundan variadik parametre paketine sahip olduğu için, parametre paketine sahip olduğu için

02:36.160 --> 02:42.520
böyle bir sınıfta oluşturabilirim, böyle bir sınıfta oluşturabilirim.

02:42.520 --> 02:48.700
Efendim buraya en tane tür argümanı yazabilirim.

02:48.980 --> 02:58.580
Eğer örneğin şöyle bir tür oluşturursam, int double long, tabii ki bunlar herhangi bir tür argümanı olabilir.

02:59.800 --> 03:04.160
Bu durumda pakette üç tane parametre var demek.

03:05.760 --> 03:10.580
Parametre paketinde üç tane template tür parametresi var demek.

03:10.580 --> 03:21.580
İşte değerli arkadaşlar, bu parametre paketindeki türlere erişmek için bir takım ifadeler kullanıyorduk.

03:22.260 --> 03:25.920
Bunlara expansion deniyor dedi.

03:26.360 --> 03:27.580
Tam da zaten orada kalmıştık.

03:28.660 --> 03:30.300
Yalnız bir şeye dikkat.

03:30.300 --> 03:41.740
Şimdi parametre paketinin olması, template parametre paketinin olması sınıf şablonu ya da değişken şablonu ya da fonksiyon şablonu olmasıyla ilgili değil.

03:41.740 --> 03:45.860
Örneğin bu bir fonksiyon şablonu da olabilir.

03:46.660 --> 03:55.240
Fonksiyon şablonu olduğunda eğer template parametre paketinden sonra bu kez elipsiz token'a gelirse,

03:56.460 --> 04:02.020
arkadaşlar bu durumda bu da fonksiyonun parametre paketi.

04:03.300 --> 04:07.740
Template parametre paketi başka, fonksiyon parametre paketi başka.

04:07.740 --> 04:13.380
Başka, birbiriyle ilişkili ama ikisi aynı olmak zorunda değil.

04:14.140 --> 04:17.700
Mesela ben bu fonksiyona çağrı yaparken,

04:18.620 --> 04:21.320
yine diğer fonksiyon şablonlarında olduğu gibi

04:21.320 --> 04:29.060
explicit template argümanı kullanabilirim ya da didakçından, tür çıkarımından faydalanabilirim.

04:29.060 --> 04:44.020
Örneğin funk'ı bu şekilde çağırırsam, 1, 4, 7, 2.3, fonksiyona dört tane argüman gönderdiğim için fonksiyonun dört tane parametre değişkeni olacak.

04:45.160 --> 04:46.980
Her biri için çıkarım yapılacak.

04:47.980 --> 04:52.020
Template parametre paketinde de, tür parametre paketinde de dört tür olacak.

04:52.020 --> 04:59.620
Yani örneğin fonksiyonu böyle çağırmak, aslında funk'ı hangi specialization'ı çağırmak demek?

04:59.920 --> 05:09.340
Funk, int, int, efendim üçüncüsü yine int, dördüncüsü double.

05:10.820 --> 05:17.140
Derleyicinin oluşturduğu fonksiyonunda doğal olarak dört tane parametre değişkeni var dedik değil mi?

05:17.140 --> 05:27.820
Yani kafanızda canlandırın, derleyicinin oluşturduğu specialization, instantiation daha doğrusu asla nasıl bir fonksiyon olacak?

05:28.660 --> 05:40.540
Sanki int türden birinci parametre, int türden ikinci parametre, int türden üçüncü parametre ve double türden dördüncü parametre.

05:40.540 --> 05:54.940
Şimdi işte bütün mesele, özellikle fonksiyon çablonlarında bunun bize sağlayacağı olanaklar ve bu parametre değişkenlerinin nasıl kullanılacağı üstünde epey bir vakit harcayacağız.

05:55.900 --> 06:01.260
Arkadaşlar baştan söyledim, şimdi template'ler o kadar geniş bir konu ki anlat anlat bitmez.

06:01.260 --> 06:08.880
Biz önce en önemli sentaks özelliklerinden başlayarak yavaş yavaş detaya gidiyoruz.

06:09.120 --> 06:14.260
Yani daha çok da detaya gitmiş değiliz kursun süresi göz önüne alındığında.

06:15.280 --> 06:19.300
Arkadaşlar birden fazla template parametre paketi olabilir mi?

06:20.100 --> 06:22.280
Geçen bir arkadaşım da bu soruyu sormuştu.

06:22.980 --> 06:25.680
Olabilir, yani teknik olarak olamaz değil.

06:27.040 --> 06:30.720
Belirli template'lerde sorunun cevabı net olamaz.

06:30.720 --> 06:33.200
Örneğin sınıf şablonlarında.

06:33.300 --> 06:36.720
Örneğin şöyle bir sınıf şablonu oluşturmak isteseniz.

06:37.380 --> 06:44.520
Diyelim ki template, type name, efendim, A.

06:46.280 --> 06:48.340
Büyük harf genelde tercih ediliyor.

06:48.500 --> 06:53.120
Evet, type name, B.

06:53.120 --> 07:00.900
Şimdi bu zaten doğrudan template'i oluştururken sentaks hatası.

07:01.860 --> 07:04.520
Hemen görüyorsunuz yardımcı program altını çizdi.

07:06.000 --> 07:14.820
İki, yine sınıf şablonları için en sondaki template parametresi, parametre paketi olabilir.

07:15.000 --> 07:16.560
Yani şunu da yazamam açıkçası.

07:16.560 --> 07:23.000
Fakat fonksiyon şablonlarında biraz daha esneklik var.

07:23.800 --> 07:29.040
Yani fonksiyon şablonlarında ne parametre paketi bir tane olmak zorunda,

07:29.040 --> 07:35.760
ne de parametre paketi en son parametre olmak zorunda.

07:35.760 --> 07:48.120
tamamen duruma göre eğer template parametre paketindeki parametrelere karşılık gelen argümanlar anlaşılıyorsa,

07:48.460 --> 07:49.320
müsaade ediliyor.

07:50.780 --> 07:52.580
Bir örnek vermek gerekirse,

07:52.580 --> 08:05.580
Mesela bakınız, template type name yine x, type name y,

08:06.300 --> 08:08.660
tabi klas anahtar sözcüğünü de kullanabilirdim,

08:09.940 --> 08:11.660
void bu.

08:13.260 --> 08:16.420
Bakın şu anda aldığını çizmedi, henüz bir sentaks hatası yok.

08:16.420 --> 08:24.100
x, xarx, şöyle yazalım.

08:27.100 --> 08:35.300
Örneğin int, int, y, yarx.

08:37.300 --> 08:44.880
Halen yardımcı aracın bir sentaks hatası işaretlemediğini görüyorsunuz.

08:44.880 --> 08:49.020
Hemen bu arada size of operatörünü de hatırlayalım.

08:49.160 --> 08:50.820
Yeni size of operatörümüzü.

08:52.240 --> 08:56.140
Eğer size of anahtar sözcüğünden sonra

08:56.140 --> 08:59.020
ellipsis token'ı gelirse,

09:00.340 --> 09:06.220
parantez içinde template parametre paketini ya da fonksiyon parametre paketinin ismini yazarsam,

09:06.220 --> 09:15.160
son by time sabiti olarak pakette kaç argüman olduğu bilgisini

09:15.160 --> 09:20.220
stot size t türünden bir değer olarak elde ediyorum.

09:20.220 --> 09:36.340
Mesela bakınız, stot cout size of x, şöyle yazalım, eşittir size of x.

09:37.000 --> 09:40.900
Bunu kod içinde de kullanmaya yaygın, çok örnek yapacağız.

09:40.900 --> 09:48.700
Yeni aynı şekilde size of y, size of y.

09:49.340 --> 09:55.180
Template kodun derlenmesinde bir sentaks hatası olmadığını görüyorsunuz.

09:55.180 --> 10:02.000
Şimdi birinci parametre, template parametre paketi olduğu için

10:02.000 --> 10:07.180
örneğin ekspresit olarak argümanları şöyle yazarsam,

10:08.760 --> 10:17.120
int, double, int, arkadaşlar izleyin.

10:17.940 --> 10:22.120
Zaten bu argümanlar birinci parametre paketine gidecek.

10:22.240 --> 10:23.600
Yani burada illegal bir şey yok.

10:23.600 --> 10:33.240
Fonksiyon çağrı operatörü, örneğin bir, iki, üç, takip edin,

10:34.060 --> 10:40.140
dört, beş, altı, yedi, sekiz, dokuz, hadi bu kadar olsun.

10:41.760 --> 10:46.420
Şimdi bu durumda, şunlar birinci parametre paketine gidecek.

10:47.540 --> 10:51.420
Dolayısıyla fonksiyonun ilk üç parametresine geçinen değerler,

10:51.420 --> 10:56.940
bu da fonksiyonun ilk üç parametresinin int, double, int olduğu anlamına geliyor.

10:58.060 --> 11:01.740
Bu durumda fonksiyonun kodundaki şu sabit,

11:02.560 --> 11:03.720
üç sabit olacak.

11:04.980 --> 11:06.420
Diğer iki parametreye,

11:07.480 --> 11:10.420
yani birinci parametre paketinden sonra gelen parametrelere,

11:11.880 --> 11:14.260
sırasıyla onlara beş ve beş değerleri gelecek.

11:14.260 --> 11:17.080
Geriye kalanlar da ikinci pakete gidecek.

11:18.020 --> 11:19.800
Eğer bir yanlışlık yapmadıysa,

11:20.840 --> 11:23.020
runtime'da gösterelim arkadaşlar.

11:23.260 --> 11:23.580
Bakın,

11:24.580 --> 11:26.300
birinci parametre paketinde,

11:26.580 --> 11:28.140
üç tane parametre var.

11:28.320 --> 11:29.780
İkinci parametre paketinde,

11:30.400 --> 11:31.880
dört tane parametre var.

11:32.740 --> 11:35.460
Hatta burada şöyle bir kural dahi var arkadaşlar.

11:35.460 --> 11:42.000
Şimdi fonksiyon şablonları söz konusu olduğu zaman,

11:42.140 --> 11:46.040
variyadik parametre paketi ikiye ayırıyor standart.

11:46.360 --> 11:48.900
Trailing ya da non-trailing diye.

11:49.820 --> 11:50.200
Şimdi,

11:50.780 --> 11:51.780
trailing olması,

11:52.340 --> 11:54.200
en son parametre olması demek.

11:55.460 --> 11:57.460
Ama non-trailing olması,

11:57.880 --> 12:00.040
en son parametre olmaması demek.

12:00.040 --> 12:04.780
Fonksiyona çağrı yaptığımız zaman,

12:06.600 --> 12:09.320
eğer eksplisit argüman kullanmazsak,

12:09.580 --> 12:11.500
örneğin çağrıyı şöyle yaparsam,

12:12.940 --> 12:13.360
arkadaşlar,

12:16.900 --> 12:17.620
bu durumda,

12:18.100 --> 12:20.680
birinci parametre paketi boş kabul ediliyor.

12:22.180 --> 12:22.940
Argümanlar,

12:23.180 --> 12:25.160
ondan sonraki öğelere dağıtılıyor.

12:25.560 --> 12:25.940
Bu da,

12:27.440 --> 12:29.020
standartın koyduğu bir kural.

12:29.020 --> 12:32.160
Dolayısıyla arkadaşımız sorusunun cevabı,

12:32.500 --> 12:32.860
evet,

12:33.580 --> 12:35.420
duruma göre bu örnekte olduğu gibi,

12:35.880 --> 12:38.420
birden fazla parametre paketi olabilir.

12:39.720 --> 12:40.860
Yalnız bir şeye dikkat,

12:41.120 --> 12:42.180
fonksiyon şablonlarına.

12:42.300 --> 12:42.740
Tabii bu,

12:43.220 --> 12:45.640
çok daha seyrek karşımıza çıkacak bir senaryo.

12:47.000 --> 12:47.840
Senaryoların,

12:48.080 --> 12:49.500
çok büyük çoğunluğunda,

12:51.160 --> 12:52.920
özellikle fonksiyon şablonlarında,

12:53.560 --> 12:54.360
sadece,

12:54.880 --> 12:57.640
bir tane parametre paketi olacak.

12:57.640 --> 12:59.480
Ama tabii fonksiyonun,

12:59.520 --> 13:02.580
birden fazla parametre paketi olabilir.

13:03.000 --> 13:05.020
Birden fazla parametresi olabilir.

13:05.840 --> 13:06.360
Mesela,

13:07.120 --> 13:08.860
şöyle kafamızı da canlandıralım.

13:11.120 --> 13:13.640
En çok karşımıza çıkacak senaryoları.

13:15.480 --> 13:16.460
Burada fonksiyonun,

13:16.540 --> 13:18.060
bir tane parametre paketi var.

13:19.620 --> 13:19.820
Ve,

13:21.260 --> 13:22.640
temput parametre paketi var,

13:22.740 --> 13:24.640
fonksiyonun da bir tane parametre paketi var.

13:24.840 --> 13:26.040
Ama örneğin şöyle de olabilir.

13:26.040 --> 13:28.400
Bu durumda,

13:28.600 --> 13:30.680
fonksiyonun iki parametresi var.

13:30.760 --> 13:32.580
Birincisi normal parametre,

13:32.660 --> 13:34.160
ikincisi parametre paketi.

13:35.820 --> 13:37.560
Hem put parametre sayısı da,

13:37.820 --> 13:38.880
bir daha fazla olabilir.

13:39.300 --> 13:39.820
Mesela,

13:40.520 --> 13:41.040
böyle olsaydı,

13:42.140 --> 13:42.640
arkadaşlar,

13:43.760 --> 13:44.040
P türünden,

13:44.880 --> 13:45.180
X,

13:45.560 --> 13:45.780
E,

13:45.860 --> 13:46.140
S,

13:46.380 --> 13:46.780
Arx,

13:47.420 --> 13:48.820
özellikle bu yapıya dikkat.

13:49.560 --> 13:49.880
Örneğin,

13:49.960 --> 13:52.040
ben bu fonksiyonu şöyle çağırdığımda,

13:52.040 --> 14:01.020
Fonksiyona gönderilen,

14:01.260 --> 14:02.760
hem birinci argüman için,

14:02.920 --> 14:04.300
hem de diğer argümanlar için,

14:04.400 --> 14:05.320
çıkarım yapılacak.

14:06.320 --> 14:07.120
Birinci argüman,

14:07.220 --> 14:09.720
fonksiyonun birinci parametresine gönderildiği için,

14:09.780 --> 14:10.720
o da birinci template,

14:10.940 --> 14:12.960
tür parametresinden olduğu için,

14:13.900 --> 14:15.580
P karşılığı kullanılan tür,

14:15.820 --> 14:16.400
int olacak.

14:16.400 --> 14:18.220
Ama geriye kalanlar,

14:18.960 --> 14:19.860
pakete gidecek.

14:20.720 --> 14:21.180
Bu durumda,

14:21.260 --> 14:22.640
template parametre paketinde,

14:22.780 --> 14:23.400
üç tane parametre,

14:24.960 --> 14:25.400
ve buna karşılık da,

14:26.120 --> 14:27.620
fonksiyonun üç ilave,

14:27.960 --> 14:29.140
parametre değişkeni,

14:29.380 --> 14:29.940
daha olacak.

14:31.020 --> 14:31.620
Arkadaşlar,

14:32.160 --> 14:33.500
bir şey daha göstermek istiyorum.

14:33.640 --> 14:33.940
Bakınız,

14:34.320 --> 14:36.400
geçen derslerden birinde göstermiştim.

14:37.160 --> 14:37.480
Şimdi,

14:38.620 --> 14:40.800
GCC derleyicisinde,

14:40.800 --> 14:43.480
bu makro,

14:44.160 --> 14:45.000
pretty function,

14:45.800 --> 14:47.480
visual studio'da,

14:47.580 --> 14:48.780
underscore underscore,

14:50.220 --> 14:50.660
func,

14:51.180 --> 14:52.560
signature'da.

14:53.720 --> 14:55.380
Şimdi bu makro,

14:55.860 --> 14:56.780
fonksiyonun,

14:57.440 --> 14:58.960
geri dönüş değeri dahil,

14:59.680 --> 15:01.800
parametrelerine de işaret eden,

15:02.100 --> 15:03.320
bir yazıya açılıyor.

15:04.320 --> 15:04.980
Yani örneğin,

15:04.980 --> 15:06.900
ben şöyle bir kod yazarsam,

15:07.820 --> 15:09.780
bazı konuları daha iyi anlamak için,

15:09.780 --> 15:10.720
arkadaşlar,

15:13.360 --> 15:14.900
derleyicinin oluşturduğu,

15:14.960 --> 15:16.180
instantiation'ın,

15:17.140 --> 15:18.580
nasıl bir fonksiyonu olduğunu,

15:19.380 --> 15:20.000
görebilirim.

15:20.120 --> 15:20.640
Bakın şimdi,

15:23.040 --> 15:23.700
izleyin,

15:24.240 --> 15:25.760
C declaration'ı görmeyin,

15:26.440 --> 15:26.960
foo'nun,

15:27.340 --> 15:28.260
int virgül,

15:28.420 --> 15:29.400
int virgül,

15:29.580 --> 15:30.720
char virgül,

15:31.420 --> 15:32.220
double açılımı.

15:33.160 --> 15:33.960
Bu durumda,

15:33.960 --> 15:35.240
birinci int,

15:35.460 --> 15:36.820
birinci parametre paketi,

15:37.400 --> 15:39.380
birinci template parametresi için,

15:39.780 --> 15:41.420
ve diğerleri,

15:41.760 --> 15:42.100
yani,

15:42.900 --> 15:44.100
int, char ve double,

15:44.880 --> 15:46.260
parametre paketine gidiyor.

15:47.020 --> 15:48.720
Yani bazı karmaşık durumların,

15:48.960 --> 15:50.520
üstesinden gelmek için,

15:51.340 --> 15:52.360
arka planda ne oluyor,

15:52.460 --> 15:53.280
bunu görmek için,

15:53.400 --> 15:55.240
ilave bir yazım kullanmıyorsanız,

15:56.240 --> 15:57.660
creative function,

15:57.880 --> 15:59.400
ya da funcic makrosunu,

15:59.760 --> 16:00.620
kullanabilirsiniz.

16:00.620 --> 16:02.860
Şimdi geldik,

16:03.480 --> 16:04.360
en kritik yere.

16:05.720 --> 16:06.420
Arkadaşlar,

16:07.100 --> 16:07.740
bu konunun,

16:08.180 --> 16:09.800
en kritik kısmı,

16:10.000 --> 16:10.680
İngilizce,

16:11.200 --> 16:12.600
tech expansion,

16:13.180 --> 16:13.840
dediğimiz,

16:14.200 --> 16:14.560
yapı.

16:17.400 --> 16:18.900
Tech expansion,

16:20.520 --> 16:22.120
paketin genişletilmesi,

16:22.480 --> 16:24.120
diye belki Türkçe'ye çevrilebilir.

16:24.120 --> 16:28.540
biraz kapa ama ben paketin patlatılması da diyorum,

16:28.680 --> 16:29.780
patlat paketi.

16:30.700 --> 16:31.280
Arkadaşlar,

16:31.880 --> 16:33.120
öyle bir ifade ki,

16:34.100 --> 16:34.700
derleyici,

16:35.100 --> 16:36.300
ilgili kontekste,

16:37.240 --> 16:39.380
belirli örüntülere uygun olarak,

16:39.380 --> 16:40.380
burada örüntüsü,

16:41.840 --> 16:43.000
sözcüğünde Türkçe,

16:43.280 --> 16:46.100
İngilizce pattern sözcüğünün karşılığı olarak kullanıyorum,

16:46.920 --> 16:49.360
virgüllerle ayrılan listeye dönüştürüyor.

16:49.360 --> 16:53.380
şimdilik şu parametreyi yok edelim,

16:54.080 --> 16:57.000
ve buradan tekrar başlayalım.

16:58.020 --> 16:58.740
Arkadaşlar,

16:59.980 --> 17:01.020
tech expansion'ı,

17:01.540 --> 17:03.280
template parametre paketi içinde,

17:04.140 --> 17:06.980
fonksiyon parametre paketi içinde kullanabilirsiniz.

17:08.280 --> 17:08.700
Eğer,

17:09.300 --> 17:10.920
template parametre paketinin,

17:11.820 --> 17:12.920
isminden sonra,

17:12.920 --> 17:15.320
bu sefer elipsizin yerine bakın,

17:16.300 --> 17:18.320
elipsiz token'ını koyarsanız,

17:18.320 --> 17:20.140
derleyici bunu,

17:21.620 --> 17:22.500
paketteki,

17:23.240 --> 17:23.900
sürülerin,

17:24.620 --> 17:25.860
isimlerini içeren,

17:26.200 --> 17:28.140
virgüllerle ayrılan bir listeye,

17:28.960 --> 17:29.840
çeviriyor.

17:30.380 --> 17:31.640
Yani bu ne demek?

17:32.660 --> 17:33.220
Örneğin,

17:33.480 --> 17:33.920
arkadaşlar,

17:34.960 --> 17:35.580
diyelim ki,

17:35.820 --> 17:37.460
henüz bizim tanışmadığımız,

17:38.420 --> 17:39.820
ama C++'ın,

17:40.240 --> 17:41.640
jenerik programlama tarafında,

17:41.640 --> 17:43.940
özellikle en sık kullanılan sınıflarından biri,

17:44.040 --> 17:45.640
sınıf şablonlarından biri olan,

17:46.400 --> 17:47.460
Google sınıfına bakın.

17:48.320 --> 17:49.260
Şimdi ben,

17:50.120 --> 17:51.040
bu tuple'ın,

17:51.620 --> 17:52.440
int,

17:52.780 --> 17:53.340
virgül,

17:53.560 --> 17:54.140
double,

17:54.500 --> 17:55.520
açılımı deseydim,

17:55.600 --> 17:55.900
bu arada,

17:56.600 --> 17:59.640
tuple'ın kendi site variyetlik parametre paketine sahip,

18:00.640 --> 18:01.980
tuple sınıf şablonunun,

18:02.980 --> 18:05.780
öyle bir instant station'ını oluşturacak giderleyici,

18:06.260 --> 18:07.260
parametre paketinde,

18:07.500 --> 18:08.380
iki tane türü var.

18:08.380 --> 18:10.120
ama şimdi bakınız,

18:10.120 --> 18:11.940
eğer ben şöyle yazarsam,

18:12.320 --> 18:12.700
es,

18:14.820 --> 18:15.360
burada,

18:16.100 --> 18:18.120
parametre paketindeki parametreler,

18:18.780 --> 18:19.040
int,

18:19.040 --> 18:19.280
double,

18:19.400 --> 18:19.920
long ise,

18:20.960 --> 18:22.120
derleyicinin oluşturduğu,

18:22.820 --> 18:23.900
fonksiyon kodunda,

18:24.240 --> 18:24.760
tuple'ın,

18:25.160 --> 18:25.440
int,

18:25.640 --> 18:26.000
double,

18:26.240 --> 18:27.100
long açılımı,

18:27.760 --> 18:28.600
söz konusu olacak.

18:28.600 --> 18:29.680
yani,

18:30.400 --> 18:31.460
parametre paketi,

18:31.600 --> 18:33.020
template parametre paketi,

18:34.020 --> 18:35.340
expand edildiğinde,

18:36.400 --> 18:38.020
parametre paketindeki,

18:38.380 --> 18:38.960
türler,

18:39.160 --> 18:40.740
ya da değerlerden oluşan,

18:41.580 --> 18:43.960
comma separated liste dönüşüyor.

18:43.960 --> 18:46.700
işte bu örneğin,

18:47.320 --> 18:48.440
başka bir template'in,

18:48.720 --> 18:51.680
explicit template argümanları olarak kullanılabilir.

18:52.880 --> 18:53.880
Yeri geldiğinde,

18:54.700 --> 18:57.120
ilk değer verme listesi olarak kullanılabilir.

18:58.480 --> 18:59.160
Arkadaşlar,

18:59.820 --> 19:01.880
avant sınıflarının listesi olabilir,

19:02.380 --> 19:03.360
olabilir de olabilir.

19:04.280 --> 19:05.520
Fakat daha da önemlisi,

19:05.520 --> 19:08.520
şimdi burayı biraz daha dikkatli izlemelisiniz,

19:09.960 --> 19:11.920
eğer parametre paketi,

19:11.920 --> 19:14.400
template parametre paketi değil de,

19:15.200 --> 19:16.980
fonksiyon parametre paketi,

19:18.220 --> 19:19.780
hack extension dediğimiz,

19:20.080 --> 19:20.760
örüntüye,

19:20.940 --> 19:23.420
ya da örüntülerden birine tabi tutulursa,

19:24.560 --> 19:26.660
bu da aslında derleyici tarafından,

19:27.000 --> 19:28.000
neye dönüştürülüyor?

19:28.420 --> 19:29.200
Buraya dikkat.

19:30.180 --> 19:31.380
Şimdi bu fonksiyon,

19:31.800 --> 19:32.900
parametre paketinde,

19:32.900 --> 19:34.620
üç tane parametre varsa,

19:35.400 --> 19:37.220
şimdi kafanızda canlandırmaya çalışın.

19:37.300 --> 19:38.820
Aslında fonksiyon şöyle değil mi?

19:39.580 --> 19:40.700
T1 türünden,

19:40.700 --> 19:41.980
E1 bir tür,

19:43.640 --> 19:44.660
parametre P1,

19:45.220 --> 19:46.280
P2 türünden,

19:46.640 --> 19:47.660
parametre P2,

19:48.460 --> 19:49.500
P3 türünden,

19:49.880 --> 19:50.780
parametre P3.

19:50.940 --> 19:51.320
Örneğin,

19:51.980 --> 19:53.400
template parametre paketinde,

19:53.840 --> 19:55.200
üç tane tür varsa,

19:56.180 --> 19:56.880
şimdi ben,

19:57.620 --> 19:58.040
eğer,

19:58.660 --> 19:59.680
çok iyi izliyorsunuz,

20:01.760 --> 20:04.840
template parametre paketini ekspant edersem,

20:05.480 --> 20:06.900
aslında o neye dönüşecek?

20:06.900 --> 20:07.780
E1,

20:08.020 --> 20:08.620
E2,

20:09.120 --> 20:09.680
P3,

20:10.360 --> 20:10.840
yukarı.

20:12.480 --> 20:13.280
E1,

20:14.280 --> 20:14.880
E2,

20:15.220 --> 20:15.800
E3,

20:15.900 --> 20:17.180
böyle bir listeye dönüşecek.

20:18.240 --> 20:18.680
Fakat,

20:19.740 --> 20:20.180
eğer,

20:20.560 --> 20:21.660
burada olduğu gibi,

20:22.800 --> 20:25.960
fonksiyon parametre paketini ekspant edersem,

20:26.900 --> 20:27.820
o zaman da bu,

20:28.460 --> 20:28.900
aslında,

20:29.360 --> 20:30.860
nasıl bir listeye dönüştürülecek?

20:30.860 --> 20:31.900
P1,

20:32.260 --> 20:32.800
P2,

20:33.140 --> 20:33.680
P3.

20:35.180 --> 20:36.720
Buraya kadar takip edebildik mi?

20:37.700 --> 20:38.460
Dolayısıyla,

20:39.480 --> 20:42.880
virgüllerle ayrılan liste kullanılan birçok kontekste,

20:43.880 --> 20:44.780
ne yapabiliyorum?

20:45.100 --> 20:48.260
Parametre paketinin ekspant edilmiş halini,

20:48.680 --> 20:49.540
kullanabiliyorum.

20:50.200 --> 20:51.740
Mesela birkaç tane örnek vereyim.

20:52.620 --> 20:53.660
Herkes de katkı izliyor.

20:55.080 --> 20:56.620
Altının çizmesine de bakmayın.

20:56.620 --> 20:57.260
Örneğin,

20:57.700 --> 20:59.880
bari isimli bir fonksiyonu olsaydı,

21:00.860 --> 21:04.480
ve ben bari bu şekilde çağırsaydım,

21:05.800 --> 21:07.540
bu durumda bar fonksiyonla,

21:07.620 --> 21:10.220
bu arada barın kendisi de bir fonksiyon şablonu olabilir.

21:11.400 --> 21:11.960
Aslında,

21:12.700 --> 21:15.360
kimin değerlerini göndermiş olacaktım olsam,

21:16.320 --> 21:17.200
fonksiyonun,

21:17.500 --> 21:18.840
parametre değişkeninin,

21:19.140 --> 21:21.720
değişkenlerinin değerlerini göndermiş olacaktım.

21:22.320 --> 21:23.160
Burayı anladık mı?

21:23.900 --> 21:24.900
Evet, bravo çağrı.

21:24.960 --> 21:25.280
P1,

21:25.360 --> 21:25.680
P2,

21:25.680 --> 21:26.080
P3.

21:26.660 --> 21:27.940
Yalnız burası,

21:28.800 --> 21:30.280
biraz daha karmaşık.

21:30.400 --> 21:30.640
Neden?

21:30.860 --> 21:32.880
Pek Expansion,

21:33.620 --> 21:34.100
arkadaşlar,

21:34.480 --> 21:35.620
bir ne de olabilir?

21:36.480 --> 21:38.360
Daha uzun bir örüntü de olabilir.

21:39.000 --> 21:39.300
Mesela,

21:39.400 --> 21:40.800
paternin kendisinde,

21:41.460 --> 21:43.180
adres operatörü olsaydı,

21:43.960 --> 21:44.800
bu sefer de,

21:45.040 --> 21:46.480
derleyici bunu neye dönüştürecekti?

21:48.280 --> 21:48.920
Mehmet Can,

21:49.320 --> 21:50.360
şuna dönüştürecekti.

21:50.480 --> 21:50.840
Bar,

21:51.880 --> 21:52.520
diyelim ki,

21:52.700 --> 21:54.360
fonksiyonun birinci parametresi,

21:54.500 --> 21:55.380
adres P1,

21:56.180 --> 21:57.700
fonksiyonun ikinci parametresi,

21:57.780 --> 21:58.740
adres P2,

21:58.740 --> 22:00.940
üçüncü parametresi,

22:01.000 --> 22:01.640
adres P3,

22:01.720 --> 22:04.080
bu sefer de böyle bir listeye dönüştürecekti.

22:04.820 --> 22:05.900
Takip edebiliyor muyuz?

22:05.900 --> 22:07.040
Ama,

22:07.040 --> 22:09.040
şimdi bakın özellikle arkadaşlar,

22:09.520 --> 22:09.760
bu,

22:11.360 --> 22:11.840
Arx,

22:16.400 --> 22:18.160
burada,

22:18.780 --> 22:19.820
dikkat ederseniz,

22:20.080 --> 22:20.780
Elipsis,

22:21.160 --> 22:22.080
Arx,

22:22.760 --> 22:24.800
parametre paketi ismini izlemiyor.

22:25.640 --> 22:26.340
Bunu izliyor.

22:26.340 --> 22:27.800
Dolayısıyla,

22:27.940 --> 22:28.160
burada,

22:28.160 --> 22:29.800
Expansion nasıl yapılacak,

22:29.900 --> 22:30.980
tahmin edebilir misiniz?

22:31.520 --> 22:33.080
Zaten birkaç tane örnek görünce,

22:33.180 --> 22:34.960
hepsini tahmin etmeniz çok zor olmuyor.

22:35.740 --> 22:37.100
Aslında şuna dönüştürecek,

22:37.840 --> 22:38.300
Bar'a,

22:38.740 --> 22:39.680
argüman olarak,

22:39.680 --> 22:41.460
Fu P1,

22:42.780 --> 22:43.340
virgül,

22:43.900 --> 22:44.960
Fu P2,

22:45.900 --> 22:46.500
virgül,

22:46.940 --> 22:47.880
Fu P3.

22:48.660 --> 22:49.520
Yani aslında,

22:50.060 --> 22:51.100
Fu fonksiyonuna,

22:51.820 --> 22:52.780
gönderilen,

22:53.580 --> 22:55.420
bizim fonksiyonumuzun,

22:55.780 --> 22:56.180
arkadaşlar,

22:56.460 --> 22:57.140
Fu olmasın,

22:57.220 --> 22:57.520
Bar'a,

22:57.520 --> 22:58.920
şununla barışmasın,

22:59.080 --> 23:00.220
baz olsun.

23:01.140 --> 23:01.380
Evet,

23:02.000 --> 23:02.460
bu durumda,

23:02.560 --> 23:03.580
Bar fonksiyonu,

23:03.740 --> 23:05.060
Fu fonksiyonundan,

23:05.700 --> 23:07.400
Fu fonksiyonuna yapılan çağrılardan,

23:07.400 --> 23:08.020
elde edilen,

23:08.440 --> 23:09.700
geri dönüş değerleriyle,

23:10.300 --> 23:10.840
çağrılacak.

23:11.320 --> 23:11.820
Şimdi ben,

23:12.300 --> 23:13.260
Hack Expansion'a,

23:14.040 --> 23:15.320
birkaç tane örnek vereceğim.

23:15.540 --> 23:15.720
Ama,

23:15.920 --> 23:16.540
çok sayıda,

23:16.820 --> 23:17.220
örnek,

23:17.620 --> 23:19.200
üstünden geçebilmemiz için,

23:19.380 --> 23:20.680
kodları tek tek yazmam,

23:21.360 --> 23:22.420
çok iyi bir fikir olmaz.

23:22.640 --> 23:23.040
O yüzden,

23:23.540 --> 23:24.960
küçük küçük açıklamalarla,

23:25.680 --> 23:26.520
yazdığım kodları,

23:26.580 --> 23:27.920
buraya yapıştıracağım.

23:28.660 --> 23:29.160
Arkadaşlar,

23:29.580 --> 23:29.800
ama,

23:30.260 --> 23:31.780
biraz sabırlı olmamız gerekiyor.

23:32.400 --> 23:32.880
İzleyin.

23:33.640 --> 23:34.080
Şimdi,

23:35.120 --> 23:36.200
önce buraya bir bakalım,

23:36.200 --> 23:37.700
sevgili arkadaşlar.

23:38.800 --> 23:39.000
Ve,

23:39.300 --> 23:39.660
burada,

23:40.240 --> 23:41.320
neler görüyoruz?

23:41.580 --> 23:41.800
Bir,

23:42.020 --> 23:42.520
konuşalım.

23:43.820 --> 23:44.280
Bu arada,

23:45.960 --> 23:46.280
evet,

23:46.420 --> 23:48.680
C++ 17'ye almışız en son,

23:48.880 --> 23:49.320
tekrar,

23:49.680 --> 23:50.380
düzeltelim.

23:51.260 --> 23:51.520
Şimdi,

23:52.020 --> 23:52.600
soru bir.

23:53.040 --> 23:53.340
Bu ne?

23:54.340 --> 23:54.580
Bu,

23:54.720 --> 23:56.620
C++ 20 ile gelen,

23:58.620 --> 24:00.300
Abbreviated Template Syntax.

24:00.920 --> 24:01.840
Eğer bu,

24:02.340 --> 24:03.640
kafanızı karıştırıyorsa,

24:03.640 --> 24:04.560
o zaman,

24:04.880 --> 24:05.920
şöyle de yazabilirim.

24:05.920 --> 24:07.040
böyle yazmakla,

24:08.720 --> 24:09.220
PS,

24:09.820 --> 24:11.520
PS,

24:11.880 --> 24:12.300
ARX,

24:12.900 --> 24:13.380
aynı şey.

24:14.300 --> 24:14.640
O zaman,

24:14.840 --> 24:16.680
şimdilik orayla kafanızı karıştırmayalım.

24:17.520 --> 24:17.940
Çok güzel.

24:18.820 --> 24:19.360
Arkadaşlar,

24:19.700 --> 24:21.220
bu bir fonksiyon şablonu,

24:22.120 --> 24:23.720
ve fonksiyon şablonunun,

24:24.220 --> 24:25.920
hem tek parametre paketi var,

24:26.000 --> 24:27.660
hem fonksiyon parametre paketi var.

24:27.660 --> 24:28.780
ama,

24:28.780 --> 24:31.280
sizin şu anda şunu bilmeniz yeterli,

24:31.400 --> 24:32.140
konuyla ilgili.

24:34.260 --> 24:35.000
Bu fonksiyon,

24:35.060 --> 24:37.060
kendisine gönderilen argümanları,

24:38.060 --> 24:39.620
standart output'a yazdırıyor,

24:39.720 --> 24:41.000
sonra da bir new line veriyor.

24:41.720 --> 24:42.760
Bunu nasıl yaptığını,

24:42.860 --> 24:43.960
şimdilik konuşmayacağız.

24:43.960 --> 24:46.160
Yine aynı şekilde,

24:47.260 --> 24:49.280
bu da aslında,

24:50.340 --> 24:51.560
template type name'de,

24:52.560 --> 24:53.000
bu demek.

24:54.140 --> 24:54.880
Bunu da geçtik.

24:55.920 --> 24:57.140
Ve bu da aynı şekilde,

24:58.440 --> 24:59.480
template type name,

24:59.880 --> 25:00.300
arkadaşlar,

25:04.300 --> 25:04.800
TS,

25:04.800 --> 25:05.480
TS,

25:07.480 --> 25:08.640
ARX demek.

25:08.640 --> 25:10.340
Şimdi buraya kadar,

25:10.680 --> 25:12.240
sanırım olay netleşti.

25:13.480 --> 25:13.760
Bu,

25:14.280 --> 25:15.400
bir fonksiyon şablonunun,

25:15.560 --> 25:16.940
nasıl çalıştığını bilmiyoruz,

25:17.200 --> 25:18.480
ama kendisine gönderilen,

25:18.600 --> 25:20.000
argümanların hepsini,

25:20.860 --> 25:22.300
standart output'a yazdırıyor.

25:23.500 --> 25:25.320
Bu tek parametreli bir,

25:25.680 --> 25:26.840
fonksiyon şablonu,

25:28.280 --> 25:29.440
kendisine gönderilen,

25:30.380 --> 25:31.140
adresi,

25:31.600 --> 25:33.360
böyle bir return ifadesine kullanıyor.

25:33.680 --> 25:35.220
Beni ilgilendiren şimdi burası,

25:35.480 --> 25:37.620
diğerlerini yardımcı arası olarak kullanıyorum.

25:38.640 --> 25:39.560
Arkadaşlar,

25:39.940 --> 25:41.240
şimdi sadece F'ye,

25:41.560 --> 25:41.820
bakın,

25:41.980 --> 25:43.100
diğerlerini görmeyin.

25:45.280 --> 25:46.760
Bunların her biri,

25:47.340 --> 25:47.620
20.

25:47.880 --> 25:48.300
21.

25:48.600 --> 25:48.980
22.

25:49.340 --> 25:49.800
23.

25:49.800 --> 25:50.240
24.

25:50.380 --> 25:50.660
25.

25:50.920 --> 25:51.760
satırdaki,

25:53.820 --> 25:56.260
elipsisle oluşturulan ifadelerin,

25:56.380 --> 25:57.080
her biri bir,

25:57.080 --> 25:57.980
pek eksperşen.

25:58.700 --> 26:00.200
Şimdi ben size tek tek soracağım.

26:00.340 --> 26:02.340
Zaten bir çoğunu tahmin edebileceksiniz.

26:04.700 --> 26:05.560
Soru bir,

26:06.820 --> 26:08.060
bu neye açılacak?

26:09.520 --> 26:09.840
Burada,

26:10.240 --> 26:12.180
herhangi bir pattern olmadığı için,

26:12.620 --> 26:13.740
print fonksiyonuna,

26:14.520 --> 26:16.560
fonksiyonumuzun parametrelerine,

26:16.620 --> 26:18.060
argüman olarak göndereceğiz.

26:19.060 --> 26:19.720
Burayı anladık mı?

26:19.820 --> 26:20.100
Yani,

26:20.440 --> 26:20.760
f'i,

26:20.840 --> 26:21.060
x,

26:21.120 --> 26:21.240
y,

26:21.360 --> 26:22.680
z ile çağırdığımda,

26:23.700 --> 26:24.360
fonksiyonun,

26:24.480 --> 26:26.400
üç tane int parametresi var.

26:27.360 --> 26:28.700
Ve bu parametreler,

26:28.940 --> 26:31.240
yukarıdaki print fonksiyon çablonuna,

26:31.320 --> 26:32.740
argüman olarak gönderecek.

26:33.740 --> 26:34.140
Dolayısıyla,

26:34.200 --> 26:35.640
o fonksiyon çablonu da,

26:36.480 --> 26:37.820
bizim argümanlarımızın,

26:37.900 --> 26:39.440
değerlerini yazdırdığına göre,

26:39.720 --> 26:40.520
gördüğünüz gibi,

26:40.520 --> 26:41.880
değerler yazıldı.

26:43.100 --> 26:44.800
Eğer böyle çağırmak yerine,

26:45.980 --> 26:47.760
iki argüman daha verseydim,

26:48.560 --> 26:49.300
herhangi bir şekilde,

26:49.460 --> 26:50.520
bir problem olmayacaktı.

26:51.160 --> 26:51.500
Bu sefer,

26:51.580 --> 26:52.520
bunlar da yazdırılacaktı.

26:54.200 --> 26:55.540
Takip edebiliyor muyuz?

26:55.920 --> 26:56.100
Evet.

26:56.100 --> 26:57.800
Şimdi ikinciye bakalım.

26:59.520 --> 27:00.280
İkinci de,

27:01.180 --> 27:02.620
az önce söylediğim gibi,

27:03.720 --> 27:05.020
Ater'nin kendisi,

27:05.600 --> 27:06.600
adres args.

27:07.540 --> 27:08.040
O zaman,

27:08.360 --> 27:09.180
derleyici bunu,

27:09.480 --> 27:10.560
neye dönüştürecek?

27:11.720 --> 27:12.240
Söyleyin.

27:13.300 --> 27:14.200
Adres p1,

27:14.580 --> 27:15.540
adres p2,

27:15.620 --> 27:16.460
bu şekilde,

27:16.640 --> 27:17.200
bir listeye,

27:17.640 --> 27:18.580
dönüştürecek.

27:19.340 --> 27:19.860
Dolayısıyla,

27:20.000 --> 27:21.440
print fonksiyonu da bu durumda,

27:21.600 --> 27:22.580
aldığı argümanları,

27:22.660 --> 27:23.700
print ettiğine göre,

27:24.920 --> 27:25.720
gönderdiğim,

27:26.100 --> 27:26.960
adresleri,

27:27.160 --> 27:28.500
yazdırmış olacak.

27:29.180 --> 27:30.180
Takip edebiliyor muyuz?

27:30.380 --> 27:30.600
Tabii,

27:31.700 --> 27:32.180
arkadaşlar,

27:32.340 --> 27:33.220
bir şeye dikkat edin.

27:33.780 --> 27:35.120
Buradaki adresler,

27:35.520 --> 27:37.560
F'e gönderdiğim argümanlar değil,

27:37.840 --> 27:39.840
parametre değişkenlerinin adresleri.

27:40.920 --> 27:41.520
Dolayısıyla,

27:42.280 --> 27:42.720
aslında,

27:42.960 --> 27:45.540
standart alpuda yazılacak bütün değerler,

27:46.280 --> 27:47.640
int nesne adresleri.

27:48.220 --> 27:48.520
Değil mi?

27:48.980 --> 27:49.160
Evet.

27:49.660 --> 27:50.060
Bakın.

27:53.320 --> 27:54.120
Devam.

27:54.500 --> 27:55.240
Bunu da geçtik.

27:55.240 --> 27:56.580
şimdi üçüncüye gelelim.

27:58.560 --> 27:58.780
Evet.

27:59.700 --> 28:01.460
Bu sayıyı da biraz azaltalım.

28:04.540 --> 28:05.200
Lütfen dikkat.

28:05.600 --> 28:05.820
Peki,

28:05.900 --> 28:06.960
burada pater ne?

28:07.620 --> 28:08.880
10 çarpı args.

28:09.700 --> 28:09.940
Peki,

28:10.040 --> 28:10.680
bu durumda,

28:10.880 --> 28:11.660
derdeyici bunu,

28:11.960 --> 28:13.020
neye dönüştürecek?

28:13.640 --> 28:14.220
Arkadaşlar,

28:14.220 --> 28:16.940
10 çarpı P1,

28:17.760 --> 28:18.380
virgül,

28:19.000 --> 28:21.100
10 çarpı P2,

28:21.480 --> 28:22.060
virgül,

28:22.360 --> 28:24.200
10 çarpı P3.

28:25.620 --> 28:26.360
Dolayısıyla,

28:26.480 --> 28:28.760
print fonksiyonuna gönderilen argümanlar,

28:29.180 --> 28:29.680
bu durumda,

28:29.760 --> 28:30.600
1, 2, 3 değil,

28:31.240 --> 28:31.520
10,

28:31.760 --> 28:32.160
20,

28:32.380 --> 28:33.280
ve 30 olacak.

28:34.620 --> 28:35.580
Takip edebildik mi?

28:36.200 --> 28:36.520
Bravo.

28:37.060 --> 28:37.440
Bakın.

28:37.440 --> 28:40.460
10,

28:40.540 --> 28:40.720
20,

28:40.820 --> 28:41.120
30.

28:41.440 --> 28:41.920
Devam.

28:44.220 --> 28:45.760
Buraya özellikle dikkat.

28:45.880 --> 28:46.120
Bakın,

28:46.200 --> 28:47.300
tahmin edebilecek misiniz?

28:48.220 --> 28:49.140
Burada pater,

28:49.720 --> 28:51.100
args çarpı args.

28:52.080 --> 28:52.780
Dolayısıyla,

28:53.060 --> 28:54.280
P1 çarpı P1,

28:54.280 --> 28:54.800
virgül,

28:55.200 --> 28:56.860
P2 çarpı P2 virgül,

28:57.360 --> 28:58.900
P3 çarpı P3 virgül.

28:59.340 --> 28:59.980
Dolayısıyla,

29:00.920 --> 29:02.260
gönderilen argümanların,

29:02.560 --> 29:03.680
karesi yazdırılacak.

29:05.080 --> 29:05.880
Şimdi,

29:06.000 --> 29:06.740
paternimiz,

29:07.100 --> 29:08.720
biraz daha karmaşık hale geliyor.

29:08.900 --> 29:09.340
İzleyin.

29:10.540 --> 29:11.400
Bu durumda,

29:12.060 --> 29:12.720
değerli arkadaşlar,

29:14.060 --> 29:15.020
derdeyici bunu,

29:15.020 --> 29:16.740
neye dönüştürecek?

29:18.040 --> 29:18.580
Yanıt,

29:18.920 --> 29:19.380
G,

29:20.120 --> 29:21.240
adres P1,

29:22.540 --> 29:23.280
virgül,

29:23.760 --> 29:24.160
arkadaşlar,

29:25.160 --> 29:25.460
G,

29:26.100 --> 29:27.180
adres P2,

29:28.240 --> 29:28.860
virgül,

29:29.240 --> 29:29.500
G,

29:30.100 --> 29:31.060
adres P3.

29:31.960 --> 29:35.080
G'nin kendisi de bir fonksör çamlını olduğuna göre,

29:36.520 --> 29:39.600
bu aldığı adresteki nesnenin karesi,

29:39.840 --> 29:41.500
artı 10 değerini döndürüyor.

29:42.620 --> 29:43.420
Dolayısıyla,

29:43.420 --> 29:44.340
arkadaşlar,

29:45.380 --> 29:48.940
bizim gönderdiğimiz nesnelerin karesi artı 10,

29:50.360 --> 29:51.380
ne olur?

29:52.080 --> 29:52.480
11,

29:52.480 --> 29:54.780
arkadaşlar,

29:55.660 --> 29:57.520
14 ve 19,

29:57.740 --> 29:58.020
değil mi?

29:58.440 --> 29:59.400
Yanlış mı hesapladım?

30:00.220 --> 30:00.480
Evet.

30:01.120 --> 30:01.540
Bakın,

30:03.180 --> 30:03.580
11,

30:03.740 --> 30:04.200
14,

30:04.660 --> 30:05.100
19,

30:05.260 --> 30:06.080
bunu da geçtik.

30:06.080 --> 30:08.340
burada ise,

30:08.340 --> 30:10.020
herhalde bu da açık,

30:11.820 --> 30:12.840
neye dönüştürecek?

30:13.080 --> 30:14.000
Artı artı P1,

30:14.120 --> 30:15.080
artı artı P2,

30:15.180 --> 30:16.160
artı artı P3.

30:17.460 --> 30:18.300
Dolayısıyla,

30:18.680 --> 30:21.080
print fonksiyonuna gönderdiğim değerler,

30:21.080 --> 30:25.640
aslında öne kartı artı artı artı operatörünün ürettiği değerler,

30:25.720 --> 30:30.320
dolayısıyla nesnelerin değerlerinin bir fazlası.

30:30.320 --> 30:32.160
takip edebildik mi?

30:32.820 --> 30:33.040
Evet.

30:34.100 --> 30:34.700
Arkadaşlar,

30:35.080 --> 30:35.240
şimdi,

30:35.240 --> 30:37.080
pek expansion'in üstünde çalışıyoruz.

30:37.560 --> 30:38.300
İkinci örnek,

30:38.480 --> 30:41.320
anlamadığınız bir yer olduğu zaman tekrar edelim.

30:42.620 --> 30:42.960
Şimdi,

30:43.180 --> 30:46.280
ikinci önemli uyarı,

30:46.280 --> 30:48.320
şimdiye kadar,

30:49.180 --> 30:51.620
yazdığım fonksiyon şablonu örneklerinde,

30:52.720 --> 30:53.320
biz hep,

30:53.540 --> 30:55.140
template parametre paketini,

30:56.000 --> 30:56.620
doğrudan,

30:57.240 --> 30:58.920
referans semantiği olmadan,

30:59.520 --> 31:00.580
bu şekilde kullandık.

31:00.580 --> 31:01.900
Şimdi bakınız,

31:02.220 --> 31:02.960
eğer burada,

31:03.380 --> 31:05.320
referans dektaratörü olsaydı,

31:06.300 --> 31:08.920
bu durumda fonksiyonun bütün parametreleri,

31:09.300 --> 31:11.000
L-value referansı olacaktı.

31:12.380 --> 31:12.780
Yani,

31:13.080 --> 31:14.120
parametre paketinde,

31:14.280 --> 31:15.620
int double string varsa,

31:16.280 --> 31:18.940
derleyicinin oluşturduğu instantiation'da,

31:19.800 --> 31:20.400
int ref,

31:21.440 --> 31:22.180
double ref,

31:22.440 --> 31:23.060
string ref,

31:23.540 --> 31:24.520
parametreleri olacak.

31:25.960 --> 31:29.120
Eğer burada const anahtar sözcü olsaydı,

31:29.120 --> 31:33.000
bu sefer fonksiyonun bütün parametreleri,

31:33.820 --> 31:36.040
const L-value referansı olacaktı.

31:38.200 --> 31:39.080
Arkadaşlar,

31:39.400 --> 31:39.760
burada,

31:40.720 --> 31:42.500
ref ref dektaratörü olsaydı,

31:42.600 --> 31:44.140
geçen dersimizi hatırlayın,

31:45.140 --> 31:46.120
bu durumda da,

31:46.280 --> 31:49.140
fonksiyonun bütün parametreleri,

31:50.000 --> 31:51.900
universal referansı olacaktı.

31:52.900 --> 31:53.980
Yani örneğin,

31:54.360 --> 31:55.560
parametre paketinde,

31:55.900 --> 31:57.800
iki tane template parametresi varsa,

31:58.940 --> 31:59.600
bu durumda,

32:00.020 --> 32:01.440
iki tane ne olacak?

32:01.760 --> 32:03.120
Universal referansı,

32:03.120 --> 32:03.920
parametre olacak.

32:03.920 --> 32:06.880
yani parametre paketi,

32:07.300 --> 32:08.940
ya hepsi L-value referans,

32:10.380 --> 32:12.820
ya hepsi universal referans,

32:12.940 --> 32:14.620
ya hepsi R-value referans,

32:15.140 --> 32:17.140
olmak zorunda.

32:17.580 --> 32:18.420
Anlaşıldı değil mi?

32:18.660 --> 32:18.900
Yine,

32:19.040 --> 32:20.280
constluk da aynı şekilde,

32:20.860 --> 32:21.680
hepsini birden,

32:22.220 --> 32:22.680
niteliyor.

32:23.540 --> 32:23.820
Şimdi,

32:23.920 --> 32:24.900
ikinci örneğe bakalım.

32:25.660 --> 32:26.120
Hadi bakalım.

32:26.120 --> 32:27.600
İzleyin.

32:35.740 --> 32:36.500
Arkadaşlar,

32:37.220 --> 32:37.580
burada,

32:38.160 --> 32:40.500
sizin sadece bilmeniz gereken kısmı söylüyorum.

32:40.980 --> 32:42.400
Buraları henüz anlatmadım ama,

32:42.520 --> 32:44.000
birazdan detaylı anlatacağım.

32:45.220 --> 32:46.640
Square ve sum,

32:46.900 --> 32:48.740
bunlar birlikte kullanılmak üzere,

32:48.740 --> 32:50.760
buradaki ifadeye,

32:50.900 --> 32:52.120
fold expression deniyor.

32:52.300 --> 32:53.800
Bunların hiçbiri henüz görmedik.

32:53.920 --> 32:55.120
Bugün görmeye başlayacağız.

32:55.240 --> 32:55.500
Bu bir.

32:56.520 --> 32:58.020
Fakat sizi ilgilendiren şu,

32:59.460 --> 33:01.820
sum bir fonksiyon şablonunun ismi,

33:02.900 --> 33:04.260
bu fonksiyon şablonu,

33:04.440 --> 33:05.680
kendisine gönderilen,

33:05.940 --> 33:07.860
argümanların toplamını döndürüyor.

33:08.040 --> 33:10.160
Nasıl yaptığı sizi ilgilendirmiyor şimdilik.

33:11.220 --> 33:11.980
Anlaşıldı değil mi?

33:11.980 --> 33:13.020
Yani örneğin ben,

33:13.400 --> 33:14.980
sum'u şöyle çağırsaydım,

33:16.120 --> 33:16.580
sum,

33:16.580 --> 33:17.960
1,

33:18.200 --> 33:18.800
4,

33:19.020 --> 33:19.480
6,

33:20.500 --> 33:22.860
bunların toplamını döndürecekti.

33:23.180 --> 33:23.460
Yani,

33:24.280 --> 33:26.900
11 değerini döndürecekti arkadaşlar.

33:28.680 --> 33:29.400
Önemli olan,

33:29.880 --> 33:31.420
bu örneği hazırlama nedenim,

33:31.700 --> 33:32.200
buradaki,

33:32.620 --> 33:34.500
hack expansion'ları görmemiz.

33:35.100 --> 33:36.320
Yukarıdakiler önemli değil.

33:37.840 --> 33:38.340
Arkadaşlar,

33:38.460 --> 33:39.360
col-sum içinde,

33:40.160 --> 33:41.140
parametre paketi,

33:41.140 --> 33:42.900
yine expand edilmiş.

33:43.600 --> 33:45.360
Hem fonksiyon parametre paketi.

33:45.360 --> 33:46.940
Dolayısıyla,

33:47.300 --> 33:49.420
ben bu fonksiyonu ilk haline girelim,

33:49.500 --> 33:50.640
böyle çağırdığımda,

33:51.580 --> 33:52.680
aslında bu noktada,

33:53.100 --> 33:53.720
sum'u da,

33:54.480 --> 33:57.300
fonksiyonun parametre değişkenlerinin değerleriyle,

33:57.460 --> 33:57.900
yani 1,

33:57.960 --> 33:58.080
2,

33:58.080 --> 33:58.200
3,

33:58.260 --> 33:58.420
4,

33:58.480 --> 34:00.120
5 değerleriyle çağırmış olacağım.

34:01.540 --> 34:02.180
Dolayısıyla,

34:02.680 --> 34:04.720
15 değerini döndürecek.

34:05.500 --> 34:06.380
Yazdırdığım zaman,

34:06.880 --> 34:09.700
15 değerinin yazdırıldığını göreceksiniz.

34:10.700 --> 34:11.700
Deniyorum.

34:11.700 --> 34:16.480
ikinciye gelelim.

34:16.980 --> 34:17.920
İkinci de ise,

34:18.460 --> 34:19.220
buraya dikkat,

34:20.240 --> 34:21.260
parametre paketi,

34:21.640 --> 34:22.920
expand edildiğinde,

34:23.260 --> 34:25.500
virgürlerle ayrılmış bir isteğe dönüşüyor.

34:25.760 --> 34:27.280
Ama burada bir de,

34:27.960 --> 34:29.460
85 argümanı var.

34:29.460 --> 34:31.200
Dolayısıyla,

34:31.400 --> 34:32.500
sum fonksiyonuna,

34:33.280 --> 34:33.820
sadece 1,

34:33.880 --> 34:33.960
2,

34:33.960 --> 34:34.140
3,

34:34.200 --> 34:34.400
4,

34:34.460 --> 34:35.100
5'i değil,

34:35.860 --> 34:37.660
fonksiyonun ilk parametresine de,

34:37.780 --> 34:39.760
85 değerini göndermiş olacağım.

34:40.620 --> 34:41.100
Dolayısıyla,

34:41.260 --> 34:42.480
85 artı 15,

34:43.000 --> 34:44.640
100 değerini döndürecek.

34:47.240 --> 34:49.200
Yine üçüncü örneğe bakın.

34:49.880 --> 34:51.160
Üçüncü örnekte ise,

34:52.300 --> 34:52.740
pattern,

34:53.460 --> 34:55.660
square args olduğu için,

34:55.660 --> 34:57.160
derleyici,

34:57.260 --> 34:58.700
zaten yanına yazmışım,

34:59.480 --> 35:01.440
şöyle bir listeye dönüştürecek.

35:02.300 --> 35:02.700
Dolayısıyla,

35:02.840 --> 35:04.080
bu sefer fonksiyonu,

35:04.180 --> 35:06.420
square fonksiyonunda kare döndürdüğü için,

35:07.500 --> 35:07.920
arkadaşlar,

35:08.520 --> 35:08.860
1'in,

35:09.100 --> 35:09.440
2'nin,

35:09.600 --> 35:09.880
3'ün,

35:10.000 --> 35:10.360
4'ün,

35:10.460 --> 35:10.920
5'in,

35:11.520 --> 35:14.300
karelerinin toplamı hesaplanmış.

35:14.300 --> 35:16.940
Ve o değer yazdırılmış olacak.

35:17.320 --> 35:17.500
Yani,

35:17.640 --> 35:18.760
25 artı 16,

35:19.880 --> 35:20.360
arkadaşlar,

35:20.600 --> 35:21.160
artı 9,

35:21.300 --> 35:21.840
artı 2,

35:22.340 --> 35:22.960
artı 1.

35:22.960 --> 35:26.360
Evet.

35:27.480 --> 35:27.920
Şimdi,

35:28.200 --> 35:29.380
hemen sırada,

35:30.960 --> 35:33.540
cppref.com'dan bir örnek var.

35:34.020 --> 35:34.820
Güzel bir örnek.

35:35.780 --> 35:36.340
Hatta ben,

35:36.920 --> 35:37.840
kitaba koyarken,

35:39.740 --> 35:42.260
cppref.com'dan olan örnekleri de,

35:42.660 --> 35:44.360
özellikle linkini veriyorum.

35:45.140 --> 35:45.560
Arkadaşlar,

35:45.620 --> 35:46.120
bakın şimdi,

35:47.360 --> 35:47.720
burada,

35:48.200 --> 35:49.680
g isimli fonksiyona,

35:50.200 --> 35:52.820
çare yapıldığında,

35:52.960 --> 35:54.380
main fonksiyonu içinde,

35:55.480 --> 35:56.660
g fonksiyonu da,

35:57.340 --> 35:58.360
f'ye çağrı yapıyor.

35:58.940 --> 36:00.120
Şimdi çok dikkatli izleyelim.

36:01.220 --> 36:01.820
g'ye,

36:02.180 --> 36:03.820
gönderdiğim argümanlara bakın,

36:04.200 --> 36:04.460
1,

36:04.740 --> 36:05.820
0.2,

36:06.140 --> 36:06.840
string literal,

36:07.420 --> 36:07.600
a,

36:08.140 --> 36:08.340
a.

36:09.140 --> 36:09.940
Arkadaşlar,

36:10.020 --> 36:10.680
bu durumda,

36:11.580 --> 36:12.820
g fonksiyonu,

36:13.740 --> 36:15.580
f'yi bu şekilde çağırdığında,

36:16.140 --> 36:16.560
f'ye,

36:16.960 --> 36:18.220
neleri göndermiş oluyor?

36:19.340 --> 36:21.280
Parametre değişkenlerin adreslerini.

36:21.280 --> 36:23.000
Şimdi,

36:23.840 --> 36:24.560
bu sefer de,

36:24.640 --> 36:25.840
f fonksiyonunun,

36:27.060 --> 36:28.840
parametre paketindeki türleri,

36:28.920 --> 36:30.700
ve fonksiyonun parametrelerinin,

36:30.840 --> 36:32.240
ne olacağını söyleyebilir misiniz?

36:33.200 --> 36:33.960
Cevap tabi,

36:34.500 --> 36:35.280
int yıldız,

36:35.740 --> 36:36.640
double yıldız,

36:37.540 --> 36:37.820
ama,

36:38.480 --> 36:38.840
bu da,

36:39.500 --> 36:40.020
arkadaşlar,

36:40.840 --> 36:42.860
conschar yıldız olduğu için,

36:43.940 --> 36:45.620
conschar yıldız türünden,

36:45.620 --> 36:48.120
bir değişkenin adresi olan tür,

36:48.740 --> 36:49.340
conschar,

36:49.340 --> 36:50.900
yıldız yıldız olacak.

36:51.780 --> 36:52.900
Espriyi anladınız mı?

36:53.760 --> 36:54.620
Burada özellikle,

36:55.540 --> 36:56.020
aslında,

36:57.060 --> 36:58.460
gönderilen argümanın,

36:59.260 --> 37:01.000
ve template parametre paketindeki,

37:01.120 --> 37:02.020
türlerin ne olduğunu,

37:02.140 --> 37:03.060
çok güzel göstermiş.

37:03.140 --> 37:04.040
Tekrar edelim mi?

37:04.040 --> 37:05.760
g'yi çağırdığımda,

37:06.640 --> 37:08.020
g'nin parametreleri,

37:08.740 --> 37:10.540
int double conschar yıldız olacak.

37:11.760 --> 37:12.320
Ama,

37:12.820 --> 37:14.720
g'yi içinde f çağrıldığında,

37:15.220 --> 37:15.940
bu sefer de,

37:16.780 --> 37:17.080
burada,

37:17.640 --> 37:18.680
adreslerle,

37:18.900 --> 37:20.640
pack expansion yapıldığı için,

37:21.600 --> 37:23.100
f'nin parametreleri de,

37:23.480 --> 37:24.000
bu durumda,

37:24.260 --> 37:25.600
int için int yıldız,

37:26.380 --> 37:27.680
double için double yıldız,

37:27.680 --> 37:29.300
conschar yıldız için de,

37:29.460 --> 37:31.480
conschar yıldız yıldız olacak.

37:31.480 --> 37:32.960
Anlaşıldı mı?

37:34.100 --> 37:34.360
Evet.

37:36.200 --> 37:36.920
Arkadaşlar,

37:37.960 --> 37:38.240
tabii,

37:39.520 --> 37:41.320
açılım daha karmaşık da olabilir.

37:41.540 --> 37:42.640
Mesela şu örneğe bakın.

37:44.040 --> 37:44.200
Bu,

37:45.380 --> 37:47.080
bütün örüntüleri başta tek tek,

37:47.740 --> 37:49.540
ezberlemeniz mümkün olmayabilir.

37:49.540 --> 37:50.560
Yine,

37:50.860 --> 37:53.540
yukarıdaki iki fonksiyon çablonunu görmeyin.

37:53.820 --> 37:54.780
Sizi ilgilendiren,

37:55.740 --> 37:56.220
sum'ın,

37:56.560 --> 37:59.340
kendisine gönderilen argümanları topluyor olması,

38:00.560 --> 38:03.160
multiplication'dan ismi verilen malın da,

38:03.860 --> 38:07.020
kendisine gönderilen argümanların çarpımını döndürmesi.

38:08.080 --> 38:09.180
Şimdi espriye bakın.

38:10.940 --> 38:13.020
13. satırda tanıma başlayan,

38:13.020 --> 38:15.140
fu isimli fonksiyon çablonunda,

38:16.220 --> 38:17.020
return ifadesindeki,

38:18.160 --> 38:19.320
pack extension'a bakın.

38:20.540 --> 38:21.160
Arkadaşlar,

38:21.440 --> 38:21.780
burada,

38:23.200 --> 38:25.260
args parametre paketi,

38:25.540 --> 38:26.840
fonksiyon parametre paketi,

38:26.940 --> 38:27.980
expand edilmiş.

38:28.840 --> 38:29.220
Ama,

38:29.720 --> 38:31.860
burada da parametre paketi var.

38:32.860 --> 38:34.060
Bu da expand edilmiş.

38:34.900 --> 38:35.940
Takip edebiliyor musunuz?

38:37.020 --> 38:37.860
Dolayısıyla,

38:38.680 --> 38:39.180
arkadaşlar,

38:40.360 --> 38:41.260
bu durumda,

38:41.260 --> 38:43.560
iki tane pack expansion,

38:43.960 --> 38:46.360
birlikte karşılıklı olarak ele alınacak.

38:46.360 --> 38:48.180
Şimdi fonksiyona,

38:48.260 --> 38:50.480
1, 2, 4 değerlerini gönderdiğimde,

38:51.860 --> 38:53.540
buradaki açılım şöyle olacak.

38:54.540 --> 38:55.080
Arkadaşlar,

38:55.360 --> 38:55.640
sum,

38:55.700 --> 38:56.320
1, 2, 4,

38:56.580 --> 38:57.260
artı 1,

38:58.380 --> 38:58.760
sum,

38:58.760 --> 38:59.460
1, 2, 4,

38:59.700 --> 39:00.320
artı 2,

39:01.080 --> 39:01.480
sum,

39:01.540 --> 39:02.160
1, 2, 4,

39:02.420 --> 39:03.120
artı 4.

39:04.100 --> 39:04.660
Yani,

39:05.300 --> 39:06.340
parametre paketi,

39:06.340 --> 39:08.500
birden fazla kez de,

39:09.220 --> 39:10.360
yine ifade içinde,

39:10.500 --> 39:11.500
expand edilebilir.

39:11.740 --> 39:11.980
Hatta,

39:12.060 --> 39:12.220
hatta,

39:12.300 --> 39:14.020
farklı parametre paketleri de,

39:14.100 --> 39:15.660
karşılıklı expand edilebilir.

39:16.940 --> 39:17.920
Takip edebiliyor muyuz?

39:18.640 --> 39:19.160
Arkadaşlar,

39:19.220 --> 39:19.420
bakın,

39:19.480 --> 39:20.940
bunun en tipik örneği,

39:21.600 --> 39:23.400
perfect forwarding uygulamaları.

39:24.400 --> 39:24.680
Şimdi,

39:24.760 --> 39:25.320
izleyin.

39:26.360 --> 39:27.580
Geçenlerde yazdığımız,

39:27.580 --> 39:28.220
kod,

39:28.520 --> 39:30.220
şimdi çok daha açık hale gelecek.

39:31.100 --> 39:32.180
Şöyle bir kod yazmıştık,

39:32.260 --> 39:32.980
hatırlıyor musunuz?

39:32.980 --> 39:34.300
template type name t.

39:37.060 --> 39:37.940
Şimdi bakın,

39:38.000 --> 39:40.460
pek expansion'ı en güzel gösteren örneklerden,

39:40.660 --> 39:41.320
biri aslında.

39:42.360 --> 39:43.460
Template type name t.

39:44.020 --> 39:44.700
Type name.

39:49.280 --> 39:49.960
Arx.

39:52.960 --> 39:53.600
Make,

39:53.900 --> 39:55.340
şimdi herkes bu örneği hatırlayacak.

39:55.460 --> 39:55.840
Unique.

39:58.340 --> 39:59.960
Fonksiyonun geri dönüş değeri,

40:00.720 --> 40:01.180
tut,

40:01.900 --> 40:02.420
unique.

40:02.980 --> 40:04.520
PTR'ın,

40:05.420 --> 40:06.120
P açılımı.

40:08.320 --> 40:10.900
Ve fonksiyonun parametrelerine bakın.

40:11.240 --> 40:11.700
Arx,

40:13.480 --> 40:14.140
refref,

40:15.200 --> 40:15.600
Arx.

40:18.060 --> 40:19.380
Bu durumda,

40:19.520 --> 40:21.940
bu fonksiyonun bütün parametreleri,

40:24.060 --> 40:25.980
Arwell'in referansı değil,

40:26.400 --> 40:26.940
universal referansı.

40:26.940 --> 40:31.940
yani ben bu fonksiyona kaç tane argüman gönderirsem,

40:32.940 --> 40:34.480
argümanların her biri,

40:35.400 --> 40:37.240
universal referanslara gidiyor.

40:38.240 --> 40:40.140
Ona yönelik kurallar geçerli olacak.

40:40.140 --> 40:42.280
koda bakın,

40:42.280 --> 40:43.480
koda bakın şimdi,

40:43.480 --> 40:43.600
koda bakın şimdi,

40:44.600 --> 40:45.800
nif ifadesiyle,

40:46.480 --> 40:48.440
t türünden bir nesne oluşturuyorum,

40:49.860 --> 40:50.920
ve konstruktora,

40:50.920 --> 40:51.260
eğer,

40:51.260 --> 40:52.380
eğer,

40:52.380 --> 40:52.420
eğer,

40:52.420 --> 40:53.300
şöyle,

40:53.300 --> 40:54.880
arkadaşlar,

40:55.080 --> 40:56.420
bir çağrı yapsaydım,

40:57.380 --> 41:00.480
fonksiyonun parametre değişkenlerini göndermiş olurdum.

41:00.480 --> 41:03.800
Zaten bu durumda fonksiyonun parametre değişkenleri,

41:03.920 --> 41:04.960
ya L value referans,

41:05.020 --> 41:06.320
ya R value referansı olacak.

41:08.320 --> 41:10.260
Eğer şöyle yazsaydım,

41:12.060 --> 41:12.600
ismi,

41:13.340 --> 41:13.980
F olan,

41:15.000 --> 41:17.360
fonksiyona argümanları gönderip,

41:17.440 --> 41:19.200
parametre değişkenlerini gönderip,

41:20.700 --> 41:22.300
onların oluşturduğu,

41:22.380 --> 41:24.260
virgüllerle ayrılan listeyi de,

41:25.400 --> 41:28.600
T sınıfının konstruktörün argümanı olarak göndermiş olurdu.

41:28.600 --> 41:30.460
E şimdi,

41:30.980 --> 41:31.500
burada,

41:32.500 --> 41:33.260
P yerine,

41:33.480 --> 41:35.300
bu sefer standart kütüphanenin,

41:36.640 --> 41:39.580
stut forward fonksiyonunu çağırırsam,

41:40.500 --> 41:42.440
eğer stut forward'ın kendisi,

41:42.820 --> 41:44.840
bir fonksiyon şablonu olmasaydı,

41:44.940 --> 41:46.000
template argümanının,

41:46.660 --> 41:48.960
ne olduğunu belirtmek zorunda kalmasaydım,

41:49.900 --> 41:50.560
bu durumda,

41:51.120 --> 41:54.440
her bir argüman stut forward'a gönderilecekti.

41:55.400 --> 41:56.120
Ama şimdi,

41:57.780 --> 41:58.360
bakınız,

41:58.600 --> 42:00.320
bu durumda,

42:01.280 --> 42:02.940
nasıl bir açılım yapılacak,

42:04.500 --> 42:06.040
eğer parametre paketinde,

42:06.180 --> 42:07.620
3 tane parametre varsa,

42:10.220 --> 42:12.780
3 kez stut forward'a çağrı yapılacak.

42:13.280 --> 42:13.940
Birinci de,

42:14.940 --> 42:15.380
arkadaşlar,

42:15.600 --> 42:15.900
burada,

42:16.780 --> 42:18.720
parametre paketindeki birinci tür,

42:19.680 --> 42:20.480
birinci argüman,

42:20.600 --> 42:22.060
fonksiyon parametre paketinde,

42:22.180 --> 42:22.680
virgül,

42:23.360 --> 42:23.920
ikinci tür,

42:23.980 --> 42:24.780
ikinci argüman,

42:24.780 --> 42:27.160
zaten perfect forward'ing'i,

42:27.940 --> 42:29.120
gerçekten de mükemmelleştiren,

42:30.060 --> 42:31.040
buradaki yapı.

42:31.740 --> 42:32.940
Buraya kadar olan kısmı,

42:33.000 --> 42:34.340
şöyle bir gösterelim.

42:35.260 --> 42:36.440
Mesela fonksiyonun,

42:37.180 --> 42:37.620
arkadaşlar,

42:38.300 --> 42:40.200
derleyici tarafından yazılan fonksiyonu,

42:40.260 --> 42:41.400
kafanızda canlandırın.

42:41.400 --> 42:42.120
hatta şöyle,

42:42.560 --> 42:43.400
yavaş yavaş bitelim.

42:43.400 --> 42:44.780
Mesela,

42:45.140 --> 42:45.980
make unique,

42:50.400 --> 42:54.720
my class bir sınıf olsun,

43:00.720 --> 43:02.840
ve diyelim ki,

43:03.560 --> 43:04.120
arkadaşlar,

43:04.960 --> 43:05.620
burada da,

43:05.880 --> 43:06.620
argümanlar,

43:06.800 --> 43:07.600
x, y,

43:08.440 --> 43:09.580
10 olsun.

43:09.580 --> 43:11.240
Şimdi,

43:11.320 --> 43:12.000
derleyici bunu,

43:12.520 --> 43:13.560
neye dönüştürecek?

43:14.580 --> 43:15.180
Arkadaşlar,

43:15.460 --> 43:16.080
stot forward,

43:16.760 --> 43:17.600
x'in türü,

43:18.140 --> 43:19.200
template argümanı,

43:19.380 --> 43:19.680
x,

43:20.620 --> 43:21.160
virgül,

43:21.580 --> 43:22.380
stot forward,

43:23.560 --> 43:24.660
açısal parantez içinde,

43:24.800 --> 43:25.520
y'nin türü,

43:26.060 --> 43:26.200
y.

43:26.960 --> 43:27.800
Bu da ne demek?

43:28.620 --> 43:29.700
Son derece basit.

43:29.920 --> 43:31.160
Geçen derste gördüğümüz,

43:31.340 --> 43:33.040
perfect forwarding mekanizması,

43:34.120 --> 43:35.220
fonksiyonun bütün,

43:35.560 --> 43:36.540
parametreleri için,

43:36.700 --> 43:37.520
kullanılmış olacak.

43:38.520 --> 43:38.900
Yani,

43:38.900 --> 43:40.700
bizim yazdığımız,

43:40.840 --> 43:42.220
make unique fonksiyonu,

43:42.800 --> 43:44.140
aldığı argümanları,

43:45.540 --> 43:45.980
arkadaşlar,

43:46.400 --> 43:47.300
t sınıfının,

43:47.400 --> 43:49.220
t'nin bir sınıf türü olduğunu düşünelim,

43:49.460 --> 43:50.460
constructor'ın da,

43:51.300 --> 43:52.440
perfect forward edecek.

43:52.560 --> 43:53.880
Perfect forward etmesi ne demek?

43:54.560 --> 43:56.140
Value kategorisini koruyarak,

43:56.260 --> 43:57.320
constant'u koruyarak,

43:57.740 --> 43:58.340
gönderecek.

43:59.420 --> 44:01.520
E zaten fonksiyonun da böyle olduğunu,

44:02.060 --> 44:03.300
göstermiştik daha önce.

44:03.500 --> 44:04.740
Sadece aradaki fark ne?

44:04.740 --> 44:05.640
işte bu,

44:06.840 --> 44:08.520
buradan t yıldız türünden,

44:08.600 --> 44:09.820
bir adres elde ediliyor.

44:09.820 --> 44:11.440
Aslında,

44:11.440 --> 44:15.500
unique ptr sınıfının da,

44:16.340 --> 44:18.320
böyle bir pointer parametreli,

44:18.540 --> 44:20.100
nesi var arkadaşlar,

44:20.760 --> 44:23.780
kontraktörü var.

44:23.780 --> 44:25.580
ve burada,

44:25.580 --> 44:28.460
bu konstruktörle,

44:29.100 --> 44:31.800
bir pr value nesne oluşturuyorum.

44:31.900 --> 44:33.100
Dolayısıyla burada da yine,

44:34.100 --> 44:35.380
daha önce öğrendiğimiz,

44:36.380 --> 44:38.800
mandatory copy illusion gerçekleşiyor.

44:38.800 --> 44:40.500
işte,

44:42.180 --> 44:43.260
parametre paketinin,

44:43.780 --> 44:45.800
ya da fonksiyon parametre paketinin,

44:46.500 --> 44:48.140
expand edilmesine yönelik,

44:48.400 --> 44:49.420
örnekler verdik.

44:50.380 --> 44:50.920
Arkadaşlar,

44:51.000 --> 44:52.480
yine sınıflarla ilgili,

44:52.580 --> 44:54.060
verdiğimiz örneklerin hepsini,

44:54.120 --> 44:55.960
çok hızlı bir şekilde görelim.

44:56.160 --> 44:57.660
Sınıf şablonlarında da olabilir.

44:59.380 --> 45:00.120
Mesela burada,

45:01.200 --> 45:03.400
Warren kendisi de bir sınıf şablonu,

45:04.280 --> 45:06.600
Michael's'ın kendisi de bir sınıf şablonu.

45:06.600 --> 45:08.240
O zaman,

45:08.880 --> 45:12.240
ben Michael's'ın int virgül double açılımını,

45:12.380 --> 45:13.560
oluşturduğum zaman,

45:14.440 --> 45:17.020
Michael's'ın int virgül double açılımı,

45:17.800 --> 45:18.320
aslında,

45:19.660 --> 45:22.500
burada virgüllerle ayrılmış liste olduğu için,

45:22.640 --> 45:23.280
bu arada bakın,

45:24.220 --> 45:24.960
expansion'a,

45:25.460 --> 45:27.240
tabii ki buradaki public de dahil,

45:27.400 --> 45:28.820
public dahil olmasaydı,

45:29.540 --> 45:31.760
sadece ilk sınıf ne olurdu?

45:32.520 --> 45:33.060
Arkadaşlar,

45:33.160 --> 45:35.200
public base class olurdu,

45:35.200 --> 45:36.280
diğerleri,

45:36.600 --> 45:37.720
protected olurdu.

45:39.040 --> 45:39.720
Dolayısıyla,

45:40.280 --> 45:42.560
şimdi bizim sınıfımızın taban sınıfı,

45:43.360 --> 45:43.800
arkadaşlar,

45:44.420 --> 45:45.060
ne olacak?

45:46.160 --> 45:46.560
Warren,

45:47.120 --> 45:48.880
yani yukarıdaki sınıf şablonunun,

45:49.360 --> 45:52.020
int double açılımı olacak.

45:53.020 --> 45:53.840
Yine aynı şekilde,

45:54.700 --> 45:55.600
sınıfın public bölümünde,

45:57.080 --> 45:57.600
size t türünden,

45:58.340 --> 45:59.640
statik veri elemanında,

46:00.520 --> 46:01.280
ilk değerini,

46:01.840 --> 46:02.440
size of,

46:02.980 --> 46:04.700
değişken size of operatörüyle,

46:04.700 --> 46:06.480
varianic size of operatörüyle,

46:07.360 --> 46:07.820
değerini,

46:08.380 --> 46:08.920
aldığını,

46:09.320 --> 46:10.080
görüyorsunuz.

46:10.980 --> 46:11.220
Evet.

46:12.300 --> 46:12.900
Arkadaşlar,

46:13.340 --> 46:13.600
şimdi,

46:14.460 --> 46:14.680
tabii,

46:15.220 --> 46:16.540
ilerleyen derslerde,

46:16.820 --> 46:18.140
çok fazla örnek yapacağız,

46:18.380 --> 46:19.100
aynı şeyleri de,

46:19.240 --> 46:19.760
tekrar tekrar,

46:19.860 --> 46:21.560
üstünden geçmek de istemiyorum.

46:22.320 --> 46:22.660
Ama,

46:23.940 --> 46:24.580
yavaş yavaş,

46:24.700 --> 46:25.440
konuya gelelim.

46:25.720 --> 46:25.840
Ha,

46:25.920 --> 46:26.960
bu arada bir örnek daha,

46:27.040 --> 46:27.980
belki ilginç bir örnek,

46:28.080 --> 46:29.080
geçen dersimizde,

46:29.080 --> 46:30.660
üstünden,

46:31.480 --> 46:32.640
geçtik mi hatırlamıyorum.

46:32.780 --> 46:32.980
Bakın,

46:33.020 --> 46:34.320
daha karmaşık bir örnek.

46:36.160 --> 46:36.820
Bu sefer,

46:37.680 --> 46:38.200
arkadaşlar,

46:38.560 --> 46:40.320
iki tane parametre paketi var.

46:42.380 --> 46:42.780
Birinci,

46:42.960 --> 46:43.200
hani,

46:43.540 --> 46:45.540
birden fazla parametre paketi olabilir mi,

46:45.620 --> 46:46.840
sorusuna da güzel bir cevap.

46:48.740 --> 46:49.980
Birinci parametre paketi,

46:50.080 --> 46:51.580
template type parametre paketi,

46:51.660 --> 46:52.800
ikinci parametre paketi,

46:52.900 --> 46:54.260
non type parametre paketi.

46:54.260 --> 46:56.700
Arkadaşlar,

46:56.800 --> 46:57.740
fonksiyonun,

46:58.100 --> 46:59.020
parametrelerinin,

46:59.220 --> 47:00.320
nasıl yazıldığına bakın.

47:01.500 --> 47:02.280
Bu durumda,

47:02.600 --> 47:03.620
bu fonksiyonun,

47:03.920 --> 47:05.540
her bir parametresi,

47:06.560 --> 47:07.580
türü t olan,

47:08.440 --> 47:09.360
listeye değil,

47:09.500 --> 47:09.900
diziye,

47:10.760 --> 47:11.740
türü t olan,

47:12.380 --> 47:13.540
boyutu neye olan,

47:14.020 --> 47:14.960
diziye referans.

47:15.120 --> 47:16.200
Doğru mu?

47:17.140 --> 47:17.560
Yani,

47:17.640 --> 47:17.960
örneğin,

47:17.960 --> 47:20.160
fang fonksiyonunu böyle çağırdığımda,

47:21.020 --> 47:21.540
aslında,

47:22.380 --> 47:23.540
fang fonksiyonunun,

47:23.540 --> 47:26.520
hangi specialization'la çağır yapmış oluyorum?

47:27.820 --> 47:28.200
int,

47:28.840 --> 47:29.860
ref,

47:31.120 --> 47:32.440
köşeli parantez,

47:32.840 --> 47:33.140
2,

47:35.120 --> 47:35.540
int,

47:36.180 --> 47:36.700
ref,

47:37.180 --> 47:37.660
arkadaşlar,

47:39.820 --> 47:41.800
bu tabii template vergibene özür dilerim,

47:41.920 --> 47:43.040
int köşeli parantez,

47:43.080 --> 47:43.300
2,

47:44.840 --> 47:46.200
int köşeli parantez,

47:46.200 --> 47:46.780
3,

47:48.780 --> 47:50.560
int köşeli parantez,

47:50.620 --> 47:51.000
5,

47:51.000 --> 47:52.960
ve,

47:53.840 --> 47:55.480
double köşeli parantez,

47:55.980 --> 47:59.120
double köşeli parantez,

47:59.240 --> 47:59.620
7,

48:00.620 --> 48:01.540
takip edebiliyor muyuz?

48:01.620 --> 48:01.800
Bu,

48:02.800 --> 48:03.880
template argümanları.

48:04.120 --> 48:04.400
Fakat,

48:04.540 --> 48:04.800
buna,

48:05.260 --> 48:06.240
çare yaparken,

48:07.480 --> 48:08.120
bu durumda,

48:08.480 --> 48:09.200
fonksiyonun,

48:09.400 --> 48:10.620
parametreleri ne olacak?

48:10.900 --> 48:11.100
İşte,

48:11.200 --> 48:12.220
demin söylediğim gibi,

48:12.220 --> 48:14.000
böyle dizilere,

48:14.360 --> 48:15.280
referans olacak.

48:16.880 --> 48:17.100
Evet,

48:18.100 --> 48:18.480
peki,

48:19.580 --> 48:20.120
arkadaşlar,

48:23.120 --> 48:25.660
yine çok sık karşımıza çıkan yapılardan biri,

48:25.920 --> 48:27.120
parametre paketini,

48:28.080 --> 48:29.540
fonksiyonun içindeki,

48:30.200 --> 48:31.120
yine,

48:31.620 --> 48:34.140
sınıf şablonlarına argüman yapmak.

48:34.140 --> 48:35.420
Mesela şu örneğe bakın.

48:36.360 --> 48:38.200
Sadece benim gösterdiğim yere bakınız.

48:39.720 --> 48:40.400
Arkadaşlar,

48:41.300 --> 48:41.640
burada,

48:42.420 --> 48:43.500
fun fonksiyonunun,

48:44.000 --> 48:45.720
3 tane template parametresi var.

48:46.900 --> 48:48.220
Birinci parametre paket değil,

48:48.340 --> 48:49.580
ikinci parametre paket değil,

48:49.680 --> 48:50.960
üçüncü parametre paket.

48:52.560 --> 48:53.360
Arkadaşlar,

48:53.360 --> 48:55.460
bu durumda örneğin,

48:56.600 --> 48:58.440
13. satırda oluşturduğum,

48:58.540 --> 48:59.460
yerel değişken,

49:00.640 --> 49:02.160
couple sınıf şablonunun,

49:03.280 --> 49:04.320
hangi açılımı?

49:05.060 --> 49:05.380
A,

49:05.620 --> 49:05.860
B,

49:06.360 --> 49:07.800
ve paketteki açılımı.

49:08.480 --> 49:09.160
Yani örneğin,

49:09.240 --> 49:11.100
ben funk'ı bu şekilde çağırdım da,

49:11.180 --> 49:11.900
buraya dikkat.

49:13.280 --> 49:14.820
Parametre paketindeki türler,

49:15.080 --> 49:15.360
int,

49:15.680 --> 49:16.040
float,

49:16.340 --> 49:16.620
double,

49:16.620 --> 49:17.340
long,

49:17.680 --> 49:18.120
çarş.

49:19.140 --> 49:20.340
Dolayısıyla burada,

49:21.120 --> 49:21.660
couple'ın,

49:22.460 --> 49:22.820
int,

49:22.820 --> 49:23.820
float,

49:24.900 --> 49:25.440
double,

49:25.740 --> 49:26.280
long,

49:26.600 --> 49:27.800
çar açılımı türünden,

49:27.900 --> 49:29.280
bir nesne oluşturmuş oluyorum.

49:30.740 --> 49:31.720
İkincide ise,

49:32.320 --> 49:32.780
bu sefer,

49:33.060 --> 49:33.920
parametre paketi,

49:34.040 --> 49:35.280
burada ekspant edilmiş.

49:36.900 --> 49:37.400
Dolayısıyla,

49:37.540 --> 49:39.780
parametre paketindeki türler,

49:41.020 --> 49:41.320
double,

49:41.440 --> 49:41.640
long,

49:41.720 --> 49:42.620
çar olduğu için,

49:42.780 --> 49:43.360
bu sefer de,

49:43.360 --> 49:43.900
tuple'ın,

49:44.220 --> 49:44.480
double,

49:44.480 --> 49:44.840
long,

49:44.960 --> 49:45.340
çar,

49:45.900 --> 49:46.120
int,

49:46.200 --> 49:47.000
float açılımı,

49:47.660 --> 49:48.700
söz konusu olacak.

49:49.980 --> 49:50.820
Ya da buraya bakın,

49:50.940 --> 49:51.660
burada ise,

49:51.660 --> 49:53.040
int,

49:53.740 --> 49:54.580
float,

49:54.760 --> 49:55.000
double,

49:55.000 --> 49:55.580
long,

49:56.580 --> 49:57.780
ve arkadaşlar,

49:58.880 --> 49:59.140
pardon,

49:59.280 --> 49:59.620
söyleyeyim,

49:59.780 --> 50:00.120
int,

50:00.980 --> 50:02.200
double,

50:02.360 --> 50:02.620
long,

50:02.720 --> 50:03.080
çar,

50:03.380 --> 50:04.840
ve float açılımı olacak.

50:06.320 --> 50:06.620
Evet,

50:07.120 --> 50:07.960
şimdi gelelim,

50:09.220 --> 50:10.640
özellikle fonksiyon,

50:10.640 --> 50:11.980
şablonlarında,

50:13.040 --> 50:14.960
parametre paketini nasıl kullanacağım?

50:14.960 --> 50:16.920
şimdi bütün mesele burada.

50:17.960 --> 50:18.340
Yani,

50:18.340 --> 50:20.500
variatik fonksiyon çablonları,

50:20.840 --> 50:23.280
variatik parametre paketine sahip,

50:24.080 --> 50:25.360
fonksiyon çablonları,

50:26.380 --> 50:28.500
dilediğimiz sayıda argümanla,

50:29.440 --> 50:31.120
çağrılma şansı,

50:31.620 --> 50:32.860
olanağı veriyorlar bize.

50:33.860 --> 50:34.180
Ama,

50:34.540 --> 50:35.400
bu olanaktan,

50:35.740 --> 50:37.340
nasıl istifade edeceğiz?

50:38.080 --> 50:38.660
Ona bakalım.

50:39.640 --> 50:40.140
Arkadaşlar,

50:40.240 --> 50:41.200
önce şunu söyleyeyim.

50:41.200 --> 50:43.780
bundan istifade etmek için,

50:44.220 --> 50:45.640
birden fazla teknik var.

50:45.800 --> 50:46.020
Yani,

50:46.120 --> 50:47.060
bütün problem şu,

50:47.200 --> 50:47.460
değil mi?

50:48.300 --> 50:48.960
Sizin bir,

50:48.960 --> 50:50.800
parametre paketiniz var.

50:51.920 --> 50:52.860
Lütfen dikkat edin.

50:53.120 --> 50:53.320
Evet.

50:54.380 --> 50:54.840
Bu da,

50:55.400 --> 50:56.060
diyelim ki,

50:56.640 --> 50:57.380
fonksiyonun,

50:57.620 --> 50:58.600
parametre paketi.

51:00.680 --> 51:01.340
Ve sizin,

51:01.700 --> 51:02.860
böyle bir fonksiyona,

51:03.080 --> 51:03.680
bir iş,

51:03.800 --> 51:05.820
faydalı iş yaptırabilmeniz için,

51:07.000 --> 51:07.640
fonksiyonun,

51:07.720 --> 51:09.220
parametre değişkenlerini,

51:09.220 --> 51:10.820
bir şekilde,

51:11.260 --> 51:12.540
kullanmanız gerekiyor.

51:13.640 --> 51:14.080
Mesela,

51:14.220 --> 51:14.360
bu,

51:14.440 --> 51:16.060
print fonksiyonu olsaydı,

51:17.260 --> 51:17.760
arkadaşlar,

51:18.960 --> 51:19.180
ve,

51:19.940 --> 51:20.640
fonksiyonun,

51:20.760 --> 51:21.600
parametreleri,

51:22.780 --> 51:23.940
const,

51:24.280 --> 51:26.000
lvalue referansı olsaydı,

51:27.860 --> 51:29.060
ve bu fonksiyonun amacı,

51:29.160 --> 51:30.220
kendisine gönderilen,

51:30.220 --> 51:32.000
gönderilen bütün argümanları,

51:32.100 --> 51:34.400
standart output'a yazdırmak olsaydı,

51:35.480 --> 51:37.220
o zaman şöyle bir soru gündeme geliyor.

51:37.220 --> 51:38.480
İyi de,

51:38.940 --> 51:39.840
bunun için benim,

51:40.700 --> 51:41.340
fonksiyonun,

51:41.400 --> 51:42.460
parametrelerinden,

51:42.640 --> 51:43.420
her birine,

51:43.760 --> 51:44.840
erişmem gerekiyor.

51:45.480 --> 51:46.900
O erişimin hızlı yapacağım.

51:49.120 --> 51:49.960
Arkadaşlar,

51:50.040 --> 51:50.340
burada,

51:51.100 --> 51:52.500
böyle kötü habere söyleyeyim,

51:53.460 --> 51:54.540
dil size doğrudan,

51:54.620 --> 51:55.500
bir araç vermiyor.

51:55.620 --> 51:56.860
Yani şöyle bir şey beklemeyin,

51:57.420 --> 51:58.680
bir döngü oluştururum,

51:58.840 --> 51:59.440
o döngüyle,

51:59.520 --> 52:00.840
bütün parametreleri alırım.

52:01.600 --> 52:01.840
Hayır.

52:03.340 --> 52:03.940
Arkadaşlar,

52:03.940 --> 52:06.020
birden fazla teknik var.

52:06.160 --> 52:06.620
Gelin şimdi,

52:06.700 --> 52:07.660
önce tekniklere,

52:07.800 --> 52:09.900
şöyle kendimiz isimler verelim.

52:11.060 --> 52:12.780
Kullanılan tekniklerden biri,

52:13.460 --> 52:14.960
ben şu terimi yakıştırıyorum,

52:15.160 --> 52:16.040
compile time,

52:18.040 --> 52:18.900
recursive,

52:20.360 --> 52:21.060
pack expansion.

52:25.060 --> 52:25.940
Compile time,

52:26.080 --> 52:28.000
önerili isteği bir tamamlayalım.

52:28.780 --> 52:29.360
Arkadaşlar,

52:29.360 --> 52:32.560
ikinci şansımız,

52:33.520 --> 52:35.580
bu biraz enteresan gelebilir.

52:36.460 --> 52:37.140
Arkadaşlar,

52:38.140 --> 52:38.460
bir,

52:39.020 --> 52:40.700
initializer liste oluşturmak.

52:40.860 --> 52:42.200
Ne alakası var diyeceksiniz.

52:43.660 --> 52:44.140
Anlatacağım.

52:44.760 --> 52:45.700
Ve üçüncüsü,

52:47.180 --> 52:48.500
arkadaşlar,

52:48.680 --> 52:49.620
C++'a,

52:50.180 --> 52:50.900
görece olarak,

52:51.100 --> 52:51.640
daha geç,

52:51.920 --> 52:52.560
eklenen,

52:53.460 --> 52:54.280
hold expressions.

52:54.280 --> 52:59.240
katlama ifadeleri.

53:01.040 --> 53:01.320
Yani,

53:01.400 --> 53:01.800
bir şekilde,

53:01.960 --> 53:04.120
parametreleri kullanmak istiyorsanız,

53:05.460 --> 53:06.620
ya da dördüncüsü,

53:07.140 --> 53:07.580
arkadaşlar,

53:08.020 --> 53:09.000
constexpr'i.

53:11.060 --> 53:12.020
Ve,

53:12.820 --> 53:13.620
recursive'de.

53:14.280 --> 53:15.560
Compile time recursive'de.

53:18.060 --> 53:18.860
Şimdi,

53:18.980 --> 53:20.400
buralar sizi biraz yoracak.

53:20.540 --> 53:21.320
Baştan söyleyeyim.

53:21.320 --> 53:21.820
Yani,

53:22.740 --> 53:24.540
büyük ihtimalle verilen örnekleri,

53:24.760 --> 53:26.360
herkesin başına geldiği gibi,

53:27.640 --> 53:29.440
birinci de anlamayabileceksiniz.

53:30.240 --> 53:30.940
Nedeni şu,

53:32.020 --> 53:32.360
arkadaşlar,

53:32.580 --> 53:33.620
recursive kodları,

53:33.720 --> 53:36.240
insan zihninin algılaması çok kolay olmuyor.

53:36.340 --> 53:37.740
Biraz egzersiz gerekiyor.

53:38.520 --> 53:41.500
Bu runtime recursive vitesi için de geçerli,

53:41.740 --> 53:43.920
ama compile time recursive vitesi için,

53:44.520 --> 53:45.400
daha da geçerli.

53:46.520 --> 53:47.120
Arkadaşlar,

53:47.560 --> 53:48.900
birinciyle başlayalım.

53:48.900 --> 53:51.480
compile time recursive pack expansion.

53:52.460 --> 53:52.920
Burada,

53:53.960 --> 53:54.540
aslında,

53:55.700 --> 53:57.780
işin yapılması şöyle oluyor.

53:58.040 --> 53:58.740
Buraya dikkat.

54:00.360 --> 54:01.000
Hamlete,

54:01.620 --> 54:03.280
parametre paketinin dışında,

54:04.200 --> 54:06.400
bir template parametresi daha ekliyoruz.

54:07.320 --> 54:07.900
Type name,

54:08.400 --> 54:09.140
örneğin t,

54:09.720 --> 54:10.740
type name ps.

54:12.280 --> 54:13.480
Ve fonksiyona da,

54:14.200 --> 54:16.080
yine parametre paketinin dışında,

54:16.080 --> 54:18.180
bir parametre daha ekliyoruz.

54:18.180 --> 54:20.100
Arkadaşlar,

54:21.540 --> 54:23.880
şimdi bu durumda ne oluyor?

54:24.120 --> 54:25.040
Çok dikkatli izleyin.

54:25.800 --> 54:26.240
Örneğin,

54:26.660 --> 54:29.000
ben yukarıdaki print fonksiyonuna,

54:30.040 --> 54:30.400
2,

54:30.820 --> 54:32.120
5.6,

54:33.600 --> 54:34.080
efendim,

54:34.320 --> 54:34.860
Alihan,

54:37.360 --> 54:39.700
link başlık tasasını da dahil etmiş olalım.

54:39.700 --> 54:40.480
ve,

54:40.480 --> 54:45.180
diyelim ki,

54:45.180 --> 54:46.400
stotstring,

54:47.400 --> 54:50.600
name,

54:51.600 --> 54:54.540
Oğuzhan,

54:57.060 --> 54:58.360
böyle bir çağrı yaptığımda,

54:58.580 --> 54:59.980
herkes çok dikkatli izlesin.

55:01.780 --> 55:02.300
Arkadaşlar,

55:02.380 --> 55:03.040
söyleyin bakalım,

55:03.540 --> 55:04.800
fonksiyona gönderdiğim,

55:04.880 --> 55:05.800
birinci argüman,

55:05.800 --> 55:07.020
kime gidecek?

55:08.120 --> 55:08.440
Neço,

55:08.960 --> 55:09.900
birinci argüman,

55:10.360 --> 55:12.380
fonksiyonun birinci parametresine gidecek.

55:13.580 --> 55:14.320
Bu durumda,

55:14.560 --> 55:15.540
ben bu fonksiyona,

55:15.780 --> 55:17.800
3 tane argümanla çağrı yaptığımda,

55:19.160 --> 55:20.000
dikkatli izleyin,

55:20.800 --> 55:22.040
parametre paketinde,

55:22.840 --> 55:24.260
kaç tane parametre olacak?

55:24.260 --> 55:25.840
Cevap,

55:26.520 --> 55:27.980
3 tane parametre olacak.

55:28.220 --> 55:28.760
Öyle değil mi?

55:29.780 --> 55:30.140
Peki,

55:31.140 --> 55:32.980
burada ben herhangi bir şekilde,

55:34.080 --> 55:34.540
yine,

55:35.080 --> 55:36.620
print ismini kullanarak,

55:37.560 --> 55:40.240
bir fonksiyon çağrısını yaparken,

55:40.540 --> 55:41.760
buraya çok dikkatli izleyin,

55:42.760 --> 55:43.860
print çağrısını,

55:44.220 --> 55:45.540
bu şekilde yaparsam,

55:46.240 --> 55:46.640
bu sefer,

55:46.760 --> 55:47.900
parametre paketini,

55:48.340 --> 55:49.560
expand etmiş olurum,

55:49.620 --> 55:49.920
değil mi?

55:51.180 --> 55:51.500
Peki,

55:52.260 --> 55:54.120
fonksiyonun kodu sadece bu kadar demiyorum.

55:54.660 --> 55:56.240
Kilit noktayı anlamanızı istiyorum.

55:57.200 --> 55:57.720
O zaman,

55:58.760 --> 56:00.740
ilk çağrılan print fonksiyonu,

56:01.280 --> 56:03.460
ikinci çağrılan print fonksiyonunu,

56:03.860 --> 56:06.100
bir eksik argümanla çağırmış olacak,

56:06.220 --> 56:06.480
değil mi?

56:07.700 --> 56:08.520
Burayı anladık mı?

56:09.160 --> 56:09.380
Evet.

56:10.000 --> 56:10.320
Bravo.

56:10.320 --> 56:11.200
Alian diyor ki,

56:11.280 --> 56:12.220
her seferinde,

56:12.800 --> 56:14.120
paketten biri ayrılıyor.

56:14.900 --> 56:15.420
Arkadaşlar,

56:15.480 --> 56:16.820
bir şey dikkatinizi çekiyor mu?

56:17.140 --> 56:18.060
Bu durumda,

56:18.780 --> 56:20.220
burada çağrılan print fonksiyonu,

56:20.220 --> 56:20.920
anlayacaksınız,

56:21.000 --> 56:22.060
çağrı hiç merak etmeyin.

56:22.580 --> 56:24.240
Burada çağrılan print fonksiyonu,

56:25.240 --> 56:26.040
buraya dikkat.

56:29.180 --> 56:31.380
Aynı print fonksiyonu değil,

56:32.000 --> 56:32.640
öyle değil mi?

56:33.520 --> 56:34.860
Çünkü her defasında,

56:35.860 --> 56:37.320
buradaki print çağrısında,

56:37.400 --> 56:38.640
bir argüman eksilecek.

56:38.640 --> 56:40.020
dolayısıyla,

56:40.160 --> 56:42.420
burada compile time'daki recursive t'yi,

56:43.060 --> 56:44.000
durduracak,

56:44.360 --> 56:46.140
bir mekanizmaya ihtiyacımız var.

56:47.180 --> 56:47.560
Bunun için,

56:47.680 --> 56:49.320
farklı teknikler kullanılabilir.

56:49.520 --> 56:51.200
Ama en çok kullanılan teknik,

56:52.480 --> 56:53.720
bir parametre için,

56:54.200 --> 56:55.760
ayrı bir fonksiyon yazmak,

56:56.560 --> 56:57.720
ve print fonksiyonu,

56:57.800 --> 56:58.160
örneğin,

56:58.480 --> 57:00.300
tek parametre ile çağrıldığında,

57:00.300 --> 57:01.720
artık,

57:01.720 --> 57:01.900
artık,

57:02.580 --> 57:03.120
bizim,

57:03.520 --> 57:05.400
parametre paketine sahip,

57:05.640 --> 57:06.920
template'ten değil de,

57:07.920 --> 57:08.260
template,

57:08.840 --> 57:09.840
başka bir template'ten,

57:09.900 --> 57:11.480
ya da başka bir fonksiyondan,

57:11.620 --> 57:12.620
kodun oluşturulması.

57:12.760 --> 57:13.080
Çağrı,

57:13.140 --> 57:14.080
şimdi anlayacaksınız.

57:14.720 --> 57:15.220
Bakın şimdi,

57:15.860 --> 57:17.020
başlangıçta da uyardım,

57:17.020 --> 57:17.740
tabii ki,

57:18.300 --> 57:19.800
anlamak çok kolay olmayabilir.

57:20.000 --> 57:20.220
Ama,

57:20.460 --> 57:22.020
bir kere işin içine girdiğimizde,

57:22.560 --> 57:22.900
artık,

57:23.020 --> 57:23.380
gerisi,

57:23.660 --> 57:24.400
çok kolay olacak.

57:25.200 --> 57:25.720
Arkadaşlar,

57:25.780 --> 57:26.340
şimdi bakınız,

57:26.880 --> 57:29.020
buradaki print fonksiyon şablonuna bakın,

57:30.080 --> 57:32.060
ve yukarıdaki print template'ine bakın.

57:32.760 --> 57:34.620
Şimdi soruma cevap vermeye çalışın.

57:35.540 --> 57:38.460
15. satırda yapılan print çağrısı,

57:39.560 --> 57:40.820
bu template'e mi ilişkin,

57:40.820 --> 57:42.460
yukarıdaki template'e mi ilişkin?

57:43.540 --> 57:45.560
Cevap yukarıdaki çağrı,

57:45.600 --> 57:45.960
bravo.

57:45.960 --> 57:47.460
O zaman,

57:48.240 --> 57:52.220
ben 25. satırda print fonksiyonunu çağırdığımda,

57:53.540 --> 57:55.880
birden fazla argüman gönderdiğime göre,

57:56.320 --> 57:58.280
buradan bir fonksiyon yazılacak değil mi?

57:59.480 --> 58:00.960
Buradan yazılacak fonksiyonda,

58:02.120 --> 58:02.460
x,

58:03.240 --> 58:05.560
fonksiyonun birinci parametresine gidecek,

58:06.780 --> 58:06.980
d,

58:07.740 --> 58:10.060
long ve necati string literali,

58:10.840 --> 58:13.300
fonksiyonun parametre paketine gidecek.

58:14.600 --> 58:14.960
Dolayısıyla,

58:14.960 --> 58:18.000
derleyicinin yazdığı fonksiyonun da,

58:19.000 --> 58:20.000
burada çağrılan,

58:20.320 --> 58:21.220
aslında yukarıdaki fonksiyon,

58:22.220 --> 58:23.980
ilk argümanı yazdıracak,

58:24.880 --> 58:27.220
ve burada da pack expansion olduğunda,

58:28.080 --> 58:29.220
bu sefer de pack expansion'da,

58:30.520 --> 58:31.000
aslında,

58:31.620 --> 58:32.800
şu üç değeri olacak.

58:33.060 --> 58:33.600
Öyle değil mi?

58:34.380 --> 58:35.420
Takip edebiliyor muyuz?

58:36.100 --> 58:36.400
Evet.

58:36.400 --> 58:37.440
anlaşıldı mı?

58:37.440 --> 58:38.500
Anlaşıldı mı?

58:38.500 --> 58:39.100
Evet.

58:39.600 --> 58:41.940
Bu durumda çağrılan print fonksiyonu da,

58:42.940 --> 58:45.520
yine gönderilen ilk argümanı,

58:45.780 --> 58:47.340
birinci parametre alacak,

58:48.300 --> 58:50.340
ama diğer argümanları bu olacak.

58:50.660 --> 58:51.380
Ne zaman ki,

58:51.440 --> 58:52.160
buraya dikkat,

58:52.600 --> 58:52.960
arkadaşlar,

58:52.960 --> 58:55.160
ne zaman ki,

58:56.160 --> 58:56.620
burada,

58:57.000 --> 58:57.800
pakette,

58:58.420 --> 58:59.000
bir tane,

59:00.000 --> 59:02.140
argüman kaldı,

59:03.140 --> 59:04.280
takip edebiliyor muyuz?

59:05.140 --> 59:05.800
Onu da,

59:06.000 --> 59:07.880
en son çağrılan,

59:08.280 --> 59:10.220
print fonksiyonu yazdıracak.

59:10.220 --> 59:11.620
Çünkü,

59:12.040 --> 59:13.220
parametre paketini,

59:13.480 --> 59:14.740
patlattığımız zaman,

59:15.740 --> 59:16.860
bir tane sadece,

59:17.340 --> 59:18.340
print fonksiyonu,

59:19.240 --> 59:20.360
bir parametre ile,

59:20.420 --> 59:22.140
print fonksiyonunu çağırmış olacağız.

59:22.400 --> 59:22.780
O da,

59:23.380 --> 59:24.760
buradaki fonksiyonu çağıracak.

59:25.360 --> 59:25.540
Şimdi,

59:25.620 --> 59:26.700
başlangıçta zor olabilir.

59:27.040 --> 59:27.280
Önce,

59:27.460 --> 59:28.040
gerçekten,

59:28.340 --> 59:29.340
çalışmasına bakalım.

59:30.720 --> 59:31.300
Ama şimdi,

59:31.760 --> 59:32.540
eğer kafanızda,

59:32.720 --> 59:33.860
kurulayamadıysanız,

59:34.200 --> 59:35.420
ben size bir şey göstereyim.

59:36.040 --> 59:36.580
Bakın bakın,

59:36.960 --> 59:37.800
çok dikkatli izleyin.

59:38.620 --> 59:39.320
Şimdi ben,

59:39.320 --> 59:41.740
print fonksiyonu şablonu içinde,

59:42.400 --> 59:43.000
en sonunda,

59:43.120 --> 59:44.820
iki kere üstteki print'e çağrı oluyor.

59:44.940 --> 59:45.140
Bravo.

59:45.860 --> 59:46.400
Arkadaşlar,

59:46.480 --> 59:46.800
bakınız,

59:47.380 --> 59:49.120
print fonksiyonu şablonu içinde,

59:50.080 --> 59:50.520
stut,

59:51.280 --> 59:51.960
see out,

59:54.400 --> 59:54.960
underscore,

59:55.120 --> 59:55.640
underscore,

59:56.500 --> 59:56.880
punk,

59:57.880 --> 59:58.420
signature,

01:00:01.620 --> 01:00:02.060
new line.

01:00:04.880 --> 01:00:06.300
Takip edebiliyor muyuz?

01:00:07.180 --> 01:00:07.480
Evet.

01:00:09.320 --> 01:00:11.320
ve,

01:00:11.320 --> 01:00:13.920
yukarıdaki print fonksiyonunun,

01:00:14.000 --> 01:00:15.940
içindeki yazdırmayı da iptal ediyorum.

01:00:17.680 --> 01:00:19.100
Buraya kadar anlaşıldı mı?

01:00:19.600 --> 01:00:20.080
Bakın şimdi,

01:00:20.400 --> 01:00:21.000
derliyorum,

01:00:22.960 --> 01:00:23.820
çalıştırıyorum,

01:00:24.980 --> 01:00:25.400
arkadaşlar,

01:00:27.140 --> 01:00:27.380
ve,

01:00:27.940 --> 01:00:28.940
ekran çıktısına,

01:00:29.200 --> 01:00:30.260
bir bakmanızı istiyorum.

01:00:30.480 --> 01:00:30.700
Bakın,

01:00:30.880 --> 01:00:31.660
ilk çağrılan,

01:00:32.020 --> 01:00:32.520
printte,

01:00:32.520 --> 01:00:36.520
dört tane template argümanı var.

01:00:37.600 --> 01:00:38.140
Birincisi,

01:00:38.220 --> 01:00:39.980
birinci template parametresine gitti.

01:00:40.480 --> 01:00:41.420
Diğer üçü,

01:00:42.100 --> 01:00:43.380
parametre paketine gitti.

01:00:44.800 --> 01:00:45.060
Fakat,

01:00:45.260 --> 01:00:47.260
ikinci kez çağrılan print fonksiyonu,

01:00:47.300 --> 01:00:48.700
aynı print fonksiyonu değil.

01:00:48.700 --> 01:00:50.800
Bu sefer,

01:00:51.160 --> 01:00:53.140
üç tane template parametresi var.

01:00:54.240 --> 01:00:54.720
Birinci,

01:00:54.960 --> 01:00:57.100
birinci template parametresine gitti.

01:00:57.540 --> 01:00:58.900
Diğer ikisi pakete gitti.

01:01:00.280 --> 01:01:01.980
Ve son kez çağrıldığında,

01:01:03.100 --> 01:01:03.700
Alihan'ın,

01:01:03.900 --> 01:01:06.020
saplamasının doğru olduğunu görüyorsunuz.

01:01:06.820 --> 01:01:07.300
Bakın,

01:01:07.660 --> 01:01:09.440
iki tane template argümanı var.

01:01:09.660 --> 01:01:10.280
Biri long,

01:01:10.840 --> 01:01:11.280
arkadaşlar,

01:01:12.200 --> 01:01:12.480
biri,

01:01:12.880 --> 01:01:14.060
yedi elemanlı,

01:01:14.440 --> 01:01:15.580
çar dizi.

01:01:15.580 --> 01:01:17.620
takip edebiliyor muyuz?

01:01:17.940 --> 01:01:18.240
Ve,

01:01:19.540 --> 01:01:20.720
en son çağrı,

01:01:20.820 --> 01:01:22.620
print fonksiyonunda böyle yapıldı ya,

01:01:23.840 --> 01:01:24.440
o zaman,

01:01:25.080 --> 01:01:25.560
buradaki,

01:01:26.200 --> 01:01:27.060
kime gidecek?

01:01:27.380 --> 01:01:28.060
Arkadaşlar,

01:01:28.760 --> 01:01:29.920
yukarıdaki printe,

01:01:31.140 --> 01:01:32.260
parametre paketinde,

01:01:32.500 --> 01:01:33.380
bir tane olacak.

01:01:34.480 --> 01:01:35.660
Bir tane olduğu için,

01:01:36.000 --> 01:01:36.840
açıldığında,

01:01:36.840 --> 01:01:39.040
sadece ve sadece bir tane olduğu için,

01:01:39.120 --> 01:01:40.040
bu da buna gidecek.

01:01:40.960 --> 01:01:41.640
Anlaşıldı mı?

01:01:42.620 --> 01:01:43.680
Ama bu kurguyu,

01:01:44.040 --> 01:01:44.840
bu recursive kurguyu,

01:01:45.580 --> 01:01:47.760
farklı şekillerde de yapabilirdim.

01:01:47.880 --> 01:01:49.020
Şimdi başka bir örnek.

01:01:49.820 --> 01:01:50.340
İzleyin.

01:01:52.060 --> 01:01:53.080
Genel mantık aynı.

01:01:54.280 --> 01:01:55.860
Abdülkadir anlaşıldı ama,

01:01:56.200 --> 01:01:57.000
şöyle söyleyelim,

01:01:57.240 --> 01:01:58.120
biraz belki,

01:01:59.060 --> 01:02:00.120
alıştırma yapmak,

01:02:00.360 --> 01:02:01.160
iyi fikir olabilir.

01:02:02.340 --> 01:02:02.820
Arkadaşlar,

01:02:02.880 --> 01:02:03.360
bu sefer,

01:02:04.200 --> 01:02:05.160
değiştirdim.

01:02:05.380 --> 01:02:05.600
Bakın,

01:02:05.680 --> 01:02:05.960
bakın,

01:02:06.760 --> 01:02:07.860
bu örnek daha da güzel.

01:02:07.860 --> 01:02:08.380
Hatta,

01:02:08.520 --> 01:02:10.060
hepsini sileyim.

01:02:13.060 --> 01:02:13.920
Şimdi bakın,

01:02:13.980 --> 01:02:14.760
bu daha da şık.

01:02:15.580 --> 01:02:17.000
herkes dikkatli izliyor.

01:02:18.260 --> 01:02:20.540
Fonksiyonu bu şekilde çağırdığım zaman,

01:02:21.940 --> 01:02:23.940
yine ilk yapılan çağrı,

01:02:24.160 --> 01:02:25.300
bu template'e ilişkin.

01:02:26.300 --> 01:02:27.080
Ne zamanki,

01:02:27.380 --> 01:02:28.680
print fonksiyonu,

01:02:28.760 --> 01:02:30.460
iki parametre ile çağrılacak,

01:02:31.080 --> 01:02:33.020
o zaman yukarıdaki template kullanılacak.

01:02:34.700 --> 01:02:35.320
Arkadaşlar,

01:02:35.400 --> 01:02:36.660
print ilk önce ne yapıyor?

01:02:36.660 --> 01:02:41.740
ikinci parametreyi yazdırıyor ve bir virgül koyuyor.

01:02:43.100 --> 01:02:44.280
Ondan sonra,

01:02:44.520 --> 01:02:45.240
ne yapıyor?

01:02:46.660 --> 01:02:49.220
Yine print fonksiyon şablonunda bir çağrı yapıyor.

01:02:49.720 --> 01:02:51.380
Orada pack expansion kullanılmış.

01:02:52.700 --> 01:02:53.740
Takip edebiliyor muyuz?

01:02:54.200 --> 01:02:54.420
Evet.

01:02:54.420 --> 01:02:58.000
Böylece argümanlar sırayla yazdırılıyor.

01:02:58.920 --> 01:02:59.380
Fakat,

01:02:59.380 --> 01:03:00.860
ne zaman ki,

01:03:01.660 --> 01:03:02.920
parametre paketinde,

01:03:03.080 --> 01:03:05.460
sadece bir tane parametre kalacak,

01:03:06.920 --> 01:03:07.640
bu durumda,

01:03:07.840 --> 01:03:08.880
parametre paketi,

01:03:09.200 --> 01:03:10.540
ekspant edildiğinde,

01:03:11.460 --> 01:03:14.280
burada tek bir argüman olduğu için,

01:03:14.920 --> 01:03:15.700
bu sefer yine,

01:03:16.060 --> 01:03:18.640
yukarıdaki fonksiyondan yazılmış olacak.

01:03:19.580 --> 01:03:20.360
Anlaşıldı değil mi?

01:03:20.460 --> 01:03:21.260
Öyle ya da böyle,

01:03:21.260 --> 01:03:23.140
bir neye ihtiyacımız var?

01:03:24.440 --> 01:03:25.160
Arkadaşlar,

01:03:25.320 --> 01:03:25.860
eksilte,

01:03:25.980 --> 01:03:27.020
eksilte bir yerde,

01:03:27.160 --> 01:03:29.640
recursivity'yi durdurmamız gerekiyor.

01:03:30.440 --> 01:03:31.040
Mesela bakın,

01:03:31.120 --> 01:03:31.580
çok şık,

01:03:31.880 --> 01:03:32.780
birkaç örnek daha.

01:03:34.020 --> 01:03:35.800
Bazıları biraz daha karmaşık olabilir.

01:03:36.840 --> 01:03:37.580
Bu örneğe bakın.

01:03:39.020 --> 01:03:40.700
Aslında buradaki fonksiyon,

01:03:41.480 --> 01:03:43.780
kendisine gönderilen argümanların,

01:03:44.580 --> 01:03:46.520
en büyüğünü hesaplamaya yönelik.

01:03:47.780 --> 01:03:49.240
Yani bu şekilde çağırdığımda,

01:03:49.340 --> 01:03:50.920
en büyük değer olan dördü,

01:03:51.260 --> 01:03:53.260
bu şekilde çağırdığımda,

01:03:53.380 --> 01:03:55.700
en büyük değer olan 5.1'i döndürüyor.

01:03:56.640 --> 01:03:57.580
Doğru çalışıyor inşallah.

01:04:01.640 --> 01:04:03.580
Bir argüman daha ekleyelim.

01:04:04.260 --> 01:04:05.220
8.2.

01:04:05.420 --> 01:04:07.560
Şimdi 8.2 döndürmesi gerekiyor.

01:04:11.160 --> 01:04:11.900
Arkadaşlar,

01:04:11.980 --> 01:04:14.020
yine max isimli iki tane template var.

01:04:14.020 --> 01:04:16.400
fonksiyonun,

01:04:16.400 --> 01:04:18.360
iki tane çağrılan fonksiyonun,

01:04:18.460 --> 01:04:20.180
iki tane parametresi olduğunda,

01:04:20.540 --> 01:04:21.800
bu template kullanılacak.

01:04:22.880 --> 01:04:24.720
İkiden fazla parametresi olduğunda,

01:04:24.800 --> 01:04:25.920
bu template kullanılacak.

01:04:26.980 --> 01:04:28.080
Takip edebiliyor muyuz?

01:04:28.080 --> 01:04:30.200
ne zaman ki,

01:04:31.200 --> 01:04:33.400
şuradaki max çağrısı,

01:04:33.860 --> 01:04:34.300
arkadaşlar,

01:04:36.640 --> 01:04:39.300
parametre paketinde,

01:04:40.300 --> 01:04:41.540
iki tane argüman,

01:04:41.860 --> 01:04:42.540
kaldığında,

01:04:42.820 --> 01:04:43.840
ekspant edildi,

01:04:45.080 --> 01:04:45.680
o zaman,

01:04:46.240 --> 01:04:48.080
dışarıdaki max çağrısı,

01:04:48.580 --> 01:04:49.640
o da iki argümanla,

01:04:49.740 --> 01:04:50.680
çağrılmış olacak.

01:04:50.680 --> 01:04:52.820
o da,

01:04:53.020 --> 01:04:54.520
yine yukarıdaki template'ten,

01:04:55.100 --> 01:04:55.580
onların,

01:04:56.020 --> 01:04:56.740
büyük olanını,

01:04:57.140 --> 01:04:57.820
döndürecek.

01:05:00.360 --> 01:05:01.080
Mesela,

01:05:01.140 --> 01:05:01.900
bu da çok güzel.

01:05:02.100 --> 01:05:02.800
İzleyin şimdi,

01:05:03.400 --> 01:05:04.840
hoşunuza gidecek bir başka örnek.

01:05:04.980 --> 01:05:05.860
Ama hepsi bunların,

01:05:06.300 --> 01:05:07.760
sonuçta aynı tekniği kullanıyor.

01:05:08.480 --> 01:05:09.760
Bu da çok klasik bir örnek.

01:05:10.940 --> 01:05:11.520
Bakın şimdi,

01:05:14.080 --> 01:05:14.700
bu sefer,

01:05:15.180 --> 01:05:15.720
amaç,

01:05:16.100 --> 01:05:17.500
argümanları toplamak.

01:05:18.660 --> 01:05:18.980
Yani,

01:05:19.160 --> 01:05:20.480
summer isimli fonksiyon,

01:05:20.680 --> 01:05:21.800
yaz anlamında değil,

01:05:21.880 --> 01:05:22.880
toplayıcı anlamında.

01:05:24.080 --> 01:05:25.920
Kaç tane argüman gönderirsem,

01:05:26.440 --> 01:05:27.980
onların toplam değerini,

01:05:28.440 --> 01:05:28.940
döndürüyor.

01:05:30.180 --> 01:05:31.260
Ama tabii ki,

01:05:31.720 --> 01:05:31.960
bu,

01:05:32.660 --> 01:05:34.500
fonksiyon şablonu olduğu için,

01:05:35.400 --> 01:05:36.200
parametreler,

01:05:36.360 --> 01:05:37.000
her defasında,

01:05:37.140 --> 01:05:38.620
aynı türden olmak zorunda değil.

01:05:38.740 --> 01:05:38.960
Mesela,

01:05:39.080 --> 01:05:40.320
stringler de toplanır.

01:05:41.120 --> 01:05:42.680
Stringle c string toplanır.

01:05:42.760 --> 01:05:44.100
Tam sayılar toplanır.

01:05:45.280 --> 01:05:45.800
Arkadaşlar,

01:05:45.880 --> 01:05:46.260
bakınız,

01:05:47.400 --> 01:05:48.360
fonksiyonun,

01:05:48.680 --> 01:05:49.000
kodu,

01:05:49.280 --> 01:05:49.460
bu,

01:05:49.780 --> 01:05:50.660
daha da kolay anlaşılır.

01:05:50.680 --> 01:05:51.080
açılabilir.

01:05:52.080 --> 01:05:52.800
Aslında,

01:05:53.320 --> 01:05:54.960
bir return ifadesinden oluşuyor.

01:05:55.520 --> 01:05:57.080
İlk parametre artı,

01:05:58.380 --> 01:06:00.060
summer'a yapılan bir çağrı daha.

01:06:00.880 --> 01:06:01.540
Pack expansion.

01:06:01.540 --> 01:06:03.500
dolayısıyla,

01:06:03.500 --> 01:06:03.940
dolayısıyla yine,

01:06:04.940 --> 01:06:06.540
summer'ı ilk kez çağrıldığında,

01:06:07.500 --> 01:06:09.440
pakette dört tane argüman var.

01:06:10.640 --> 01:06:12.620
İkincide üç tane argüman var.

01:06:13.100 --> 01:06:14.480
İki tane argüman var.

01:06:15.320 --> 01:06:15.860
Buraya dikkat,

01:06:16.000 --> 01:06:17.340
bir tane argüman var.

01:06:18.380 --> 01:06:20.540
Ne zamanki bir tane argüman var,

01:06:21.460 --> 01:06:22.000
o zaman,

01:06:22.520 --> 01:06:25.060
bu template'ten kod üretilmek yerine,

01:06:25.360 --> 01:06:27.660
yukarıdaki template'ten kod üretilecek değil mi?

01:06:27.660 --> 01:06:30.120
Herkes burayı anladı mı?

01:06:31.120 --> 01:06:34.800
Yukarıdaki template'te aldığı argümanı döndürdüğüne göre,

01:06:35.800 --> 01:06:38.340
o zaman pakette bir tane argüman kaldığında,

01:06:39.680 --> 01:06:41.340
summer'ın geri dönüş değeri,

01:06:41.520 --> 01:06:43.680
yukarıdaki fonksiyonun geri dönüş değeri,

01:06:43.800 --> 01:06:45.200
yani argümanın kendisi.

01:06:45.200 --> 01:06:48.620
Burada da durdurucu mekanizma olarak,

01:06:48.940 --> 01:06:49.840
base case olarak,

01:06:50.080 --> 01:06:52.180
bu template'in kullanıldığını görüyorsunuz.

01:06:53.400 --> 01:06:54.260
Anlaşıldı mı?

01:06:55.460 --> 01:06:55.720
Evet.

01:06:56.340 --> 01:06:57.620
Şimdi bu birinci teknik.

01:06:57.800 --> 01:06:59.340
Örnekleri çoğaltmak mümkün.

01:07:00.320 --> 01:07:01.400
STL'e geldiğimizde,

01:07:01.500 --> 01:07:02.980
daha güzel örnekler de vereceğim.

01:07:03.700 --> 01:07:04.840
Yani bu tekniklerin,

01:07:05.440 --> 01:07:07.140
hepsinin ortak özelliği,

01:07:07.980 --> 01:07:08.580
eksiltme.

01:07:08.700 --> 01:07:09.880
Ben eksiltme diyorum.

01:07:09.880 --> 01:07:14.880
Yani aynı parametre paketine sahip fonksiyon şablonundan,

01:07:16.260 --> 01:07:20.180
her defasında bir fonksiyon çağrısı oluşturmak,

01:07:20.440 --> 01:07:21.900
ayrı bir imzaya sahip,

01:07:22.700 --> 01:07:24.340
ama parametre paketinden,

01:07:25.040 --> 01:07:26.240
Alihan'ın dediği gibi,

01:07:27.100 --> 01:07:28.880
argümanları birer birer azaltmak,

01:07:30.080 --> 01:07:32.880
ve sonunda da bir base case oluşturmak.

01:07:32.880 --> 01:07:37.820
Ama ilginç bir ikinci teknik daha var.

01:07:38.780 --> 01:07:39.980
Burayı çok dikkatli izleyelim.

01:07:40.080 --> 01:07:41.780
Şimdi burası kafa karıştırışa.

01:07:42.560 --> 01:07:43.240
Arkadaşlar,

01:07:43.660 --> 01:07:45.660
şimdi C kursuna katılmayan,

01:07:46.180 --> 01:07:47.360
epey bir arkadaşım var.

01:07:48.200 --> 01:07:49.340
Ama katılanlar da var.

01:07:49.480 --> 01:07:52.700
Ama kursa katılmadan da çok iyi C'yi öğrenenler de var.

01:07:54.860 --> 01:07:55.420
Söyleyin,

01:07:56.260 --> 01:07:58.980
C'nin en çok aşağılanan,

01:07:59.440 --> 01:08:00.300
fakir görülen,

01:08:00.540 --> 01:08:01.580
operatörü hangisi?

01:08:01.580 --> 01:08:04.700
Bana bu soru sorulsaydı,

01:08:05.100 --> 01:08:05.960
derdim ki,

01:08:06.480 --> 01:08:07.840
comma operator,

01:08:08.120 --> 01:08:09.240
go to operatör değil,

01:08:09.340 --> 01:08:10.580
go to bir kontrol deyimi.

01:08:11.720 --> 01:08:13.320
Comma operator,

01:08:14.460 --> 01:08:17.820
yani Türkçesiyle virgül operatörü.

01:08:18.880 --> 01:08:19.380
Arkadaşlar,

01:08:19.460 --> 01:08:21.000
şimdi C++'a gelenler,

01:08:21.100 --> 01:08:22.680
C'den virgül operatörünü,

01:08:22.680 --> 01:08:24.640
iyi öğrenmemiş oluyorlar.

01:08:24.780 --> 01:08:26.380
O yüzden ben virgül operatörünü,

01:08:26.500 --> 01:08:28.420
önce 3 dakika özetleyeceğim.

01:08:28.820 --> 01:08:29.520
5 dakika değil,

01:08:29.620 --> 01:08:30.140
3 dakika.

01:08:30.140 --> 01:08:32.380
geçersen 3 dakikayı,

01:08:32.440 --> 01:08:33.420
ceza yiyeceksin diyeceğim.

01:08:33.500 --> 01:08:33.700
Tamam.

01:08:34.700 --> 01:08:35.320
Arkadaşlar,

01:08:35.820 --> 01:08:36.680
virgül operatörü,

01:08:36.720 --> 01:08:37.440
bir operatör.

01:08:38.540 --> 01:08:39.400
Yani örneğin,

01:08:39.940 --> 01:08:40.360
eğer,

01:08:41.060 --> 01:08:42.980
comma separated list değilse,

01:08:43.100 --> 01:08:44.640
çünkü her virgül operatör değil,

01:08:45.640 --> 01:08:46.760
virgül operatörü,

01:08:46.940 --> 01:08:48.760
nasıl toplama bir operatörse,

01:08:48.860 --> 01:08:50.240
çarpma bir operatörse,

01:08:50.940 --> 01:08:51.780
virgül operatör,

01:08:51.920 --> 01:08:53.380
operatörü de bir operatör.

01:08:53.380 --> 01:08:55.400
gelin önce virgül operatörünü,

01:08:55.480 --> 01:08:56.420
çok kısa konuşalım.

01:08:57.620 --> 01:08:58.280
Arkadaşlar,

01:08:59.520 --> 01:09:00.060
izleyin,

01:09:00.060 --> 01:09:01.800
virgül operatörü,

01:09:02.680 --> 01:09:03.980
binary bir operatör.

01:09:04.300 --> 01:09:05.840
Binary infix bir operatör.

01:09:06.760 --> 01:09:06.980
Bu,

01:09:07.400 --> 01:09:08.320
sol operandı,

01:09:08.380 --> 01:09:09.600
bu da sağ operandı.

01:09:10.340 --> 01:09:10.580
Bakın,

01:09:10.660 --> 01:09:10.880
bakın,

01:09:11.880 --> 01:09:12.260
mesela,

01:09:12.760 --> 01:09:13.080
burada,

01:09:13.620 --> 01:09:15.580
x ve y değişkenleri olmak üzere,

01:09:15.820 --> 01:09:16.620
x virgül y,

01:09:16.620 --> 01:09:20.220
x virgül operatörünün sol operandı,

01:09:20.300 --> 01:09:21.460
y sağ operandı.

01:09:22.500 --> 01:09:23.780
Virgül operatörünün,

01:09:23.860 --> 01:09:25.000
bize ilgilendiren,

01:09:25.240 --> 01:09:26.800
iki tane önemli özelliği var.

01:09:27.040 --> 01:09:27.640
Birincisi,

01:09:28.720 --> 01:09:30.000
virgül operatörünün,

01:09:30.160 --> 01:09:31.700
sequence pointı oluşturması.

01:09:32.560 --> 01:09:33.120
Bu ne demek?

01:09:34.440 --> 01:09:35.040
Örneğin,

01:09:36.520 --> 01:09:37.900
üç tane ifade eden,

01:09:38.380 --> 01:09:40.320
üç tane deyim yazmak yerine,

01:09:43.740 --> 01:09:46.080
sabırlı bir şekilde dinleyin izleme,

01:09:46.620 --> 01:09:47.540
mesela,

01:09:47.720 --> 01:09:48.880
şöyle yazmak yerine,

01:09:49.100 --> 01:09:49.980
artı artı x,

01:09:50.940 --> 01:09:51.880
artı artı y,

01:09:53.220 --> 01:09:54.200
artı artı z,

01:09:55.700 --> 01:09:56.280
bunları,

01:09:56.840 --> 01:09:58.160
virgül operatörünün,

01:09:58.240 --> 01:09:59.220
operandı olan,

01:09:59.520 --> 01:10:00.920
ifadeler yaparsam,

01:10:02.000 --> 01:10:03.100
üç ifade yerine,

01:10:03.340 --> 01:10:05.080
bin ifade oluşturmuş oluyorum.

01:10:05.340 --> 01:10:05.620
Ama,

01:10:06.340 --> 01:10:08.580
virgül operatörü bana şu garanti veriyor,

01:10:09.320 --> 01:10:09.720
arkadaşlar,

01:10:10.660 --> 01:10:11.840
bir sequence point var.

01:10:11.940 --> 01:10:13.400
Sequence point olması ne demek?

01:10:14.260 --> 01:10:15.440
Önce bu yapılacak,

01:10:15.440 --> 01:10:18.920
bunun yan etkisi tamamlandıktan sonra,

01:10:19.160 --> 01:10:20.000
bu yapılacak,

01:10:20.860 --> 01:10:23.200
bunun yan etkisi tamamlandıktan sonra,

01:10:23.280 --> 01:10:23.920
bu yapılacak.

01:10:25.060 --> 01:10:25.680
Yani ne demek?

01:10:25.840 --> 01:10:26.280
Örneğin,

01:10:26.740 --> 01:10:28.860
virgül operatörünün operandıları,

01:10:30.340 --> 01:10:31.640
şöyle olsaydı,

01:10:32.640 --> 01:10:33.620
arkadaşlar,

01:10:33.620 --> 01:10:41.040
herhangi bir şekilde anlam yüklemeyin.

01:10:42.280 --> 01:10:43.740
Önce hangi işlem yapılacak?

01:10:44.460 --> 01:10:45.300
x arttırıldı.

01:10:46.560 --> 01:10:47.840
Tıpkı ayrı bir değinmiş gibi.

01:10:48.840 --> 01:10:49.040
Peki,

01:10:49.180 --> 01:10:50.520
buraya geldiğimizde,

01:10:50.920 --> 01:10:51.800
x'in değeri,

01:10:51.800 --> 01:10:56.800
x'in artık artmış değeri olma garantisi var mı?

01:10:57.280 --> 01:10:57.540
Cevap,

01:10:57.600 --> 01:10:58.240
kesinlikle.

01:10:59.500 --> 01:11:00.380
Yani artık burada,

01:11:00.520 --> 01:11:02.360
x değişkenlerinin değeri 11,

01:11:02.580 --> 01:11:03.200
10 değil.

01:11:04.000 --> 01:11:05.520
Tıpkı ayrı bir değinmiş gibi.

01:11:07.100 --> 01:11:07.800
Dolayısıyla,

01:11:08.520 --> 01:11:10.200
sequence point oluşturması,

01:11:10.200 --> 01:11:12.200
bu operatörün,

01:11:14.480 --> 01:11:16.540
evaluate edilmesinden sonraki,

01:11:16.660 --> 01:11:17.200
yan etkilerin,

01:11:18.340 --> 01:11:19.200
daha sağdaki operand,

01:11:20.100 --> 01:11:21.020
ele alındığında,

01:11:21.940 --> 01:11:24.480
artık etkisini göstermiş olması demek.

01:11:25.260 --> 01:11:26.160
Bu çok çok önemli.

01:11:26.840 --> 01:11:28.080
Burayı bir kere anladınız mı?

01:11:28.160 --> 01:11:30.200
C'de bu konuyu öğrenmeyen arkadaşlar,

01:11:30.380 --> 01:11:31.260
burayı anladınız mı?

01:11:32.080 --> 01:11:32.880
Mesela bakınız,

01:11:33.740 --> 01:11:34.560
başka bir örnek.

01:11:35.560 --> 01:11:35.940
İzir.

01:11:38.480 --> 01:11:39.120
Primtef,

01:11:39.120 --> 01:11:43.400
Ali,

01:11:45.500 --> 01:11:46.140
virgül,

01:11:47.660 --> 01:11:48.360
printf,

01:11:49.420 --> 01:11:49.760
Veli.

01:11:51.640 --> 01:11:54.180
Virgül operatörünün sağ operandı,

01:11:54.460 --> 01:11:56.640
sol operandı ve sağ operandı.

01:11:57.100 --> 01:11:59.440
Önce bu printf çağrısının,

01:12:00.120 --> 01:12:03.740
sonra bu printf çağrısının yapılması garanti altında mı?

01:12:05.080 --> 01:12:06.260
Evet ya da hayır diyeyim.

01:12:07.000 --> 01:12:07.360
Cevap,

01:12:07.360 --> 01:12:09.340
evet kesinlikle.

01:12:10.080 --> 01:12:11.020
Yani örneğin,

01:12:11.220 --> 01:12:13.260
önce standart alt kuta belli,

01:12:13.440 --> 01:12:16.140
sonra Ali yazması gibi bir ihtimal söz konusu mu?

01:12:16.900 --> 01:12:17.340
Asla.

01:12:18.000 --> 01:12:19.140
Takip edebiliyor musunuz?

01:12:19.420 --> 01:12:19.600
Evet.

01:12:19.600 --> 01:12:22.420
Birinci önemli özellik,

01:12:22.480 --> 01:12:25.840
virgül operatörünün bir sequence point oluşturması.

01:12:26.940 --> 01:12:28.540
Bundan faydalanacağız birazdan.

01:12:29.180 --> 01:12:29.480
İki,

01:12:31.420 --> 01:12:31.980
arkadaşlar,

01:12:32.660 --> 01:12:36.100
virgül operatörü de diğer operatörler gibi bir değer üretiyor.

01:12:37.320 --> 01:12:39.460
Virgül operatörünün ürettiği değer,

01:12:39.880 --> 01:12:41.240
sağ operandın değeri.

01:12:41.240 --> 01:12:42.920
yani,

01:12:43.560 --> 01:12:45.940
x virgül y ifadesinin değeri ne?

01:12:46.780 --> 01:12:48.980
Bu ifadenin türü ve değeri ne?

01:12:49.860 --> 01:12:50.420
Cevap,

01:12:51.060 --> 01:12:51.760
türü int,

01:12:52.160 --> 01:12:53.320
değeri 20.

01:12:54.180 --> 01:12:54.860
Mesela,

01:12:55.640 --> 01:12:58.120
benim üçüncü bir değişkenim daha olsa,

01:12:58.400 --> 01:12:59.520
buraya özellikle dikkat.

01:12:59.520 --> 01:13:01.380
ve ben

01:13:01.380 --> 01:13:05.440
böyle bir deyim oluştursam,

01:13:05.700 --> 01:13:08.240
niye böyle bir deyim oluşturduğumda uğraşmayın lütfen.

01:13:09.620 --> 01:13:10.880
z'ye kaç atılacak?

01:13:12.340 --> 01:13:12.860
Cevap,

01:13:16.740 --> 01:13:17.340
söyleyin,

01:13:17.800 --> 01:13:18.160
20,

01:13:18.840 --> 01:13:19.580
y'nin değeri.

01:13:20.540 --> 01:13:21.540
Gerçekten de,

01:13:21.900 --> 01:13:23.000
bakınız arkadaşlar,

01:13:23.920 --> 01:13:25.760
z'nin değerini yazdıracağım.

01:13:25.760 --> 01:13:29.180
ve z'nin değerinin

01:13:29.180 --> 01:13:31.040
20 olduğunu göreceksiniz.

01:13:33.180 --> 01:13:33.940
Peki,

01:13:34.520 --> 01:13:36.860
şimdi aynı z'ye bir atama daha yapalım.

01:13:38.080 --> 01:13:38.740
Ve bu sefer,

01:13:39.460 --> 01:13:42.140
y virgül x diyelim.

01:13:43.340 --> 01:13:45.220
Bu sefer de bu ifadenin değeri

01:13:45.220 --> 01:13:47.300
10 arkadaşlar.

01:13:49.640 --> 01:13:50.640
Hakim edebiliyor muyuz?

01:13:50.940 --> 01:13:51.100
Evet.

01:13:51.100 --> 01:13:53.600
Hayır,

01:13:53.720 --> 01:13:55.820
uneverlated konteks değil kesinlikle.

01:13:56.480 --> 01:13:57.500
Hepsine cevap vereceğim,

01:13:57.600 --> 01:13:58.220
merak etmeyin.

01:13:59.000 --> 01:13:59.520
Arkadaşlar,

01:13:59.580 --> 01:14:00.900
şimdi bir iki noktaya daha

01:14:00.900 --> 01:14:02.200
dikkat çekelim.

01:14:02.920 --> 01:14:03.180
Bakın,

01:14:03.260 --> 01:14:04.680
burada öncelik parantezi

01:14:04.680 --> 01:14:05.680
olmasaydı,

01:14:06.700 --> 01:14:08.600
virgül operatörünün önceliği

01:14:08.600 --> 01:14:10.400
atama operatöründen

01:14:10.400 --> 01:14:12.420
bile düşük.

01:14:13.200 --> 01:14:14.600
Dolayısıyla bu durumda,

01:14:15.660 --> 01:14:16.100
arkadaşlar,

01:14:16.100 --> 01:14:17.600
virgül operatörünün

01:14:17.600 --> 01:14:19.260
sol operandı z'ye eşittir.

01:14:19.260 --> 01:14:21.660
x sağ operandı y.

01:14:22.420 --> 01:14:23.820
Dolayısıyla ben,

01:14:24.340 --> 01:14:26.200
x virgül y ifadesinin

01:14:26.200 --> 01:14:26.920
değerinin

01:14:26.920 --> 01:14:28.800
atama operatörünün

01:14:28.800 --> 01:14:30.540
sağ operandı olması için

01:14:30.540 --> 01:14:32.140
ne yapmak zorundayım?

01:14:32.940 --> 01:14:33.980
Öncelik parantezi

01:14:33.980 --> 01:14:35.140
kullanmak zorundayım.

01:14:36.020 --> 01:14:36.700
Anlaşıldı mı?

01:14:37.500 --> 01:14:37.800
Evet.

01:14:39.080 --> 01:14:40.120
Dünkü arkadaşım,

01:14:40.620 --> 01:14:42.200
ben soruyu doğru anladıysam,

01:14:42.940 --> 01:14:43.980
şöyle bir ifade

01:14:43.980 --> 01:14:45.100
oluştursaydım,

01:14:45.100 --> 01:14:47.580
bu ifadede

01:14:47.580 --> 01:14:48.460
A,

01:14:49.060 --> 01:14:49.980
herhangi bir şekilde

01:14:49.980 --> 01:14:51.940
bir tanımsız davranış var mı?

01:14:52.740 --> 01:14:53.180
Cevap,

01:14:53.460 --> 01:14:53.720
hayır.

01:14:54.720 --> 01:14:55.040
B,

01:14:55.160 --> 01:14:56.420
x artacak mı?

01:14:56.900 --> 01:14:57.280
Cevap,

01:14:57.420 --> 01:14:57.780
evet.

01:14:58.820 --> 01:14:59.500
Virgül operatörünün

01:15:00.260 --> 01:15:01.380
sol operandı da,

01:15:01.500 --> 01:15:02.580
sağ operandı da

01:15:02.580 --> 01:15:04.180
evaluate ediliyor.

01:15:04.700 --> 01:15:05.060
Zaten,

01:15:05.440 --> 01:15:07.280
ondan faydalanacağız birazdan.

01:15:07.960 --> 01:15:08.760
Anlaşıldı değil mi?

01:15:08.760 --> 01:15:09.960
mesela,

01:15:10.640 --> 01:15:10.880
bakın,

01:15:10.940 --> 01:15:12.600
bu C'de o kadar şık

01:15:12.600 --> 01:15:13.940
hileler var ki

01:15:13.940 --> 01:15:15.380
virgül operatörüyle ilgili.

01:15:16.080 --> 01:15:16.900
Mesela bakınız,

01:15:17.640 --> 01:15:18.280
printf,

01:15:19.400 --> 01:15:19.900
alican,

01:15:20.640 --> 01:15:21.080
arkadaşlar.

01:15:22.200 --> 01:15:22.680
Soru,

01:15:23.340 --> 01:15:23.580
z,

01:15:23.820 --> 01:15:25.320
y'nin değeri atanacak

01:15:25.320 --> 01:15:26.420
ama

01:15:26.420 --> 01:15:28.160
standart output'a da

01:15:28.160 --> 01:15:29.700
alican yazacak mı?

01:15:30.120 --> 01:15:30.480
Cevap,

01:15:30.560 --> 01:15:30.820
evet.

01:15:31.560 --> 01:15:33.520
Unavaluated context olsaydı,

01:15:34.160 --> 01:15:35.660
alican yazma garantisi

01:15:35.660 --> 01:15:36.780
olmazdı.

01:15:38.760 --> 01:15:40.540
Takip edebildik mi?

01:15:41.040 --> 01:15:41.260
Evet.

01:15:41.400 --> 01:15:42.240
Şimdi yavaş yavaş

01:15:42.240 --> 01:15:43.880
konuya gireceğiz.

01:15:44.500 --> 01:15:44.720
Peki,

01:15:44.840 --> 01:15:45.340
soru

01:15:45.340 --> 01:15:46.240
arkadaşlar.

01:15:47.180 --> 01:15:47.740
İzleyin.

01:15:48.720 --> 01:15:50.280
Ben şöyle bir kod yazsam.

01:15:51.600 --> 01:15:52.140
Mesela,

01:15:52.680 --> 01:15:53.300
see out

01:15:53.300 --> 01:15:54.740
using

01:15:54.740 --> 01:15:55.640
varmış,

01:15:55.700 --> 01:15:55.840
evet.

01:15:56.320 --> 01:15:56.980
see out

01:15:56.980 --> 01:15:59.280
x

01:15:59.280 --> 01:16:00.820
arkadaşlar,

01:16:00.980 --> 01:16:01.580
virgül

01:16:01.580 --> 01:16:03.300
sıfır.

01:16:04.500 --> 01:16:04.920
Şimdi,

01:16:05.500 --> 01:16:06.400
bu bir ifade mi?

01:16:07.280 --> 01:16:07.620
Evet.

01:16:08.760 --> 01:16:11.260
bu bir ifade olduğuna göre,

01:16:11.600 --> 01:16:13.860
virgül operatörünün sol operandı değil mi?

01:16:14.860 --> 01:16:17.620
Çünkü virgül operatörü daha düşük önceliğe sahip.

01:16:18.920 --> 01:16:19.720
Dolayısıyla,

01:16:19.980 --> 01:16:22.620
tıpkı az önceki printf çağrısında olduğu gibi,

01:16:24.100 --> 01:16:24.460
burada,

01:16:25.320 --> 01:16:29.220
virgül operatörünün sol operandının evaluate edilmesi demek,

01:16:30.220 --> 01:16:30.820
bu işlemin,

01:16:30.920 --> 01:16:31.360
bu deyimin,

01:16:32.040 --> 01:16:33.520
bu ifadenin yürütülmesi demek.

01:16:33.520 --> 01:16:35.640
yani bu durumda,

01:16:36.200 --> 01:16:37.100
ben örneğin,

01:16:37.840 --> 01:16:39.540
böyle bir ifade yazarsam,

01:16:39.920 --> 01:16:40.340
arkadaşlar,

01:16:41.480 --> 01:16:44.120
virgül operatörünün sol operandı bu ifade,

01:16:44.260 --> 01:16:46.220
sağ operandı bu ifade olur değil mi?

01:16:46.740 --> 01:16:48.340
Burayı kaçırmamanız gerekiyor.

01:16:48.460 --> 01:16:48.700
Evet.

01:16:49.580 --> 01:16:50.100
O zaman,

01:16:50.520 --> 01:16:52.720
standart output örneğin 10 yazar mı?

01:16:52.720 --> 01:16:54.740
Cevap evet.

01:16:55.120 --> 01:16:55.620
Ama şimdi,

01:16:56.660 --> 01:16:58.520
ikinci soruya cevap vermeye çalışın.

01:16:58.660 --> 01:16:59.240
İkinci soru.

01:17:00.140 --> 01:17:00.520
Peki,

01:17:01.700 --> 01:17:03.320
bu ifadenin değeri ne?

01:17:06.860 --> 01:17:07.620
Cevap,

01:17:08.300 --> 01:17:08.820
sıfır.

01:17:09.620 --> 01:17:09.900
Peki,

01:17:10.580 --> 01:17:11.900
şimdi çok dikkatli izleyin.

01:17:12.860 --> 01:17:13.580
Diyelim ki,

01:17:14.060 --> 01:17:15.820
benim şöyle değişkenlerim olsa,

01:17:16.640 --> 01:17:17.820
nereden nereye geleceğiz?

01:17:17.820 --> 01:17:18.820
Çok şaşıracaksınız.

01:17:20.180 --> 01:17:22.380
Benim böyle değişkenlerim olsa,

01:17:22.720 --> 01:17:24.960
ben arkadaşlar,

01:17:26.240 --> 01:17:28.300
bunları örneğin parantez içine alsam

01:17:28.300 --> 01:17:34.220
ve bunları da virgül operatörünün operandı yapsam.

01:17:37.720 --> 01:17:38.280
Hatta,

01:17:39.240 --> 01:17:40.840
şöyle boşluk da olsun.

01:17:41.140 --> 01:17:41.320
Tamam.

01:17:41.320 --> 01:17:48.520
Bakın,

01:17:48.600 --> 01:17:50.000
buradaki virgül operatör.

01:17:50.320 --> 01:17:51.500
Ama şimdi dikkat edin.

01:17:52.340 --> 01:17:52.680
Eğer,

01:17:52.940 --> 01:17:54.760
benim bir dizim olsaydı,

01:17:56.540 --> 01:17:57.220
bu diziyi,

01:17:57.820 --> 01:17:59.240
initialize etseydim,

01:18:03.840 --> 01:18:04.440
arkadaşlar,

01:18:04.440 --> 01:18:24.520
Sadece soruya cevap vermeye çalışın.

01:18:24.660 --> 01:18:25.200
Soru,

01:18:26.060 --> 01:18:27.740
A dizisinin kaç elemanı var?

01:18:30.120 --> 01:18:30.700
Cevap,

01:18:30.760 --> 01:18:30.940
3.

01:18:30.940 --> 01:18:33.420
buradaki virgül operatör mü?

01:18:35.060 --> 01:18:36.300
Evet ya da hayır.

01:18:36.440 --> 01:18:36.620
Peki,

01:18:36.720 --> 01:18:38.200
buradaki virgül operatör mü?

01:18:39.180 --> 01:18:39.700
Cevap,

01:18:39.900 --> 01:18:40.180
hayır.

01:18:41.500 --> 01:18:43.040
Buradaki virgül operatör değil,

01:18:43.180 --> 01:18:44.120
buradaki virgül,

01:18:44.660 --> 01:18:46.680
comma separated listin virgülü.

01:18:46.680 --> 01:18:49.600
Ama şimdi soruya cevap vermeye çalışın.

01:18:50.460 --> 01:18:50.800
Peki,

01:18:51.440 --> 01:18:54.500
virgül operatörü sequence point oluşturduğuna göre,

01:18:55.880 --> 01:18:57.840
bu ifadenin yürütülmesi demek,

01:18:58.880 --> 01:19:01.980
önce bu ifadenin yürütülmesi demek değil mi?

01:19:02.080 --> 01:19:04.700
Sol operandan önce yürütülme garantisi vardı ya,

01:19:05.720 --> 01:19:09.120
o zaman bu diziye bu şekilde ilk değer verdiğimde,

01:19:10.180 --> 01:19:12.680
x'in, y'nin ve z'nin de değerleri,

01:19:12.680 --> 01:19:18.020
standart output'a yazdırılır desem katılır mısınız?

01:19:18.860 --> 01:19:19.560
Cevap,

01:19:19.620 --> 01:19:19.840
evet.

01:19:20.840 --> 01:19:21.140
Evet.

01:19:21.980 --> 01:19:22.400
Bakın.

01:19:24.960 --> 01:19:26.140
Şimdi o zaman,

01:19:26.680 --> 01:19:27.460
gelelim,

01:19:28.640 --> 01:19:31.780
variadic parametre paketinde bunu nasıl kullanacağımıza.

01:19:33.140 --> 01:19:33.960
Arkadaşlar,

01:19:34.040 --> 01:19:36.360
şöyle bir parametre paketi olsa,

01:19:37.000 --> 01:19:38.660
template parametre paketi olsa,

01:19:39.900 --> 01:19:40.340
void,

01:19:40.960 --> 01:19:41.360
print.

01:19:41.360 --> 01:19:43.740
const,

01:19:44.280 --> 01:19:44.760
ts,

01:19:46.040 --> 01:19:46.520
ref,

01:19:48.520 --> 01:19:49.040
arcs.

01:19:52.360 --> 01:19:54.040
Şimdi çok şaşıracaksınız.

01:19:55.300 --> 01:19:57.320
Az önce yaptığımı buraya yazıyorum.

01:19:57.620 --> 01:19:58.500
Stociao,

01:19:58.740 --> 01:20:00.360
arkadaşlar,

01:20:02.080 --> 01:20:02.680
izleyin.

01:20:06.020 --> 01:20:06.640
arcs,

01:20:08.160 --> 01:20:09.200
virgül sıfır,

01:20:09.200 --> 01:20:14.660
pack expansion.

01:20:15.660 --> 01:20:19.860
Bunu nasıl bir virgüllerle ayrılmış listeye dönüştürecek?

01:20:20.600 --> 01:20:22.940
Hatta şuraya bir de boşluk verelim.

01:20:24.380 --> 01:20:26.920
Bunu nasıl bir virgüllerle ayrılmış listeye,

01:20:27.720 --> 01:20:28.180
arkadaşlar,

01:20:28.780 --> 01:20:29.320
ayıracak?

01:20:29.320 --> 01:20:31.320
bir,

01:20:32.380 --> 01:20:33.280
bunu yazacak,

01:20:33.500 --> 01:20:35.720
burada fonksiyonun birinci parametresi olacak.

01:20:36.200 --> 01:20:38.040
Buradaki virgülü operatör virgül,

01:20:38.920 --> 01:20:41.920
comma separated liste dönüştürüyordu ya,

01:20:42.700 --> 01:20:43.200
o zaman,

01:20:44.620 --> 01:20:47.120
bütün parametreler bu şekilde sırasıyla,

01:20:48.220 --> 01:20:49.780
comma separated listin,

01:20:49.780 --> 01:20:50.980
böyle ileri olacak.

01:20:51.460 --> 01:20:52.640
İsterseniz gösterelim.

01:20:53.040 --> 01:20:53.380
Bakın,

01:20:53.760 --> 01:20:54.740
sıkılmayacaksınız.

01:20:54.960 --> 01:20:55.620
Şöyle değil mi?

01:20:56.540 --> 01:20:57.300
Şuna aldım.

01:20:59.300 --> 01:21:02.300
Fonksiyonun parametreleri P1, P2, P3 olsun.

01:21:02.300 --> 01:21:05.440
Aslında burada P1 var.

01:21:07.760 --> 01:21:08.640
Arkadaşlar,

01:21:09.140 --> 01:21:11.940
burada yine aynı ifade,

01:21:12.460 --> 01:21:13.560
ama P2 var.

01:21:16.020 --> 01:21:17.680
Yine aynı ifade,

01:21:19.220 --> 01:21:20.700
burada P3 var.

01:21:22.000 --> 01:21:22.980
Şimdi söyleyin,

01:21:23.500 --> 01:21:26.900
virgüllerle ayrılmış bir liste olarak bunu kullanırsam,

01:21:26.900 --> 01:21:28.400
örneğin,

01:21:28.920 --> 01:21:31.420
bir diziye ilk değer verirsem,

01:21:31.960 --> 01:21:33.120
ki daha iyisini yapacağım,

01:21:35.260 --> 01:21:36.880
sadece soruma cevap vermeye çalışıyorum.

01:21:36.960 --> 01:21:39.060
O zaman burada bir küve parantezi olması lazım.

01:21:40.360 --> 01:21:42.540
Burada da küve parantezinin kapanması lazım.

01:21:44.120 --> 01:21:45.880
Buraya kadar yakaladınız mı?

01:21:46.960 --> 01:21:48.040
Şimdi söyler misiniz,

01:21:48.840 --> 01:21:51.660
parametre paketinde 5 tane parametre varsa,

01:21:52.540 --> 01:21:56.800
aslında ben 5 elemanlı bir diziye ilk değer vermiş olurum,

01:21:56.800 --> 01:21:57.180
değil mi?

01:21:58.140 --> 01:22:00.280
Aslında dizinin bütün elemanlarına,

01:22:01.160 --> 01:22:02.840
sıfır değerini vermiş olurum.

01:22:03.780 --> 01:22:07.320
Ama burada sequence point oluşturduğu için,

01:22:08.160 --> 01:22:10.960
sırasıyla argümanların hepsini yazacak.

01:22:12.140 --> 01:22:13.560
Ama diyeceksiniz ki,

01:22:14.200 --> 01:22:15.420
Necati bu güzel ama,

01:22:16.120 --> 01:22:18.020
sen bir dizi tanımlamış olacaksın,

01:22:18.200 --> 01:22:19.360
onu da açmanın yolu var,

01:22:19.440 --> 01:22:20.080
merak etmeyin.

01:22:20.200 --> 01:22:20.760
Ama önce,

01:22:21.760 --> 01:22:23.820
mesela böyle bırakmayı sevmem tabii,

01:22:23.820 --> 01:22:25.060
olmaz, çok çirkin olur.

01:22:25.060 --> 01:22:27.680
Bir kere en iyi ihtimalle,

01:22:28.060 --> 01:22:29.240
herhangi bir derleyici burada,

01:22:29.360 --> 01:22:31.040
bu dizi kullanılmadığı için,

01:22:31.700 --> 01:22:32.900
uyarı mesajı verebilir,

01:22:33.020 --> 01:22:34.480
sentaks hatası olmasa da.

01:22:35.160 --> 01:22:35.860
İzleyin şimdi,

01:22:36.780 --> 01:22:37.980
gerçekten bir deneyelim,

01:22:38.880 --> 01:22:40.680
print fonksiyonuna çağrı yapalım,

01:22:41.640 --> 01:22:41.820
ve,

01:22:42.640 --> 01:22:44.280
hatta argümanların türüne bakın,

01:22:44.640 --> 01:22:44.900
2,

01:22:45.120 --> 01:22:46.120
2.3,

01:22:46.120 --> 01:22:47.920
efendim,

01:22:48.080 --> 01:22:48.600
Alihan,

01:22:49.900 --> 01:22:50.120
ve,

01:22:52.520 --> 01:22:53.080
mesela,

01:22:53.880 --> 01:22:55.300
bitset başlık dosyasında,

01:22:56.220 --> 01:22:57.220
inkulu dediğim,

01:22:58.300 --> 01:22:58.540
ve,

01:22:58.800 --> 01:22:59.820
stud bitset'in,

01:23:02.620 --> 01:23:04.120
16 açılımı türünden,

01:23:04.220 --> 01:23:05.640
bu sınıfı henüz öğrenmedik,

01:23:06.400 --> 01:23:07.120
453u.

01:23:07.120 --> 01:23:09.740
ve bakın şimdi,

01:23:10.120 --> 01:23:10.800
derliyorum,

01:23:12.680 --> 01:23:14.080
bir sentaks hatası yok,

01:23:15.600 --> 01:23:16.500
çalıştırıyorum,

01:23:18.720 --> 01:23:19.560
gayet de güzel,

01:23:19.980 --> 01:23:21.200
argümanları yazdırdı,

01:23:21.340 --> 01:23:21.600
2,

01:23:21.800 --> 01:23:22.520
2.3,

01:23:22.640 --> 01:23:23.060
Alihan,

01:23:24.060 --> 01:23:26.220
şimdi bundan daha iyisini yapabiliriz,

01:23:26.300 --> 01:23:26.520
çünkü,

01:23:26.920 --> 01:23:28.960
burada kullanılmayan bir ne var,

01:23:29.300 --> 01:23:29.720
arkadaşlar,

01:23:30.760 --> 01:23:31.260
dizi var,

01:23:31.260 --> 01:23:33.580
ya bunu,

01:23:34.060 --> 01:23:35.780
initializer list yapabiliriz,

01:23:36.680 --> 01:23:37.080
arkadaşlar,

01:23:37.340 --> 01:23:37.620
bakın,

01:23:38.740 --> 01:23:40.120
initializer listin,

01:23:40.340 --> 01:23:40.760
tut,

01:23:44.880 --> 01:23:46.360
initializer listin,

01:23:47.880 --> 01:23:48.360
arkadaşlar,

01:23:48.660 --> 01:23:49.500
int açılımı,

01:23:50.440 --> 01:23:50.680
ki,

01:23:51.220 --> 01:23:51.640
aslında,

01:23:52.020 --> 01:23:52.340
burada,

01:23:53.240 --> 01:23:53.480
yine,

01:23:53.880 --> 01:23:54.580
sitatla,

01:23:55.500 --> 01:23:57.960
template argümanını yazmak zorunda da değilim,

01:23:58.220 --> 01:23:58.420
yani,

01:23:58.620 --> 01:23:59.720
şöyle yazmakla,

01:24:00.160 --> 01:24:01.160
deduction'a bırakmak,

01:24:01.160 --> 01:24:02.240
arasında bir fark yok,

01:24:02.380 --> 01:24:02.640
bravo,

01:24:02.740 --> 01:24:03.340
cenzan ve,

01:24:04.520 --> 01:24:04.820
ve,

01:24:06.080 --> 01:24:06.500
bu,

01:24:07.080 --> 01:24:07.760
artık bir,

01:24:08.180 --> 01:24:08.860
PR value,

01:24:09.700 --> 01:24:10.040
ama,

01:24:11.460 --> 01:24:12.360
ee,

01:24:12.360 --> 01:24:13.120
ifadeyi de,

01:24:13.200 --> 01:24:14.700
void türüne test edersem,

01:24:15.640 --> 01:24:16.560
herhangi bir şekilde,

01:24:17.600 --> 01:24:19.180
uyarı alma ihtimalim de,

01:24:19.660 --> 01:24:20.220
ortadan,

01:24:20.980 --> 01:24:21.560
kalkacak,

01:24:21.940 --> 01:24:22.980
takip edebiliyor muyuz?

01:24:23.940 --> 01:24:24.260
Evet,

01:24:24.420 --> 01:24:24.980
aynı işi,

01:24:25.380 --> 01:24:26.520
yine böyle yapmış olacağım,

01:24:27.380 --> 01:24:27.720
arkadaşlar,

01:24:27.920 --> 01:24:28.680
tabi bu tekniğin,

01:24:28.780 --> 01:24:29.560
türevleri var,

01:24:29.700 --> 01:24:30.560
farklı şekilde yazabilirim,

01:24:31.160 --> 01:24:32.300
ama,

01:24:32.300 --> 01:24:33.920
ortak özellik,

01:24:34.540 --> 01:24:35.040
aslında,

01:24:35.660 --> 01:24:37.440
virgül operatörünün,

01:24:37.620 --> 01:24:39.220
sequence point oluşturması,

01:24:39.940 --> 01:24:41.320
ve virgül operatörünün,

01:24:41.420 --> 01:24:42.380
ürettiği değerin,

01:24:43.040 --> 01:24:44.060
sağ operandın,

01:24:44.780 --> 01:24:45.780
değeri olmasından,

01:24:46.780 --> 01:24:47.440
kaynaklanıyor,

01:24:47.700 --> 01:24:48.380
anlaşıldı mı?

01:24:49.380 --> 01:24:49.660
Evet,

01:24:51.660 --> 01:24:52.100
peki,

01:24:52.740 --> 01:24:53.140
bu da,

01:24:53.240 --> 01:24:53.800
bizim,

01:24:54.220 --> 01:24:54.640
ikinci,

01:24:55.140 --> 01:24:55.860
tekniğimiz,

01:24:56.240 --> 01:24:56.980
diyebiliriz,

01:24:56.980 --> 01:24:59.760
başka teknikler var mı?

01:25:00.220 --> 01:25:00.480
Evet,

01:25:01.940 --> 01:25:02.360
arkadaşlar,

01:25:02.900 --> 01:25:03.880
üçüncü teknik,

01:25:04.660 --> 01:25:05.360
buraya dikkat,

01:25:06.440 --> 01:25:07.800
neden faydalanmak?

01:25:09.680 --> 01:25:11.080
Compile time if'den,

01:25:11.320 --> 01:25:11.940
faydalanmak,

01:25:12.000 --> 01:25:13.280
yine rekürsif yapı,

01:25:14.160 --> 01:25:14.480
ama,

01:25:14.720 --> 01:25:15.300
bu sefer,

01:25:16.400 --> 01:25:17.160
kullanacağım,

01:25:17.540 --> 01:25:18.360
araç,

01:25:19.000 --> 01:25:20.420
henüz bizim görmediğimiz,

01:25:20.920 --> 01:25:21.580
şimdi birazdan,

01:25:21.660 --> 01:25:22.660
o konuya da gireceğim,

01:25:22.660 --> 01:25:24.940
compile time if,

01:25:25.460 --> 01:25:26.160
o zaman hemen,

01:25:27.040 --> 01:25:29.020
C++ 17 standardıyla,

01:25:29.120 --> 01:25:30.300
dilimize eklenen,

01:25:31.100 --> 01:25:32.960
en önemli araçlardan biri olan,

01:25:33.680 --> 01:25:35.000
neyi görmeye başlayalım?

01:25:36.140 --> 01:25:36.420
if,

01:25:36.660 --> 01:25:37.480
constexpr,

01:25:37.740 --> 01:25:38.940
constexpr if,

01:25:39.060 --> 01:25:40.000
compile time if,

01:25:40.140 --> 01:25:40.840
static if,

01:25:41.500 --> 01:25:42.400
farklı farklı işler,

01:25:42.500 --> 01:25:44.060
farklı terim kullanabiliyorlar,

01:25:44.240 --> 01:25:45.180
ama sonuçta,

01:25:45.800 --> 01:25:46.840
hepsi,

01:25:46.840 --> 01:25:47.340
aynı,

01:25:47.340 --> 01:25:48.100
konuya,

01:25:48.620 --> 01:25:49.280
işaret ediyor.

01:25:50.240 --> 01:25:50.920
Arkadaşlar,

01:25:51.360 --> 01:25:52.400
izleyin,

01:25:52.660 --> 01:25:54.740
şuraya da,

01:25:55.040 --> 01:25:56.600
hazırlatayım örnekleri açtım.

01:25:56.980 --> 01:25:57.480
Bakın şimdi,

01:25:58.700 --> 01:25:59.320
yine dilin,

01:25:59.460 --> 01:26:01.660
en önemli araçlarından biriyle tanışacağız.

01:26:01.980 --> 01:26:02.260
Yani,

01:26:02.540 --> 01:26:03.120
şimdiye kadar,

01:26:03.380 --> 01:26:05.080
hiç bundan bahsetmemiş olabiliriz,

01:26:05.140 --> 01:26:06.880
ya da çok az bahsetmiş olabiliriz,

01:26:07.700 --> 01:26:08.000
ama,

01:26:08.600 --> 01:26:09.040
C++,

01:26:09.280 --> 01:26:09.980
görece olarak,

01:26:10.060 --> 01:26:11.520
dilin de gerçeklenmiş olsa,

01:26:11.740 --> 01:26:13.620
dilin en önemli araçlarından biri.

01:26:14.800 --> 01:26:15.340
Arkadaşlar,

01:26:15.440 --> 01:26:15.700
biz,

01:26:15.700 --> 01:26:17.000
C dilinde,

01:26:17.900 --> 01:26:19.340
ön işlemci programın,

01:26:19.660 --> 01:26:22.400
conditional compiling komutlarını kullanarak,

01:26:22.660 --> 01:26:25.940
derleyicinin bir kodu görmesini,

01:26:26.480 --> 01:26:28.020
ya da bir kodu görmemesini,

01:26:28.800 --> 01:26:33.700
yani compile time'da derleyici için kod seçimini yaptırabiliyorduk.

01:26:34.380 --> 01:26:35.320
Ben C kursunda,

01:26:35.560 --> 01:26:37.780
conditional compiling başlığı altında,

01:26:38.720 --> 01:26:41.040
hem burada kullanılan ön işlemci komutlarını,

01:26:41.040 --> 01:26:43.040
hem de buradaki yapıyı,

01:26:44.040 --> 01:26:46.440
detaylı bir şekilde anlattım.

01:26:46.440 --> 01:26:48.040
fakat şimdi,

01:26:49.420 --> 01:26:51.400
C++ 17 itibariyle,

01:26:52.500 --> 01:26:55.020
derleyicinin bir kodu görmesi,

01:26:55.340 --> 01:26:57.160
ya da görmemesini sağlayacak,

01:26:57.420 --> 01:26:58.740
ön işlemci programı,

01:26:58.940 --> 01:27:00.600
hiç devreye katmadan,

01:27:01.780 --> 01:27:02.100
bir,

01:27:03.220 --> 01:27:03.720
derleme zamanında,

01:27:03.720 --> 01:27:05.700
ele alınacak if deyim var.

01:27:05.780 --> 01:27:07.040
Ne demek bir if deyiminin,

01:27:07.100 --> 01:27:08.560
derleme zamanında ele alınması?

01:27:09.560 --> 01:27:10.620
Burada amaç,

01:27:11.880 --> 01:27:12.340
if'in,

01:27:13.440 --> 01:27:14.800
kontrol ifadesi,

01:27:14.920 --> 01:27:16.580
yani conditional expression'ı,

01:27:16.660 --> 01:27:18.600
bir constant expression olacak.

01:27:19.920 --> 01:27:21.400
Eğer o constant expression,

01:27:21.580 --> 01:27:23.000
compile time'da,

01:27:23.000 --> 01:27:24.480
true değer üretirse,

01:27:25.680 --> 01:27:26.260
o zaman,

01:27:26.520 --> 01:27:27.180
derleyici,

01:27:27.580 --> 01:27:30.120
if'in doğru kısmındaki kodu derleyecek.

01:27:30.120 --> 01:27:33.920
eğer false değer üretirse,

01:27:34.560 --> 01:27:35.960
if'in yanlış kısmı varsa,

01:27:36.160 --> 01:27:38.220
yanlış kısmındaki kodu derleyecek.

01:27:39.400 --> 01:27:40.240
Arkadaşlar,

01:27:41.380 --> 01:27:42.600
yanlış kısmı yoksa,

01:27:42.880 --> 01:27:44.380
herhangi bir kodu derlemeyecek.

01:27:44.620 --> 01:27:45.260
Dolayısıyla,

01:27:46.300 --> 01:27:47.300
jenerik bir koda,

01:27:47.500 --> 01:27:48.100
mesela bakın,

01:27:48.220 --> 01:27:49.460
template type name'de,

01:27:49.840 --> 01:27:50.220
void,

01:27:50.700 --> 01:27:51.120
func,

01:27:51.920 --> 01:27:52.100
p.

01:27:53.780 --> 01:27:56.600
Biraz kodun jenerik olması burada,

01:27:56.920 --> 01:27:57.780
son derece önemli.

01:27:57.780 --> 01:27:58.460
yani,

01:27:59.180 --> 01:28:00.640
fonksiyon şablonu söz konusu.

01:28:01.220 --> 01:28:02.940
Necati fonksiyon şablonu,

01:28:03.180 --> 01:28:05.200
yoksa normal fonksiyonun içinde de,

01:28:05.320 --> 01:28:06.740
statik if'i kullanamaz mıyız?

01:28:06.840 --> 01:28:07.820
Kullanırız ama orada,

01:28:08.600 --> 01:28:09.740
bazı kurallar farklı.

01:28:10.540 --> 01:28:11.200
Şimdi bakın,

01:28:11.800 --> 01:28:12.140
önce,

01:28:12.700 --> 01:28:13.980
deyim nasıl oluşturuluyor?

01:28:14.940 --> 01:28:15.780
if'ten sonra,

01:28:16.940 --> 01:28:18.820
constant expression anahtar sözcüğü var.

01:28:20.020 --> 01:28:21.240
Yani bakınız,

01:28:21.420 --> 01:28:22.580
şu if deyimi,

01:28:23.160 --> 01:28:24.300
bizim bildiğimiz,

01:28:25.360 --> 01:28:27.100
runtime'a yönelik if deyimi,

01:28:27.100 --> 01:28:28.780
hayır hayır,

01:28:29.380 --> 01:28:30.640
si'deki if defle,

01:28:30.720 --> 01:28:32.040
hiçbir alakası yok kabe.

01:28:32.920 --> 01:28:34.060
si'deki if def,

01:28:34.300 --> 01:28:36.240
preprocesör programını kullanıyor.

01:28:36.960 --> 01:28:38.160
Bunun preprocesörle,

01:28:38.260 --> 01:28:40.080
uzaktan yakından bir alakası yok.

01:28:40.560 --> 01:28:41.440
Sadece ve sadece,

01:28:41.620 --> 01:28:43.600
compiler devrede.

01:28:43.700 --> 01:28:44.700
Yani ön işlemci,

01:28:44.760 --> 01:28:46.820
biz Türkçe'de ön işlemci program diyoruz.

01:28:47.960 --> 01:28:49.940
Onun yaptığı işi,

01:28:49.940 --> 01:28:52.220
yapar mı anlamında söylüyorsanız,

01:28:52.220 --> 01:28:55.220
ondan çok daha fazlasına muktedir.

01:28:55.220 --> 01:28:56.340
kadir.

01:28:57.480 --> 01:28:57.940
Yani,

01:28:58.500 --> 01:29:01.480
koşullu derleme if defle yapabileceğimiz şeylerin,

01:29:01.560 --> 01:29:03.740
çok daha fazlasını yapma şansına sahibiz.

01:29:04.580 --> 01:29:05.100
Arkadaşlar,

01:29:05.160 --> 01:29:05.740
bakın şimdi,

01:29:06.920 --> 01:29:07.280
burada,

01:29:07.940 --> 01:29:10.040
herhangi bir constant expression olabilir.

01:29:10.400 --> 01:29:10.840
Örneğin,

01:29:11.300 --> 01:29:11.520
true.

01:29:11.520 --> 01:29:12.980
örneğin,

01:29:13.260 --> 01:29:13.740
arkadaşlar,

01:29:13.960 --> 01:29:14.280
12,

01:29:14.420 --> 01:29:15.820
boolean olarak yorumlayacak.

01:29:16.740 --> 01:29:17.220
Tabii ki,

01:29:17.300 --> 01:29:18.900
buradaki constant expression,

01:29:20.220 --> 01:29:22.480
template parametresiyle de ilgili olabilir.

01:29:22.960 --> 01:29:23.480
Mesela,

01:29:23.760 --> 01:29:25.360
if size of t,

01:29:26.500 --> 01:29:27.020
büyük,

01:29:27.720 --> 01:29:28.020
2.

01:29:29.800 --> 01:29:30.200
Sadece,

01:29:31.140 --> 01:29:32.300
kodu anlamaya çalışın.

01:29:32.300 --> 01:29:33.740
Ben bu fonksiyona,

01:29:35.060 --> 01:29:35.660
örneğin,

01:29:35.980 --> 01:29:36.840
argüman olarak,

01:29:37.320 --> 01:29:37.820
arkadaşlar,

01:29:37.820 --> 01:29:43.400
short türden bir değişkenin ifade olarak versem.

01:29:45.920 --> 01:29:47.480
Bu durumda,

01:29:47.920 --> 01:29:51.420
didaction'da template parametresi short olacak değil mi?

01:29:52.180 --> 01:29:52.400
Evet.

01:29:53.620 --> 01:29:53.980
Peki,

01:29:54.780 --> 01:29:56.360
burada statik if varsa,

01:29:57.480 --> 01:30:00.080
compile time'da sınanan bu ifade,

01:30:00.360 --> 01:30:02.700
benim derleyicim için doğru mu yanlış mı?

01:30:02.700 --> 01:30:05.820
Benim derleyicimde short türü 2 byte.

01:30:05.820 --> 01:30:06.560
yanlış.

01:30:07.380 --> 01:30:07.920
O zaman,

01:30:08.640 --> 01:30:10.680
if'in içindeki bu kodu,

01:30:10.760 --> 01:30:12.300
mesela burada herhangi bir kodu olabilir.

01:30:13.220 --> 01:30:13.800
Arkadaşlar,

01:30:14.100 --> 01:30:15.880
Iostream sadece göstermek için,

01:30:16.140 --> 01:30:16.680
see up,

01:30:19.180 --> 01:30:20.140
derlenen kod,

01:30:21.820 --> 01:30:23.300
compiled kod,

01:30:24.140 --> 01:30:24.520
is

01:30:24.520 --> 01:30:25.720
through path.

01:30:26.820 --> 01:30:27.420
Through path.

01:30:32.420 --> 01:30:33.060
as

01:30:33.060 --> 01:30:34.560
olmayan da bilirdi.

01:30:35.820 --> 01:30:37.860
compiled kod,

01:30:39.420 --> 01:30:39.740
is

01:30:39.740 --> 01:30:40.640
possible.

01:30:41.700 --> 01:30:42.340
Şimdi önce,

01:30:43.180 --> 01:30:45.820
ne anlama geldiğini iyi anlamamız gerekiyor.

01:30:46.560 --> 01:30:47.100
Soru 1,

01:30:47.900 --> 01:30:51.200
derleyici bu fonksiyon şablondan bir fonksiyon kodu yazacak değil mi?

01:30:51.380 --> 01:30:51.600
Evet.

01:30:52.800 --> 01:30:53.040
Peki,

01:30:53.140 --> 01:30:54.940
derleyicinin yazacağı kod,

01:30:55.660 --> 01:30:57.120
ya bu deyimden oluşacak,

01:30:57.960 --> 01:30:59.200
ya da bu deyimden oluşacak.

01:30:59.620 --> 01:31:00.600
Hakip edebiliyor muyuz?

01:31:00.600 --> 01:31:01.280
Evet.

01:31:01.280 --> 01:31:02.680
Peki,

01:31:02.940 --> 01:31:06.260
bu örnek için derleyicinin yazdığı kod,

01:31:07.160 --> 01:31:09.860
parametresi short olan bir fonksiyon,

01:31:10.560 --> 01:31:13.500
fakat fonksiyonun içinde sadece böyle bir deyim var.

01:31:14.560 --> 01:31:15.380
Anlaşıldı değil mi?

01:31:16.280 --> 01:31:17.940
Derleyici bu kodu derlemiyor,

01:31:18.060 --> 01:31:19.660
bu koda yok muamelesi yapıyor.

01:31:19.660 --> 01:31:21.540
Sadece bu kodu derliyor.

01:31:22.400 --> 01:31:22.800
Eğer,

01:31:23.220 --> 01:31:23.760
örneğin,

01:31:24.020 --> 01:31:24.760
fonksiyona,

01:31:25.180 --> 01:31:28.280
intürden bir argüman gönderseydim,

01:31:28.560 --> 01:31:29.680
hatta deneyelim bakın,

01:31:30.720 --> 01:31:31.660
önce fonksiyonu,

01:31:33.660 --> 01:31:35.340
s ile çağırıyorum,

01:31:36.020 --> 01:31:38.460
ondan sonra da intürden bir değerle çağırıyorum.

01:31:39.060 --> 01:31:41.020
Fonksiyonu s ile çağırdığım zaman,

01:31:41.840 --> 01:31:42.740
runtime'da değil,

01:31:42.960 --> 01:31:45.120
compile time'da derleyici bu kodu oluyor.

01:31:45.120 --> 01:31:49.280
fonksiyonu 45 ile çağırdığımda,

01:31:49.840 --> 01:31:50.300
arkadaşlar,

01:31:50.540 --> 01:31:52.760
bu sefer de ifin doğru kısmındaki kodu oluyor.

01:31:54.120 --> 01:31:55.940
Şimdi diğer çağrıya bakın.

01:31:58.180 --> 01:31:58.540
Ooo,

01:31:58.800 --> 01:32:00.120
çok da önemli bir araç.

01:32:03.120 --> 01:32:04.000
Şimdi burada,

01:32:04.340 --> 01:32:04.560
bir,

01:32:05.340 --> 01:32:05.740
arkadaşlar,

01:32:05.980 --> 01:32:09.380
bu ifadenin constant expression olma mecburiyeti var.

01:32:09.380 --> 01:32:14.000
yani mesela burada şöyle bir kod yazabilir misiniz?

01:32:14.560 --> 01:32:15.620
T türünden x,

01:32:16.580 --> 01:32:17.100
efendim,

01:32:17.880 --> 01:32:20.080
x büyük 10.

01:32:22.580 --> 01:32:23.420
Hayır,

01:32:23.580 --> 01:32:24.980
bu sabit ifadesi olmaz.

01:32:25.980 --> 01:32:26.820
Buradaki ifade,

01:32:27.220 --> 01:32:28.380
sabit ifadesi olacak.

01:32:28.960 --> 01:32:29.260
Bu bir.

01:32:30.140 --> 01:32:30.840
İkincisi,

01:32:30.840 --> 01:32:32.340
şimdi sıkı durun.

01:32:33.260 --> 01:32:33.920
Arkadaşlar,

01:32:34.100 --> 01:32:38.280
derleyicinin derlemediği kısımdaki kod,

01:32:38.280 --> 01:32:41.480
sentax hatası oluşturmayacak.

01:32:42.380 --> 01:32:42.940
Mesela,

01:32:43.440 --> 01:32:44.060
izleyin,

01:32:44.920 --> 01:32:46.320
şöyle bir kodu olsaydı,

01:32:47.820 --> 01:32:48.340
struct,

01:32:49.100 --> 01:32:49.480
nec,

01:32:50.380 --> 01:32:50.960
arkadaşlar,

01:32:52.240 --> 01:32:52.880
izleyin,

01:32:54.240 --> 01:32:54.700
void,

01:32:55.400 --> 01:32:55.660
foo.

01:32:57.500 --> 01:32:57.840
Şimdi,

01:32:58.000 --> 01:33:00.580
nec'in foo isimli bir üye fonksiyonu var değil mi?

01:33:01.500 --> 01:33:02.160
Kesinlikle.

01:33:03.020 --> 01:33:03.280
Peki,

01:33:03.600 --> 01:33:04.440
ben burada,

01:33:05.440 --> 01:33:07.900
şöyle bir çağrı yapsam,

01:33:07.900 --> 01:33:10.000
x'in foo'su.

01:33:11.620 --> 01:33:12.420
Arkadaşlar,

01:33:13.380 --> 01:33:13.900
izleyin.

01:33:20.680 --> 01:33:21.480
Ve,

01:33:21.720 --> 01:33:23.140
bu fonksiyona,

01:33:26.020 --> 01:33:29.940
bu sefer koşul ifadesi başka bir compile time ifadesi olsa,

01:33:30.960 --> 01:33:31.400
mesela,

01:33:31.820 --> 01:33:32.900
high trades kütüphanesindeki,

01:33:34.900 --> 01:33:36.900
meta function'lardan birini kullansam,

01:33:37.900 --> 01:33:40.980
geçen derslerden birinde bahsetmiştik.

01:33:41.060 --> 01:33:41.280
Mesela,

01:33:41.340 --> 01:33:42.620
buradaki ifade şöyle olsa,

01:33:43.060 --> 01:33:43.380
iz,

01:33:44.540 --> 01:33:45.100
arkadaşlar,

01:33:46.680 --> 01:33:47.280
efendim,

01:33:48.200 --> 01:33:48.600
tut,

01:33:50.220 --> 01:33:50.620
iz,

01:33:51.280 --> 01:33:52.000
integral,

01:33:52.400 --> 01:33:53.680
underscore v'nin,

01:33:54.220 --> 01:33:54.960
p açılımı.

01:33:56.000 --> 01:33:56.240
Şimdi,

01:33:56.320 --> 01:33:58.320
bu ifadenin doğru olması için,

01:33:58.440 --> 01:34:01.420
t türünün tam sayı türlerinden biri olması gerekiyor,

01:34:01.500 --> 01:34:01.780
değil mi?

01:34:01.780 --> 01:34:02.780
evet,

01:34:02.780 --> 01:34:03.340
evet,

01:34:03.340 --> 01:34:04.560
o zaman,

01:34:04.560 --> 01:34:04.700
o zaman,

01:34:04.700 --> 01:34:08.720
şimdi de tam sayı türlerinden biri olmaması gerekiyor,

01:34:08.820 --> 01:34:09.120
değil mi?

01:34:10.120 --> 01:34:11.260
Takip edebiliyor muyuz?

01:34:11.700 --> 01:34:11.860
Evet.

01:34:12.560 --> 01:34:13.580
Şimdi söyleyin bakalım,

01:34:14.620 --> 01:34:15.800
ben bu fonksiyona,

01:34:16.620 --> 01:34:17.760
çağrı yaparken,

01:34:18.500 --> 01:34:19.000
arkadaşlar,

01:34:19.800 --> 01:34:20.780
pan fonksiyonunu,

01:34:20.780 --> 01:34:26.740
efendim,

01:34:27.280 --> 01:34:28.920
12 değeriyle çağırsam,

01:34:30.240 --> 01:34:32.180
bu durumda t türü int olacak,

01:34:33.340 --> 01:34:33.880
burası,

01:34:34.560 --> 01:34:35.440
fos olacak,

01:34:36.160 --> 01:34:38.500
ve derleyici bu kodu üretecek.

01:34:38.500 --> 01:34:39.960
eğer,

01:34:40.140 --> 01:34:41.800
bu kodu da derleseydi,

01:34:43.660 --> 01:34:45.120
int türden değişkeni,

01:34:45.320 --> 01:34:47.740
nokta operatörünün operanda yapmış olacaktım,

01:34:47.820 --> 01:34:48.040
değil mi,

01:34:48.100 --> 01:34:48.300
Kave?

01:34:49.340 --> 01:34:51.340
Bu da sentaks hatası oluşturacaktı,

01:34:51.400 --> 01:34:51.720
değil mi?

01:34:52.620 --> 01:34:54.680
Ama şimdi sentaks hatası oluşacak mı?

01:34:55.220 --> 01:34:55.460
Hayır.

01:34:55.720 --> 01:34:58.120
Çünkü derleyici bu kodu derlemiyor.

01:34:59.100 --> 01:35:00.980
Derleyici bu kodu derlemediği için,

01:35:01.340 --> 01:35:03.020
sentaks hatası da oluşmayacak.

01:35:04.260 --> 01:35:05.940
En önemli özelliklerinden biri,

01:35:06.540 --> 01:35:06.700
bu.

01:35:06.700 --> 01:35:08.580
anlaşıldı mı?

01:35:09.380 --> 01:35:10.700
Yani derlenmeyen kısımda,

01:35:12.020 --> 01:35:16.000
name lookup'la ilgili bir problem olmadığı sürece,

01:35:16.160 --> 01:35:17.260
isim aramayla ilgili,

01:35:18.220 --> 01:35:19.760
o kod derlenmiyor.

01:35:19.920 --> 01:35:23.740
O kodun sentaksa uygun olması gerekmiyor.

01:35:24.820 --> 01:35:25.500
Böylece,

01:35:26.560 --> 01:35:28.040
bu aracı kullanarak,

01:35:28.220 --> 01:35:30.080
yani compile time if'i kullanarak,

01:35:31.100 --> 01:35:34.060
normalde overloading ile yapabileceğim,

01:35:34.060 --> 01:35:37.060
bir yazabileceğim bir sürü kodu,

01:35:38.060 --> 01:35:39.940
tik bir fonksiyon şablonuyla,

01:35:40.280 --> 01:35:41.820
yazma şansına sahip oluyor.

01:35:42.020 --> 01:35:43.720
Müthiş bir araç aslına bakarsanız.

01:35:45.160 --> 01:35:46.740
Hadi gelin birkaç örnek verelim.

01:35:46.740 --> 01:35:48.280
Ama arkadaşlar,

01:35:49.040 --> 01:35:50.620
çok sık yapılan bir hatayı,

01:35:50.940 --> 01:35:52.740
hemen söyleyerek başlayalım.

01:35:53.700 --> 01:35:54.060
Şimdi,

01:35:54.420 --> 01:35:58.260
nasıl sadece doğru kısmı olan if deyimi var,

01:35:59.980 --> 01:36:01.160
sadece doğru olan,

01:36:01.420 --> 01:36:02.700
statik if deyimi de var.

01:36:03.800 --> 01:36:04.400
Hem doğru,

01:36:04.740 --> 01:36:06.100
hem yanlış kısmı olan,

01:36:06.240 --> 01:36:07.520
hem true pet'e sahip,

01:36:08.120 --> 01:36:09.480
hem false pet'e sahip,

01:36:10.200 --> 01:36:11.240
bir if deyimi var,

01:36:11.480 --> 01:36:13.120
onun statik if versiyonu da var.

01:36:13.120 --> 01:36:15.400
Bir de else if merdiveni var,

01:36:15.500 --> 01:36:15.800
değil mi?

01:36:16.700 --> 01:36:18.740
İşte çok yapılan hatalardan biri,

01:36:19.840 --> 01:36:23.120
else if merdivenini compile time'de oluştururken,

01:36:23.720 --> 01:36:24.320
arkadaşlar,

01:36:25.480 --> 01:36:27.960
constex pr'yi yazmamak.

01:36:28.800 --> 01:36:31.120
Eğer constex pr'yi burada yazmazsanız,

01:36:32.240 --> 01:36:33.120
bu artık ne olmayacak?

01:36:34.420 --> 01:36:35.540
Statik if olmayacak,

01:36:35.680 --> 01:36:36.920
normal if deyimi olacak,

01:36:37.120 --> 01:36:38.500
compile time değeri alınacak.

01:36:38.500 --> 01:36:39.800
Yani,

01:36:40.420 --> 01:36:43.380
else if constex pr'yi yazmakla,

01:36:44.560 --> 01:36:46.740
else if yazmak tamamen farklı şeyler.

01:36:48.260 --> 01:36:49.780
Else if yazarsam,

01:36:49.920 --> 01:36:51.900
bir kere bir kod seçimi söz konusu değil,

01:36:52.000 --> 01:36:53.680
bu da oradan kodun bir parçası.

01:36:54.900 --> 01:36:55.740
Anlaşıldı, değil mi?

01:36:56.900 --> 01:36:57.540
Ayrıca,

01:36:57.700 --> 01:36:58.700
else if yazarsam,

01:36:58.780 --> 01:37:01.780
buradaki ifadenin constant expression olması da gerekmiyor.

01:37:02.740 --> 01:37:03.320
Yani örneğin,

01:37:03.380 --> 01:37:05.080
yanlışlıkla else if yazsanız,

01:37:05.080 --> 01:37:07.720
ve buradaki ifade constant expression değilse,

01:37:07.720 --> 01:37:09.860
sentaks hatası olmaz.

01:37:10.880 --> 01:37:11.520
Dolayısıyla,

01:37:11.680 --> 01:37:14.220
compile time'da bir branching sağlamak için,

01:37:14.420 --> 01:37:15.340
bir dallanma,

01:37:15.460 --> 01:37:16.880
branching sağlamak için,

01:37:17.920 --> 01:37:19.840
muhtemelen yazmak istediğiniz,

01:37:20.540 --> 01:37:21.920
diğer branch'lerin de,

01:37:22.140 --> 01:37:22.980
yine ne olması?

01:37:23.840 --> 01:37:26.020
else if constex pr olması.

01:37:27.280 --> 01:37:28.780
Buraya kadar her şey anlaşıldı mı?

01:37:29.040 --> 01:37:30.380
Çok sayıda örnek yapacağız.

01:37:31.200 --> 01:37:32.860
Ama isterseniz önce bir ara verelim.

01:37:32.860 --> 01:37:36.160
saat 21.08 arkadaşlar,

01:37:37.060 --> 01:37:39.360
21.25'te devam edeceğiz.

01:37:41.560 --> 01:37:42.520
Evet,

01:37:43.520 --> 01:37:45.040
21.25'te devam ediyoruz.

01:37:45.040 --> 01:37:52.720
Arkadaşlar,

01:37:52.780 --> 01:37:53.960
mesela böylece,

01:37:54.800 --> 01:37:57.380
template parametresi ya da parametrelerinin,

01:37:57.740 --> 01:37:59.860
türlerinin ne olduğuna bağlı olarak,

01:38:01.100 --> 01:38:01.600
ya da,

01:38:02.040 --> 01:38:03.380
template parametresinin,

01:38:03.940 --> 01:38:06.240
niteliklerinin ne olduğuna bağlı olarak,

01:38:07.200 --> 01:38:09.780
farklı kodların değerlenmesini sağlayabilirsiniz.

01:38:09.780 --> 01:38:12.120
Yani bu durumda,

01:38:13.020 --> 01:38:15.440
specialization mekanizmasını oluşturmak,

01:38:16.280 --> 01:38:16.980
ya da template,

01:38:17.340 --> 01:38:18.460
fonksiyon şablonlarını,

01:38:18.600 --> 01:38:19.900
overload etmek yerine,

01:38:20.600 --> 01:38:22.280
tek bir fonksiyon şablonuyla,

01:38:23.120 --> 01:38:24.860
dilediğinizi yapabilirsiniz.

01:38:25.040 --> 01:38:26.300
Mesela aslında buradaki örnek,

01:38:26.480 --> 01:38:28.500
onu da çağrıştırıyor değil mi?

01:38:29.440 --> 01:38:30.200
Burada bir,

01:38:30.200 --> 01:38:32.020
else kısmı olsaydı,

01:38:32.800 --> 01:38:34.480
burada kodların ne olduğundan,

01:38:35.420 --> 01:38:36.280
bağımsız olarak,

01:38:37.120 --> 01:38:39.760
aslında biz şöyle bir kod oluşturmuş olurduk değil mi?

01:38:39.780 --> 01:38:42.400
Şuradaki lojik değil operatörünü de kaldıralım.

01:38:43.940 --> 01:38:44.960
Eğer t türü,

01:38:45.600 --> 01:38:46.700
tam sayı türü ise,

01:38:47.820 --> 01:38:49.260
buradaki kod derlensin.

01:38:50.080 --> 01:38:51.480
Tam sayı türü değilse,

01:38:51.980 --> 01:38:53.360
buradaki kod derlensin.

01:38:54.700 --> 01:38:55.260
Ya da,

01:38:55.620 --> 01:38:56.000
diğer,

01:38:56.520 --> 01:38:58.120
daha önce öğrendiğimiz,

01:38:58.120 --> 01:38:59.560
en azından gördüğümüz,

01:39:00.320 --> 01:39:01.540
metafarkçılara bakın,

01:39:01.760 --> 01:39:02.400
elsir,

01:39:02.960 --> 01:39:03.860
constexpr,

01:39:05.120 --> 01:39:05.700
arkadaşlar,

01:39:07.120 --> 01:39:07.640
efendim,

01:39:08.040 --> 01:39:08.500
stut,

01:39:08.500 --> 01:39:10.120
is,

01:39:10.120 --> 01:39:11.880
floating point,

01:39:14.420 --> 01:39:14.720
ve,

01:39:16.940 --> 01:39:17.400
else,

01:39:19.200 --> 01:39:21.320
şimdi buralarda kodlar olduğunu düşünün.

01:39:22.900 --> 01:39:23.280
Eğer,

01:39:23.800 --> 01:39:24.920
ham sayı türü ise,

01:39:26.060 --> 01:39:27.560
if'in doğru kısmına girecek.

01:39:27.920 --> 01:39:28.120
Burada,

01:39:28.300 --> 01:39:29.220
if'in doğru kısmına,

01:39:29.300 --> 01:39:31.100
compile time'da girmesinden bahsediyoruz.

01:39:31.200 --> 01:39:32.480
Yani buradaki kod derlenecek.

01:39:32.480 --> 01:39:34.380
eğer,

01:39:34.380 --> 01:39:36.540
tabi şunu yazmayı unutmuşuz,

01:39:36.940 --> 01:39:38.360
açısal parantezde,

01:39:39.480 --> 01:39:40.440
eğer t türü,

01:39:41.240 --> 01:39:42.540
floating point türü ise,

01:39:42.660 --> 01:39:44.660
yani gerçek sayı türlerinden biriyse,

01:39:45.140 --> 01:39:45.860
burada bir kod.

01:39:46.860 --> 01:39:49.860
Ham sayı türü ya da gerçek sayı türü değilse,

01:39:49.860 --> 01:39:53.040
o zaman buradaki kod çalışacak.

01:39:54.240 --> 01:39:56.080
Ya da örneğin,

01:39:56.080 --> 01:39:57.780
t türü'nün,

01:39:57.980 --> 01:39:59.520
pointer türü olup olmadığına,

01:39:59.640 --> 01:40:01.220
referans türü olup olmadığına,

01:40:02.040 --> 01:40:04.220
dizi türü olup olmadığına bağlı olarak,

01:40:04.980 --> 01:40:07.980
farklı kodların derlenmesini sağlayabilirsiniz.

01:40:07.980 --> 01:40:09.160
Şimdi,

01:40:09.440 --> 01:40:10.760
benim daha önce yazdığım,

01:40:10.940 --> 01:40:12.700
kitaba da koyduğum örneklerden,

01:40:13.480 --> 01:40:13.820
önce,

01:40:14.380 --> 01:40:16.580
genel sentaksı pekiştirecek,

01:40:17.300 --> 01:40:17.960
ve efendim,

01:40:20.440 --> 01:40:22.700
kullanım biçimini pekiştirecek,

01:40:22.960 --> 01:40:24.080
bir iki örnek verelim.

01:40:24.300 --> 01:40:24.860
Yani biraz,

01:40:25.100 --> 01:40:27.040
üretime yakın örnekler olsun,

01:40:27.220 --> 01:40:28.940
oyuncak örnekler olmanın dışında.

01:40:30.200 --> 01:40:30.500
Mesela,

01:40:30.560 --> 01:40:31.160
bu gerçekten,

01:40:31.720 --> 01:40:32.760
çok hoş bir kod.

01:40:33.780 --> 01:40:34.220
İsmi,

01:40:34.320 --> 01:40:35.320
as string olan,

01:40:35.320 --> 01:40:37.680
bir fonksiyon şablonu görüyorsunuz.

01:40:38.960 --> 01:40:39.180
Ve,

01:40:40.280 --> 01:40:42.060
fonksiyon şablonunun kodunda,

01:40:43.720 --> 01:40:44.460
isSame,

01:40:45.000 --> 01:40:46.840
meta function'ın,

01:40:47.340 --> 01:40:49.400
type trait'in kullanıldığını görüyorsunuz.

01:40:49.800 --> 01:40:50.740
IsSame buradaki,

01:40:52.340 --> 01:40:54.020
template argümanı olan türlerin,

01:40:54.240 --> 01:40:55.980
aynı tür olup olmadığı,

01:40:56.280 --> 01:40:57.360
sınamasını yapıyordu.

01:40:58.420 --> 01:40:58.980
Bu da bir,

01:40:59.140 --> 01:41:00.160
variable template.

01:41:00.300 --> 01:41:01.420
Bu konuları anlattığım için,

01:41:01.540 --> 01:41:02.920
tekrar şimdi bahsetmeyeceğim.

01:41:03.060 --> 01:41:03.700
Ama şu demek,

01:41:04.500 --> 01:41:06.400
eğer buraya gelen tür,

01:41:06.540 --> 01:41:07.480
string türü ise,

01:41:07.980 --> 01:41:08.800
to string ise,

01:41:09.780 --> 01:41:11.080
doğru olacak ve bu kod,

01:41:11.940 --> 01:41:12.580
derlenecek.

01:41:13.800 --> 01:41:15.340
Eğer buraya gelen tür,

01:41:15.740 --> 01:41:16.240
arkadaşlar,

01:41:17.320 --> 01:41:18.740
string türü değil de,

01:41:19.080 --> 01:41:20.260
aritmetik bir tür ise,

01:41:20.400 --> 01:41:21.560
aritmetik tür demek,

01:41:22.400 --> 01:41:23.100
tam sayı,

01:41:23.360 --> 01:41:24.660
gerçek sayı türleri demek.

01:41:24.660 --> 01:41:25.700
mesela double türü,

01:41:25.700 --> 01:41:25.740
double türü,

01:41:26.380 --> 01:41:26.880
int türü,

01:41:27.000 --> 01:41:27.580
long türü,

01:41:28.020 --> 01:41:29.420
bunlar aritmetik türler.

01:41:30.960 --> 01:41:31.560
O zaman,

01:41:32.220 --> 01:41:33.660
standart kütüphanenin,

01:41:34.140 --> 01:41:35.520
to string fonksiyonuna,

01:41:35.800 --> 01:41:37.200
argüman olarak gönderecek,

01:41:37.300 --> 01:41:37.920
to string'in,

01:41:37.980 --> 01:41:38.740
geri dönüş değeri,

01:41:38.820 --> 01:41:40.060
geri dönüş değerimiz olacak.

01:41:40.060 --> 01:41:44.880
eğer aritmetik tür değilse,

01:41:45.960 --> 01:41:46.740
buraya dikkat,

01:41:47.280 --> 01:41:48.780
string türü de değilse,

01:41:49.780 --> 01:41:50.380
o zaman,

01:41:51.600 --> 01:41:52.380
bu kod çalışacak,

01:41:52.460 --> 01:41:53.820
bu kodun çalışması demek,

01:41:55.160 --> 01:41:56.100
argümanın,

01:41:57.100 --> 01:41:58.840
kime gönderilmesi demek,

01:41:59.840 --> 01:42:00.580
string sınıfının,

01:42:00.700 --> 01:42:02.320
constructor'ına gönderilmesi,

01:42:03.240 --> 01:42:04.000
ve böylece,

01:42:04.800 --> 01:42:05.520
oluşturulacak,

01:42:05.600 --> 01:42:07.040
PR value expression ile,

01:42:07.040 --> 01:42:08.520
arkadaşlar,

01:42:08.780 --> 01:42:09.340
tabi ki,

01:42:10.220 --> 01:42:11.600
mandatory copy allegion da,

01:42:11.720 --> 01:42:12.720
devreye girecek burada,

01:42:13.520 --> 01:42:14.320
geri dönüş değerinin,

01:42:14.420 --> 01:42:15.320
oluşturulması demek.

01:42:16.160 --> 01:42:17.080
Şimdi düşünün,

01:42:17.340 --> 01:42:17.740
eğer,

01:42:18.600 --> 01:42:20.720
if constexpr olmasaydı,

01:42:21.720 --> 01:42:22.740
aslında biz bunu,

01:42:23.160 --> 01:42:24.220
overloading ile,

01:42:25.360 --> 01:42:25.960
ya da,

01:42:26.300 --> 01:42:27.860
henüz size anlatmadığım,

01:42:28.000 --> 01:42:29.900
tag dispatch dediğimiz teknikle,

01:42:29.900 --> 01:42:32.780
ya da yine size anlatmadığım,

01:42:33.320 --> 01:42:35.080
spina dediğimiz teknikle,

01:42:35.340 --> 01:42:35.900
gerçekleştirebilirdik.

01:42:35.900 --> 01:42:38.380
Yani başka alternatifler yok değil.

01:42:39.560 --> 01:42:40.580
Ama doğrusu isterseniz,

01:42:40.700 --> 01:42:41.800
burada en pratiği,

01:42:42.140 --> 01:42:42.720
gerçekten,

01:42:43.060 --> 01:42:44.040
static if.

01:42:44.900 --> 01:42:46.380
Burada bir şeye daha dikkat edelim.

01:42:47.280 --> 01:42:47.820
Mesela,

01:42:48.080 --> 01:42:48.540
arkadaşlar,

01:42:49.560 --> 01:42:49.880
eğer,

01:42:50.040 --> 01:42:50.660
t türü,

01:42:51.420 --> 01:42:52.020
t türü,

01:42:52.760 --> 01:42:54.140
double türü olsaydı,

01:42:55.620 --> 01:42:56.800
string nesnesini,

01:42:57.200 --> 01:42:58.940
double türden bir argümanla,

01:42:59.120 --> 01:43:00.840
oluşturmak mümkün olur muydu?

01:43:01.020 --> 01:43:02.220
Sentax hatası olurdu,

01:43:02.300 --> 01:43:02.580
değil mi?

01:43:04.180 --> 01:43:04.860
Parametresi,

01:43:04.860 --> 01:43:07.260
double olan bir konstruktör var mı,

01:43:07.340 --> 01:43:08.040
string sınıfının?

01:43:08.140 --> 01:43:08.380
Yok.

01:43:09.280 --> 01:43:10.600
Sentax hatası olurdu.

01:43:11.600 --> 01:43:12.480
Ve bu durumda,

01:43:13.100 --> 01:43:13.660
ya da burada,

01:43:14.360 --> 01:43:15.480
belirli türler için,

01:43:15.740 --> 01:43:17.060
sentax hatası olurdu.

01:43:17.820 --> 01:43:19.200
Ama bu kod derlenmiyor.

01:43:20.200 --> 01:43:20.540
O yüzden,

01:43:20.800 --> 01:43:21.800
sadece t'nin,

01:43:21.960 --> 01:43:23.640
aritmetik türü olması durumunda,

01:43:23.720 --> 01:43:24.720
bu kod derlenecek.

01:43:24.720 --> 01:43:28.600
sadece t'nin string türü olması durumunda,

01:43:28.680 --> 01:43:29.620
bu kod derlenecek.

01:43:29.940 --> 01:43:30.740
Ve şimdi bakın,

01:43:32.300 --> 01:43:33.840
alttaki main fonksiyonunda,

01:43:34.580 --> 01:43:35.140
yukarıdaki,

01:43:35.240 --> 01:43:37.000
as string fonksiyon şablonuna,

01:43:38.000 --> 01:43:38.740
int türden,

01:43:38.900 --> 01:43:40.660
argümanla çağrı yaptığımda,

01:43:41.780 --> 01:43:42.180
arkadaşlar,

01:43:42.360 --> 01:43:43.440
bu kod çalışacak.

01:43:43.440 --> 01:43:44.400
yani,

01:43:44.400 --> 01:43:46.820
aslında bir one-liner gövdeye sahip,

01:43:46.860 --> 01:43:48.420
bir fonksiyonu çağırmış oluyorum,

01:43:48.540 --> 01:43:49.140
herhalde.

01:43:49.980 --> 01:43:51.560
Ama o one-liner gövde,

01:43:52.100 --> 01:43:52.500
body,

01:43:53.600 --> 01:43:54.540
ya return x,

01:43:55.280 --> 01:43:56.540
ya return stut,

01:43:56.920 --> 01:43:58.000
to string x,

01:43:58.260 --> 01:43:58.740
ya da,

01:43:58.840 --> 01:43:59.180
bu.

01:43:59.180 --> 01:44:01.280
ikinci çağrıda,

01:44:01.740 --> 01:44:03.640
yirmi üçüncü satırdaki çağrıda,

01:44:04.560 --> 01:44:06.880
yine double gönderdiğim için,

01:44:07.660 --> 01:44:08.760
yine bu kod çalışacak.

01:44:08.920 --> 01:44:10.460
Ama üçüncü çağrıda,

01:44:11.560 --> 01:44:12.620
gönderilen argüman,

01:44:12.880 --> 01:44:14.520
string türünden olduğu için,

01:44:15.640 --> 01:44:16.200
birinci,

01:44:17.380 --> 01:44:18.300
koşul ifadesi,

01:44:18.360 --> 01:44:19.200
compile time'da,

01:44:19.560 --> 01:44:20.160
true olacak.

01:44:20.160 --> 01:44:22.120
Ve bu kod derlenecek.

01:44:24.300 --> 01:44:26.440
Ve en son çağrıya batıp,

01:44:26.440 --> 01:44:29.440
gönderdiğim argüman,

01:44:30.600 --> 01:44:31.660
constjar yıldız,

01:44:31.980 --> 01:44:33.700
referans parametri olmadığı için,

01:44:34.120 --> 01:44:34.600
arkadaşlar,

01:44:34.740 --> 01:44:35.660
decay olacak.

01:44:37.120 --> 01:44:38.400
Bu durumda string değil,

01:44:39.280 --> 01:44:40.420
aritmetik tür değil,

01:44:41.460 --> 01:44:41.940
buradaki,

01:44:42.620 --> 01:44:43.980
return statement,

01:44:44.280 --> 01:44:44.940
derlenecek.

01:44:48.180 --> 01:44:49.060
Evet,

01:44:49.180 --> 01:44:50.080
runtime'a bakın.

01:44:52.000 --> 01:44:53.040
Takip edebildik mi?

01:44:54.340 --> 01:44:54.620
Evet.

01:44:56.440 --> 01:44:58.800
Yalnız arkadaşlar,

01:44:59.340 --> 01:45:00.300
ikinci örnekte,

01:45:03.120 --> 01:45:04.560
dikkatinizi çekmesi gereken,

01:45:04.640 --> 01:45:05.500
bir iki nokta var.

01:45:06.760 --> 01:45:07.340
Arkadaşlar,

01:45:07.500 --> 01:45:07.720
bir,

01:45:09.300 --> 01:45:10.120
buradaki if,

01:45:10.260 --> 01:45:10.920
statik if,

01:45:12.040 --> 01:45:13.120
ama buradaki if,

01:45:13.240 --> 01:45:14.020
statik if değil.

01:45:16.740 --> 01:45:17.460
Dolayısıyla,

01:45:17.780 --> 01:45:19.160
bu koşul doğruysa,

01:45:19.520 --> 01:45:20.860
derleyicinin göreceği kod,

01:45:20.940 --> 01:45:21.960
bu if deyimi olacak.

01:45:23.220 --> 01:45:25.300
Ama bu koşul yanlışsa,

01:45:25.300 --> 01:45:27.180
derleyicinin gördüğü kod,

01:45:27.240 --> 01:45:27.900
bu kodu olacak.

01:45:29.240 --> 01:45:30.320
Takip edebiliyor muyuz?

01:45:30.660 --> 01:45:30.880
Evet.

01:45:31.640 --> 01:45:32.480
Şimdi izleyin.

01:45:33.640 --> 01:45:34.060
Eğer,

01:45:35.060 --> 01:45:36.780
t türü tam sayı türü ise,

01:45:37.940 --> 01:45:38.660
derleyici,

01:45:39.160 --> 01:45:40.500
bu kodu görecek değil mi?

01:45:40.500 --> 01:45:42.960
bu durumda,

01:45:42.960 --> 01:45:44.800
eksi eksi operatörünün örneğin,

01:45:44.900 --> 01:45:45.800
operanda olması,

01:45:45.900 --> 01:45:47.780
bir sentaks hatası oluşturmayacak.

01:45:48.960 --> 01:45:49.800
Ve buradaki çağrı,

01:45:49.860 --> 01:45:51.080
rekörsif çağrı olacak.

01:45:52.960 --> 01:45:53.760
Eğer t türü,

01:45:53.860 --> 01:45:55.320
tam sayı türü değilse,

01:45:56.480 --> 01:45:57.960
els kısmı derlenecek.

01:45:59.100 --> 01:46:00.420
Ama bir şeye dikkat edin.

01:46:01.360 --> 01:46:01.900
Arkadaşlar,

01:46:02.060 --> 01:46:02.900
eğer burada,

01:46:03.700 --> 01:46:06.400
els tarafında bu kod olsaydı,

01:46:06.400 --> 01:46:08.960
bu durumda,

01:46:09.280 --> 01:46:10.080
t türünün,

01:46:10.280 --> 01:46:11.900
tam sayı türü olsa da,

01:46:12.020 --> 01:46:12.540
olmasa da,

01:46:12.620 --> 01:46:14.020
sentaks hatası oluşurdu.

01:46:15.640 --> 01:46:15.940
Neden?

01:46:16.940 --> 01:46:18.700
Çünkü isim arama yine yapılıyor.

01:46:20.300 --> 01:46:20.680
Eğer,

01:46:21.340 --> 01:46:23.280
template parametresine bağlı değilse,

01:46:24.280 --> 01:46:26.560
yani dependent type değilse,

01:46:27.060 --> 01:46:28.100
isim araması yapılıyor.

01:46:28.280 --> 01:46:30.880
Burada funksiyona bir argüman göndermediğim için,

01:46:30.880 --> 01:46:32.560
bu isim,

01:46:32.740 --> 01:46:35.160
template kodun derlenmesi sırasında aranıyor.

01:46:36.180 --> 01:46:36.760
Yani t,

01:46:37.000 --> 01:46:38.360
tam sayı türü olsa da,

01:46:38.440 --> 01:46:39.140
olmasa da,

01:46:40.480 --> 01:46:42.480
bu ismin aranıp bulunmaması,

01:46:43.100 --> 01:46:44.640
sentaks hatası oluşturacak.

01:46:46.020 --> 01:46:46.380
Ama,

01:46:46.740 --> 01:46:47.340
burada,

01:46:48.920 --> 01:46:51.720
template argümanına bağlı isim arandığı için,

01:46:53.240 --> 01:46:54.120
undeclared,

01:46:54.620 --> 01:46:55.020
sözde,

01:46:55.120 --> 01:46:55.840
fonksiyonla,

01:46:55.920 --> 01:46:58.140
tx argüman olarak gönderildiği için,

01:46:58.140 --> 01:47:01.220
bu ismin aranması için,

01:47:01.760 --> 01:47:02.300
arkadaşlar,

01:47:03.220 --> 01:47:05.560
else kısmındaki kodun derlenmesi gerekiyor.

01:47:05.680 --> 01:47:07.660
Else kısmındaki kod derlenmezse,

01:47:08.540 --> 01:47:10.080
burada bir sentaks hatası,

01:47:10.640 --> 01:47:11.360
olmayacak.

01:47:13.100 --> 01:47:13.520
Alihan,

01:47:13.660 --> 01:47:14.280
hocam bunlar,

01:47:14.380 --> 01:47:15.880
compile time'da olduğu için,

01:47:16.640 --> 01:47:17.680
string ifadesi,

01:47:17.720 --> 01:47:20.260
runtime'da değer belirlenen öğelerle çağrı yapmak,

01:47:20.340 --> 01:47:21.580
sentaks hatası mıdır?

01:47:21.720 --> 01:47:22.640
Tabii ki değildir.

01:47:23.160 --> 01:47:23.440
Alihan,

01:47:23.500 --> 01:47:25.600
çok önemli bir noktayı kaçırmış olmalısınız.

01:47:25.600 --> 01:47:28.880
compile time'da kod seçimi yapılıyor.

01:47:29.760 --> 01:47:31.260
Ama çağrılan fonksiyon,

01:47:31.340 --> 01:47:32.540
runtime'da çağrılıyor.

01:47:33.640 --> 01:47:34.520
Yani örneğin,

01:47:34.900 --> 01:47:36.400
fonksiyonu şöyle çağırırsak,

01:47:36.460 --> 01:47:37.560
şimdi aradaki farkı,

01:47:38.240 --> 01:47:39.800
anlayacağınız bir örnek vereyim.

01:47:40.740 --> 01:47:41.480
Mesela bakınız,

01:47:41.720 --> 01:47:43.200
int x eşittir,

01:47:43.760 --> 01:47:43.960
bu.

01:47:45.960 --> 01:47:47.680
Bu da bir fonksiyon olsun.

01:47:47.680 --> 01:47:54.760
x'in değeri runtime'da belli oluyor,

01:47:54.860 --> 01:47:55.160
değil mi?

01:47:56.160 --> 01:47:56.460
Evet.

01:47:57.240 --> 01:47:57.460
Peki,

01:47:57.540 --> 01:47:58.940
funk'ı böyle çağırmamda bir,

01:47:59.140 --> 01:47:59.900
herhangi bir şekilde,

01:48:00.820 --> 01:48:02.220
bir sentaks hatası var mı?

01:48:02.360 --> 01:48:02.620
Hayır.

01:48:03.900 --> 01:48:04.100
Peki,

01:48:04.180 --> 01:48:04.840
bu durumda,

01:48:05.340 --> 01:48:07.480
funk bir fonksiyon çablonu olduğu için,

01:48:08.320 --> 01:48:10.280
derleyici bu fonksiyon çablonundan bir,

01:48:10.280 --> 01:48:11.600
instant sharing yapacak,

01:48:11.700 --> 01:48:11.980
değil mi?

01:48:12.980 --> 01:48:14.180
Derleyicinin yazdığı,

01:48:14.600 --> 01:48:15.380
funk fonksiyonu,

01:48:15.420 --> 01:48:16.600
şöyle bir fonksiyon olacak.

01:48:16.600 --> 01:48:18.080
Çağır Alihan.

01:48:19.200 --> 01:48:19.720
Aslında,

01:48:20.680 --> 01:48:21.560
void,

01:48:22.080 --> 01:48:23.500
funk'ın,

01:48:25.820 --> 01:48:27.720
int specialization'ı,

01:48:28.840 --> 01:48:30.400
parametresi int,

01:48:31.540 --> 01:48:32.600
takip edebiliyor muyuz?

01:48:33.240 --> 01:48:33.460
Evet.

01:48:34.560 --> 01:48:34.800
Ve,

01:48:35.160 --> 01:48:35.700
kodu da,

01:48:39.700 --> 01:48:39.920
bu.

01:48:45.460 --> 01:48:46.420
Anlaşıldı mı?

01:48:46.600 --> 01:48:47.680
yani,

01:48:47.760 --> 01:48:50.940
runtime ile ilgisi olan kısım ayrı,

01:48:51.860 --> 01:48:55.020
compile time ile ilgisi olan kısım ayrı.

01:48:55.620 --> 01:48:56.580
Anlaşıldı mı?

01:48:57.360 --> 01:48:57.580
Evet.

01:48:58.260 --> 01:48:58.640
Ve yine,

01:48:59.200 --> 01:49:00.160
bir şeye daha bakınız,

01:49:00.380 --> 01:49:01.500
az önce söylediğim.

01:49:03.200 --> 01:49:03.880
Arkadaşlar,

01:49:04.060 --> 01:49:04.480
eğer,

01:49:05.560 --> 01:49:06.200
buradaki,

01:49:07.680 --> 01:49:08.740
ifade doğruysa,

01:49:08.820 --> 01:49:10.440
compile time de doğruysa,

01:49:10.440 --> 01:49:11.520
t türü,

01:49:11.520 --> 01:49:12.660
t türü,

01:49:13.120 --> 01:49:14.240
tam sayı türüdür.

01:49:14.600 --> 01:49:15.260
Ve bu kod,

01:49:15.620 --> 01:49:17.320
sentaks hatası oluşturmaz.

01:49:18.620 --> 01:49:19.400
Ama örneğin,

01:49:19.460 --> 01:49:21.780
ben bu fonksiyona şöyle bir çağrı yapsaydım.

01:49:23.360 --> 01:49:23.720
Class,

01:49:23.780 --> 01:49:24.400
my class,

01:49:24.780 --> 01:49:26.960
izleyin.

01:49:27.960 --> 01:49:29.000
Ve fonksiyona,

01:49:30.280 --> 01:49:32.900
my class türünden bir argüman gönderseydim.

01:49:32.900 --> 01:49:33.880
Yine bakın,

01:49:33.980 --> 01:49:35.140
Alihan,

01:49:35.440 --> 01:49:37.220
sizin sorunuza başka bir cevap olacak.

01:49:38.360 --> 01:49:40.920
My class türünden bir argüman gönderseydim.

01:49:41.920 --> 01:49:42.180
Şimdi,

01:49:42.320 --> 01:49:42.840
t türü,

01:49:43.360 --> 01:49:45.140
integral type olmadığı için,

01:49:46.220 --> 01:49:46.900
bu kod derlenmeyecekti.

01:49:47.780 --> 01:49:49.300
Bu kod derlenmediği için,

01:49:49.300 --> 01:49:53.220
sıfırla karşılaştırma işlemi yapılmayacaktı.

01:49:53.680 --> 01:49:57.940
Eksi eksi ifadesi için kod derlenmeyecekti.

01:49:58.660 --> 01:50:00.580
Ve sentaks hatası oluşmayacaktı.

01:50:01.540 --> 01:50:02.360
Anlaşıldı değil mi?

01:50:03.220 --> 01:50:04.160
Burada örneğin,

01:50:05.040 --> 01:50:06.820
gerçekten şöyle bir kod olsaydı,

01:50:06.940 --> 01:50:07.800
t x'in,

01:50:09.020 --> 01:50:09.680
ne olsun,

01:50:09.980 --> 01:50:11.940
bar isimli fonksiyonu çağrılsın.

01:50:12.940 --> 01:50:14.240
Artı artı,

01:50:14.600 --> 01:50:15.160
p x.

01:50:16.320 --> 01:50:17.000
Arkadaşlar,

01:50:17.160 --> 01:50:18.640
şimdi sentaks hatası olur.

01:50:19.300 --> 01:50:19.920
Ama,

01:50:20.500 --> 01:50:21.160
bu sınıfın,

01:50:21.400 --> 01:50:23.720
gerçekten bu operasyonları olsaydı,

01:50:24.940 --> 01:50:25.440
örneğin,

01:50:25.680 --> 01:50:26.980
sınıfın çağrılabilen,

01:50:27.180 --> 01:50:28.300
bir bar fonksiyonu olsaydı,

01:50:31.620 --> 01:50:32.040
efendim,

01:50:32.360 --> 01:50:33.760
artı artı operatörünü,

01:50:34.100 --> 01:50:35.240
overload etseydi,

01:50:41.580 --> 01:50:43.100
bu durumda,

01:50:43.620 --> 01:50:45.300
bu da sentaks hatası oluşturmayacaktı.

01:50:46.100 --> 01:50:47.280
Gördüğünüz gibi kod,

01:50:48.220 --> 01:50:48.520
legal.

01:50:49.300 --> 01:50:50.500
anlaşıldı mı?

01:50:52.200 --> 01:50:52.440
Evet.

01:50:53.020 --> 01:50:53.440
Arkadaşlar,

01:50:53.520 --> 01:50:54.040
şimdi bunun,

01:50:54.860 --> 01:50:56.300
önemli bir özelliği de,

01:50:57.260 --> 01:50:59.240
fonksiyonun geri dönüş değerinin,

01:50:59.580 --> 01:51:00.760
türünün,

01:51:00.860 --> 01:51:01.160
yine,

01:51:01.500 --> 01:51:03.120
compile time'da belirli olması.

01:51:03.120 --> 01:51:05.740
mesela şöyle bir kod yazsaydım,

01:51:06.340 --> 01:51:08.400
bu fonksiyon şablonu değil de,

01:51:09.200 --> 01:51:09.740
arkadaşlar,

01:51:12.900 --> 01:51:14.840
constex.tr if değil de,

01:51:15.000 --> 01:51:16.180
normal if olsaydı,

01:51:16.300 --> 01:51:16.760
bakınız,

01:51:18.540 --> 01:51:18.980
void,

01:51:19.520 --> 01:51:20.820
void diyorum özür dilerim,

01:51:21.000 --> 01:51:21.360
auto,

01:51:23.240 --> 01:51:23.720
func,

01:51:25.080 --> 01:51:25.900
int x,

01:51:25.900 --> 01:51:30.360
efendim,

01:51:30.360 --> 01:51:32.300
if x büyüktür on,

01:51:35.300 --> 01:51:35.840
return,

01:51:36.840 --> 01:51:38.480
4.5,

01:51:40.100 --> 01:51:40.560
as,

01:51:41.440 --> 01:51:42.100
return,

01:51:43.100 --> 01:51:43.680
3.

01:51:43.680 --> 01:51:48.520
bu neden sentaks hatası,

01:51:49.240 --> 01:51:52.260
çünkü fonksiyonun geri dönüş değeri türü,

01:51:53.320 --> 01:51:55.140
farklı return statement'larda,

01:51:56.140 --> 01:51:57.020
farklı şekilde,

01:51:57.700 --> 01:51:58.680
çıkarımı yapılacak.

01:51:58.680 --> 01:52:02.000
burada geri dönüş değeri türü double,

01:52:02.520 --> 01:52:05.220
burada ise geri dönüş değeri türü int.

01:52:06.060 --> 01:52:06.540
Bu da,

01:52:07.080 --> 01:52:08.660
sentaks hatası oluşturacak.

01:52:09.940 --> 01:52:10.800
Bakın derleyici,

01:52:11.240 --> 01:52:13.320
açıkça sentaks hatasının nedenini,

01:52:14.040 --> 01:52:14.420
söylüyor.

01:52:15.280 --> 01:52:15.700
Ama,

01:52:16.620 --> 01:52:18.400
constex.tr if de böyle değil.

01:52:19.400 --> 01:52:19.860
Arkadaşlar,

01:52:19.860 --> 01:52:21.480
fonksiyon şöyle olsaydı,

01:52:22.340 --> 01:52:22.960
izleyin,

01:52:24.280 --> 01:52:24.560
if,

01:52:24.960 --> 01:52:25.920
constex.tr,

01:52:25.920 --> 01:52:31.140
size of,

01:52:34.060 --> 01:52:34.500
efendim,

01:52:34.740 --> 01:52:35.740
x büyük,

01:52:36.860 --> 01:52:37.220
2,

01:52:42.660 --> 01:52:43.120
as,

01:52:46.080 --> 01:52:46.740
şimdi bakın,

01:52:47.220 --> 01:52:48.120
sentaks hatası,

01:52:48.840 --> 01:52:49.640
olmayacak.

01:52:50.520 --> 01:52:52.400
Yani geri dönüş değeri türünde,

01:52:53.200 --> 01:52:55.020
template parametresine bağlı olarak,

01:52:55.020 --> 01:52:57.700
ya da normal bir fonksiyonda da kullanırsanız,

01:52:57.740 --> 01:52:59.440
bu şekilde farklı tür yapmanız,

01:53:00.040 --> 01:53:00.460
mümkün.

01:53:01.780 --> 01:53:02.480
Anlaşıldı mı?

01:53:03.240 --> 01:53:04.400
Yalnız bir şeye dikkat edin.

01:53:04.680 --> 01:53:05.680
Başta da söylemiştim.

01:53:06.580 --> 01:53:08.780
Eğer fonksiyon çablonu değilse,

01:53:10.240 --> 01:53:12.440
if constex.tr'nin true kısmı da,

01:53:12.560 --> 01:53:13.460
false kısmı da,

01:53:14.180 --> 01:53:15.040
yani true peti de,

01:53:15.120 --> 01:53:15.980
false peti de,

01:53:17.100 --> 01:53:18.360
compile time'da,

01:53:18.360 --> 01:53:20.860
hata oluşturmayacak kodlardan oluşmalı.

01:53:20.860 --> 01:53:22.640
struct,

01:53:23.640 --> 01:53:24.880
my class,

01:53:25.280 --> 01:53:27.360
my class bir sınıf.

01:53:29.280 --> 01:53:29.820
Arkadaşlar,

01:53:29.920 --> 01:53:30.520
diyelim ki,

01:53:30.800 --> 01:53:33.120
main fonksiyonu içine şöyle bir kod yazabilir miyim?

01:53:33.860 --> 01:53:34.660
my class,

01:53:35.160 --> 01:53:35.400
me,

01:53:35.400 --> 01:53:42.940
if constex.br,

01:53:46.560 --> 01:53:47.740
size of int,

01:53:51.540 --> 01:53:53.100
parantez olunacak tabi,

01:53:54.540 --> 01:53:55.760
size of int,

01:53:56.200 --> 01:53:57.620
büyüktür 2,

01:54:02.620 --> 01:54:03.780
artı artı m,

01:54:03.780 --> 01:54:07.720
bakın hemen sentax hatası işaretliyor.

01:54:08.340 --> 01:54:09.760
Çünkü bu template kod değil.

01:54:10.860 --> 01:54:12.180
Yani size of int,

01:54:12.620 --> 01:54:14.240
2'den büyük olmasa da,

01:54:15.060 --> 01:54:16.300
şimdi onu kapatalım,

01:54:19.040 --> 01:54:19.480
else,

01:54:23.080 --> 01:54:23.800
diyelim ki,

01:54:24.200 --> 01:54:25.020
eksi eksi mi?

01:54:28.620 --> 01:54:30.180
Bakın hem doğru kısmında,

01:54:30.260 --> 01:54:31.320
hem yanlış kısmında,

01:54:31.320 --> 01:54:33.440
yardımcı aracımız,

01:54:33.920 --> 01:54:34.420
doğrudan,

01:54:35.140 --> 01:54:36.600
sentax hatası işaretliyor.

01:54:37.600 --> 01:54:38.240
Anlaşıldı mı?

01:54:40.920 --> 01:54:41.640
Evet.

01:54:43.080 --> 01:54:43.580
Şimdi,

01:54:44.820 --> 01:54:47.220
tabi bambaşka amaçlar içinde kullanılabilir.

01:54:47.480 --> 01:54:48.620
Mesela şöyle bir örnek,

01:54:48.980 --> 01:54:50.680
belki biraz kafa karıştırıcı ama,

01:54:53.480 --> 01:54:54.320
int,

01:54:54.400 --> 01:54:54.640
n,

01:54:56.640 --> 01:54:58.320
bunun type parametre,

01:54:59.040 --> 01:55:00.120
espriye bakın şimdi,

01:55:00.120 --> 01:55:02.340
constexpr,

01:55:03.220 --> 01:55:04.160
int,

01:55:05.720 --> 01:55:06.960
fibonacci hesaplayacak.

01:55:07.040 --> 01:55:08.160
Bu örnek genelde,

01:55:08.840 --> 01:55:10.320
insanların çoğunu yanıltıyor.

01:55:10.700 --> 01:55:11.200
İzleyin.

01:55:12.080 --> 01:55:12.920
constexpr,

01:55:14.080 --> 01:55:16.160
fonksiyon kendisi de constexpr,

01:55:16.360 --> 01:55:16.680
int,

01:55:17.120 --> 01:55:17.720
fibonacci hesaplayacak.

01:55:17.720 --> 01:55:19.520
arkadaşlar,

01:55:20.880 --> 01:55:21.900
if constexpr,

01:55:24.900 --> 01:55:26.440
n büyük eşit,

01:55:26.440 --> 01:55:27.320
2,

01:55:27.320 --> 01:55:32.320
yani fibonacci fonksiyonunun,

01:55:33.320 --> 01:55:33.820
arkadaşlar,

01:55:34.540 --> 01:55:36.620
2'den büyük ya da eşit,

01:55:37.820 --> 01:55:40.220
specialization'ları söz konusu olduğunda,

01:55:40.720 --> 01:55:41.820
burada kod derlenecek.

01:55:41.820 --> 01:55:43.540
return,

01:55:46.740 --> 01:55:47.300
fibon,

01:55:49.600 --> 01:55:50.480
n-1,

01:55:52.280 --> 01:55:53.040
artı,

01:55:54.260 --> 01:55:54.800
fibon,

01:55:57.600 --> 01:55:58.340
n-2,

01:56:02.340 --> 01:56:03.140
as,

01:56:07.140 --> 01:56:07.660
return,

01:56:07.660 --> 01:56:09.260
n-1,

01:56:12.260 --> 01:56:15.060
bunu compile-time miti ile karıştırmıyoruz değil mi?

01:56:15.060 --> 01:56:17.420
mesela ben,

01:56:19.760 --> 01:56:20.460
fibon,

01:56:21.840 --> 01:56:22.560
8,

01:56:23.440 --> 01:56:24.300
ya da 7,

01:56:25.980 --> 01:56:28.040
böyle bir fonksiyonu çağırdığımda,

01:56:29.800 --> 01:56:32.480
çağırdığım fonksiyonun return ifadesi bu olacak,

01:56:33.000 --> 01:56:34.280
çünkü en büyük eşit 2.

01:56:34.280 --> 01:56:36.580
bu durumda,

01:56:37.100 --> 01:56:38.840
2 fonksiyon daha yazılacak,

01:56:40.260 --> 01:56:42.280
yazılacak fonksiyonlardan biri,

01:56:43.200 --> 01:56:44.780
fibonun 6 açılımı,

01:56:44.880 --> 01:56:46.400
öbürü fibonun 5 açılımı,

01:56:48.280 --> 01:56:50.720
oradan da yine 2 tane fonksiyon yazılacak,

01:56:51.340 --> 01:56:52.380
takip edebiliyor muyuz?

01:56:52.820 --> 01:56:53.120
evet,

01:56:54.140 --> 01:56:54.640
arkadaşlar,

01:56:55.640 --> 01:56:55.960
ama,

01:56:57.540 --> 01:56:58.180
en son,

01:56:59.260 --> 01:56:59.940
fibonun,

01:57:00.460 --> 01:57:02.880
şurada fonksiyon çağırı operatörünü koymamışım,

01:57:02.880 --> 01:57:10.500
1 ya da 0 açılımı söz konusu olduğunda,

01:57:11.460 --> 01:57:13.380
orada çağırılan fonksiyonun kodu,

01:57:14.400 --> 01:57:15.040
return n,

01:57:15.240 --> 01:57:17.280
yani return 1 ya da 0,

01:57:18.640 --> 01:57:19.380
böylece yine,

01:57:20.280 --> 01:57:23.540
compile-time'da fonksiyon yazdırarak,

01:57:24.180 --> 01:57:24.640
arkadaşlar,

01:57:25.640 --> 01:57:26.760
fibonacci sayısını,

01:57:26.760 --> 01:57:28.740
fibonacci serisinin eninci terimini,

01:57:28.800 --> 01:57:30.420
bu şekilde hesaplatmak mümkün değil,

01:57:30.900 --> 01:57:31.660
diyebilirsiniz ki,

01:57:31.740 --> 01:57:32.760
böyle bir şeye ne gerek var,

01:57:32.760 --> 01:57:33.380
haklısınız,

01:57:34.200 --> 01:57:34.760
kaldı ki bakın,

01:57:34.820 --> 01:57:36.260
bu da bir sabit ifadesi,

01:57:37.220 --> 01:57:37.540
şimdi,

01:57:38.040 --> 01:57:39.540
eğer başka bir hata yoksa,

01:57:39.940 --> 01:57:40.720
constexpr,

01:57:42.660 --> 01:57:43.120
auto,

01:57:44.380 --> 01:57:44.820
while,

01:57:45.320 --> 01:57:46.000
eşittir,

01:57:48.660 --> 01:57:49.900
burada da göstermesi lazım,

01:57:50.020 --> 01:57:50.260
bakın,

01:57:50.420 --> 01:57:51.300
yedinci terim,

01:57:51.540 --> 01:57:52.040
neymiş,

01:57:52.480 --> 01:57:53.040
13'miş,

01:57:54.440 --> 01:57:55.400
akıllı kadir diyor ki,

01:57:55.400 --> 01:57:56.380
lisans döneminde,

01:57:56.520 --> 01:57:57.500
sınav sorumuzdu,

01:57:58.340 --> 01:57:58.880
mesela bakın,

01:57:58.920 --> 01:58:00.100
çok güzel bir örnek daha,

01:58:00.100 --> 01:58:06.560
böyle bir fonksiyon yazmak istiyorum ki,

01:58:07.660 --> 01:58:09.260
parametresi pointer ise,

01:58:09.620 --> 01:58:10.600
geri dönüş değeri,

01:58:11.500 --> 01:58:14.460
o pointer'ın gösterdiği nesnenin değeri olsun,

01:58:15.880 --> 01:58:18.500
ama parametresi pointer değilse,

01:58:19.880 --> 01:58:21.560
parametrenin kendi değeri olsun,

01:58:21.560 --> 01:58:25.180
template type name t,

01:58:26.440 --> 01:58:26.800
auto,

01:58:28.380 --> 01:58:31.100
get value olsun fonksiyonun ismi,

01:58:32.180 --> 01:58:32.400
t,

01:58:32.940 --> 01:58:33.620
arkadaşlar,

01:58:34.800 --> 01:58:35.220
x,

01:58:35.220 --> 01:58:40.780
if constexpr,

01:58:42.780 --> 01:58:45.000
type trace başlık dosyası,

01:58:45.500 --> 01:58:46.940
include edilmiş durumda,

01:58:48.880 --> 01:58:49.400
t'nin,

01:58:49.780 --> 01:58:51.420
fons evitörü olup olmadığını,

01:58:51.900 --> 01:58:52.980
sorgulamak için,

01:58:54.260 --> 01:58:54.740
sput,

01:58:56.060 --> 01:58:56.480
is,

01:58:57.000 --> 01:58:57.620
integral,

01:59:01.620 --> 01:59:04.060
ya şöyle yazacağım artık buna alıştık değil mi,

01:59:04.060 --> 01:59:06.560
isintegral t'nin value'su,

01:59:08.000 --> 01:59:10.620
ya da variable template'i kullanacağım,

01:59:11.680 --> 01:59:14.560
isintegral underscore v t,

01:59:18.060 --> 01:59:18.720
return,

01:59:21.000 --> 01:59:21.820
yıldız x,

01:59:25.060 --> 01:59:25.540
as,

01:59:28.740 --> 01:59:30.460
return x,

01:59:30.460 --> 01:59:36.300
hesabı bakın,

01:59:37.840 --> 01:59:38.600
int e,

01:59:39.180 --> 01:59:40.320
eşit bir 56,

01:59:43.420 --> 01:59:44.200
iostream,

01:59:47.860 --> 01:59:48.640
cout,

01:59:50.180 --> 01:59:50.940
get value,

01:59:53.080 --> 01:59:53.380
i,

01:59:53.380 --> 02:00:06.280
tüss,

02:00:06.280 --> 02:00:06.980
just drink,

02:00:07.760 --> 02:00:10.300
P,

02:00:14.300 --> 02:00:14.760
s,

02:00:14.760 --> 02:00:19.740
what role,

02:00:19.740 --> 02:00:22.940
kod yıldız p

02:00:22.940 --> 02:00:27.340
eşittir adres s

02:00:27.340 --> 02:00:29.240
cout

02:00:29.240 --> 02:00:31.600
get value p

02:00:31.600 --> 02:00:36.080
ikinci get value çağrısında

02:00:36.080 --> 02:00:38.040
derleyicinin oluşturacağı kod

02:00:38.040 --> 02:00:40.420
return yıldız x

02:00:40.420 --> 02:00:43.620
t türü pointer türü olduğu zaman

02:00:49.740 --> 02:00:51.640
ters yazmışız

02:00:51.640 --> 02:00:59.420
integral kalmış ters yazmamışım da

02:00:59.420 --> 02:01:01.100
is pointer yazacakken

02:01:01.100 --> 02:01:03.100
is integral yazmışım

02:01:03.100 --> 02:01:04.780
evet is pointer

02:01:04.780 --> 02:01:07.780
underscore v

02:01:07.780 --> 02:01:09.200
e

02:01:09.200 --> 02:01:11.360
şimdi doğru

02:01:19.740 --> 02:01:23.060
runtime'a bakalım

02:01:23.060 --> 02:01:29.840
evet arkadaşlar bakın şimdi

02:01:29.840 --> 02:01:32.680
çok güzel bir örnek daha

02:01:32.680 --> 02:01:35.920
yani if constexpr'nin

02:01:35.920 --> 02:01:37.860
sağladığı avantajı

02:01:37.860 --> 02:01:39.600
anlatabilen bence

02:01:39.600 --> 02:01:41.320
çok güzel bir örnek daha

02:01:41.320 --> 02:01:43.920
önce şu koda bakalım

02:01:43.920 --> 02:01:54.340
arkadaşlar şimdi bu kodda ne görüyoruz

02:01:54.340 --> 02:01:55.840
bu kodda

02:01:55.840 --> 02:01:57.220
dört tane

02:01:57.220 --> 02:01:58.500
overload var

02:01:58.500 --> 02:02:01.440
üstteki overload

02:02:01.440 --> 02:02:03.040
hepsinin ismi aynı olduğu için

02:02:03.040 --> 02:02:04.020
bunlar overload

02:02:04.020 --> 02:02:06.400
biliyorsunuz normal fonksiyonlarla

02:02:06.400 --> 02:02:07.760
fonksiyon şablonları

02:02:07.760 --> 02:02:09.700
birbirini overload edebiliyor

02:02:09.700 --> 02:02:13.840
en üstteki fonksiyon şablonu

02:02:13.840 --> 02:02:16.280
ama alttakilerin hepsi

02:02:16.280 --> 02:02:18.540
normal fonksiyon

02:02:18.540 --> 02:02:20.880
bu durumda hatırlayın

02:02:20.880 --> 02:02:23.880
eğer gerçek fonksiyonun

02:02:23.880 --> 02:02:26.200
parametresiyle aynı tür ise

02:02:26.200 --> 02:02:27.640
gönderilen argüman

02:02:27.640 --> 02:02:28.700
aynı türden ise

02:02:28.700 --> 02:02:31.240
gerçek fonksiyon çağrılacak

02:02:31.240 --> 02:02:33.020
aksi halde

02:02:33.020 --> 02:02:35.800
fonksiyon şablonundan fonksiyon üretilecek

02:02:35.800 --> 02:02:37.780
dolayısıyla

02:02:37.780 --> 02:02:40.340
fonksiyonların koduna bakalım

02:02:40.340 --> 02:02:43.100
fonksiyon şablonu

02:02:43.100 --> 02:02:44.660
to string'e çağrı yaptı

02:02:44.660 --> 02:02:48.060
buradaki fonksiyon

02:02:48.060 --> 02:02:50.740
string nesnesinin kendisini döndürdü

02:02:50.740 --> 02:02:52.960
buradaki fonksiyon

02:02:52.960 --> 02:02:54.140
arkadaşlar

02:02:54.140 --> 02:02:56.920
c string'i

02:02:56.920 --> 02:02:58.540
string'e dönüştürdü

02:02:58.540 --> 02:02:59.980
hatta hatta

02:02:59.980 --> 02:03:01.580
buradaki fonksiyon

02:03:01.580 --> 02:03:03.360
bu da ilginç

02:03:03.360 --> 02:03:05.360
boolean parametreli

02:03:05.360 --> 02:03:08.020
fakat true değer gelirse

02:03:08.020 --> 02:03:10.820
true yazısını

02:03:10.820 --> 02:03:12.600
bir string olarak döndürüyor

02:03:12.600 --> 02:03:14.280
st string olarak döndürüyor

02:03:14.280 --> 02:03:16.120
false değer gelirse

02:03:16.120 --> 02:03:18.440
false yazısını döndürüyor

02:03:18.440 --> 02:03:21.800
gerçekten de şimdi fonksiyon çağrılarına bakın

02:03:21.800 --> 02:03:24.400
hatta şöyle göstersin

02:03:24.400 --> 02:03:26.040
cztr gönderdim

02:03:26.040 --> 02:03:28.540
arkadaşlar bu çalışacak

02:03:28.540 --> 02:03:31.160
st string gönderdim

02:03:31.160 --> 02:03:33.780
arkadaşlar bu çalışacak

02:03:33.780 --> 02:03:35.040
öyle değil mi

02:03:35.040 --> 02:03:37.640
efendim int gönderdim

02:03:37.640 --> 02:03:39.780
buradan fonksiyon yazılacak

02:03:39.780 --> 02:03:41.880
double gönderdim

02:03:41.880 --> 02:03:43.440
buradan fonksiyon yazılacak

02:03:43.440 --> 02:03:44.740
boolean gönderdim

02:03:44.740 --> 02:03:45.720
bu çağrılacak

02:03:45.720 --> 02:03:51.220
ama şimdi

02:03:51.220 --> 02:03:53.240
bir iki

02:03:53.240 --> 02:03:55.660
biri fonksiyon çablonu olmak üzere

02:03:55.660 --> 02:03:57.520
bir iki

02:03:57.520 --> 02:03:58.300
üç

02:03:58.300 --> 02:03:59.540
dört tane

02:03:59.540 --> 02:04:01.420
fonksiyon yazdık

02:04:01.420 --> 02:04:04.440
yani overloading'den faydalandık

02:04:04.440 --> 02:04:05.260
öyle değil mi

02:04:05.260 --> 02:04:06.900
ama şimdi

02:04:06.900 --> 02:04:09.440
overloading yerine

02:04:09.440 --> 02:04:12.320
derleyicinin compile time'da

02:04:12.320 --> 02:04:14.040
kod seçmesini sağlayalım

02:04:14.040 --> 02:04:16.680
template type name'de

02:04:16.680 --> 02:04:18.900
st string

02:04:18.900 --> 02:04:22.500
to str

02:04:22.500 --> 02:04:25.900
parametrisi

02:04:25.900 --> 02:04:27.080
p türünden

02:04:27.080 --> 02:04:28.240
ne olsun

02:04:28.240 --> 02:04:28.820
p

02:04:28.820 --> 02:04:33.400
az önceki fonksiyonun

02:04:33.400 --> 02:04:35.500
yapısının aynısını oluşturacağım

02:04:35.500 --> 02:04:36.760
arkadaşlar

02:04:36.760 --> 02:04:39.220
is convertible diye bir

02:04:39.220 --> 02:04:40.480
meta fonksiyon var

02:04:40.480 --> 02:04:42.520
bir türden bir türe

02:04:42.520 --> 02:04:43.760
dönüşüm var mı

02:04:43.760 --> 02:04:44.800
onu sınıyor

02:04:44.800 --> 02:04:47.000
yani şöyle kullanıyor

02:04:47.000 --> 02:04:47.260
bakın

02:04:47.260 --> 02:04:47.720
st

02:04:47.720 --> 02:04:49.540
is

02:04:49.540 --> 02:04:52.220
convertible'ın

02:04:52.220 --> 02:04:58.760
iki tane template parametrisi var

02:04:58.760 --> 02:04:59.500
t

02:04:59.500 --> 02:05:01.800
ikinci tür

02:05:01.800 --> 02:05:04.660
mesela iki tane template parametrisi olsaydı bu

02:05:04.660 --> 02:05:06.900
t türünden u türüne

02:05:06.900 --> 02:05:08.780
dönüşüm var mı

02:05:08.780 --> 02:05:10.760
sorusunun cevabını olacaktık

02:05:10.760 --> 02:05:11.300
ama burada

02:05:11.300 --> 02:05:12.820
st

02:05:12.820 --> 02:05:13.260
st

02:05:13.260 --> 02:05:13.720
string

02:05:13.720 --> 02:05:15.060
yazarsam

02:05:15.060 --> 02:05:17.060
neyi sınamış oluyorum

02:05:17.060 --> 02:05:23.100
bu fonksiyonun template parametrisine karşılık gelen template argümanı olan türden

02:05:23.100 --> 02:05:23.800
st

02:05:23.800 --> 02:05:24.340
st

02:05:24.340 --> 02:05:24.680
string

02:05:24.680 --> 02:05:25.300
türüne

02:05:25.300 --> 02:05:26.820
dönüşüm var mı

02:05:26.820 --> 02:05:29.760
bakın farklı farklı meta fonksiyonlar var

02:05:29.760 --> 02:05:31.260
böyle yazmak yerine

02:05:31.260 --> 02:05:33.040
is

02:05:33.040 --> 02:05:34.380
seyimi kullansaydım

02:05:34.380 --> 02:05:36.200
bu dönüşüm değil

02:05:36.200 --> 02:05:37.500
t türü doğrudan

02:05:37.500 --> 02:05:38.500
string türü mü

02:05:38.500 --> 02:05:41.140
sorusunun cevabını alacaktım

02:05:41.140 --> 02:05:43.840
ama böyle yazarsam

02:05:43.840 --> 02:05:45.700
arkadaşlar bu

02:05:45.700 --> 02:05:48.300
dönüşüm var mı

02:05:48.300 --> 02:05:49.560
sorusunun cevabını veriyor

02:05:49.560 --> 02:05:52.100
o zaman if constexpr'de

02:05:52.100 --> 02:05:57.140
if parantezi içine bu ifadeye koyarsam

02:05:57.140 --> 02:05:57.540
bu arada

02:05:57.540 --> 02:06:02.340
arkadaşlar burada constexpr bir fonksiyona çağrı da yapabilirsiniz

02:06:02.340 --> 02:06:03.060
tabii ki

02:06:03.060 --> 02:06:05.900
çünkü o da bir sabit ifadesi

02:06:05.900 --> 02:06:09.860
if'in doğru kısmına girerse

02:06:09.860 --> 02:06:13.240
string'e dönüştürülebilen bir türse

02:06:13.240 --> 02:06:14.300
o zaman doğrudan

02:06:14.300 --> 02:06:16.100
argüman

02:06:16.100 --> 02:06:19.640
fonksiyonun parametre değişikliğine return ifadesi yapıyorum

02:06:19.640 --> 02:06:22.400
ne de olsa string'e örtülü olarak dönüşüyor

02:06:22.400 --> 02:06:24.700
else if

02:06:24.700 --> 02:06:27.300
constexpr

02:06:27.300 --> 02:06:29.960
e

02:06:29.960 --> 02:06:30.540
tür

02:06:30.540 --> 02:06:31.700
bool türü ise

02:06:31.700 --> 02:06:33.160
bu özel bir durum

02:06:33.160 --> 02:06:35.740
o zaman burada da

02:06:35.740 --> 02:06:36.940
is seyimi kullanırım

02:06:36.940 --> 02:06:38.200
stud

02:06:38.200 --> 02:06:40.500
is seyimi

02:06:40.500 --> 02:06:42.800
underscore ve

02:06:42.800 --> 02:06:45.400
p türüyle

02:06:45.400 --> 02:06:46.340
bu türü

02:06:46.340 --> 02:06:47.860
aynı türlerse

02:06:47.860 --> 02:06:49.360
arkadaşlar

02:06:49.360 --> 02:06:51.500
o zaman da

02:06:51.500 --> 02:06:52.840
burada kodlendirilecek

02:06:52.840 --> 02:06:53.740
return

02:06:53.740 --> 02:06:59.260
turner operatörü kullanalım yine

02:06:59.260 --> 02:07:00.060
true

02:07:00.060 --> 02:07:02.740
boz

02:07:02.740 --> 02:07:08.740
eğer string'e dönüştürülebilen bir tür değilse

02:07:08.740 --> 02:07:10.980
bu türü de değilse

02:07:10.980 --> 02:07:13.940
o zaman buradaki statement yürütülecek

02:07:13.940 --> 02:07:15.480
return

02:07:15.480 --> 02:07:15.540
return

02:07:15.540 --> 02:07:17.100
to

02:07:17.100 --> 02:07:18.280
to

02:07:18.280 --> 02:07:18.680
string

02:07:18.680 --> 02:07:22.680
ee

02:07:22.680 --> 02:07:24.400
bu kadar

02:07:24.400 --> 02:07:26.500
arkadaşlar tabi

02:07:26.500 --> 02:07:30.040
bundan sonra öğreneceğimiz araçlarla da birlikte kullanacağız

02:07:30.040 --> 02:07:31.040
sadece kullanımı

02:07:31.040 --> 02:07:33.120
bunlarla sınırlı değil

02:07:33.120 --> 02:07:35.580
şimdi sadece bir tanışma olduğu

02:07:35.580 --> 02:07:37.660
if constexpr'nin

02:07:37.660 --> 02:07:39.700
compile time if'in kullanılacağı

02:07:39.700 --> 02:07:42.300
daha ileride özellikle STL'e geçtiğimizde

02:07:42.300 --> 02:07:43.640
bir sürü

02:07:43.640 --> 02:07:45.140
farklı senaryolar

02:07:45.140 --> 02:07:46.300
olacak

02:07:46.300 --> 02:07:49.440
şimdi geriye kaldı

02:07:49.440 --> 02:07:51.440
iki tane daha alt başlığımız

02:07:51.440 --> 02:07:54.700
biliyorum sizi de baya bir yordu bu

02:07:54.700 --> 02:07:55.600
tentep konusu

02:07:55.600 --> 02:07:56.240
ama

02:07:56.240 --> 02:07:59.920
iki üç tane daha alt başlığı alıp artık gerçekten bitireceğiz

02:07:59.920 --> 02:08:02.960
is convertible ve

02:08:02.960 --> 02:08:05.060
örtülü dönüşümü kontrol ediyor

02:08:05.060 --> 02:08:05.520
evet

02:08:05.520 --> 02:08:06.600
evet

02:08:06.600 --> 02:08:07.420
evet yani

02:08:07.420 --> 02:08:09.860
örtülü dönüşüm olmazsa

02:08:09.860 --> 02:08:10.600
true değer

02:08:10.600 --> 02:08:11.540
vermeyecek

02:08:11.540 --> 02:08:13.040
arkadaşlar şimdi

02:08:13.040 --> 02:08:13.860
bir

02:08:13.860 --> 02:08:15.460
static

02:08:15.460 --> 02:08:17.600
assert

02:08:17.600 --> 02:08:19.600
declaration

02:08:19.600 --> 02:08:24.040
2

02:08:24.040 --> 02:08:27.320
old

02:08:27.320 --> 02:08:28.000
expressions

02:08:28.000 --> 02:08:33.580
her iki konuyu da

02:08:33.580 --> 02:08:36.100
yine belirli bir ayrıntı düzeyinde

02:08:36.100 --> 02:08:37.600
görmemiz gerekiyor

02:08:37.600 --> 02:08:39.420
arkadaşlar önce

02:08:39.420 --> 02:08:40.400
static

02:08:40.400 --> 02:08:40.800
assert

02:08:40.800 --> 02:08:41.900
declaration

02:08:41.900 --> 02:08:43.000
başlayalım

02:08:43.000 --> 02:08:44.280
arkadaşlar

02:08:44.280 --> 02:08:45.300
şimdi

02:08:45.300 --> 02:08:47.400
assertion'ın ne olduğunu herkes hatırlıyor

02:08:47.400 --> 02:08:49.580
c'den daha biliyorsunuz

02:08:49.600 --> 02:08:51.460
doğrulama

02:08:51.460 --> 02:08:56.640
assertion'ları iki kategoriye ayırdığımızı daha önce konuşmuştuk

02:08:56.640 --> 02:08:58.140
compile time assertions

02:08:58.140 --> 02:08:59.620
ya da static assertions

02:08:59.620 --> 02:09:01.260
bir de

02:09:01.260 --> 02:09:02.080
runtime

02:09:02.080 --> 02:09:03.320
assertions

02:09:03.320 --> 02:09:06.760
yani compile time'de yapılan doğrulamalar

02:09:06.760 --> 02:09:08.800
ve runtime'de yapılan doğrulamalar

02:09:08.800 --> 02:09:10.140
runtime assertions

02:09:10.140 --> 02:09:14.680
assert makrosu ile tipik olarak

02:09:14.680 --> 02:09:15.800
kullanılıyor

02:09:15.800 --> 02:09:17.400
yani assert makrosu

02:09:17.400 --> 02:09:19.260
runtime assertions'ın

02:09:19.260 --> 02:09:20.200
temel aracı

02:09:20.200 --> 02:09:22.040
c'de

02:09:22.040 --> 02:09:23.600
assert başlık dosyasındaki

02:09:23.600 --> 02:09:24.440
functional

02:09:24.440 --> 02:09:25.680
makro'dan bahsediyorum

02:09:25.680 --> 02:09:26.880
c'de ayrıntılı olarak

02:09:26.880 --> 02:09:28.340
anlatmıştım

02:09:28.340 --> 02:09:29.880
ama

02:09:29.880 --> 02:09:32.320
compile time assertions

02:09:32.320 --> 02:09:34.780
compile time'de yapılan doğrulamalar

02:09:34.780 --> 02:09:35.640
arkadaşlar

02:09:35.640 --> 02:09:37.360
arkadaşlar c'nin

02:09:37.360 --> 02:09:39.280
yine 2011 standartıyla

02:09:39.280 --> 02:09:40.720
c'ye de static assert

02:09:40.720 --> 02:09:42.280
declarations

02:09:42.280 --> 02:09:42.940
eklendi

02:09:42.940 --> 02:09:45.760
c++'da da static assert

02:09:45.760 --> 02:09:48.100
modern c++'da

02:09:48.100 --> 02:09:49.640
dileklenen bir araç

02:09:49.640 --> 02:09:53.640
static assert

02:09:53.640 --> 02:09:56.500
arkadaşlar

02:09:56.500 --> 02:10:00.080
bir bildirim

02:10:00.080 --> 02:10:00.480
yani

02:10:00.480 --> 02:10:02.280
syntax'da ne olarak

02:10:02.280 --> 02:10:02.740
geçiyor

02:10:02.740 --> 02:10:03.840
bir bildirim olarak

02:10:03.840 --> 02:10:04.340
geçiyor

02:10:04.340 --> 02:10:05.260
static assert

02:10:05.260 --> 02:10:06.220
declarations

02:10:06.220 --> 02:10:08.500
bu bildirimi

02:10:08.500 --> 02:10:11.000
lokal düzeyde

02:10:11.000 --> 02:10:12.900
ya da global düzeyde

02:10:12.900 --> 02:10:14.900
yapabiliyorsunuz

02:10:14.900 --> 02:10:16.460
hatta bir sınıfın içinde de

02:10:16.460 --> 02:10:17.920
doğrudan yazabiliyorsunuz

02:10:17.920 --> 02:10:19.860
yani

02:10:19.860 --> 02:10:21.680
şunların hepsi geçerli

02:10:21.680 --> 02:10:22.560
bir

02:10:22.560 --> 02:10:23.580
static assert

02:10:23.580 --> 02:10:24.680
bildirimini

02:10:24.680 --> 02:10:28.640
syntax'ı birazdan göstereceğim

02:10:28.640 --> 02:10:29.820
global düzeyde

02:10:29.820 --> 02:10:31.320
yapmak

02:10:31.320 --> 02:10:33.440
static assert

02:10:33.440 --> 02:10:34.280
bildirimini

02:10:34.280 --> 02:10:35.940
lokal düzeyde

02:10:35.940 --> 02:10:36.960
yani bir fonksiyonun

02:10:36.960 --> 02:10:37.860
içinde yapmak

02:10:37.860 --> 02:10:39.640
hatta

02:10:39.640 --> 02:10:40.640
static assert

02:10:40.640 --> 02:10:41.500
bildirimini

02:10:41.500 --> 02:10:43.180
doğrudan

02:10:43.180 --> 02:10:44.680
arkadaşlar

02:10:44.680 --> 02:10:46.180
bir sınıf tanımı

02:10:46.180 --> 02:10:47.080
içinde yapmak

02:10:47.080 --> 02:10:53.860
tabii ki burada

02:10:53.860 --> 02:10:55.120
static assert

02:10:55.120 --> 02:10:55.860
bildirimi

02:10:55.860 --> 02:10:57.320
jenerik

02:10:57.320 --> 02:10:57.900
kodlarla

02:10:57.900 --> 02:10:58.520
kullanılmak

02:10:58.520 --> 02:10:59.300
zorunda değil

02:10:59.300 --> 02:11:01.440
yani ortada

02:11:01.440 --> 02:11:01.900
bir template

02:11:01.900 --> 02:11:02.600
olsa da

02:11:02.600 --> 02:11:03.460
olmasa da

02:11:03.460 --> 02:11:04.400
static assert

02:11:04.400 --> 02:11:05.180
bildirimini

02:11:05.180 --> 02:11:06.860
kullanabiliyorsunuz

02:11:06.860 --> 02:11:08.720
fakat

02:11:08.720 --> 02:11:09.800
arkadaşlar

02:11:09.800 --> 02:11:12.260
template

02:11:12.260 --> 02:11:12.860
kodlarla

02:11:12.860 --> 02:11:13.480
kullanımı

02:11:13.480 --> 02:11:14.320
tabii ki

02:11:14.320 --> 02:11:14.900
çok daha

02:11:14.900 --> 02:11:15.820
yaygın

02:11:15.820 --> 02:11:17.440
şimdi

02:11:17.440 --> 02:11:18.860
static assert

02:11:18.860 --> 02:11:19.720
bildiriminde

02:11:19.720 --> 02:11:21.420
normalde

02:11:21.420 --> 02:11:22.480
syntax'ta

02:11:22.480 --> 02:11:23.980
static assert

02:11:23.980 --> 02:11:24.920
bildiriminin

02:11:24.920 --> 02:11:25.440
iki tane

02:11:25.440 --> 02:11:26.200
parametresi

02:11:26.200 --> 02:11:27.240
olması gerekiyordu

02:11:27.240 --> 02:11:28.920
yanlış bir

02:11:28.920 --> 02:11:29.400
kararla

02:11:29.400 --> 02:11:31.160
şöyle ki

02:11:31.160 --> 02:11:32.120
genel

02:11:32.120 --> 02:11:32.560
syntax

02:11:32.560 --> 02:11:33.280
şöyleydi

02:11:33.280 --> 02:11:34.200
static

02:11:34.200 --> 02:11:34.680
assert

02:11:34.680 --> 02:11:36.920
arkadaşlar

02:11:36.920 --> 02:11:39.500
o anahtar

02:11:39.500 --> 02:11:40.460
sözcükten sonra

02:11:40.460 --> 02:11:41.340
parantez

02:11:41.340 --> 02:11:42.160
parantezin

02:11:42.160 --> 02:11:42.500
içine

02:11:42.500 --> 02:11:42.880
bir

02:11:42.880 --> 02:11:43.600
compile time

02:11:43.600 --> 02:11:44.560
ifadesi

02:11:44.560 --> 02:11:45.860
yani bir

02:11:45.860 --> 02:11:47.260
constant expression

02:11:47.260 --> 02:11:49.580
ondan sonra da

02:11:49.580 --> 02:11:50.020
bir string

02:11:50.020 --> 02:11:50.540
literali

02:11:50.540 --> 02:11:56.700
böylece

02:11:56.700 --> 02:11:57.420
derleyici

02:11:57.420 --> 02:11:58.240
compile time

02:11:58.240 --> 02:11:59.320
buraya dikkat

02:11:59.320 --> 02:12:01.180
statik assert

02:12:01.180 --> 02:12:01.200
statik assert

02:12:01.200 --> 02:12:03.100
birinci

02:12:03.100 --> 02:12:04.080
parametresi

02:12:04.080 --> 02:12:04.480
diyelim

02:12:04.480 --> 02:12:06.900
ona gönderilen

02:12:06.900 --> 02:12:08.220
sabit ifadesinin

02:12:08.220 --> 02:12:09.360
compile time'da

02:12:09.360 --> 02:12:09.820
true mu

02:12:09.820 --> 02:12:10.700
false mu olduğunu

02:12:10.700 --> 02:12:11.200
sınıyor

02:12:11.200 --> 02:12:12.160
boolean olarak

02:12:12.160 --> 02:12:12.740
yorumlanıyor

02:12:12.740 --> 02:12:13.400
bu ifade

02:12:13.400 --> 02:12:15.400
true ise

02:12:15.400 --> 02:12:16.000
bir syntax

02:12:16.000 --> 02:12:16.420
hatası

02:12:16.420 --> 02:12:17.040
oluşmuyor

02:12:17.040 --> 02:12:18.260
ama

02:12:18.260 --> 02:12:19.060
false ise

02:12:19.060 --> 02:12:20.280
doğrudan

02:12:20.280 --> 02:12:20.820
bir syntax

02:12:20.820 --> 02:12:21.240
hatası

02:12:21.240 --> 02:12:21.780
oluşuyor

02:12:21.780 --> 02:12:24.360
ve oluşan

02:12:24.360 --> 02:12:24.840
syntax

02:12:24.840 --> 02:12:25.320
hatasını

02:12:25.320 --> 02:12:25.840
verirken

02:12:25.840 --> 02:12:26.900
de derleyiciniz

02:12:26.900 --> 02:12:28.360
statik assert'un

02:12:28.360 --> 02:12:29.820
ikinci parametresi

02:12:29.820 --> 02:12:30.240
olan

02:12:30.240 --> 02:12:32.140
string literalini

02:12:32.140 --> 02:12:33.280
hata mesajında

02:12:33.280 --> 02:12:33.940
gösteriyor

02:12:33.940 --> 02:12:36.020
hadi bir örnek verelim

02:12:36.020 --> 02:12:36.700
arkadaşlar

02:12:36.700 --> 02:12:38.520
mesela

02:12:38.520 --> 02:12:39.740
izleyin

02:12:39.740 --> 02:12:41.140
herhangi bir kodda

02:12:41.140 --> 02:12:44.540
hatta global düzeyde

02:12:44.540 --> 02:12:46.360
statik assert

02:12:46.360 --> 02:12:51.840
bu benim sabit ifadem

02:12:51.840 --> 02:12:53.500
size of

02:12:53.500 --> 02:12:54.240
int

02:12:54.240 --> 02:12:58.000
büyüktür

02:12:58.000 --> 02:12:58.580
2

02:12:58.580 --> 02:13:00.440
c++

02:13:00.440 --> 02:13:02.100
17'ye kadar

02:13:02.100 --> 02:13:04.000
string literali olan

02:13:04.000 --> 02:13:04.600
argümanın

02:13:04.600 --> 02:13:04.980
olması

02:13:04.980 --> 02:13:05.880
mecburiyetti

02:13:05.880 --> 02:13:06.960
soru ortadan

02:13:06.960 --> 02:13:07.560
kalktı

02:13:07.560 --> 02:13:08.320
dolayısıyla

02:13:08.320 --> 02:13:08.800
şimdi

02:13:08.800 --> 02:13:11.340
size of

02:13:11.340 --> 02:13:11.980
int

02:13:11.980 --> 02:13:13.500
must

02:13:13.500 --> 02:13:14.080
be

02:13:14.080 --> 02:13:15.580
greater

02:13:15.580 --> 02:13:17.200
than

02:13:17.200 --> 02:13:19.020
arkadaşlar

02:13:19.020 --> 02:13:19.920
do

02:13:19.920 --> 02:13:22.200
bakın

02:13:22.200 --> 02:13:23.540
kodu derlediğim

02:13:23.540 --> 02:13:23.980
zaman

02:13:23.980 --> 02:13:25.820
static

02:13:25.820 --> 02:13:26.140
assert

02:13:26.140 --> 02:13:26.880
fail olmadı

02:13:26.880 --> 02:13:27.620
çünkü ifade

02:13:27.620 --> 02:13:28.080
doğru

02:13:28.080 --> 02:13:29.880
ama

02:13:29.880 --> 02:13:31.080
bu ifade

02:13:31.080 --> 02:13:32.180
compile time'de

02:13:32.180 --> 02:13:33.460
yanlış olsaydı

02:13:33.460 --> 02:13:35.640
derleyici

02:13:35.640 --> 02:13:36.640
bir syntax

02:13:36.640 --> 02:13:37.060
hatası

02:13:37.060 --> 02:13:37.500
verme

02:13:37.500 --> 02:13:38.640
yükümlülüğünde

02:13:38.640 --> 02:13:39.920
ve bu

02:13:39.920 --> 02:13:40.900
string literalini

02:13:40.900 --> 02:13:41.800
syntax

02:13:41.800 --> 02:13:42.220
hatası

02:13:42.220 --> 02:13:42.700
mesajı

02:13:42.700 --> 02:13:43.060
olarak

02:13:43.060 --> 02:13:44.100
bize

02:13:44.100 --> 02:13:44.860
verecekti

02:13:44.860 --> 02:13:45.580
bakın static

02:13:45.580 --> 02:13:45.940
assert

02:13:45.940 --> 02:13:46.480
failed

02:13:46.480 --> 02:13:48.040
yani static

02:13:48.040 --> 02:13:48.480
assertion

02:13:48.480 --> 02:13:49.120
başarısız

02:13:49.120 --> 02:13:50.020
olduğu anlamda

02:13:50.020 --> 02:13:51.360
int

02:13:51.360 --> 02:13:52.100
size

02:13:52.100 --> 02:13:52.360
of

02:13:52.360 --> 02:13:53.320
4'den

02:13:53.320 --> 02:13:53.600
büyük

02:13:53.600 --> 02:13:54.200
olmalı

02:13:54.200 --> 02:13:55.980
dolayısıyla

02:13:55.980 --> 02:13:56.900
compile time'de

02:13:56.900 --> 02:13:57.580
bir kontrol

02:13:57.580 --> 02:13:58.260
yaptırıyorum

02:13:58.260 --> 02:13:59.300
derleyiciye

02:13:59.300 --> 02:14:01.060
o kontrol

02:14:01.060 --> 02:14:03.000
doğru neticelenmez

02:14:03.000 --> 02:14:03.420
ise

02:14:03.420 --> 02:14:04.680
doğru sonuçlanmaz

02:14:04.680 --> 02:14:05.120
ise

02:14:05.120 --> 02:14:06.680
derleyicinin

02:14:06.680 --> 02:14:07.220
syntax

02:14:07.220 --> 02:14:07.640
hatası

02:14:07.640 --> 02:14:08.240
vermesini

02:14:08.240 --> 02:14:08.880
sağlıyorum

02:14:08.880 --> 02:14:10.400
böylece

02:14:10.400 --> 02:14:12.640
kodun

02:14:12.640 --> 02:14:13.580
derlenmesi

02:14:13.580 --> 02:14:13.960
için

02:14:13.960 --> 02:14:14.480
gerekli

02:14:14.480 --> 02:14:15.000
şartlar

02:14:15.000 --> 02:14:16.060
oluşmadığında

02:14:16.060 --> 02:14:17.860
erken

02:14:17.860 --> 02:14:18.560
daha derleme

02:14:18.560 --> 02:14:19.120
zamanında

02:14:19.120 --> 02:14:19.580
syntax

02:14:19.580 --> 02:14:20.040
hatası

02:14:20.040 --> 02:14:20.560
alarak

02:14:20.560 --> 02:14:21.940
arkadaşlar

02:14:21.940 --> 02:14:23.580
işimi

02:14:23.580 --> 02:14:24.840
kolaylaştırıyorum

02:14:24.840 --> 02:14:26.700
ortada

02:14:26.700 --> 02:14:27.220
bir template

02:14:27.220 --> 02:14:27.660
kodun

02:14:27.660 --> 02:14:28.060
olması

02:14:28.060 --> 02:14:28.800
gerekmese

02:14:28.800 --> 02:14:29.100
de

02:14:29.100 --> 02:14:30.600
daha çok

02:14:30.600 --> 02:14:31.140
jenerik

02:14:31.140 --> 02:14:31.800
programlama

02:14:31.800 --> 02:14:32.320
tarafında

02:14:32.320 --> 02:14:32.940
kullanılacak

02:14:32.940 --> 02:14:33.900
tekrar söylüyorum

02:14:33.900 --> 02:14:34.800
bu bir mecburiyet

02:14:34.800 --> 02:14:35.220
değil

02:14:35.220 --> 02:14:36.700
mesela

02:14:36.700 --> 02:14:37.300
bakınız

02:14:37.300 --> 02:14:38.220
arkadaşlar

02:14:38.220 --> 02:14:39.760
bir sınıf

02:14:39.760 --> 02:14:40.220
şablonu

02:14:40.220 --> 02:14:40.440
ya da

02:14:40.440 --> 02:14:41.120
bir fonksiyon

02:14:41.120 --> 02:14:41.860
şablonu

02:14:41.860 --> 02:14:43.200
class

02:14:43.200 --> 02:14:44.600
my class

02:14:44.600 --> 02:14:48.040
şimdi özellikle

02:14:48.040 --> 02:14:49.060
C++ 20

02:14:49.060 --> 02:14:50.020
standardıyla

02:14:50.020 --> 02:14:52.560
konseptler

02:14:52.560 --> 02:14:53.700
dile eklenmediği

02:14:53.700 --> 02:14:54.100
zaman

02:14:54.100 --> 02:14:55.900
template'leri

02:14:55.900 --> 02:14:56.640
constraint

02:14:56.640 --> 02:14:57.040
etmek

02:14:57.040 --> 02:14:57.800
kısıtlamak

02:14:57.800 --> 02:14:58.160
için

02:14:58.160 --> 02:14:59.780
farklı farklı

02:14:59.780 --> 02:15:00.300
araçlar

02:15:00.300 --> 02:15:01.060
kullanılıyordu

02:15:01.060 --> 02:15:02.200
işte bu

02:15:02.200 --> 02:15:02.800
araçlardan

02:15:02.800 --> 02:15:03.500
biri de

02:15:03.500 --> 02:15:04.200
statik

02:15:04.200 --> 02:15:04.580
assert

02:15:04.580 --> 02:15:05.860
mesela

02:15:05.860 --> 02:15:07.100
ben

02:15:07.100 --> 02:15:08.260
my class

02:15:08.260 --> 02:15:08.600
sınıf

02:15:08.600 --> 02:15:09.380
şablonunun

02:15:09.380 --> 02:15:10.900
sadece

02:15:10.900 --> 02:15:12.180
tam sayı

02:15:12.180 --> 02:15:13.200
türleri için

02:15:13.200 --> 02:15:14.720
oluşturulacak

02:15:14.720 --> 02:15:15.980
specialization'ların

02:15:15.980 --> 02:15:16.960
geçerli olmasını

02:15:16.960 --> 02:15:17.700
istiyorsam

02:15:17.700 --> 02:15:19.620
örneğin

02:15:19.620 --> 02:15:20.980
my class'ın

02:15:20.980 --> 02:15:22.840
double açılımı

02:15:22.840 --> 02:15:23.780
gibi bir

02:15:23.780 --> 02:15:24.800
specialization'ın

02:15:24.800 --> 02:15:25.800
kullanılmasının

02:15:25.800 --> 02:15:27.160
syntax

02:15:27.160 --> 02:15:27.580
hatası

02:15:27.580 --> 02:15:28.100
olmasını

02:15:28.100 --> 02:15:28.820
istiyorsam

02:15:28.820 --> 02:15:30.680
bu durumda

02:15:30.680 --> 02:15:31.820
T türünün

02:15:31.820 --> 02:15:33.020
tam sayı

02:15:33.020 --> 02:15:33.220
türü

02:15:33.220 --> 02:15:33.980
olmaması

02:15:33.980 --> 02:15:34.640
durumunda

02:15:34.640 --> 02:15:36.220
statik

02:15:36.220 --> 02:15:37.320
assertion'ın

02:15:37.320 --> 02:15:38.260
fail olmasını

02:15:38.260 --> 02:15:39.260
sağlayabilirim

02:15:39.260 --> 02:15:41.300
bunu yapmak da

02:15:41.300 --> 02:15:41.820
son derece

02:15:41.820 --> 02:15:42.360
basit

02:15:42.360 --> 02:15:43.160
T'nin

02:15:43.160 --> 02:15:44.040
visible olduğu

02:15:44.040 --> 02:15:44.960
herhangi bir yerde

02:15:44.960 --> 02:15:46.680
statik

02:15:46.680 --> 02:15:47.000
assert

02:15:47.000 --> 02:15:47.840
declaration'ı

02:15:47.840 --> 02:15:48.320
koyup

02:15:48.320 --> 02:15:50.840
yine

02:15:50.840 --> 02:15:51.740
type

02:15:51.740 --> 02:15:52.200
traits

02:15:52.200 --> 02:15:53.540
kütüphanesindeki

02:15:53.540 --> 02:15:55.680
meta fonksiyonlardan

02:15:55.680 --> 02:15:56.680
faydalanarak

02:15:56.680 --> 02:15:58.220
tut

02:15:58.220 --> 02:15:59.720
is

02:15:59.720 --> 02:16:01.980
integral

02:16:01.980 --> 02:16:02.940
V'nin

02:16:02.940 --> 02:16:04.400
T açılımı

02:16:04.400 --> 02:16:07.500
şimdi görüyorsunuz

02:16:07.500 --> 02:16:08.400
string literelerde

02:16:08.400 --> 02:16:09.540
kullanmak zorunda da

02:16:09.540 --> 02:16:09.880
değilim

02:16:09.880 --> 02:16:10.840
eğer derleyiciniz

02:16:10.840 --> 02:16:12.280
statik assert'ün

02:16:12.280 --> 02:16:12.820
kendisine

02:16:12.820 --> 02:16:13.720
syntax hatası

02:16:13.720 --> 02:16:14.260
veriyorsa

02:16:14.260 --> 02:16:15.320
o

02:16:15.320 --> 02:16:17.080
string litereli

02:16:17.080 --> 02:16:18.000
kullanmadığınız için

02:16:18.000 --> 02:16:19.060
ama söylediğim gibi

02:16:19.060 --> 02:16:19.840
seedbastas

02:16:19.840 --> 02:16:20.500
17 ile

02:16:20.500 --> 02:16:21.460
o kalktı

02:16:21.460 --> 02:16:22.240
şimdi

02:16:22.240 --> 02:16:22.820
bakınız

02:16:22.820 --> 02:16:26.100
artık bu

02:16:26.100 --> 02:16:27.120
statik assertion'ın

02:16:27.120 --> 02:16:28.560
devreye girmesi için

02:16:28.560 --> 02:16:30.240
bu tabletten

02:16:30.240 --> 02:16:31.460
bir specialization

02:16:31.460 --> 02:16:32.180
oluşturmam

02:16:32.180 --> 02:16:32.640
gerekiyor

02:16:32.640 --> 02:16:33.520
olamam kontrol

02:16:33.520 --> 02:16:34.120
yapılacak

02:16:34.120 --> 02:16:35.540
örneğin

02:16:35.540 --> 02:16:36.820
my class'ın

02:16:36.820 --> 02:16:38.660
arkadaşlar

02:16:38.660 --> 02:16:39.960
int açılımı

02:16:39.960 --> 02:16:41.420
ne şekilde

02:16:41.420 --> 02:16:42.160
kullanırsam

02:16:42.160 --> 02:16:42.780
kullanayım

02:16:42.780 --> 02:16:43.860
bir

02:16:43.860 --> 02:16:44.760
syntax hatası

02:16:44.760 --> 02:16:45.080
yok

02:16:45.080 --> 02:16:46.740
ama

02:16:46.740 --> 02:16:47.980
my class'ın

02:16:47.980 --> 02:16:48.720
örneğin

02:16:48.720 --> 02:16:49.780
double açılımı

02:16:49.780 --> 02:16:50.480
deseydim

02:16:50.480 --> 02:16:52.820
statik assertion'a

02:16:52.820 --> 02:16:53.960
takılacaktı

02:16:53.960 --> 02:16:55.120
arkadaşlar

02:16:55.120 --> 02:16:56.440
izleyin

02:16:56.440 --> 02:16:58.660
gördüğünüz gibi

02:16:58.660 --> 02:16:59.920
statik assertion

02:16:59.920 --> 02:17:00.660
failed

02:17:00.660 --> 02:17:02.560
hatta buraya

02:17:02.560 --> 02:17:03.240
şöyle bir yazı

02:17:03.240 --> 02:17:03.940
koysaydım

02:17:03.940 --> 02:17:04.540
template

02:17:04.540 --> 02:17:07.580
argument

02:17:07.580 --> 02:17:10.080
must be

02:17:10.080 --> 02:17:11.460
integral

02:17:11.460 --> 02:17:18.340
gördünüz değil mi

02:17:18.340 --> 02:17:19.360
yine

02:17:19.360 --> 02:17:20.680
statik assertion'a

02:17:20.680 --> 02:17:21.600
takıldı

02:17:21.600 --> 02:17:23.060
arkadaşlar

02:17:23.060 --> 02:17:24.060
birden fazla

02:17:24.060 --> 02:17:25.200
statik assertion'u

02:17:25.200 --> 02:17:26.140
da koyabilirsiniz

02:17:26.140 --> 02:17:28.180
yani onda da

02:17:28.180 --> 02:17:29.100
herhangi bir şekilde

02:17:29.100 --> 02:17:29.980
bir engel yok

02:17:29.980 --> 02:17:31.020
mesela bir

02:17:31.020 --> 02:17:31.500
fonksiyon

02:17:31.500 --> 02:17:32.240
şalvunu

02:17:32.240 --> 02:17:35.860
template

02:17:35.860 --> 02:17:36.460
pipe name

02:17:36.460 --> 02:17:37.860
void

02:17:37.860 --> 02:17:39.980
func

02:17:39.980 --> 02:17:41.980
t türünden

02:17:41.980 --> 02:17:42.980
x

02:17:42.980 --> 02:17:43.580
tabi

02:17:43.580 --> 02:17:43.920
template

02:17:43.920 --> 02:17:44.660
parametresini

02:17:44.660 --> 02:17:45.080
fonksiyon

02:17:45.080 --> 02:17:45.740
parametresini

02:17:45.740 --> 02:17:46.760
kullanmadığım için

02:17:46.760 --> 02:17:48.340
sadece örnek olduğu için

02:17:48.340 --> 02:17:49.400
isim de vermiyorum

02:17:49.400 --> 02:17:50.780
arkadaşlar

02:17:50.780 --> 02:17:53.140
mesela

02:17:53.140 --> 02:17:54.380
statik assert

02:17:54.380 --> 02:18:01.060
spot

02:18:01.060 --> 02:18:03.800
is

02:18:03.800 --> 02:18:07.040
integral

02:18:07.040 --> 02:18:07.780
v

02:18:07.780 --> 02:18:09.080
e

02:18:09.080 --> 02:18:11.140
hem tam sayı

02:18:11.140 --> 02:18:11.400
türü

02:18:11.400 --> 02:18:15.200
olacak t türü

02:18:15.200 --> 02:18:17.120
ister

02:18:17.120 --> 02:18:17.720
logic v

02:18:17.720 --> 02:18:18.420
operatörünü

02:18:18.420 --> 02:18:19.000
kullanın

02:18:19.000 --> 02:18:19.940
ister

02:18:19.940 --> 02:18:20.940
ikinci bir

02:18:20.940 --> 02:18:21.620
statik assert

02:18:21.620 --> 02:18:22.080
yazın

02:18:22.080 --> 02:18:23.460
bu sefer

02:18:23.460 --> 02:18:24.340
ikisinin de

02:18:24.340 --> 02:18:25.080
fail olmaması

02:18:25.080 --> 02:18:25.560
gerekecek

02:18:25.560 --> 02:18:26.060
örneğin

02:18:26.060 --> 02:18:27.100
size of t

02:18:27.100 --> 02:18:32.040
büyük

02:18:32.040 --> 02:18:33.100
2

02:18:33.100 --> 02:18:37.960
bu arada

02:18:37.960 --> 02:18:38.440
noktalı

02:18:38.440 --> 02:18:38.780
virgül

02:18:38.780 --> 02:18:39.380
sen tersin

02:18:39.380 --> 02:18:39.920
bir birleşin

02:18:39.920 --> 02:18:40.520
yani noktalı

02:18:40.520 --> 02:18:40.840
virgül

02:18:40.840 --> 02:18:41.640
olmak zorunda

02:18:41.640 --> 02:18:42.400
çünkü bu da

02:18:42.400 --> 02:18:43.060
bir declaration

02:18:43.060 --> 02:18:45.380
bu durumda

02:18:45.380 --> 02:18:46.460
bu fonksiyon

02:18:46.460 --> 02:18:47.420
şablonundan

02:18:47.420 --> 02:18:48.780
kod üretilebilmesi

02:18:48.780 --> 02:18:49.300
için

02:18:49.300 --> 02:18:51.080
t türünün

02:18:51.080 --> 02:18:51.860
hem tam sayı

02:18:51.860 --> 02:18:52.420
türü olması

02:18:52.420 --> 02:18:53.160
gerekecek

02:18:53.160 --> 02:18:54.600
hem de

02:18:54.600 --> 02:18:56.120
aynı zamanda

02:18:56.120 --> 02:18:56.700
size of

02:18:56.700 --> 02:18:57.780
değerinin de

02:18:57.780 --> 02:18:58.340
2'den

02:18:58.340 --> 02:18:59.340
büyük olması

02:18:59.340 --> 02:19:00.040
gerekecek

02:19:00.040 --> 02:19:02.200
takip edebiliyor

02:19:02.200 --> 02:19:02.560
muyuz

02:19:02.560 --> 02:19:03.300
işte burada

02:19:03.300 --> 02:19:04.960
template

02:19:04.960 --> 02:19:05.980
parametrelerini

02:19:05.980 --> 02:19:07.220
constraint

02:19:07.220 --> 02:19:08.060
etmenin

02:19:08.060 --> 02:19:08.960
yollarından

02:19:08.960 --> 02:19:09.540
biri bu

02:19:09.540 --> 02:19:11.200
ama şimdi

02:19:11.200 --> 02:19:12.320
farklı yollar

02:19:12.320 --> 02:19:13.020
arasındaki

02:19:13.020 --> 02:19:13.780
farklara da

02:19:13.780 --> 02:19:14.460
dikkat edelim

02:19:14.460 --> 02:19:15.800
mesela

02:19:15.800 --> 02:19:16.920
burada

02:19:16.920 --> 02:19:18.640
template argümanını

02:19:18.640 --> 02:19:18.940
ben

02:19:18.940 --> 02:19:20.160
constraint ediyorum

02:19:20.160 --> 02:19:21.440
ama

02:19:21.440 --> 02:19:22.400
onun için

02:19:22.400 --> 02:19:23.380
bu template'in

02:19:23.380 --> 02:19:24.280
seçilmesi ve

02:19:24.280 --> 02:19:24.620
bundan

02:19:24.620 --> 02:19:25.540
kod üretilmesi

02:19:25.540 --> 02:19:26.140
gerekiyor

02:19:26.140 --> 02:19:27.600
yani

02:19:27.600 --> 02:19:28.180
overload

02:19:28.180 --> 02:19:28.960
resolution'a

02:19:28.960 --> 02:19:29.600
girecek

02:19:29.600 --> 02:19:31.940
ondan sonra

02:19:31.940 --> 02:19:32.820
static

02:19:32.820 --> 02:19:33.420
assertion

02:19:33.420 --> 02:19:34.760
kontrol edilecek

02:19:34.760 --> 02:19:37.320
dolayısıyla

02:19:37.320 --> 02:19:39.120
zaten

02:19:39.120 --> 02:19:40.020
bunun seçilmiş

02:19:40.020 --> 02:19:40.880
olması gerekiyor

02:19:40.880 --> 02:19:41.580
bu kontrolün

02:19:41.580 --> 02:19:42.440
yapılması için

02:19:42.440 --> 02:19:44.140
ama daha sonra

02:19:44.140 --> 02:19:45.080
öğreneceğimiz örneğin

02:19:45.080 --> 02:19:46.120
sphineye teknikleri

02:19:46.120 --> 02:19:46.860
böyle değil

02:19:46.860 --> 02:19:48.940
biraz bahsetmiştim

02:19:48.940 --> 02:19:49.660
sphineyden

02:19:49.660 --> 02:19:51.360
sphineyde ise

02:19:51.360 --> 02:19:53.620
constraint

02:19:53.620 --> 02:19:54.280
var ama

02:19:54.280 --> 02:19:55.500
arkadaşlar

02:19:55.500 --> 02:19:56.300
substitution

02:19:56.300 --> 02:19:56.980
failure

02:19:56.980 --> 02:19:58.340
error olduğunda

02:19:58.340 --> 02:19:59.560
overload

02:19:59.560 --> 02:20:00.120
setten

02:20:00.120 --> 02:20:00.820
çıkartıyor

02:20:00.820 --> 02:20:02.460
dolayısıyla

02:20:02.460 --> 02:20:04.280
compile time'da

02:20:04.280 --> 02:20:05.480
kod seçimine de

02:20:05.480 --> 02:20:07.080
yardımcı oluyor

02:20:07.080 --> 02:20:09.180
şimdi compile time'da

02:20:09.180 --> 02:20:10.140
kod seçimi için

02:20:10.140 --> 02:20:11.400
zaten 3-4 tane

02:20:11.400 --> 02:20:12.380
tipik araç var

02:20:12.380 --> 02:20:14.380
bunların bir kısmına

02:20:14.380 --> 02:20:14.820
değindik

02:20:14.820 --> 02:20:15.360
bir kısmına

02:20:15.360 --> 02:20:16.200
hiç değinmedik

02:20:16.200 --> 02:20:17.700
araçlardan biri

02:20:17.700 --> 02:20:19.340
sphiney

02:20:19.340 --> 02:20:21.120
uzun uzun

02:20:21.120 --> 02:20:22.300
incelenmesi gereken

02:20:22.300 --> 02:20:22.940
bir konu

02:20:22.940 --> 02:20:25.000
bununla compile time'da

02:20:25.000 --> 02:20:26.180
kod seçtirebiliyorum

02:20:26.180 --> 02:20:26.880
derleyiciye

02:20:26.880 --> 02:20:28.020
o kod ya da bu kod

02:20:28.020 --> 02:20:29.500
ikincisi

02:20:29.500 --> 02:20:30.320
şüphesiz

02:20:30.320 --> 02:20:30.900
if

02:20:30.900 --> 02:20:31.740
constexpr

02:20:31.740 --> 02:20:33.560
statik if

02:20:33.560 --> 02:20:35.080
bir de

02:20:35.080 --> 02:20:35.640
bizim

02:20:35.640 --> 02:20:36.160
henüz

02:20:36.160 --> 02:20:37.340
hiç değinmediğimiz

02:20:37.340 --> 02:20:39.200
ileride

02:20:39.200 --> 02:20:40.340
vakit bulursak

02:20:40.340 --> 02:20:40.700
tabi

02:20:40.700 --> 02:20:41.340
bu kadar çok

02:20:41.340 --> 02:20:42.180
konumuz var ki

02:20:42.180 --> 02:20:43.340
ayrıntılı

02:20:43.340 --> 02:20:44.180
görebileceğimiz

02:20:44.180 --> 02:20:44.900
hack dispatch

02:20:44.900 --> 02:20:45.360
dediğimiz

02:20:45.360 --> 02:20:46.080
teknik var

02:20:46.080 --> 02:20:48.180
tabi

02:20:48.180 --> 02:20:48.980
bir de

02:20:48.980 --> 02:20:50.280
c++20 ile

02:20:50.280 --> 02:20:50.760
gelen

02:20:50.760 --> 02:20:52.360
konsept

02:20:52.360 --> 02:20:53.940
ve konseptler

02:20:53.940 --> 02:20:55.500
ve konsept kütüphanesi

02:20:55.500 --> 02:20:56.180
bunlarla

02:20:56.180 --> 02:20:57.940
ne yapma

02:20:57.940 --> 02:20:58.340
şansına

02:20:58.340 --> 02:20:59.000
sahibiz

02:20:59.000 --> 02:21:00.180
compile time'da

02:21:00.180 --> 02:21:01.460
derleyiciye

02:21:01.460 --> 02:21:02.220
kod seçtirme

02:21:02.220 --> 02:21:02.760
şansına

02:21:02.760 --> 02:21:04.080
sahibiz

02:21:04.080 --> 02:21:06.000
non-type

02:21:06.000 --> 02:21:06.900
parametrelerle

02:21:06.900 --> 02:21:07.420
ilgili de

02:21:07.420 --> 02:21:08.080
tabi ki

02:21:08.080 --> 02:21:08.900
arkadaşlar

02:21:08.900 --> 02:21:10.220
statik

02:21:10.220 --> 02:21:10.540
asort

02:21:10.540 --> 02:21:11.440
kullanabilirsiniz

02:21:11.440 --> 02:21:11.940
mesela

02:21:11.940 --> 02:21:15.120
template type

02:21:15.120 --> 02:21:15.720
name t

02:21:15.720 --> 02:21:19.420
stud

02:21:19.420 --> 02:21:20.820
size t

02:21:20.820 --> 02:21:21.820
n

02:21:21.820 --> 02:21:26.220
class

02:21:26.220 --> 02:21:27.580
array

02:21:27.580 --> 02:21:31.000
şimdi

02:21:31.000 --> 02:21:32.320
diyelim ki

02:21:32.320 --> 02:21:33.520
arkadaşlar

02:21:33.520 --> 02:21:35.400
dizilerin

02:21:35.400 --> 02:21:36.100
array'de

02:21:36.100 --> 02:21:36.760
non-type

02:21:36.760 --> 02:21:37.980
parametreye

02:21:37.980 --> 02:21:38.380
karşılık

02:21:38.380 --> 02:21:38.840
argüman

02:21:38.840 --> 02:21:39.580
en az

02:21:39.580 --> 02:21:41.260
10 olması

02:21:41.260 --> 02:21:41.980
gereksin

02:21:41.980 --> 02:21:42.800
yani dizinin

02:21:42.800 --> 02:21:43.640
beri boyutun

02:21:43.640 --> 02:21:44.000
üstünde

02:21:44.000 --> 02:21:44.340
olması

02:21:44.340 --> 02:21:44.780
gereksin

02:21:44.780 --> 02:21:45.060
mesela

02:21:45.060 --> 02:21:45.500
sınıfın

02:21:45.500 --> 02:21:45.900
belki de

02:21:45.900 --> 02:21:46.260
şöyle bir

02:21:46.260 --> 02:21:46.940
veri elemanı

02:21:46.940 --> 02:21:47.240
var

02:21:47.240 --> 02:21:49.440
ma

02:21:49.440 --> 02:21:50.720
n

02:21:50.720 --> 02:21:53.360
şöyle

02:21:53.360 --> 02:21:53.900
constraint

02:21:53.900 --> 02:21:54.560
edebilirim

02:21:54.560 --> 02:21:55.140
değil mi?

02:21:55.240 --> 02:21:55.680
statika

02:21:55.680 --> 02:21:56.120
search

02:21:56.120 --> 02:22:03.700
n

02:22:03.700 --> 02:22:03.720
n

02:22:03.720 --> 02:22:05.220
büyüktür

02:22:05.220 --> 02:22:07.260
ya da büyük

02:22:07.260 --> 02:22:07.820
eşit

02:22:07.820 --> 02:22:09.120
5

02:22:09.120 --> 02:22:14.600
size

02:22:14.600 --> 02:22:15.780
must be

02:22:15.780 --> 02:22:17.200
greater

02:22:17.200 --> 02:22:18.500
than

02:22:18.500 --> 02:22:19.960
5

02:22:19.960 --> 02:22:25.160
mesela

02:22:25.160 --> 02:22:26.300
mesela

02:22:26.300 --> 02:22:27.140
array'in

02:22:27.140 --> 02:22:29.400
int

02:22:29.400 --> 02:22:30.000
virgül

02:22:30.000 --> 02:22:31.260
8

02:22:31.260 --> 02:22:33.540
specialization'da

02:22:33.540 --> 02:22:34.120
bir problem

02:22:34.120 --> 02:22:34.880
çıkmayacak

02:22:34.880 --> 02:22:38.380
ama örneğin

02:22:38.380 --> 02:22:39.840
array'in

02:22:39.840 --> 02:22:40.620
int virgül

02:22:40.620 --> 02:22:41.340
4

02:22:41.340 --> 02:22:42.420
specialization'ı

02:22:42.420 --> 02:22:43.020
oluşturmak

02:22:43.020 --> 02:22:43.680
istersem

02:22:43.680 --> 02:22:45.120
statik

02:22:45.120 --> 02:22:46.340
assertion'a

02:22:46.340 --> 02:22:47.260
takılacak

02:22:47.260 --> 02:22:50.260
takip edebiliyor muyuz?

02:22:51.260 --> 02:22:51.540
Evet

02:22:51.540 --> 02:22:56.280
özellikle meta fonksiyonlar

02:22:56.280 --> 02:22:58.260
statik assertion'larla birlikte

02:22:58.260 --> 02:22:59.320
çok sık kullanıyor

02:22:59.320 --> 02:23:00.120
mesela bakınız

02:23:00.120 --> 02:23:03.480
birçok sınıf şablonunda

02:23:03.480 --> 02:23:06.040
şablonun

02:23:06.040 --> 02:23:07.620
template parametresinin

02:23:07.620 --> 02:23:10.280
bir sınıfla

02:23:10.280 --> 02:23:11.500
karşılanması

02:23:11.500 --> 02:23:12.040
isteniyor

02:23:12.040 --> 02:23:13.680
ve o sınıfın

02:23:13.680 --> 02:23:14.820
belirli özelliklere

02:23:14.820 --> 02:23:15.680
sahip olması

02:23:15.680 --> 02:23:16.260
isteniyor

02:23:16.260 --> 02:23:16.880
mesela copy

02:23:16.880 --> 02:23:17.580
constructible

02:23:17.580 --> 02:23:18.140
olması

02:23:18.140 --> 02:23:19.680
move

02:23:19.680 --> 02:23:20.440
constructible

02:23:20.440 --> 02:23:21.020
olması

02:23:21.020 --> 02:23:22.960
ya da

02:23:22.960 --> 02:23:24.120
move

02:23:24.120 --> 02:23:25.160
constructor'ının

02:23:25.160 --> 02:23:26.100
no

02:23:26.100 --> 02:23:26.520
except

02:23:26.520 --> 02:23:26.960
olması

02:23:26.960 --> 02:23:27.300
gibi

02:23:27.300 --> 02:23:29.080
bu koşullar

02:23:29.080 --> 02:23:30.000
sağlanmadığında

02:23:30.000 --> 02:23:30.580
eğer bir

02:23:30.580 --> 02:23:31.420
syntax hatası

02:23:31.420 --> 02:23:32.020
oluşturmak

02:23:32.020 --> 02:23:32.700
isterseniz

02:23:32.700 --> 02:23:34.900
yine o meta fonksiyonları

02:23:34.900 --> 02:23:36.220
kullanabilirsiniz

02:23:36.220 --> 02:23:37.580
mesela

02:23:37.580 --> 02:23:39.020
my class

02:23:39.020 --> 02:23:40.200
sınıfı için

02:23:40.200 --> 02:23:41.800
arkadaşlar

02:23:41.800 --> 02:23:43.760
my class'ın

02:23:43.760 --> 02:23:44.860
argümanı olan

02:23:44.860 --> 02:23:45.660
türün

02:23:45.660 --> 02:23:46.940
default

02:23:46.940 --> 02:23:47.820
constructible

02:23:47.820 --> 02:23:48.160
copy

02:23:48.160 --> 02:23:49.120
constructible

02:23:49.120 --> 02:23:49.960
not

02:23:49.960 --> 02:23:50.640
copy

02:23:50.640 --> 02:23:51.400
constructible

02:23:51.400 --> 02:23:51.920
vesaire

02:23:51.920 --> 02:23:52.880
olması

02:23:52.880 --> 02:23:54.360
gerekiyorsa

02:23:54.360 --> 02:23:55.680
buraya

02:23:55.680 --> 02:23:56.920
bir

02:23:56.920 --> 02:23:57.340
statik

02:23:57.340 --> 02:23:57.680
assert

02:23:57.680 --> 02:23:58.320
declaration

02:23:58.320 --> 02:23:58.960
koyup

02:23:58.960 --> 02:24:03.840
girildiğiniz

02:24:03.840 --> 02:24:04.880
create'i

02:24:04.880 --> 02:24:05.580
seçebilirsiniz

02:24:05.580 --> 02:24:05.980
örneğin

02:24:05.980 --> 02:24:06.460
stut

02:24:06.460 --> 02:24:08.120
is

02:24:08.120 --> 02:24:10.920
default

02:24:10.920 --> 02:24:12.540
constructible

02:24:12.540 --> 02:24:12.920
ve

02:24:12.920 --> 02:24:13.840
p

02:24:13.840 --> 02:24:16.000
bakın bu basit

02:24:16.000 --> 02:24:17.120
örnekte bile

02:24:17.120 --> 02:24:19.400
struct

02:24:19.400 --> 02:24:19.720
net

02:24:19.720 --> 02:24:22.700
şimdi

02:24:22.700 --> 02:24:23.000
net

02:24:23.000 --> 02:24:23.440
default

02:24:23.440 --> 02:24:24.320
constructible

02:24:24.320 --> 02:24:25.640
dolayısıyla

02:24:25.640 --> 02:24:27.120
my class'ın

02:24:27.120 --> 02:24:28.560
net

02:24:28.560 --> 02:24:29.200
açılımı

02:24:29.200 --> 02:24:30.460
bir

02:24:30.460 --> 02:24:30.860
syntax

02:24:30.860 --> 02:24:31.260
hatası

02:24:31.260 --> 02:24:32.260
oluşturmayacak

02:24:32.260 --> 02:24:33.540
yani

02:24:33.540 --> 02:24:33.900
static

02:24:33.900 --> 02:24:34.360
assertion

02:24:34.360 --> 02:24:35.140
takılmadı

02:24:35.140 --> 02:24:36.820
ama

02:24:36.820 --> 02:24:39.100
net

02:24:39.100 --> 02:24:40.160
int

02:24:40.160 --> 02:24:44.160
arkadaşlar

02:24:44.160 --> 02:24:44.760
şimdi

02:24:44.760 --> 02:24:45.540
static

02:24:45.540 --> 02:24:46.020
assertion

02:24:46.020 --> 02:24:46.600
takıldı

02:24:46.600 --> 02:24:47.860
int

02:24:47.860 --> 02:24:48.580
parametreli

02:24:48.580 --> 02:24:48.840
bir

02:24:48.840 --> 02:24:49.660
constructor

02:24:49.660 --> 02:24:50.420
oluşturduğum

02:24:50.420 --> 02:24:50.700
için

02:24:50.700 --> 02:24:52.820
ne oldu

02:24:52.820 --> 02:24:54.800
default

02:24:54.800 --> 02:24:55.560
constructible

02:24:55.560 --> 02:24:55.940
olma

02:24:55.940 --> 02:24:56.640
niteliğini

02:24:56.640 --> 02:24:57.540
kaybetti

02:24:57.540 --> 02:24:58.060
default

02:24:58.060 --> 02:24:58.740
constructible

02:24:58.740 --> 02:24:59.320
olmadığı

02:24:59.320 --> 02:24:59.700
için

02:24:59.700 --> 02:25:00.420
syntax

02:25:00.420 --> 02:25:00.820
hatası

02:25:00.820 --> 02:25:01.320
oluştu

02:25:01.320 --> 02:25:04.200
peki

02:25:04.200 --> 02:25:04.620
şimdi

02:25:04.620 --> 02:25:05.400
o zaman

02:25:05.400 --> 02:25:05.880
statika

02:25:05.880 --> 02:25:06.400
search'ın

02:25:06.400 --> 02:25:06.580
ne

02:25:06.580 --> 02:25:07.220
onun hakkında

02:25:07.220 --> 02:25:08.220
bilgi edindik

02:25:08.220 --> 02:25:10.080
variadic

02:25:10.080 --> 02:25:11.260
template'lere

02:25:11.260 --> 02:25:11.580
biraz

02:25:11.580 --> 02:25:12.160
baktık

02:25:12.160 --> 02:25:12.660
orada

02:25:12.660 --> 02:25:13.020
bazı

02:25:13.020 --> 02:25:13.700
eksiklerimiz

02:25:13.700 --> 02:25:13.900
var

02:25:13.900 --> 02:25:14.320
onları

02:25:14.320 --> 02:25:15.240
dolduracağız

02:25:15.240 --> 02:25:16.760
arkadaşlar

02:25:16.760 --> 02:25:17.280
şimdi

02:25:17.280 --> 02:25:18.500
yine

02:25:18.500 --> 02:25:19.180
c++

02:25:19.180 --> 02:25:20.500
17 ile

02:25:20.500 --> 02:25:21.420
dile eklenen

02:25:21.420 --> 02:25:22.880
fold

02:25:22.880 --> 02:25:23.620
ifadelerine

02:25:23.620 --> 02:25:24.100
katlama

02:25:24.100 --> 02:25:24.820
ifadelerine

02:25:24.820 --> 02:25:25.100
biraz

02:25:25.100 --> 02:25:25.480
bakalım

02:25:25.480 --> 02:25:26.060
yine

02:25:26.060 --> 02:25:26.540
biraz

02:25:26.540 --> 02:25:27.200
karmaşık

02:25:27.200 --> 02:25:27.840
bir konu

02:25:27.840 --> 02:25:30.800
variyatik

02:25:30.800 --> 02:25:32.060
parametre

02:25:32.060 --> 02:25:33.960
parametre

02:25:33.960 --> 02:25:34.060
parametre

02:25:34.060 --> 02:25:35.120
parametre

02:25:35.120 --> 02:25:35.760
paketlerine

02:25:35.760 --> 02:25:36.300
sahip

02:25:36.300 --> 02:25:37.620
fonksiyon

02:25:37.620 --> 02:25:38.360
şablonlarında

02:25:38.360 --> 02:25:38.640
ya da

02:25:38.640 --> 02:25:38.920
sınıf

02:25:38.920 --> 02:25:39.820
şablonlarında

02:25:39.820 --> 02:25:41.760
kullanacağımız

02:25:41.760 --> 02:25:42.460
araçlardan

02:25:42.460 --> 02:25:43.140
biri de

02:25:43.140 --> 02:25:44.660
c++

02:25:44.660 --> 02:25:44.920
plus

02:25:44.920 --> 02:25:45.760
17

02:25:45.760 --> 02:25:46.380
standart

02:25:46.380 --> 02:25:46.600
ile

02:25:46.600 --> 02:25:47.520
dile eklenen

02:25:47.520 --> 02:25:48.920
arkadaşlar

02:25:48.920 --> 02:25:50.200
fold

02:25:50.200 --> 02:25:50.780
expressions

02:25:50.780 --> 02:25:51.380
dediğimiz

02:25:51.380 --> 02:25:52.040
ifadeler

02:25:52.040 --> 02:25:53.900
önce bunlar

02:25:53.900 --> 02:25:54.760
ne işe yarıyor

02:25:54.760 --> 02:25:56.380
bir kafamızda

02:25:56.380 --> 02:25:57.520
canlandıralım

02:25:57.520 --> 02:25:59.040
arkadaşlar

02:25:59.040 --> 02:25:59.480
bunlar

02:25:59.480 --> 02:26:00.140
parametre

02:26:00.140 --> 02:26:00.840
paketinin

02:26:00.840 --> 02:26:02.080
yine

02:26:02.080 --> 02:26:03.240
önceden

02:26:03.240 --> 02:26:03.980
belirlenmiş

02:26:03.980 --> 02:26:04.700
bir şekilde

02:26:04.700 --> 02:26:06.800
expand

02:26:06.800 --> 02:26:07.520
edilmesini

02:26:07.520 --> 02:26:08.120
sağlıyorlar

02:26:08.120 --> 02:26:09.700
ama

02:26:09.700 --> 02:26:10.540
doğrudan

02:26:10.540 --> 02:26:11.120
zaten

02:26:11.120 --> 02:26:12.840
bunlara

02:26:12.840 --> 02:26:13.420
karşılık

02:26:13.420 --> 02:26:13.780
gelen

02:26:13.780 --> 02:26:14.620
kurallar

02:26:14.620 --> 02:26:14.920
var

02:26:14.920 --> 02:26:16.820
dolayısıyla

02:26:16.820 --> 02:26:17.720
pratik bir

02:26:17.720 --> 02:26:18.120
şekilde

02:26:18.120 --> 02:26:18.740
hatta

02:26:18.740 --> 02:26:19.040
hatta

02:26:19.040 --> 02:26:19.260
şimdi

02:26:19.260 --> 02:26:20.140
şaşıracaksınız

02:26:20.140 --> 02:26:20.620
daha önce

02:26:20.620 --> 02:26:21.060
yazdığımız

02:26:21.060 --> 02:26:21.500
bazı

02:26:21.500 --> 02:26:22.080
kodlar

02:26:22.080 --> 02:26:23.320
fold

02:26:23.320 --> 02:26:24.100
ifadeleriyle

02:26:24.100 --> 02:26:24.560
katlama

02:26:24.560 --> 02:26:25.560
ifadeleriyle

02:26:25.560 --> 02:26:26.420
çok daha

02:26:26.420 --> 02:26:27.280
kolay şekilde

02:26:27.280 --> 02:26:28.560
yazılabilecek

02:26:28.560 --> 02:26:30.860
o zaman

02:26:30.860 --> 02:26:31.740
genel

02:26:31.740 --> 02:26:32.400
başlığımız

02:26:32.400 --> 02:26:33.020
fold

02:26:33.020 --> 02:26:33.660
expressions

02:26:33.660 --> 02:26:36.000
önce

02:26:36.000 --> 02:26:36.320
biraz

02:26:36.320 --> 02:26:36.960
sentakstan

02:26:36.960 --> 02:26:37.820
bahsedeceğiz

02:26:37.820 --> 02:26:39.320
ve

02:26:39.320 --> 02:26:40.260
daha sonra

02:26:40.260 --> 02:26:41.460
kullanım

02:26:41.460 --> 02:26:42.200
avantajları

02:26:42.200 --> 02:26:42.640
bize ne

02:26:42.640 --> 02:26:43.200
sağlıyor

02:26:43.200 --> 02:26:43.800
ne şekilde

02:26:43.800 --> 02:26:44.440
kullanıyoruz

02:26:44.440 --> 02:26:44.900
onlardan

02:26:44.900 --> 02:26:46.060
bahsedeceğiz

02:26:46.060 --> 02:26:47.480
arkadaşlar

02:26:47.480 --> 02:26:48.300
yine maalesef

02:26:48.300 --> 02:26:48.900
çok geniş

02:26:48.900 --> 02:26:49.340
bir konu

02:26:49.340 --> 02:26:49.640
yani

02:26:49.640 --> 02:26:50.500
3 saat

02:26:50.500 --> 02:26:50.980
4 saat

02:26:50.980 --> 02:26:51.480
5 saat

02:26:51.480 --> 02:26:51.780
fold

02:26:51.780 --> 02:26:52.320
ifadesi

02:26:52.320 --> 02:26:52.900
anlatsak

02:26:52.900 --> 02:26:53.600
yine de

02:26:53.600 --> 02:26:55.040
konuşmamız

02:26:55.040 --> 02:26:55.500
gereken

02:26:55.500 --> 02:26:56.320
alt başlıklar

02:26:56.320 --> 02:26:56.700
olabilir

02:26:56.700 --> 02:26:57.360
ama ben

02:26:57.360 --> 02:26:57.860
belirli ve

02:26:57.860 --> 02:26:58.260
ayrıntı

02:26:58.260 --> 02:26:58.680
düzeyinde

02:26:58.680 --> 02:26:59.120
tutmak

02:26:59.120 --> 02:26:59.740
zorundayım

02:26:59.740 --> 02:27:01.220
şimdi

02:27:01.220 --> 02:27:01.840
öncelikle

02:27:01.840 --> 02:27:02.740
fold

02:27:02.740 --> 02:27:03.740
ifadelerini

02:27:03.740 --> 02:27:05.420
derleyici

02:27:05.420 --> 02:27:06.520
derleyici

02:27:06.520 --> 02:27:06.760
diyorum

02:27:06.760 --> 02:27:07.140
dilin

02:27:07.140 --> 02:27:07.880
standartı

02:27:07.880 --> 02:27:08.760
iki kategoriye

02:27:08.760 --> 02:27:09.280
ayırıyorum

02:27:09.280 --> 02:27:10.480
bir

02:27:10.480 --> 02:27:12.000
unary

02:27:12.000 --> 02:27:12.340
fold

02:27:12.340 --> 02:27:13.160
expressions

02:27:13.160 --> 02:27:16.880
iki

02:27:16.880 --> 02:27:18.140
binary

02:27:18.140 --> 02:27:18.520
fold

02:27:18.520 --> 02:27:19.280
expressions

02:27:19.280 --> 02:27:24.100
yani

02:27:24.100 --> 02:27:24.640
bir fold

02:27:24.640 --> 02:27:25.640
ifadesi

02:27:25.640 --> 02:27:26.880
arkadaşlar

02:27:26.880 --> 02:27:27.680
ya

02:27:27.680 --> 02:27:28.360
unary

02:27:28.360 --> 02:27:28.660
fold

02:27:28.660 --> 02:27:29.180
olacak

02:27:29.180 --> 02:27:30.960
ya da

02:27:30.960 --> 02:27:31.840
binary

02:27:31.840 --> 02:27:32.180
fold

02:27:32.180 --> 02:27:32.600
olacak

02:27:32.600 --> 02:27:33.080
ikisinin

02:27:33.080 --> 02:27:33.580
arasındaki

02:27:33.580 --> 02:27:34.240
farkı

02:27:34.240 --> 02:27:34.800
birazdan

02:27:34.800 --> 02:27:35.360
göreceğiz

02:27:35.360 --> 02:27:38.120
unary

02:27:38.120 --> 02:27:38.460
fold

02:27:38.460 --> 02:27:38.640
ve

02:27:38.640 --> 02:27:39.100
binary

02:27:39.100 --> 02:27:39.500
fold

02:27:39.500 --> 02:27:41.580
bunlar da

02:27:41.580 --> 02:27:41.940
yine

02:27:41.940 --> 02:27:43.000
kendi içinde

02:27:43.000 --> 02:27:44.400
right

02:27:44.400 --> 02:27:44.800
fold

02:27:44.800 --> 02:27:45.500
ve left

02:27:45.500 --> 02:27:45.800
fold

02:27:45.800 --> 02:27:46.140
olarak

02:27:46.140 --> 02:27:46.540
ikiye

02:27:46.540 --> 02:27:47.080
ayrılacak

02:27:47.080 --> 02:27:48.320
yani

02:27:48.320 --> 02:27:49.320
unary

02:27:49.320 --> 02:27:50.660
right

02:27:50.660 --> 02:27:51.100
fold

02:27:51.100 --> 02:27:52.820
ve

02:27:52.820 --> 02:27:53.320
unary

02:27:53.320 --> 02:27:54.340
left

02:27:54.340 --> 02:27:54.720
fold

02:27:54.720 --> 02:27:59.500
binary

02:27:59.500 --> 02:27:59.540
binary

02:27:59.540 --> 02:27:59.880
fold

02:27:59.880 --> 02:28:00.540
ifadeleri

02:28:00.540 --> 02:28:00.800
de

02:28:00.800 --> 02:28:01.240
yine

02:28:01.240 --> 02:28:01.760
binary

02:28:01.760 --> 02:28:02.140
right

02:28:02.140 --> 02:28:02.500
fold

02:28:02.500 --> 02:28:03.620
binary

02:28:03.620 --> 02:28:04.040
left

02:28:04.040 --> 02:28:04.420
fold

02:28:04.420 --> 02:28:04.940
olarak

02:28:04.940 --> 02:28:05.340
ikiye

02:28:05.340 --> 02:28:05.900
ayrılacak

02:28:05.900 --> 02:28:07.460
sadece

02:28:07.460 --> 02:28:09.080
belirli bir süre dinlememiz

02:28:09.080 --> 02:28:09.600
gerekiyor

02:28:09.600 --> 02:28:10.300
yavaş yavaş

02:28:10.300 --> 02:28:10.620
konuya

02:28:10.620 --> 02:28:11.180
gireceğiz

02:28:11.180 --> 02:28:12.940
arkadaşlar

02:28:12.940 --> 02:28:13.540
bir kere

02:28:13.540 --> 02:28:15.020
fold expression

02:28:15.020 --> 02:28:16.980
variadic

02:28:16.980 --> 02:28:19.260
parametre paketleriyle ilgili

02:28:19.260 --> 02:28:22.820
yani ortada bir parametre paketi yoksa

02:28:22.820 --> 02:28:24.500
variadic bir template yoksa

02:28:24.500 --> 02:28:28.180
fold ifadesinin kullanılması mümkün değil

02:28:28.180 --> 02:28:29.900
fold ifadeleri

02:28:29.900 --> 02:28:33.200
variadic templateler için geçerli

02:28:33.200 --> 02:28:35.460
arkadaşlar

02:28:35.460 --> 02:28:35.920
önce

02:28:35.920 --> 02:28:36.480
unary

02:28:36.480 --> 02:28:36.740
fold

02:28:36.740 --> 02:28:37.500
ile başlayalım

02:28:37.500 --> 02:28:39.140
bir unary

02:28:39.140 --> 02:28:40.560
fold ifadesi

02:28:40.560 --> 02:28:43.460
parantez içinde yazılan bir ifade

02:28:43.460 --> 02:28:44.380
buraya dikkat

02:28:44.380 --> 02:28:45.420
parantez

02:28:45.420 --> 02:28:47.280
sentaksın bir bileşimi

02:28:47.280 --> 02:28:49.200
yani parantezi koymak zorundasınız

02:28:49.200 --> 02:28:50.240
buradaki parantez

02:28:50.240 --> 02:28:52.160
öncelik parantezi değil

02:28:52.160 --> 02:28:54.220
arkadaşlar

02:28:54.220 --> 02:28:55.560
parantezin içinde

02:28:55.560 --> 02:29:00.060
bir fonksiyon şablonu olsun

02:29:00.060 --> 02:29:05.420
fonksiyonun template parametre paketi

02:29:05.420 --> 02:29:07.840
diyelim ki

02:29:07.840 --> 02:29:10.960
toplama işlemini yaptıracak

02:29:10.960 --> 02:29:12.640
bir fonksiyon şablonu

02:29:12.640 --> 02:29:14.120
es

02:29:14.120 --> 02:29:15.160
aks

02:29:15.160 --> 02:29:17.100
tabii ki her zaman olduğu gibi

02:29:17.100 --> 02:29:18.620
ne olabilir

02:29:18.620 --> 02:29:19.880
bu

02:29:19.880 --> 02:29:21.500
referans olabilir

02:29:21.500 --> 02:29:24.400
fonksiyon parametre paketindeki parametreler

02:29:24.400 --> 02:29:26.200
referans olmayabilir

02:29:26.200 --> 02:29:27.460
const olabilir olmayabilir

02:29:27.460 --> 02:29:28.420
onları konuştuk

02:29:28.420 --> 02:29:29.600
arkadaşlar

02:29:29.600 --> 02:29:32.040
bir fold ifadesi nasıl oluşturuyorum

02:29:32.040 --> 02:29:32.360
bakın

02:29:32.360 --> 02:29:33.580
parantez içinde

02:29:33.580 --> 02:29:37.320
hangi operatör üstünde

02:29:37.320 --> 02:29:38.700
fold işlemi yapılacaksa

02:29:38.700 --> 02:29:41.360
fold işlemi bir operatör üstünde yapılmak zorunda

02:29:41.360 --> 02:29:44.360
o operatörü yazıyorsunuz

02:29:44.360 --> 02:29:46.360
arkadaşlar bu operatör

02:29:46.360 --> 02:29:48.700
binary bir operatör

02:29:48.700 --> 02:29:51.440
ve buraya dikkat

02:29:51.440 --> 02:29:53.880
binary operatörün

02:29:53.880 --> 02:29:55.360
bir operanda olarak

02:29:55.360 --> 02:29:59.100
parametre paketini

02:29:59.600 --> 02:30:01.240
fakat diğer operatör olarak

02:30:01.240 --> 02:30:01.900
ellipsis

02:30:01.900 --> 02:30:03.580
spoken'ını kullanıyorsunuz

02:30:03.580 --> 02:30:07.400
yavaş yavaş yavaş yavaş yavaş yavaş yavaş

02:30:07.400 --> 02:30:07.520
yavaş yavaş yavaş yavaş yavaş

02:30:07.520 --> 02:30:08.200
buraya kadar

02:30:08.200 --> 02:30:10.640
her şey net değil mi

02:30:10.640 --> 02:30:12.560
bu bir

02:30:12.560 --> 02:30:14.140
fold expression

02:30:14.140 --> 02:30:17.340
unery fold expression

02:30:17.340 --> 02:30:19.180
ellipsis

02:30:19.180 --> 02:30:23.160
binary operatörümüzün solid sağ 아니야

02:30:23.160 --> 02:30:25.660
Buna unary left fold diyoruz.

02:30:26.720 --> 02:30:35.760
Eğer şöyle olsaydı, arks operatör artı, elipsiz burada olsaydı, bu da right fold.

02:30:35.760 --> 02:30:42.440
Şimdi ben ilk dile eklendiğinde bu ikisini hep birbiriyle karıştırıyordum çoğu kişi gibi.

02:30:43.220 --> 02:30:45.340
Hep şöyle aklımda tutmaya başlamıştım.

02:30:45.340 --> 02:30:54.000
Elipsiz operatörün solundaysa o zaman left fold, sağındaysa right fold.

02:30:54.200 --> 02:30:56.880
O zaman bu unary left fold mu right fold mu?

02:30:57.780 --> 02:30:58.760
Unary right fold.

02:30:58.760 --> 02:31:06.260
Şöyle olsaydı, arkadaşlar söyleyin, unary left fold olacaktı.

02:31:08.040 --> 02:31:14.280
Bu operatör sizin seçtiğiniz herhangi bir binary operatör olabilir.

02:31:15.340 --> 02:31:20.280
Örneğin toplama olabilir, çarpma olabilir, bölme olabilir, büyüktür olabilir.

02:31:21.900 --> 02:31:27.580
Ve buradaki arkadaşlar, elipsiz bu şekilde bulunmak zorunda.

02:31:27.980 --> 02:31:32.340
Peki, şimdi derleyici bunun için nasıl bu kod üretecek?

02:31:33.460 --> 02:31:35.120
Arkadaşlar son derece basit.

02:31:35.980 --> 02:31:43.880
Derleyici fold expression olan ifadeyi aslında şuna dönüştürüyor unary right fold için.

02:31:43.880 --> 02:31:52.460
eğer left fold ise, bu fonksiyonun parametrelerinin isimleri olsaydı P1, P2, P3 diye

02:31:52.460 --> 02:31:58.420
P1 artı P2, buraya dikkat.

02:31:59.460 --> 02:32:03.480
Left fold olduğu için soldan parantez içine alınacak.

02:32:03.480 --> 02:32:10.540
Artı P3, arkası ters, böyle gidiyor.

02:32:11.260 --> 02:32:15.700
Artı P4, anlaşıldı mı?

02:32:16.980 --> 02:32:23.780
Dolayısıyla öyle bir ifade oluşacak ki, bu ifade zaten bütün argümanların toplama anlamına gelecek.

02:32:23.780 --> 02:32:36.900
Böylece mesela sum isimli fonksiyonu, böyle basit bir şekilde bu ifadeyi doğrudan fonksiyonun return ifadesi yaparak implemente etmiş olacağız.

02:32:36.900 --> 02:32:39.580
Buraya kadar takip edebildik mi?

02:32:40.440 --> 02:32:42.200
Arkadaşlar bu arada bir şeye de dikkat.

02:32:43.200 --> 02:32:46.600
Burada parametrelerin türünün aynı olması gerekmiyor değil mi?

02:32:47.560 --> 02:32:54.680
Dolayısıyla fonksiyonun geri dönüş değeri türü olarak, bu örnekte tabii farklı şekilde de kullanılabilir.

02:32:55.760 --> 02:32:57.240
Auto return type kullandım.

02:32:57.240 --> 02:33:01.600
Çünkü örneğin int ile double'ı toplarsam sonuç double olacak.

02:33:02.900 --> 02:33:08.000
Burada template argümanları hepsi aynı türden de olabilir, farklı türden de olabilir.

02:33:08.880 --> 02:33:11.680
Mesela bakınız, tabii noktalı virgülü de koyalım.

02:33:13.180 --> 02:33:19.240
Arkadaşlar izleyin, return, return diyorum, main fonksiyonu,

02:33:19.240 --> 02:33:26.140
1, 2, 4, 3.76.

02:33:26.980 --> 02:33:32.520
O zaman buradaki ifade, 2 artı 4 artı 3.76 olacak.

02:33:32.640 --> 02:33:34.180
Bu ifadenin türü double olacak.

02:33:35.200 --> 02:33:40.740
Aslında biz geri dönüş değeri türü double olan bir fonksiyonun kodunu yazdırmış olacağız.

02:33:41.580 --> 02:33:42.120
See out.

02:33:45.800 --> 02:33:47.300
Sabırla izlemeye devam.

02:33:47.300 --> 02:33:50.640
Bunlar çok basit örneklerdir.

02:33:53.440 --> 02:33:56.340
Arkadaşlar bakın şimdi, herkes dikkatli izliyor.

02:33:58.680 --> 02:34:04.060
Burada left fault olması ile right fault olması arasındaki fark ne?

02:34:05.200 --> 02:34:08.200
Fonksiyonun kodu böyle olmak yerine,

02:34:08.200 --> 02:34:13.540
şöyle olsaydı args artı,

02:34:15.840 --> 02:34:19.900
bu durumda da derleyicinin oluşturduğu kod şöyle olacaktı.

02:34:20.900 --> 02:34:24.720
Diyelim ki fonksiyonun 5 tane parametre değişkeni var ya da 4 tane var.

02:34:24.720 --> 02:34:35.960
return, return, p1 artı p2 artı p3 artı p4 artı p5.

02:34:36.960 --> 02:34:41.600
Ama parantezler sağdan.

02:34:42.440 --> 02:34:42.980
Örneğin böyle.

02:34:42.980 --> 02:34:48.320
Şimdi diyebilirsiniz ki,

02:34:48.980 --> 02:34:50.520
en hecatı bir şey fark etmez.

02:34:50.700 --> 02:34:51.680
Çok şey fark eder.

02:34:53.020 --> 02:34:55.460
Örneğin auto return type kullandığınız zaman,

02:34:55.660 --> 02:34:59.720
fonksiyonun geri dönüş değerinin türü farklı olabilir.

02:34:59.860 --> 02:35:00.980
Ya da veri kaybı olabilir.

02:35:01.120 --> 02:35:01.700
Ya da olmayabilir.

02:35:01.800 --> 02:35:03.560
Ya da duruma göre hiçbir fark olmayabilir.

02:35:03.560 --> 02:35:06.860
Mesela şu örneğe bakalım arkadaşlar.

02:35:09.060 --> 02:35:09.740
Soru.

02:35:12.000 --> 02:35:12.560
String.

02:35:14.200 --> 02:35:15.240
String.

02:35:18.760 --> 02:35:20.100
Ya da string.

02:35:20.700 --> 02:35:20.940
Name.

02:35:28.940 --> 02:35:29.780
Summit.

02:35:33.560 --> 02:35:34.260
Sam.

02:35:36.960 --> 02:35:37.520
Name.

02:35:42.400 --> 02:35:44.180
Summit isimli arkadaşım da var.

02:35:45.140 --> 02:35:45.660
Shen.

02:35:47.120 --> 02:35:47.680
Gel.

02:35:50.920 --> 02:35:51.760
Söyleyin bakalım.

02:35:51.860 --> 02:35:53.560
Sertaks hatası olur mu, olmaz mı?

02:35:55.560 --> 02:35:56.160
Cevap.

02:35:57.480 --> 02:35:59.540
Bu binary left fault mu?

02:36:00.040 --> 02:36:01.240
Unary left fault mu?

02:36:01.300 --> 02:36:01.960
Right fault mu?

02:36:01.960 --> 02:36:04.300
Cevap yuneri right fault.

02:36:04.840 --> 02:36:05.960
Şöyle olsaydı.

02:36:06.680 --> 02:36:08.100
Bravo Mermetcan Bey bu arada.

02:36:09.040 --> 02:36:09.520
Bakınız.

02:36:09.940 --> 02:36:10.160
Bu.

02:36:11.060 --> 02:36:11.680
Yuneri.

02:36:12.580 --> 02:36:13.680
Left fault olacaktı.

02:36:15.580 --> 02:36:16.340
Fonksiyonun.

02:36:16.920 --> 02:36:18.020
Geri dönüş değerini.

02:36:19.360 --> 02:36:20.240
Yazdıralım.

02:36:20.880 --> 02:36:22.740
Eğer bir semtaks hatası olmazsa.

02:36:22.740 --> 02:36:33.240
Gördüğünüz gibi toplama operatörünün operatörünün operatörü aslında fonksiyonun parametre değişkenliğinin değerleri.

02:36:34.380 --> 02:36:39.500
Yuneri left fault olmak yerine yuneri right fault yapalım.

02:36:41.140 --> 02:36:42.960
Arx artı.

02:36:42.960 --> 02:36:49.460
Bu durumda derlediğim size neden sentaks hatası oldu?

02:36:49.580 --> 02:36:52.060
Hemen hata mesajına bakmadan kim söyleyecek?

02:36:53.480 --> 02:36:55.840
Derleyicinin bravo bravo bravo.

02:36:56.020 --> 02:36:59.640
Konstruşar Yıldız iki tane pointer'ı toplayacak bir kod üretecek değil mi?

02:37:00.380 --> 02:37:00.680
Bravo.

02:37:00.680 --> 02:37:09.100
Dolayısıyla duruma göre yuneri left fault ile yuneri right fault birbirinden farklı sonuçlar üretebilir.

02:37:09.300 --> 02:37:09.940
Mesela bakın.

02:37:10.140 --> 02:37:11.140
Çok güzel bir örnek.

02:37:12.240 --> 02:37:17.000
Auto div arkadaşlar.

02:37:18.220 --> 02:37:19.860
Ve fonksiyonun kodu şöyle olsun.

02:37:20.860 --> 02:37:21.380
Return.

02:37:25.380 --> 02:37:26.260
Gördüğü.

02:37:27.680 --> 02:37:28.120
Arx.

02:37:28.120 --> 02:37:31.440
Yuneri left fault mu?

02:37:33.280 --> 02:37:34.720
Yuneri right fault mu?

02:37:34.980 --> 02:37:36.260
Yuneri left fault.

02:37:37.140 --> 02:37:44.460
Çünkü elipsiz solda olduğuna göre yuneri left fault.

02:37:44.560 --> 02:37:46.400
Yani soldan parantez almaya başlayacak.

02:37:48.060 --> 02:37:51.480
Hangi operatör üstüne yuneri left fault?

02:37:52.240 --> 02:37:53.620
Bölme operatörü üstüne.

02:37:54.740 --> 02:37:55.300
Öyle değil mi?

02:37:55.900 --> 02:37:56.520
Kesinlikle.

02:37:56.520 --> 02:37:58.580
Arkadaşlar bakın şimdi.

02:37:59.620 --> 02:38:04.340
Ben bu durumda div fonksiyonunu değil mi dedik?

02:38:04.580 --> 02:38:06.700
Div fonksiyonunu şöyle çağırırsam.

02:38:08.240 --> 02:38:08.720
500.

02:38:10.040 --> 02:38:11.320
Efendim 50.

02:38:12.320 --> 02:38:13.780
Bu değerleri önceden seçtim.

02:38:13.900 --> 02:38:14.680
5, 2.

02:38:15.680 --> 02:38:19.220
Div fonksiyonunun hangi değeri döndüreceğini söyleyebilir misiniz?

02:38:19.220 --> 02:38:21.060
500 bölü 50, 10.

02:38:21.940 --> 02:38:23.340
10 bölü 5, 2.

02:38:24.040 --> 02:38:25.280
2 bölü 2, 1.

02:38:26.000 --> 02:38:28.460
Yani fonksiyonunun geri dönüşü değeri 1 olur değil mi?

02:38:28.460 --> 02:38:39.920
Ama left fault yerine right fault olsaydı.

02:38:41.920 --> 02:38:42.440
Arks.

02:38:42.440 --> 02:38:49.420
Bu durumda parantezler sağdan olacak.

02:38:49.420 --> 02:38:51.840
Yani right associative gibi davranacak.

02:38:52.700 --> 02:38:54.460
5 bölü 2, 2.

02:38:55.620 --> 02:38:58.320
50 bölü 2, 25.

02:38:59.340 --> 02:39:02.080
500 bölü 25, 20 mi olur?

02:39:02.780 --> 02:39:04.040
20 olur herhalde değil mi?

02:39:04.040 --> 02:39:07.040
Şimdi fonksiyonunun geri dönüş değerine bakalım.

02:39:08.880 --> 02:39:11.040
Arkadaşlar 20 olduğunu görüyorsunuz.

02:39:12.400 --> 02:39:14.960
Şimdi burada önemli yine notlar.

02:39:15.900 --> 02:39:19.040
Herhangi bir binary operatörü üstüne ne yapabiliriz?

02:39:20.040 --> 02:39:23.040
Arkadaşlar fold ifadesi oluşturabiliriz.

02:39:23.040 --> 02:39:33.060
Özellikle idiomatik kodların önemli bir kısmı virgül operatörüyle oluşturman neler?

02:39:33.900 --> 02:39:34.460
Foldlar.

02:39:34.860 --> 02:39:37.400
Yani virgül de bir binary operatör değil mi?

02:39:38.380 --> 02:39:40.040
Virgül operatörü içinde ne oluşturabilirim?

02:39:41.480 --> 02:39:46.400
Bir unary left fault ya da unary right fault oluşturabilirim.

02:39:47.440 --> 02:39:51.820
Bu arada sadece fonksiyon şamlulu olması gibi bir zorunluluk da yok.

02:39:51.820 --> 02:39:53.140
Mesela şu örneğe bakın.

02:39:54.240 --> 02:39:55.960
Bu bir değişken şablonda olabilir.

02:39:57.720 --> 02:39:58.300
Template

02:39:58.300 --> 02:40:01.380
Int

02:40:01.380 --> 02:40:05.960
Int

02:40:05.960 --> 02:40:08.160
N

02:40:08.160 --> 02:40:14.880
ConstExpr

02:40:14.880 --> 02:40:17.660
Int

02:40:17.660 --> 02:40:18.620
Tam

02:40:18.620 --> 02:40:21.680
Buraya dikkat edin.

02:40:21.820 --> 02:40:22.640
Arkadaşlar bu

02:40:22.640 --> 02:40:24.040
Variable Template

02:40:24.040 --> 02:40:24.800
Sentaksı

02:40:24.800 --> 02:40:29.020
Variable Template'de template parametresi parametre paketti.

02:40:29.120 --> 02:40:31.240
Önce konuşmuştuk parametre paketi olması

02:40:31.240 --> 02:40:36.080
fonksiyon şablonu ya da sınır şablonu olma mecburiyetini getirmiyor.

02:40:36.080 --> 02:40:37.080
Eşittir.

02:40:37.080 --> 02:40:37.680
Eşittir.

02:40:37.680 --> 02:40:40.260
Fold Expression

02:40:40.260 --> 02:40:42.680
Artı

02:40:42.680 --> 02:40:44.420
Vars

02:40:44.420 --> 02:40:45.560
N

02:40:45.560 --> 02:40:50.380
Böylece

02:40:50.380 --> 02:40:51.380
Örneğin ben

02:40:51.380 --> 02:40:52.380
Örneğin ben

02:40:52.380 --> 02:40:52.600
Sam'ın

02:40:52.600 --> 02:41:02.680
2, 5, 7, 9 açılımı olan değişkeni kullanırsam

02:41:02.680 --> 02:41:07.860
template argümanlarının toplamı olan hangi sabit olacak?

02:41:08.600 --> 02:41:10.340
7, 14, 23 sabit olacak.

02:41:10.500 --> 02:41:11.840
Bu mesela 23 sabit.

02:41:11.920 --> 02:41:14.500
Bakın gösteriyor da compile time de belli oluyor değil mi?

02:41:14.500 --> 02:41:16.920
Takip edebildik mi?

02:41:17.920 --> 02:41:19.180
Ya da şuna bakın.

02:41:20.220 --> 02:41:21.120
Başka bir örnek.

02:41:22.120 --> 02:41:22.920
ConstExpr

02:41:22.920 --> 02:41:23.520
Int

02:41:23.520 --> 02:41:25.800
Sam değil de bu sefer

02:41:25.800 --> 02:41:27.120
SamSquare olsun.

02:41:30.120 --> 02:41:30.920
Ve

02:41:30.920 --> 02:41:32.320
Yine

02:41:32.320 --> 02:41:33.080
Yüneri

02:41:33.080 --> 02:41:34.000
LevFold olsun.

02:41:35.400 --> 02:41:35.820
Fakat

02:41:35.820 --> 02:41:36.880
Buradaki

02:41:36.880 --> 02:41:38.200
İfade

02:41:38.200 --> 02:41:40.200
N

02:41:40.200 --> 02:41:40.840
Çarpı

02:41:40.840 --> 02:41:41.420
N

02:41:41.420 --> 02:41:42.300
İfadesi olsun.

02:41:43.440 --> 02:41:44.780
Bu durumda da

02:41:44.780 --> 02:41:46.200
Derleyici

02:41:46.200 --> 02:41:48.200
Sırısıyla ne yapacak?

02:41:48.580 --> 02:41:49.200
Arkadaşlar

02:41:49.200 --> 02:41:51.220
Yine parantez içinde

02:41:51.220 --> 02:41:52.960
Toplama operatörü

02:41:52.960 --> 02:41:54.060
Kullanılacak.

02:41:54.880 --> 02:41:55.760
Ama bu kez

02:41:55.760 --> 02:41:57.560
Her biri için

02:41:57.560 --> 02:41:58.180
N

02:41:58.180 --> 02:41:58.540
Çarpı

02:41:58.540 --> 02:41:58.660
N

02:41:58.660 --> 02:41:59.860
İfadesi kullanılacak.

02:42:00.040 --> 02:42:00.380
Yani

02:42:00.380 --> 02:42:01.600
Sam değil de

02:42:01.600 --> 02:42:02.300
Örneğin

02:42:02.300 --> 02:42:05.040
SamSquare'in

02:42:05.040 --> 02:42:08.900
İki beş üç açılımı

02:42:08.900 --> 02:42:09.600
Olsaydı

02:42:09.600 --> 02:42:11.220
İkinin karesi

02:42:11.220 --> 02:42:12.280
Artı beşin karesi

02:42:12.280 --> 02:42:13.500
Artı üçün karesi

02:42:13.500 --> 02:42:15.200
Yirmi beş

02:42:15.200 --> 02:42:15.800
Dokuz daha

02:42:15.800 --> 02:42:16.660
Otuz dört

02:42:16.660 --> 02:42:17.580
Dört daha

02:42:17.580 --> 02:42:18.740
Otuz sekiz

02:42:18.740 --> 02:42:19.740
Sabiti

02:42:19.740 --> 02:42:21.260
Elde edilecekti.

02:42:22.140 --> 02:42:22.660
Yani bu

02:42:22.660 --> 02:42:23.800
Otuz sekiz

02:42:23.800 --> 02:42:24.720
Sabiti olacak.

02:42:27.700 --> 02:42:28.820
Göstermiyor ama

02:42:28.820 --> 02:42:29.780
Şöyle yazabiliriz.

02:42:29.860 --> 02:42:30.620
ConstExpr

02:42:30.620 --> 02:42:32.740
Otu

02:42:32.740 --> 02:42:34.460
X

02:42:34.460 --> 02:42:35.740
Eşiktir.

02:42:35.900 --> 02:42:37.200
Başka bir hata yoksa

02:42:37.200 --> 02:42:39.700
X'in değerini

02:42:39.700 --> 02:42:44.520
Diğerde bir parantez

02:42:44.520 --> 02:42:45.520
Almış

02:42:45.520 --> 02:42:47.460
Yedinci satır

02:42:47.460 --> 02:42:49.600
Evet şurada bir parantez eksik

02:42:49.600 --> 02:42:50.020
Onun için

02:42:50.020 --> 02:42:51.460
Tamam.

02:42:51.460 --> 02:42:54.520
Şimdi ne eksik

02:42:54.520 --> 02:42:55.880
Şimdi de

02:42:55.880 --> 02:42:56.740
Şuradaki noktalı

02:42:56.740 --> 02:42:57.460
Yirmi eksik

02:42:57.460 --> 02:43:01.420
Tamam.

02:43:01.720 --> 02:43:02.420
Şimdi bakan

02:43:02.420 --> 02:43:03.800
Gerçekten

02:43:03.800 --> 02:43:04.320
Değerin

02:43:04.320 --> 02:43:05.980
Otuz sekiz olduğunu

02:43:05.980 --> 02:43:06.700
Görüyorsunuz.

02:43:08.000 --> 02:43:08.800
Arkadaşlar

02:43:08.800 --> 02:43:12.320
Patlama ifadelerine bir giriş yaptık.

02:43:12.620 --> 02:43:14.040
Aşağı yukarı şöyle bir yarım saat

02:43:14.040 --> 02:43:14.960
Kırk beş dakika daha

02:43:14.960 --> 02:43:16.920
Fold Expressions konusunda konuşacağız.

02:43:18.220 --> 02:43:20.080
Bir iki tane daha küçük başlık olacak ama

02:43:20.080 --> 02:43:21.540
En azından şöyle söyleyebiliriz.

02:43:21.620 --> 02:43:22.620
Artık haftadan

02:43:22.620 --> 02:43:24.200
Bir dahaki haftadan itibaren

02:43:24.200 --> 02:43:26.360
Uzunca bir süre

02:43:26.360 --> 02:43:27.800
Konumuz

02:43:27.800 --> 02:43:29.060
STL olacak

02:43:29.060 --> 02:43:29.800
Standart

02:43:29.800 --> 02:43:30.220
Template

02:43:30.220 --> 02:43:30.860
Library'dir.

02:43:31.280 --> 02:43:33.180
Template konusunda eksiklerimiz var mı?

02:43:33.280 --> 02:43:33.480
Var.

02:43:33.900 --> 02:43:34.400
Doğal olarak

02:43:34.400 --> 02:43:35.400
Çok geniş bir konu.

02:43:35.960 --> 02:43:37.320
Ama artık o eksikleri

02:43:37.320 --> 02:43:39.180
STL'i incelerken

02:43:39.180 --> 02:43:39.780
Yavaş yavaş

02:43:39.780 --> 02:43:40.540
Kapatırız.

02:43:41.320 --> 02:43:42.240
Çünkü önümüzde

02:43:42.240 --> 02:43:43.240
Kursun belki

02:43:43.240 --> 02:43:45.140
En uzun bölümü olan

02:43:45.140 --> 02:43:46.460
STL

02:43:46.460 --> 02:43:46.980
Standart

02:43:46.980 --> 02:43:47.380
Template

02:43:47.380 --> 02:43:48.120
Library'i var.

02:43:48.520 --> 02:43:49.320
C++'ın

02:43:49.320 --> 02:43:49.800
Standart

02:43:49.800 --> 02:43:50.460
Kütüphanesi'ni

02:43:50.460 --> 02:43:51.560
Artık detaylı olarak

02:43:51.560 --> 02:43:51.800
Bir

02:43:51.800 --> 02:43:52.780
Görmeye

02:43:52.780 --> 02:43:53.460
Başlayacağız.

02:43:53.460 --> 02:43:55.080
Maalesef

02:43:55.080 --> 02:43:55.940
Benim yüzümden

02:43:55.940 --> 02:43:57.180
Bu hafta bir ders yapıldı.

02:43:57.840 --> 02:43:58.100
İnşallah

02:43:58.100 --> 02:43:59.080
İleride de bunu

02:43:59.080 --> 02:44:00.940
STL bitince

02:44:00.940 --> 02:44:02.100
Kurs bitiyor sanırım.

02:44:02.300 --> 02:44:02.560
Hayır.

02:44:02.940 --> 02:44:03.700
STL bitince

02:44:03.700 --> 02:44:04.160
Maalesef

02:44:04.160 --> 02:44:04.880
Kurs bitmiyor.

02:44:05.840 --> 02:44:06.960
Başka konular da var.

02:44:07.140 --> 02:44:08.240
Yani STL haricinde

02:44:08.240 --> 02:44:09.120
Konular da var.

02:44:10.320 --> 02:44:11.200
Ben Necat Ergin.

02:44:11.300 --> 02:44:12.240
Derse katıldığınız için

02:44:12.240 --> 02:44:13.120
Teşekkür ediyorum.

02:44:13.960 --> 02:44:14.580
Bir dahaki hafta

02:44:14.580 --> 02:44:15.340
Görüşmek üzere.

02:44:15.580 --> 02:44:16.060
Herkese

02:44:16.060 --> 02:44:17.600
İyi akşamlar diliyorum.

02:44:17.840 --> 02:44:18.360
Hoşçakalın

02:44:18.360 --> 02:44:18.960
Değerli arkadaşlar.

