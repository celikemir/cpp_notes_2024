WEBVTT

00:00.000 --> 00:20.620
İyi akşamlar arkadaşlar, 7 Ağustos 2024 çarşamba günü saat 19.31 12. ders günümüz dersimize başlıyoruz kaldığımız yerden devam edeceğiz ses ya da görüntüde problem olursa bildirin lütfen sevgili arkadaşlar.

00:20.620 --> 00:44.160
Kaldığımız yere hemen geri dönüyoruz copy assignment function özel sınıfların özel fonksiyonlarından bir başkası son kez sayalım mı özelliğe fonksiyonları evet default constructor, destructor, copy constructor, move constructor, copy assignment, move assignment.

00:44.160 --> 01:11.280
Evet, constructorları ve default constructor'ı gördük, destructor'ı gördük, evet pazartesi günkü dersimizde copy constructor üstünde durduk, copy constructor'ın ne olduğunu, ne işe yaradığını, ne zaman bizim tanımlamamız gerektiğini konuştuk ve kopyalayan atama operatör fonksiyonuna yani copy assignment function'a geldik.

01:11.280 --> 01:23.280
Arkadaşlar, hatta sınıfımız için, örnek sınıfımız için bir kopyalayan atama operatör fonksiyonu, copy assignment function yazdık.

01:23.280 --> 01:34.180
Tipik olarak kaynak kullanan böyle sınıflar, eğer derleyiciye bırakmazlarsa ki derleyiciye bıraksalar felaket olurdu.

01:34.980 --> 01:35.640
Ne yapıyorlar?

01:36.700 --> 01:43.220
Önce kendi kaynağını geri veriyor, sonra deep copy yapıyor.

01:43.220 --> 01:55.080
Arkadaşlar, öylediğimi yani atama operatör fonksiyonuyla kopyalayan atama operatör fonksiyonuyla copy constructor'ın ortak kodu deyip copy diyebiliriz.

01:55.240 --> 02:02.320
Ama atama operatör fonksiyonu bir constructor değil, derleyicinin nasıl bir fonksiyon yazdığını konuştuk.

02:03.160 --> 02:09.240
Derleyicinin yazdığı fonksiyon işimizi görmediğinde biz fonksiyonu implemente ediyoruz.

02:09.240 --> 02:21.180
Derleyicinin yazdığı fonksiyonun işimizi görüyorsa rule of zero deyip arkadaşlar biz derleyiciye bırakıyoruz özel üye fonksiyonların yazımını.

02:22.200 --> 02:26.420
En son şöyle bir şey eklemiştik atama operatör fonksiyonuna.

02:27.280 --> 02:34.240
Dedik ki self assignment'a da bir önlem alması gerekiyor.

02:34.580 --> 02:35.940
Self assignment ne demek?

02:35.940 --> 02:43.980
Self assignment şunu isterseniz jpp dosyasına bir kopyalayalım, tekrar aynı örnek üstünde çalışalım.

02:44.740 --> 02:57.580
Nesnenin kendine atanması yani atama operatörünün sol operandı da aslında burada da varmış sanıyorum sağ operandı da yine aynı nesne.

02:57.580 --> 03:07.840
Eğer bu durumda önlem almazsak ki işte alınan tipik önlem bu, eğer self assignment söz konusu değilse fonksiyon hiçbir şey yapmayacak.

03:08.580 --> 03:10.680
İngilizcesiyle noop olacak.

03:10.680 --> 03:32.720
Bunu da atama operatörünün sol operandının sağ operandıyla aynı nesne olup olmadığını sınamak için diz pointer'ının değeri olan adresin parametre referansın bağlandığı nesnenin adresine ki o atama operatörünün sağ operanda olan nesne eşitliğini sınıyoruz.

03:32.720 --> 03:39.080
Bu arada kalıtımla ilgili geçen bir arkadaşım yorum yapmıştı Cengiz Han.

03:39.960 --> 03:42.640
Onu tabi kalıtım konusunda göreceğiz.

03:43.340 --> 03:46.940
Arkadaşımın yaptığı yorum doğru ama şu anda ona değinmeyeceğim.

03:47.760 --> 03:49.620
Tipik olarak bu şekilde yazılıyor.

03:50.420 --> 03:53.700
Şimdi burada birkaç tane anahtar nokta arkadaşlar.

03:53.700 --> 04:02.640
Bir, bu fonksiyonlar bizim tarafımızdan ne zaman yazılması gerekiyor bunu konuştuk.

04:02.640 --> 04:16.820
Yani sınıfınızın elemanları handle ya da handle'lar değilse sınıfınızın elemanları yine aynak kontrolünü kendisi gerçekleştiren sınıflarsa

04:16.820 --> 04:28.880
yani eleman olan nesnelerin zaten copy constructor'ı, efendim copy assignment'ı ve birazdan görmeye başlayacağımız move constructor, move assignment

04:28.880 --> 04:35.680
bunlar zaten sınıf tarafından yazılmışsa derleyiciye bırakmamızda bir sakınca yok.

04:35.680 --> 04:42.560
Çünkü derleyici kendi yazdığı copy constructor'da sınıfın elemanlarını copy construct ediyor.

04:42.780 --> 04:45.380
Bu durumda elemanların copy construct'ları çağrılacak.

04:45.380 --> 04:51.660
Yani örneğin en çok kullanılan sınıflar oldukları için örneği şimdilik bunlardan veriyorum.

04:51.800 --> 05:01.320
Stud string, stud vector gibi ya da stud map gibi nesneler arkadaşlar sınıfın elemanı olan nesneler

05:01.320 --> 05:13.060
zaten copy construct'ları, copy assignment'ları implemente edilmiş uygun şekilde kaynak yönetimini yapan deep copy işlemini kendileri gerçekleştiriyorlar.

05:13.060 --> 05:18.620
Dolayısıyla onlara herhangi bir şekilde müdahale etmemize gerek yok.

05:18.620 --> 05:24.320
Arkadaşlar, copy assignment'la ilgili şöyle bir şey de söyledim.

05:24.400 --> 05:28.180
Bunu bir not düşelim ileride tekrar buraya dönmek üzere.

05:28.980 --> 05:37.180
Dedim ki bir de copy assignment function'ın idiomatik başka bir şekilde bir yazım biçimi var.

05:37.180 --> 05:43.820
Bu yazım biçimine ilişkin idioma, duyan var mı demiştim, sormuştum.

05:44.720 --> 05:45.760
Hatta yine sorayım.

05:46.420 --> 05:48.080
Duyan var mı, bilen var mı?

05:48.160 --> 05:50.060
Çok da sık kullanıyor endüstride.

05:50.900 --> 05:54.420
Arkadaşlar, copy swap idiom deniyor.

05:55.360 --> 05:57.640
Yani copy swap idiom'ı kullanıyorsanız,

05:58.360 --> 06:02.020
adama operatör fonksiyonu, copy assignment'ı böyle yazmıyorsunuz.

06:02.020 --> 06:04.220
Ama şimdi oraya girmek istemiyorum.

06:04.420 --> 06:06.800
Nasıl yazıyoruz ve neden öyle yazıyoruz?

06:07.460 --> 06:13.300
Çünkü copy swap idiom'un kullanılmasının birinci nedeni,

06:13.940 --> 06:16.400
strong exception garanti sağlamak.

06:16.540 --> 06:19.060
Ama biz şimdi exception handling'i hiç görmedik.

06:20.520 --> 06:24.340
Dolayısıyla exception handling nedir bilen arkadaşlarım vardır.

06:24.500 --> 06:27.080
Ama kursun gidişatı için de henüz görmedik.

06:27.080 --> 06:30.340
Oradaki garantiler ne anlama geliyor?

06:30.700 --> 06:35.200
Basic exception garanti, strong exception garanti,

06:35.880 --> 06:38.160
arkadaşlar no throw garanti gibi.

06:38.980 --> 06:41.020
Onlarla ilgili olduğunu söyleyebiliriz.

06:41.240 --> 06:42.780
Copy swap idiom'unu.

06:44.760 --> 06:48.600
Yine ortak koddan bahsetmiştim.

06:49.340 --> 06:52.660
Destructor kaynağı geri veriyor böyle sınıflarda.

06:52.660 --> 06:56.220
Ben böyle sınıflara biraz kendi uydurduğum terim ama

06:56.220 --> 06:57.840
rayi sınıfları diyorum.

06:59.140 --> 07:02.040
Destructor kaynağı, kaynakları geri veriyor.

07:02.960 --> 07:07.760
Onu release resources diye isimlendirebiliriz bu işlemi.

07:08.940 --> 07:11.120
Copy constructor deep copy yapıyor.

07:12.180 --> 07:14.740
Atama operatör fonksiyonu, copy assignment,

07:15.480 --> 07:18.000
hem release resources hem deep copy yapıyor.

07:18.000 --> 07:23.360
Dolayısıyla bir başka ileride tercih edebileceğimiz çözüm

07:23.360 --> 07:28.160
bu ortak kodları belki uygun şekilde isimlendirilmiş

07:28.160 --> 07:31.400
başka fonksiyonlara yüklemek,

07:32.080 --> 07:37.200
o fonksiyonların destructor, copy constructor ve copy assignment için

07:37.200 --> 07:41.240
o fonksiyonların çağrılmasını sağlamak.

07:41.240 --> 07:47.700
Evet, şimdi arkadaşlar eğer modern C++'da olmasaydık,

07:47.960 --> 07:49.900
onun biraz öncesinde olsaydık,

07:50.820 --> 07:53.860
şöyle meşhur popüler bir terim vardı.

07:54.240 --> 07:57.860
Büyük üçlü, big three.

07:59.140 --> 08:02.480
Büyük üçlü aslında şuna deniyordu.

08:02.480 --> 08:06.440
Şu üç fonksiyon, biri destructor,

08:07.840 --> 08:10.340
bir yeri copy constructor,

08:11.380 --> 08:14.800
bir yeri assignment operator function.

08:14.940 --> 08:18.880
Eskiden zaten iki tane assignment function yoktu,

08:18.940 --> 08:19.700
bir tane vardı.

08:19.920 --> 08:24.340
Ama şimdi orada ikinci bir assignment fonksiyonu geldi,

08:24.600 --> 08:25.220
move assignment.

08:25.400 --> 08:26.440
Birazdan onu göreceğiz.

08:27.380 --> 08:28.640
Şöyle deniyordu,

08:28.640 --> 08:32.080
eğer bu fonksiyonlardan birini,

08:32.740 --> 08:34.600
özellikle de destructor'ı,

08:35.360 --> 08:37.780
yazımını derleyiciye bırakmak yerine,

08:38.600 --> 08:42.800
yazımını kendiniz yapmak zorunda hissediyorsanız,

08:43.980 --> 08:48.180
o zaman diğer iki fonksiyonu da implemente etmelisiniz.

08:48.980 --> 08:53.940
Çünkü destructor'ı yazma nedeni tipik olarak bir kaynağın geri verilmesi,

08:53.940 --> 09:02.380
bu durumda copy constructor ve assignment operator function derleyici tarafından yazılırsa,

09:02.580 --> 09:04.600
onların kodu uygun, düşmeyecek.

09:05.240 --> 09:08.260
Bu yüzden bunlardan birinin yazılması durumunda,

09:09.060 --> 09:13.020
eğer çok çok çok çok sıra dışı bir durum söz konusu değilse,

09:13.740 --> 09:18.900
diğer ikisinin de yine programcı tarafından tanımlanması gerekiyor.

09:18.900 --> 09:23.040
Buna işaret etmek için big tree terimi,

09:23.420 --> 09:26.720
popüler bir terim standartın şüphesiz kullandığı bir terim değil,

09:27.360 --> 09:28.040
kullanılıyordu.

09:29.000 --> 09:30.960
Peki şimdi neden kullanılmıyor?

09:31.920 --> 09:34.040
Hemen bir görüş alalım, tahmin alalım.

09:34.840 --> 09:36.680
Madem bu kadar önemli bir kural,

09:37.160 --> 09:38.740
şimdi neden kullanılmıyor?

09:39.900 --> 09:42.500
Çünkü işin içine,

09:43.200 --> 09:44.480
bravo Fatih Akgül,

09:45.060 --> 09:46.880
bir de muğlar girdi,

09:46.880 --> 09:48.380
taşıma semanti eklendi.

09:48.380 --> 09:54.060
O zaman belki big tree yerine big five demekte fayda var.

09:54.900 --> 09:58.300
Yani işin içine bizim de neleri katmamız gerekecek,

09:58.980 --> 10:04.660
muğ konstruktör ile muğ assignment'ı birlikte katmamız gerekecek.

10:05.700 --> 10:06.340
Arkadaşlar,

10:07.600 --> 10:10.920
muğ semantiği basit gibi görünse de,

10:11.660 --> 10:13.180
aslında bir hayli karmaşık.

10:13.180 --> 10:14.620
yani özünde basit.

10:15.420 --> 10:16.900
Fakat bilmeniz gereken,

10:17.540 --> 10:19.320
gerçekten çok fazla nokta var.

10:19.640 --> 10:22.520
Bu taşıma semantiğini öğrenirken.

10:23.620 --> 10:23.900
Ben,

10:24.580 --> 10:25.180
taşıma semantiğini,

10:25.960 --> 10:27.560
ileri C++ kursunda,

10:27.880 --> 10:29.040
yanlış hatırlamıyorsam,

10:29.120 --> 10:31.180
böyle 20-30 saatlik bir konu,

10:31.700 --> 10:32.860
olarak ele alıyorum.

10:32.860 --> 10:33.700
bunun için de,

10:34.240 --> 10:34.860
taşıma semantiğinin,

10:35.580 --> 10:37.160
jenerik kodlarda,

10:38.040 --> 10:40.080
yani türden bağımsız yazılan kodlarda,

10:40.680 --> 10:40.860
kullanılması,

10:41.800 --> 10:43.540
ve yine bununla ilişkili olarak,

10:44.240 --> 10:45.840
perfect wording dediğimiz,

10:46.220 --> 10:46.900
mekanizma,

10:47.540 --> 10:48.240
daha çok yine,

10:48.480 --> 10:51.380
jenerik programlama paradigmasıyla ilgili.

10:51.380 --> 10:53.220
Hocam,

10:53.300 --> 10:55.240
ileri C++ kursu ne zaman olacak?

10:55.900 --> 10:57.180
Bir aksilik olmazsa,

10:57.300 --> 10:59.140
Kasım gibi kesin açılacak.

10:59.240 --> 10:59.980
Kasım ya da,

11:00.320 --> 11:00.620
Aralık.

11:00.800 --> 11:00.960
Yani,

11:01.740 --> 11:02.240
bu kurs,

11:02.560 --> 11:03.600
şöyle söyleyelim ya da,

11:03.660 --> 11:05.800
bu kursun bitiminden sonra açılacak ki,

11:06.200 --> 11:07.620
bekleyen bazı arkadaşlarım var,

11:07.720 --> 11:09.860
bu kurstan da belki katılmak isteyen olursa,

11:10.560 --> 11:10.960
o zaman,

11:11.640 --> 11:13.840
yeterli öğrenci sayısına ulaşıyoruz.

11:14.000 --> 11:15.480
İleri C++'a talep,

11:15.480 --> 11:18.300
bu ne diyelim,

11:18.380 --> 11:19.080
ileri olmayan,

11:19.160 --> 11:21.460
normal C++'a olan talepten,

11:21.920 --> 11:23.140
daha az şüphesiz.

11:23.240 --> 11:23.460
Çünkü,

11:23.720 --> 11:25.520
biraz zor da bir kurs konular,

11:25.700 --> 11:26.520
biraz daha zor,

11:27.160 --> 11:27.780
karmaşık,

11:27.900 --> 11:29.260
herkes almak istemiyor.

11:29.360 --> 11:30.400
Ya da belki bu kadarını,

11:31.060 --> 11:32.340
yeterli buldukları için.

11:33.220 --> 11:33.640
Şimdi,

11:34.420 --> 11:36.360
taşıma semantiğine geçmeden önce,

11:36.360 --> 11:38.620
bir noktayı tekrar,

11:38.960 --> 11:40.040
vurgulamak istiyorum.

11:40.640 --> 11:42.500
Function overloading ile ilgili.

11:42.720 --> 11:43.060
Çünkü,

11:43.820 --> 11:44.360
taşıma semantiği,

11:44.360 --> 11:45.640
şimdi,

11:46.200 --> 11:47.940
üstünden tekrar geçeceğimiz,

11:48.560 --> 11:49.920
function overloading'in,

11:50.120 --> 11:51.600
özel bir durumuyla,

11:51.880 --> 11:53.220
son derece ilgili.

11:53.920 --> 11:54.540
Değerli arkadaşlar,

11:55.620 --> 11:56.180
izleyin.

11:59.000 --> 12:00.640
Buraya geri döneceğim.

12:01.920 --> 12:02.280
Ya da,

12:02.400 --> 12:03.340
şöyle kahvetmeyelim,

12:03.440 --> 12:04.500
geri döneceğiz derken.

12:05.460 --> 12:05.680
Evet.

12:06.580 --> 12:06.960
Ne olur,

12:07.040 --> 12:07.400
ne olmaz,

12:07.500 --> 12:08.780
bir kere daha kopyalayalım.

12:11.080 --> 12:11.340
Okey.

12:14.360 --> 12:15.500
Arkadaşlar,

12:16.420 --> 12:16.640
şimdi,

12:16.980 --> 12:18.560
şu overloading yapısını,

12:19.040 --> 12:19.720
tekrar bir,

12:19.920 --> 12:21.580
hatırlamanızı istiyorum.

12:22.540 --> 12:23.560
Bir sınıfımız var.

12:25.720 --> 12:26.640
Diyelim ki,

12:27.020 --> 12:27.520
class,

12:27.520 --> 12:28.460
net,

12:28.460 --> 12:28.520
net.

12:28.520 --> 12:33.480
Bir fonksiyonumuz var.

12:33.860 --> 12:34.380
Word,

12:34.860 --> 12:35.160
u.

12:36.480 --> 12:37.460
Parametresi,

12:37.700 --> 12:38.160
const,

12:38.580 --> 12:38.860
net,

12:39.160 --> 12:39.560
red.

12:40.840 --> 12:42.600
Bir fonksiyonumuz daha var.

12:43.400 --> 12:44.360
Parametresi,

12:44.700 --> 12:45.040
net,

12:45.480 --> 12:45.820
ref,

12:45.860 --> 12:46.100
ref.

12:46.860 --> 12:47.460
Şimdi bu,

12:47.660 --> 12:49.480
çok sık karşımıza çıkan bir,

12:49.480 --> 12:50.400
overloading.

12:51.080 --> 12:51.540
Bu arada,

12:52.120 --> 12:53.360
yanlış anlamı olmasın.

12:53.360 --> 12:54.900
Buraya örneğin,

12:55.340 --> 12:57.540
en az iki overload daha koyabilirim.

12:58.380 --> 12:58.940
Arkadaşlar,

12:59.040 --> 13:00.180
biri şöyle olabilir.

13:00.860 --> 13:01.420
İzleyin.

13:02.240 --> 13:03.100
Kanslı olmayan,

13:03.180 --> 13:03.740
necrif.

13:04.520 --> 13:04.860
Hatta,

13:05.040 --> 13:05.300
hatta,

13:06.180 --> 13:06.900
kullanımı,

13:07.200 --> 13:08.880
neredeyse hiç olmayan,

13:09.780 --> 13:11.060
semantik karşılığı,

13:11.420 --> 13:12.480
yanlış hatırlamıyorsam,

13:12.620 --> 13:12.880
sadece,

13:12.880 --> 13:14.900
stud optional sınıfında olan,

13:15.460 --> 13:16.500
şu bile olabilir.

13:17.760 --> 13:18.020
Yani,

13:18.240 --> 13:19.940
bunun bile var olduğunu,

13:20.080 --> 13:22.460
bazen gerekli olabileceğini düşünebilirsiniz.

13:23.360 --> 13:24.540
Takip edebiliyor muyuz?

13:24.660 --> 13:25.140
Bakın bakın,

13:25.600 --> 13:27.420
burada kaç tane overload var?

13:27.880 --> 13:28.840
Tam tamına,

13:29.040 --> 13:30.520
dört tane overload var.

13:31.840 --> 13:32.120
Şöyle,

13:32.380 --> 13:33.720
sırasıyla kaveh,

13:34.280 --> 13:34.680
bakalım,

13:35.080 --> 13:36.700
on birinci satırdan başlayalım.

13:36.840 --> 13:37.780
Şunu bir diyelim,

13:38.000 --> 13:38.240
bu,

13:39.180 --> 13:40.200
const olmayan,

13:40.580 --> 13:42.040
lvalue ref.

13:42.860 --> 13:44.200
Const lvalue ref,

13:45.800 --> 13:46.820
rvalue ref,

13:47.880 --> 13:48.320
arkadaşlar,

13:48.700 --> 13:50.220
ve const rvalue ref.

13:51.200 --> 13:52.120
Tekrar söylüyorum,

13:52.120 --> 13:54.300
dördüncüsü,

13:54.720 --> 13:55.480
tipik olarak,

13:56.120 --> 13:56.920
bir işe yaramıyor.

13:57.100 --> 13:57.800
Semantik,

13:58.080 --> 13:59.740
karşılığı hiç olamaz demiyorum,

13:59.900 --> 14:00.800
ama çok nadir.

14:01.580 --> 14:02.780
Ama yine de bir overload.

14:03.360 --> 14:03.760
Süper.

14:04.780 --> 14:05.320
Arkadaşlar,

14:05.440 --> 14:06.300
fakat daha çok,

14:07.240 --> 14:09.000
üretimde karşımıza çıkacak,

14:09.140 --> 14:10.060
ya da kullanacağımız,

14:10.120 --> 14:12.120
kütüphanelerde karşımıza çıkacak,

14:12.820 --> 14:13.620
şu ikisi,

14:14.400 --> 14:15.120
diğer ikisi,

14:15.480 --> 14:16.180
çoğunlukla,

14:16.900 --> 14:18.480
bunlarla birlikte olmayacak.

14:19.060 --> 14:20.280
O zaman buna bir diyelim,

14:20.600 --> 14:21.500
buna iki diyelim.

14:21.500 --> 14:23.380
Arkadaşlar,

14:24.220 --> 14:26.680
böyle bir overloadla neyi sağlıyoruz?

14:27.500 --> 14:28.540
Son derece basit.

14:29.400 --> 14:33.020
Lvalue ve rvalue sınıf nesneleri için,

14:33.820 --> 14:35.960
farklı implementasyonlar sunuluyor.

14:35.960 --> 14:39.880
11. satırdaki fonksiyon diyor ki,

14:40.680 --> 14:44.560
lvalue neç argümanları bana gelsin.

14:45.560 --> 14:47.980
12. satırdaki fonksiyon diyor ki,

14:48.640 --> 14:51.820
rvalue olan argümanlar bana gelsin.

14:51.820 --> 14:53.140
şimdi,

14:53.140 --> 14:55.900
sadece beni izleyin.

14:56.700 --> 14:57.480
Diyelim ki,

14:57.820 --> 15:01.700
burada bir lvalue ifade var.

15:01.920 --> 15:02.520
My neç.

15:02.520 --> 15:03.520
neç.

15:03.520 --> 15:04.400
Hemen altına da,

15:04.400 --> 15:05.240
hemen altına da,

15:05.240 --> 15:09.640
rvalue olan bir neç ifadesi yazalım.

15:10.160 --> 15:12.080
Henüz görmedik ama yakın göreceğiz.

15:12.860 --> 15:13.320
Arkadaşlar,

15:13.400 --> 15:15.360
bu şekilde oluşturulan nesnelere,

15:16.360 --> 15:17.960
ilerleyen saatlerde,

15:18.680 --> 15:20.460
temporary objects diyeceğiz.

15:20.580 --> 15:20.760
Bakın,

15:20.800 --> 15:22.320
bu çok önemli bir konu.

15:23.160 --> 15:24.280
Önce terimi yazalım.

15:25.020 --> 15:26.620
Temporary objects.

15:27.220 --> 15:29.780
Necati bunu ayrı bir başlık altında mı inceleyeceğiz?

15:29.780 --> 15:30.680
Kesinlikle.

15:32.180 --> 15:34.140
Ya neden böyle bir sentaks var?

15:34.280 --> 15:35.060
Ne işe yarıyor?

15:36.040 --> 15:36.920
Fakat şimdilik,

15:37.700 --> 15:39.220
temporary objects derken,

15:39.960 --> 15:41.620
kastedilen ifadelerin,

15:42.160 --> 15:42.900
tipik olarak,

15:43.620 --> 15:47.000
bir sınıf türünden nesne anlamına geldiği bir,

15:47.760 --> 15:48.760
fakat ortada,

15:49.060 --> 15:51.960
o nesnenin isminin olmadığı ifadeler.

15:52.940 --> 15:53.580
Arkadaşlar,

15:54.040 --> 15:55.860
bakın burada bir değişkenin ismi var.

15:56.620 --> 15:58.360
Fakat burada bir değişkenin ismi yok.

15:58.360 --> 15:59.960
Sınıfın ismi var sadece.

16:00.880 --> 16:01.660
Ama bu da,

16:03.100 --> 16:04.840
nec türünden bir nesne,

16:05.160 --> 16:06.760
bu da nec türünden bir nesne.

16:07.720 --> 16:08.220
Aradaki,

16:09.400 --> 16:10.520
ikinci önemli fark,

16:11.220 --> 16:14.740
bir ismin olması ya da olmamasının yanında,

16:15.820 --> 16:19.440
bu ifadelerin value kategorilerinin farklı olması.

16:19.440 --> 16:23.740
şüphesiz bir ismin söz konusu olduğu ifadeler,

16:23.740 --> 16:25.620
l-value expression,

16:26.240 --> 16:29.660
ama ismin olmadığı ifadeler,

16:30.400 --> 16:31.400
r-value expression.

16:31.540 --> 16:37.000
Ve burada tabi r-value expression'ın combined value kategori olduğunu,

16:37.000 --> 16:37.980
yani,

16:37.980 --> 16:38.000
yani,

16:38.600 --> 16:38.860
hem,

16:38.860 --> 16:43.000
p-r-value expression olan primary value kategorinin,

16:43.880 --> 16:44.480
hem de,

16:44.720 --> 16:45.180
arkadaşlar,

16:46.260 --> 16:49.640
x-value olan primary value kategorisinin,

16:50.280 --> 16:51.800
birleşim kümesi olduğunu,

16:52.400 --> 16:54.940
r-value kategorisinin,

16:55.380 --> 16:56.000
hatırlayalım.

16:56.000 --> 17:01.000
Dolayısıyla ben birinci değer kategorisinden bahsediyor olsaydım,

17:01.620 --> 17:04.060
buna p-r-value diyecektim.

17:04.840 --> 17:05.480
Arkadaşlar,

17:06.200 --> 17:06.820
ama bakın,

17:07.140 --> 17:08.660
yine gün içinde,

17:09.160 --> 17:11.400
geri döneceğimiz bir derste bahsetmiştik.

17:12.300 --> 17:12.860
İsmi,

17:13.500 --> 17:16.300
move olan fonksiyona,

17:17.260 --> 17:18.260
argüman olarak,

17:18.620 --> 17:21.240
bir l-value expression verirseniz,

17:22.180 --> 17:24.380
bu const expr function,

17:24.380 --> 17:26.260
ismi move olan fonksiyon,

17:26.900 --> 17:27.400
ne yapıyor?

17:28.060 --> 17:30.760
Kötü isimlendirildiğinden daha önce bahsetmiştim,

17:30.860 --> 17:32.800
bir İngilizcesiyle misnomer.

17:33.620 --> 17:34.200
Ne yapıyor?

17:34.900 --> 17:36.060
Move falan yapmıyor.

17:36.700 --> 17:40.060
Hatta Scott Meyers'ın ünlü bir gümlesi var,

17:40.360 --> 17:42.740
çok sık atıfta bulunulan,

17:43.100 --> 17:45.000
move doesn't move.

17:46.080 --> 17:48.020
Yani stud move doesn't move.

17:48.260 --> 17:48.840
Move yapmıyor.

17:49.020 --> 17:49.420
Ne yapıyor?

17:49.560 --> 17:50.520
Move cast yapıyor.

17:51.580 --> 17:52.860
Stud move fonksiyonu,

17:52.860 --> 17:57.240
ileride nasıl implement edildiğini de göstereceğim arkadaşlar.

17:58.180 --> 17:59.080
Sadece ne yapıyor?

17:59.740 --> 18:00.980
L-value alırsa,

18:01.220 --> 18:02.900
onu r-value'ya dönüştürüyor.

18:03.780 --> 18:04.660
r-value'yu,

18:04.900 --> 18:07.020
yine r-value olarak veriyor.

18:07.980 --> 18:08.640
Dolayısıyla,

18:09.380 --> 18:10.600
move fonksiyonu,

18:11.160 --> 18:12.360
l-value'da gelse,

18:12.600 --> 18:13.660
r-value'da gelse,

18:13.740 --> 18:15.000
kendisine argüman olarak,

18:15.000 --> 18:19.420
r-value kategorisinde bir ifade oluşturuyor.

18:19.420 --> 18:20.880
Aslında,

18:21.520 --> 18:26.120
bu ileride yine detaylı göreceğimiz move fonksiyonu yerine,

18:26.840 --> 18:27.480
pekala,

18:28.040 --> 18:29.460
şunu da yazabilirsiniz.

18:30.200 --> 18:31.260
Static cast,

18:31.640 --> 18:32.120
arkadaşlar,

18:33.300 --> 18:33.720
nec,

18:34.060 --> 18:34.860
refref,

18:36.800 --> 18:37.680
efendim,

18:38.020 --> 18:38.440
nezne.

18:38.440 --> 18:41.740
Yani ben pekala,

18:42.360 --> 18:43.760
move'u çağırmak yerine,

18:44.500 --> 18:46.980
static cast operatörünü bu şekilde kullanıp,

18:47.660 --> 18:49.700
move'un geri dönüş değeri yerine,

18:50.360 --> 18:54.800
static cast operatörünün oluşturduğu ifadeyi kullanabilirim.

18:54.860 --> 18:56.900
Arada gerçekten pratik olarak fark yok.

18:56.900 --> 18:58.220
Fakat tabi,

18:58.440 --> 19:01.840
stud move'u daha zengin kullanım olanağı veriyor.

19:02.520 --> 19:03.440
Onu ileride göreceğiz.

19:03.560 --> 19:04.520
Belki tek suçu,

19:04.820 --> 19:05.580
stud move'un,

19:06.400 --> 19:08.000
kötü isimlendirilmiş olması.

19:08.600 --> 19:09.520
Ve öğrenenlerin,

19:10.100 --> 19:11.620
işini biraz zorlaştırması.

19:12.300 --> 19:12.660
Çünkü,

19:13.460 --> 19:14.160
bunu gören,

19:14.680 --> 19:15.320
taşımayı,

19:15.640 --> 19:18.280
sanki bu fonksiyonun yaptığını zannediyor.

19:18.840 --> 19:19.840
Taşımaya gelmedik.

19:19.940 --> 19:21.000
Ama neden bahsediyorum?

19:21.640 --> 19:22.140
Bakın şimdi,

19:22.360 --> 19:24.300
r-value expression olan,

19:24.300 --> 19:28.180
sınıf nesnesi oluşturan birkaç tane ifade var.

19:28.780 --> 19:29.220
Biri,

19:30.220 --> 19:32.140
yine az önce söylediğim gibi,

19:32.240 --> 19:35.300
önümüzdeki derslerden birinin alt başlığı olacak,

19:36.040 --> 19:38.680
temporary object oluşturma ifadeleri.

19:39.760 --> 19:40.500
İkincisi,

19:40.800 --> 19:41.260
arkadaşlar,

19:41.520 --> 19:43.200
birkaç tanesini söyleyelim.

19:43.720 --> 19:44.400
İkincisi,

19:45.220 --> 19:48.760
stud move fonksiyonuna yapılan çağrı ifadesi.

19:49.560 --> 19:50.360
Üçüncüsü,

19:50.520 --> 19:51.620
stud move yerine,

19:52.480 --> 19:52.900
efendim,

19:52.900 --> 19:54.240
sınıf türünden,

19:54.600 --> 19:56.680
r-value reference türüne,

19:56.960 --> 19:57.640
cast eden,

19:57.880 --> 19:59.960
static cast operatörüyle ifadeler.

20:01.520 --> 20:02.280
Fakat,

20:02.420 --> 20:03.920
arada belki şöyle bir fark var.

20:04.420 --> 20:05.340
Bu da r-value,

20:05.640 --> 20:07.880
ama bunun primary value kategorisi,

20:08.460 --> 20:09.100
x-value.

20:10.460 --> 20:12.100
x-value ifadelerle ilgili,

20:12.200 --> 20:13.520
çok fazla konuşmadık.

20:14.000 --> 20:14.640
Ama sadece,

20:14.960 --> 20:15.420
şimdilik,

20:15.640 --> 20:16.580
bir ipucu vereyim.

20:16.580 --> 20:19.680
en sık karşımıza çıkma ihtimali olan,

20:19.680 --> 20:23.760
x-value kategorisindeki ifadeler,

20:24.400 --> 20:25.740
geri dönüş değeri,

20:26.600 --> 20:28.800
sağ taraf referansı olan,

20:29.460 --> 20:31.280
fonksiyonlara yapılan,

20:31.640 --> 20:32.680
çağrı ifadeleri.

20:32.680 --> 20:34.360
yani örneğin,

20:34.360 --> 20:37.860
bar gibi bir fonksiyon bu şekilde bildirilmişse,

20:38.560 --> 20:39.060
arkadaşlar,

20:39.940 --> 20:43.360
bar fonksiyonuna yapılan çağrı ifadesi,

20:43.960 --> 20:45.400
value kategori olarak,

20:45.800 --> 20:46.520
x-value.

20:46.520 --> 20:48.780
takip edebiliyor muyuz?

20:49.400 --> 20:49.660
Ama,

20:50.240 --> 20:50.840
tabii ki,

20:51.160 --> 20:52.820
aynı zamanda r-value.

20:53.940 --> 20:54.660
Dolayısıyla,

20:55.720 --> 20:57.440
bir daha tekrar edecek olursak,

20:58.280 --> 21:00.200
move fonksiyonuna yapılan çağrı,

21:00.860 --> 21:02.440
static cast operatörünün,

21:02.500 --> 21:04.340
az önce söylediğim gibi kullanımı,

21:05.420 --> 21:05.820
efendim,

21:06.540 --> 21:07.560
geri dönüş değeri,

21:07.920 --> 21:11.480
sağ taraf referansı olan bir fonksiyonuna yapılan çağrı,

21:11.480 --> 21:12.240
ve,

21:12.360 --> 21:14.080
geri dönüş değeri,

21:15.000 --> 21:16.060
referansı olmayan,

21:16.060 --> 21:19.400
doğrudan tür olan bir fonksiyona yapılan çağrı ifadeleri,

21:20.040 --> 21:22.100
tipik r-value expression'lar.

21:22.840 --> 21:23.080
Ama,

21:23.160 --> 21:24.620
şimdi konuya geri dönmek istiyorum.

21:24.760 --> 21:25.860
Bunları göreceğiz zaten.

21:26.940 --> 21:27.980
Nereden başladık?

21:28.420 --> 21:29.780
Böyle bir overload varsa,

21:30.840 --> 21:31.220
arkadaşlar,

21:31.820 --> 21:33.020
böyle bir overloadda,

21:33.780 --> 21:35.780
l-value expression argüman,

21:36.640 --> 21:39.840
birinci overloadun çağrılmasını sağlayacak,

21:39.840 --> 21:42.540
function overload resolution'la,

21:43.860 --> 21:45.460
sağ taraf değeri olan,

21:45.460 --> 21:46.660
x-value'de olabilir,

21:46.840 --> 21:48.040
pr-value'de olabilir,

21:48.800 --> 21:49.560
bir argüman,

21:50.120 --> 21:52.780
ikinci fonksiyonun çağrılması sonucunda olacak.

21:53.080 --> 21:54.140
Burası kritik önemi,

21:54.380 --> 21:55.100
önem taşıyor.

21:55.100 --> 21:59.080
o zaman tekrar şimdi ben size soracak olursam,

21:59.760 --> 22:00.700
nec, may nec,

22:00.700 --> 22:01.540
soru bir,

22:02.320 --> 22:03.860
bu, may nec,

22:04.200 --> 22:05.300
hangisi çağrılır?

22:06.400 --> 22:06.940
Cevap,

22:07.200 --> 22:07.940
tabii ki bir.

22:08.740 --> 22:09.100
Bravo,

22:09.440 --> 22:09.880
arkadaşlar.

22:10.680 --> 22:11.300
Soru iki,

22:11.300 --> 22:18.400
oysa ben may nec'i bu şekilde argüman olarak kullanmak yerine,

22:19.180 --> 22:22.980
ilerleyen saatlerde belki daha ayrıntılı göreceğimiz,

22:23.640 --> 22:27.560
stud move fonksiyonla may nec'i argüman olarak gönderirsem,

22:28.280 --> 22:30.940
ve argüman olarak bu ifadeyi kullanırsam,

22:30.940 --> 22:35.760
bu artık bir r-value expression olduğu için iki çağrılacak değil mi?

22:36.760 --> 22:37.160
Yine,

22:37.320 --> 22:39.320
bakın bunların hepsine çok dikkat edin,

22:39.860 --> 22:40.200
yine,

22:41.080 --> 22:43.140
henüz detaylı görmesek de,

22:43.920 --> 22:45.860
fonksiyona gönderdiğim argüman,

22:46.600 --> 22:49.940
eğer bir temporary object ifadesiyse,

22:49.940 --> 22:52.800
bu da p-r-value expression,

22:52.940 --> 22:54.680
dolayısıyla r-value expression,

22:55.180 --> 22:57.120
yine hangi fonksiyon çağrılacak?

22:57.760 --> 22:58.160
Alihan,

22:58.280 --> 22:58.680
Samet,

22:58.780 --> 22:59.120
Kaan,

22:59.260 --> 22:59.560
Kave,

22:59.980 --> 23:02.480
tabii ki iki çağrılacak.

23:03.440 --> 23:03.580
Evet,

23:04.220 --> 23:07.440
ya da ya da ya da az önceki fonksiyona bakınız,

23:08.200 --> 23:12.300
geri dönüş değeri nec olan bar fonksiyonu,

23:12.840 --> 23:15.860
ya da geri dönüş değeri nec rep rep olan,

23:16.560 --> 23:17.100
efendim,

23:17.500 --> 23:19.100
baz fonksiyonu,

23:19.540 --> 23:19.880
baz.

23:19.940 --> 23:22.760
Şimdi,

23:23.660 --> 23:29.220
bu'ya argüman olarak bar fonksiyonla yapılan çağrı ifadesini verirsem,

23:29.820 --> 23:33.480
yine bir r-value expression argüman vermiş oluyorum.

23:34.080 --> 23:40.240
Yine baz fonksiyonla yapılan çağrı ifadesini arkadaşlar argüman olarak verirsem,

23:40.380 --> 23:42.940
yine r-value expression oluyor.

23:43.820 --> 23:45.760
Muhammed Furkan Toptaş,

23:45.760 --> 23:47.260
nec ref ref,

23:47.600 --> 23:49.700
my nec ifadesi ile de,

23:49.700 --> 23:53.420
C tipi şeklinde r-value expression yapabilir miyiz?

23:53.420 --> 23:55.660
Biz yapabiliriz ama yapmayız, o ayrı.

23:56.240 --> 23:56.960
Yapabiliriz.

23:56.960 --> 24:01.240
yani aslında C tarzı tür dönüştürme operatörünün kullanımında,

24:01.240 --> 24:05.560
genel olarak bir problem yok.

24:05.560 --> 24:10.220
ama şimdi yapabilir miyiz başka?

24:10.220 --> 24:11.220
asla yapmayalım.

24:11.220 --> 24:12.220
Asla yapmayalım.

24:12.220 --> 24:27.040
Yani her zaman eğer statikest operatörünü kullanmak ya da C++'ın genel olarak tür dönüştürme operatörlerini kullanmak çok istisnai sayılabilecek birkaç durumun dışında her zaman birinci tercihimiz.

24:27.040 --> 24:37.320
Şimdi neden buraya girdiğimi anlatayım, çok dikkatli izliyorsunuz, o zaman şöyle yapalım, şu fonksiyonları çağıralım.

24:37.320 --> 24:45.840
Bu, nec, bir soru soracağım çünkü çok önemli.

24:45.840 --> 24:53.500
Bu, su, mu, my nec.

24:53.500 --> 24:55.500
Tamam.

24:55.500 --> 24:59.440
Şimdi beni takip etmeye devam edin.

25:00.120 --> 25:10.780
21, özür dilerim, 22, 23, 24 ve 25. satırdaki fonksiyon çağrıları hangi fonksiyona bağlanacak?

25:11.040 --> 25:17.460
Function overload resolution ile istisnansız hepsi arkadaşlar ikinci fonksiyona bağlanacak.

25:18.080 --> 25:21.620
Şimdi soruyu anlamaya çalışın.

25:21.620 --> 25:26.900
Hatta bir ipucu vermemek için önce soruyu sözel olarak sorayım.

25:27.720 --> 25:32.120
İkinci overloadu silersem, sentaks hatası olur mu?

25:34.380 --> 25:37.880
Bu kodda, görünüz, Rasul Mamadol, hayır.

25:38.700 --> 25:39.860
Muhammed Furkan, hayır.

25:40.080 --> 25:42.140
Muhammed Ateşoğlu, Oğuzhan Esin, hayır hayır.

25:42.260 --> 25:43.800
Süper cevap, olmaz.

25:44.460 --> 25:48.700
İsterseniz bakın, kodda tabii yanlışlıkla yazdım, başka bir öğe yoksa.

25:48.700 --> 25:49.540
Bu legal.

25:49.540 --> 25:54.960
Ama şimdi ikinci overloadu sildim.

25:55.680 --> 25:56.380
Yine legal.

25:56.720 --> 26:03.460
Çünkü const L value referans, R value'a da bağlanıyor, L value'a da bağlanıyor.

26:04.820 --> 26:05.920
Doğru mu?

26:06.280 --> 26:09.800
Kesinlikle R value'a da, L value'a da bağlanıyor.

26:09.800 --> 26:15.160
Dolayısıyla sağ taraf, sol taraf değeriyle çağırmak zorunda değilim ki.

26:16.220 --> 26:16.420
Evet.

26:16.420 --> 26:23.100
Şimdi bu durum için ilerleyen saatlerde yine popüler bir terim kullanılıyor.

26:23.640 --> 26:25.000
Arkadaşlar, fallback.

26:26.380 --> 26:27.040
Duydunuz mu?

26:27.200 --> 26:33.760
Yani bu tabii İngilizce'de genel bir terim ama burada fallback'i şu anlamda kullanacağım.

26:33.760 --> 26:40.900
Ve siz de belki başka kitaplarda, yazılarda, makalelerde, videolarda kullanıldığını göreceksiniz.

26:40.900 --> 27:03.000
Normalde hem L value referans, hem de const L value referans, hem de R value referans parametreli iki fonksiyon varsa, iki overload varsa, R value'ları R value referans parametreli, L value'ları L value referans parametreli, const L value referans parametreli oluyor.

27:03.000 --> 27:08.900
Ama R value referans parametreli, overload olmadığında hepsini kim alıyor?

27:09.580 --> 27:13.120
Arkadaşlar, L value referans parametreli oluyor.

27:14.180 --> 27:15.220
Burayı anladık mı?

27:15.960 --> 27:26.000
Yani sağ taraf referans parametreli den olsaydı o olacaktı ama o olmadığı için, Türkçeleştirelim biraz, nereye düşüyor?

27:28.120 --> 27:32.540
Const Natch Ref, bu örnek için konuşuyorum, parametreli fonksiyona düşüyor.

27:33.000 --> 27:35.980
Bunu şimdi bir köşeye yazın.

27:36.600 --> 27:38.100
Buraya geri döneceğiz.

27:38.820 --> 27:44.220
Şimdi gelelim arkadaşlar, move constructora ve move assignment'a.

27:44.220 --> 28:08.340
Öyle durumlar var ki, aslında koda bakarak biz, aynı zamanda derleyici, bir sınıf nesnesinin artık kullanılma olanağının olmadığını, o nesneye kullanacak bir kodun söz konusu olmadığını derleyici anlayabiliyor.

28:08.340 --> 28:12.340
Biz de koda bakarak anlayabiliyoruz arkadaşlar.

28:12.340 --> 28:28.380
Arkadaşlar, şimdi böyle bir durumda bir sınıf nesnesi varken, diyelim ki bizim string sınıfı gibi, onun değeriyle başka bir sınıf nesnesini hayata getirmek istediğimde,

28:28.380 --> 28:35.620
şimdiye kadar, arkadaşlar buraya dikkat, yani modern C++'dan önce şimdiye kadar derken,

28:38.200 --> 28:45.800
değerini kullanacağım, değerini alacağım sınıf nesnesinin hayatı bitecek olmasına karşın,

28:45.800 --> 28:55.900
onu kullanacak hiçbir kodu olmayacak, onun hayatı bitecek olmasına karşın, onun kaynağını yine kopyalıyorduk birçok durumda.

28:55.900 --> 29:05.320
Fakat, şimdi dilin nasıl bir olanağı, sentaks düzeyinde söz konusu oldu,

29:06.480 --> 29:14.120
adeta şunu yapacağız, bakın bakın, sen sınıf nesnesi, seni kullanacak başka bir kod yok zaten,

29:14.560 --> 29:21.960
senin hayatın bitecek, sen gidicisin Türkçe, bilmiyorum bu, siz de kullanıyor musunuz Resul bu sözü,

29:21.960 --> 29:27.260
sen gidicisin, yani öbür dünyaya gideceksin, öleceksin, destroy olacaksın,

29:28.100 --> 29:38.980
o zaman ben neden senin kaynağını kopyalıyım, ben senin kaynağını edineyim, kaynağa devralıyım, kaynağa çalayım.

29:38.980 --> 29:49.860
Burada gerçekten İngilizce'de kullanılan, arkadaşlar fiil, steal, to steal the resource.

29:51.960 --> 29:56.380
Kaynağını çalıyorum, arkadaşlar bakın şimdi,

29:57.120 --> 30:01.400
geçen halen duruyor mu, kötü kötü çizimler yapmıştım ama,

30:01.980 --> 30:03.600
duruyor çizimlerden biri.

30:04.120 --> 30:08.740
Şimdi kafanızda canlandırmaya çalışın, ne demek istediğimi anlamaya çalışın.

30:08.900 --> 30:12.020
Şunları da sileyim, sadece bir tanesi kalsın.

30:12.020 --> 30:25.500
Evet, şimdi diyelim ki böyle bir string sınıfı türünden nesnemiz var, bizim yazdığımız string sınıfından bahsediyorum.

30:25.740 --> 30:33.520
Fakat biz biliyoruz ki, böyle ismi de olmak zorunda değil, sınıf nesnesinin hayatı bitecek.

30:33.520 --> 30:38.240
Hayatı biterken, bunun için destraktör çağrılacak.

30:39.140 --> 30:41.260
Destraktör da, hatırlıyorsunuz değil mi,

30:41.600 --> 30:45.960
dynamikle, allocated, dinamik olarak edinilmiş,

30:46.520 --> 30:48.700
bu bellek bloğunu geri verecek.

30:49.060 --> 30:56.560
Ama şimdi, ben bu sınıf nesnesinin değeriyle başka bir sınıf nesnesi oluşturmak istiyorum.

30:57.480 --> 31:00.120
Şunu yapmak daha akıllıca olmaz mı?

31:00.120 --> 31:06.940
Neden bu kaynağını geri versin ki, o zaman onun kaynağını ben edineyim.

31:07.740 --> 31:16.200
Yani benim sınıf nesnem, diğer sınıf nesnesinin kaynağını edinmek için bu sefer gerçekten pointer'ı kopyalasın.

31:17.820 --> 31:18.900
Takip edebiliyor muyuz?

31:19.760 --> 31:22.020
Ama burada bir problem var.

31:22.740 --> 31:23.740
Nedir bu problem?

31:23.740 --> 31:34.020
Bir, koda bakarak, buradaki sınıf nesnesinin hayatının bitecek olduğunu anlaması gerekiyor derleyicinin.

31:34.480 --> 31:35.560
Buraya dikkat.

31:36.340 --> 31:42.040
Ve iki, alternatif başka bir kodu seçmesi gerekiyor.

31:43.180 --> 31:47.500
Yani, şöyle bir durum oluşturmamız gerekiyor.

31:47.500 --> 31:53.820
Eğer kopyalama hayatı devam edecek bir nesneden yapılıyorsa,

31:54.800 --> 31:59.920
hayatı devam edecek bir nesne kaynak olarak kullanılması suretiyle yapılıyorsa,

32:00.820 --> 32:06.040
o zaman bizim copy constructor'ımız perfectly fit istediğimiz o.

32:06.040 --> 32:15.640
ama kopyalama, hayatı bitecek olan, asla bir daha kullanılmayacak olan bir nesneden yapılıyorsa,

32:16.640 --> 32:25.200
o zaman arkadaşlar, deep copy yapmak yerine gerçekten pointer'ı kopyalayacak bir kodu seçmem gerekiyor.

32:25.200 --> 32:28.800
Şimdi, bu yeni bir fikir değil ki.

32:29.560 --> 32:34.060
Yani, bunu akletmek için çok zeki olmak gerekmiyor.

32:34.340 --> 32:36.240
Fakat, modern C++'dan önce,

32:37.160 --> 32:40.580
statik olarak, koda bakarak bunu yapma imkanı yoktu.

32:41.660 --> 32:43.300
Ve, arkadaşlar,

32:44.220 --> 32:45.900
modern C++'la birlikte,

32:46.340 --> 32:50.520
bunun rahatlıkla implemente edilmesini sağlayacak bağlayıcı araç,

32:51.300 --> 32:53.960
R-value reference, arkadaşlar.

32:53.960 --> 32:57.620
Şimdi, çok dikkatli izleyelim.

32:58.580 --> 32:59.800
Bir problem daha var.

33:00.220 --> 33:01.200
O problem de şu.

33:01.860 --> 33:03.660
Necati, senin dediğini yaptık.

33:04.520 --> 33:04.900
Yani,

33:05.800 --> 33:08.600
ikinci nesne, yeni hayata getireceğimiz nesne,

33:09.320 --> 33:11.280
yeni bir kaynak edinmek yerine,

33:11.780 --> 33:13.640
diğerinin pointer'ını kopyaladı.

33:14.640 --> 33:15.240
Ama,

33:15.920 --> 33:18.720
bu nesne için destructor çağrıldığında,

33:19.600 --> 33:21.860
e o yine bu kaynağı geri vermeyecek mi?

33:21.860 --> 33:24.020
Cevap tabii ki verecek.

33:24.160 --> 33:26.120
O zaman da dangling pointer oluşur.

33:26.120 --> 33:27.380
Fakat,

33:27.380 --> 33:28.080
fakat şimdi biz,

33:28.280 --> 33:31.120
öyle bir fonksiyon yazabilmeliyiz ki,

33:32.580 --> 33:35.420
diğer nesnenin kaynağını çalmakla birlikte,

33:35.820 --> 33:37.840
yani pointer'ı kopyalamakla birlikte,

33:38.900 --> 33:40.080
diğer nesneyi de,

33:40.360 --> 33:40.780
Resul,

33:41.020 --> 33:41.500
Muhammed,

33:42.000 --> 33:44.280
nasıl bir state'e sokması gerekiyor?

33:44.280 --> 33:46.860
öyle bir state'e sokacak ki,

33:47.580 --> 33:48.040
artık,

33:48.340 --> 33:50.520
onun için destructor çağrıldığında,

33:51.580 --> 33:52.320
destructor,

33:53.040 --> 33:55.060
kaynağı geri vermeyecek.

33:55.920 --> 33:59.520
Adeta kaynağının çalındığının farkında olacak,

34:00.140 --> 34:02.320
ve kaynağı geri vermeyecek.

34:03.720 --> 34:04.120
İşte,

34:04.760 --> 34:06.380
bunu sağlayan fonksiyon,

34:06.840 --> 34:07.660
move constructor.

34:08.660 --> 34:10.140
Aynı şekilde,

34:10.900 --> 34:12.240
bu sefer de şunu düşünün,

34:12.240 --> 34:13.720
aynı şekilde,

34:14.220 --> 34:16.800
önce biraz şöyle teori kısmına değinelim.

34:17.760 --> 34:18.520
Aynı şekilde,

34:19.400 --> 34:19.820
eğer,

34:20.240 --> 34:21.960
iki tane ayrı nesne varsa,

34:23.200 --> 34:23.720
ve biz,

34:24.480 --> 34:27.240
kendisine atama yapacağımız nesnenin,

34:28.280 --> 34:30.680
alacağı yeni değeri temsil eden,

34:31.080 --> 34:32.240
diğer nesnenin,

34:33.620 --> 34:34.340
artık yine,

34:34.700 --> 34:37.540
kullanılır olmadığını biliyor isek,

34:37.540 --> 34:39.060
yine,

34:39.060 --> 34:42.000
bu nesnenin kaynağını çalabiliriz.

34:42.940 --> 34:43.340
İşte,

34:43.600 --> 34:45.340
bunu sağlayan fonksiyon da,

34:45.660 --> 34:46.360
move assignment.

34:47.200 --> 34:47.880
Yani,

34:48.080 --> 34:50.060
move constructor ve move assignment,

34:51.060 --> 34:52.460
öyle fonksiyonlar ki,

34:53.840 --> 34:56.260
copy constructor ve copy assignment'a göre,

34:57.080 --> 34:58.660
onlarla karşılaştırırsak,

34:59.460 --> 35:00.440
yaptıkları iş,

35:01.100 --> 35:02.060
kopyalama yapmamak,

35:03.000 --> 35:04.280
deep copy yapmamak,

35:04.280 --> 35:07.380
diğer nesnenin kaynağını çalmak,

35:08.340 --> 35:09.280
ve diğer nesneyi,

35:10.120 --> 35:12.600
sadece kaynağını çalmakla yetinmeyip,

35:13.280 --> 35:14.280
diğer nesneyi,

35:15.520 --> 35:17.400
destructor çağrıldığında,

35:17.540 --> 35:18.540
diğer nesne için,

35:19.340 --> 35:21.740
kaynağı geri vermemesini sağlamak.

35:21.880 --> 35:22.260
İyi ama,

35:22.320 --> 35:23.360
bunu nasıl yapacağız?

35:24.200 --> 35:24.720
Arkadaşlar,

35:24.820 --> 35:25.840
son derece basit.

35:27.760 --> 35:29.380
Başka bir kodun,

35:30.020 --> 35:31.280
kullanma ihtimali olmayan,

35:31.280 --> 35:33.800
hayatı bitecek,

35:33.980 --> 35:35.340
az önce söylediğim gibi,

35:35.500 --> 35:37.560
gidici nesneler,

35:38.560 --> 35:40.580
dilin kurallarına göre bu ifadeler,

35:40.680 --> 35:41.800
bravo Yusuf Terha,

35:42.500 --> 35:43.500
sağ taraf değeri.

35:44.780 --> 35:45.400
O zaman,

35:46.140 --> 35:48.460
iki tane constructor overloadu olsa,

35:49.740 --> 35:50.080
biri,

35:50.880 --> 35:53.240
sol taraf değeri argümanları alsa,

35:54.040 --> 35:54.440
diğeri,

35:54.840 --> 35:57.100
sağ taraf değeri argümanları alsa,

35:57.400 --> 35:58.140
buraya dikkat,

35:58.140 --> 35:59.220
arkadaşlar,

36:00.300 --> 36:01.560
sağ taraf değeri,

36:02.060 --> 36:03.140
argümanı alan,

36:03.500 --> 36:04.120
overload,

36:05.040 --> 36:06.140
neyi biliyor olacak?

36:07.180 --> 36:08.960
Referansın bağlandığı,

36:09.360 --> 36:10.200
nesnenin,

36:10.800 --> 36:12.240
hayatının biteceğini,

36:12.360 --> 36:13.240
başka bir kodun,

36:13.340 --> 36:15.180
ona ihtiyaç duymadığını bilecek,

36:15.300 --> 36:16.700
ve onun kaynağını çalacak.

36:17.780 --> 36:18.680
Bir şeye dikkat edin,

36:18.740 --> 36:20.060
hep karıştırılan bir nokta,

36:20.700 --> 36:22.120
sağ taraf referansı,

36:22.180 --> 36:22.960
bir referans,

36:23.920 --> 36:25.840
yani sağ taraf referansı,

36:25.840 --> 36:27.580
const olmak zorunda değil,

36:28.140 --> 36:30.240
sağ taraf referansı,

36:30.640 --> 36:32.240
bağlandığı nesneyi,

36:32.440 --> 36:33.420
değiştirebilir mi?

36:33.660 --> 36:34.840
Evet ya da hayır deyin,

36:35.680 --> 36:36.960
çare hemen cevap verdi,

36:37.200 --> 36:38.100
değiştirebilir mi?

36:38.140 --> 36:38.700
Mütahitir.

36:39.420 --> 36:40.220
Anlaşıldı değil mi?

36:40.580 --> 36:41.400
Bakın nasıl,

36:42.500 --> 36:43.720
lvalue referans,

36:44.760 --> 36:45.800
lvalue ref,

36:46.320 --> 36:48.260
const lvalue ref olabiliyorsa,

36:49.420 --> 36:50.940
sağ taraf referansı da,

36:51.440 --> 36:52.360
rvalue ref,

36:52.700 --> 36:54.120
const rvalue ref olabilir.

36:54.120 --> 36:55.440
Ama const olanı,

36:56.000 --> 36:58.320
kullanacak bir semantik söz konusu değil.

36:59.320 --> 36:59.720
O zaman,

36:59.820 --> 37:01.640
bir fonksiyonun parametresi,

37:01.900 --> 37:03.520
sağ taraf referansıysa,

37:04.660 --> 37:05.120
o referansın,

37:05.820 --> 37:07.480
bağlandığı nesneyi,

37:07.580 --> 37:08.620
o referans yoluyla,

37:08.720 --> 37:09.120
değiştirebiliriz.

37:10.540 --> 37:12.120
Bu da hangi problemi çözüyor?

37:12.420 --> 37:13.000
Çağrı,

37:13.120 --> 37:13.460
Yusuf,

37:13.460 --> 37:13.880
derha,

37:14.160 --> 37:14.620
rasul,

37:15.300 --> 37:16.600
hangi problemi çözüyor?

37:17.420 --> 37:18.980
Diğer nesneyi,

37:18.980 --> 37:20.220
destructible,

37:20.780 --> 37:21.660
bir state'e,

37:22.060 --> 37:22.640
sokacak.

37:23.140 --> 37:25.000
Ama o destructible state,

37:25.240 --> 37:25.860
kaynağı,

37:26.120 --> 37:27.100
geri vermeyecek.

37:27.580 --> 37:29.260
Şimdi o zaman,

37:29.820 --> 37:30.080
hadi,

37:30.880 --> 37:31.400
sınıfa,

37:31.760 --> 37:32.200
birer,

37:32.360 --> 37:32.900
arkadaşlar,

37:34.100 --> 37:34.380
move,

37:34.460 --> 37:37.040
constraktor ve move assignment ekleyelim.

37:38.000 --> 37:39.480
Eğer bu fonksiyonları,

37:40.000 --> 37:42.360
derleyicinin yazımına bırakırsanız,

37:42.360 --> 37:44.140
arkadaşlar,

37:47.480 --> 37:49.760
derleyicinin yazdığı move constraktor,

37:51.120 --> 37:52.620
constraktor olduğu için,

37:53.620 --> 37:54.120
ismi,

37:54.420 --> 37:55.780
sınıfın ismiyle aynı.

37:57.500 --> 37:58.100
Fakat,

37:58.560 --> 37:59.660
parametresi,

37:59.660 --> 38:00.360
arkadaşlar,

38:00.960 --> 38:02.640
my class ref ref.

38:03.460 --> 38:04.720
Yani sınıf türünden,

38:05.220 --> 38:06.460
sağ taraf referansı.

38:07.320 --> 38:08.040
Bakın bakın,

38:08.460 --> 38:09.600
aradaki farka bakın.

38:10.280 --> 38:10.620
Bu,

38:10.620 --> 38:12.400
copy constraktor.

38:16.840 --> 38:18.120
Bu ise,

38:18.720 --> 38:19.560
move constraktor.

38:20.380 --> 38:21.180
Şimdi burayı,

38:21.680 --> 38:22.580
biraz yavaş geçeceğim.

38:22.700 --> 38:22.980
Çünkü,

38:23.820 --> 38:25.820
anladık gibi hissediyor,

38:26.020 --> 38:27.220
programcıların çoğu.

38:27.400 --> 38:28.740
Ama anlamamış olabiliyor.

38:28.740 --> 38:29.880
O yüzden,

38:30.520 --> 38:32.600
burada beni iyi dinlemenizi isteyeceğim.

38:33.220 --> 38:33.800
Arkadaşlar,

38:33.960 --> 38:34.500
aslında,

38:35.400 --> 38:37.200
az önce verdiğim örneklerden,

38:37.340 --> 38:38.300
hiçbir farkı yok.

38:39.180 --> 38:39.400
Şimdi,

38:39.520 --> 38:39.840
bunun,

38:40.340 --> 38:42.140
constraktor olmasının dışında,

38:42.660 --> 38:44.540
bir üye fonksiyonu olduğu açık.

38:44.800 --> 38:45.280
Dolayısıyla,

38:45.380 --> 38:46.500
bir fonksiyon değil mi?

38:47.680 --> 38:48.340
Dolayısıyla,

38:48.520 --> 38:49.720
bu bir overload mu?

38:49.960 --> 38:51.800
Copy constraktor ile move constraktor,

38:52.080 --> 38:53.200
birer overload mu?

38:53.200 --> 38:54.300
kesinlikle.

38:55.240 --> 38:55.820
O zaman,

38:56.420 --> 38:58.980
my class sınıfı türünden bir nesneyi,

39:00.060 --> 39:06.540
L value olan bir my class nesnesinden değerini alarak hayata getirmeye çalıştığımda,

39:06.760 --> 39:07.920
bu çağrılacak değil mi?

39:07.920 --> 39:09.400
ama,

39:09.400 --> 39:14.480
R value olan bir sınıf nesnesini kaynak olarak kullandığımda,

39:14.560 --> 39:15.320
bu çağrılacak.

39:16.020 --> 39:17.180
Burayı herkes anladı mı?

39:18.000 --> 39:18.820
Demek ki aslında,

39:19.060 --> 39:20.840
copy constraktor ile move constraktor,

39:21.060 --> 39:23.260
az önceki overload'un ta kendisi.

39:24.160 --> 39:24.740
Biri,

39:25.380 --> 39:27.500
constel value referans parametreli,

39:27.800 --> 39:28.200
diğeri,

39:28.760 --> 39:30.440
R value referans parametreli.

39:31.380 --> 39:32.100
Dolayısıyla,

39:32.760 --> 39:35.200
demin neden uzun uzun açıklama yaptığımı,

39:35.380 --> 39:36.800
şimdi daha iyi anlayacaksınız.

39:36.800 --> 39:38.700
İkisi de var ise,

39:39.640 --> 39:40.120
çağrı,

39:40.280 --> 39:40.680
Yusuf,

39:40.900 --> 39:41.460
Cengiz Han,

39:42.080 --> 39:43.180
ikisi de var ise,

39:43.880 --> 39:45.120
L value'lar için,

39:45.800 --> 39:47.340
copy constraktor çağrılacak,

39:48.120 --> 39:49.760
R value argümanları için,

39:50.080 --> 39:51.540
move constraktor çağrılacak.

39:52.180 --> 39:55.220
Ama move constraktor bir nedenden yok ise,

39:56.040 --> 39:56.460
o zaman,

39:56.840 --> 39:57.980
hem L value,

39:58.520 --> 39:59.880
hem R value için,

40:00.440 --> 40:01.280
kim çağrılacak?

40:01.760 --> 40:03.240
Copy constraktor çağrılacak.

40:03.240 --> 40:04.480
İşte buna,

40:04.880 --> 40:05.360
bravo,

40:05.600 --> 40:07.460
fallback'i burada kullanıyoruz aslında.

40:07.660 --> 40:08.140
Copy'e,

40:08.700 --> 40:10.640
copy constraktora fallback olacak.

40:11.500 --> 40:11.800
Yani,

40:12.360 --> 40:15.300
bir sınıfın move constraktorının olmaması,

40:16.340 --> 40:17.420
olağan bir durum,

40:17.560 --> 40:18.220
olabilir de,

40:18.280 --> 40:19.260
olmayabilir de.

40:19.620 --> 40:19.860
Yani,

40:19.940 --> 40:20.780
bazı sınıfların,

40:20.860 --> 40:21.120
örneğin,

40:21.160 --> 40:22.340
move constraktoru yok.

40:22.480 --> 40:24.460
Ama move constraktorının olmaması,

40:25.460 --> 40:26.620
o sınıflar türünden,

40:26.760 --> 40:27.580
nesnelerin,

40:28.460 --> 40:29.240
R value expression,

40:29.240 --> 40:34.700
argümanlarla hayata getirilebileceği gerçeğini değiştirmiyor,

40:34.820 --> 40:35.120
değil mi?

40:36.160 --> 40:36.420
Evet.

40:37.060 --> 40:37.740
Böylece,

40:38.220 --> 40:39.640
ne sağlamış olacağız?

40:40.480 --> 40:40.740
Bakın,

40:40.800 --> 40:41.140
bakın,

40:41.920 --> 40:44.420
hayatı devam etmekte olan,

40:44.880 --> 40:45.820
nesnelerin,

40:46.240 --> 40:48.280
kaynak olarak kullanılması durumunda,

40:49.140 --> 40:50.720
onun kaynağını çalmak,

40:51.680 --> 40:55.340
o nesneyi kullanan kodların başını belaya sokar.

40:55.340 --> 40:57.500
Böyle bir şeye asla girmemeliyiz.

40:57.500 --> 40:59.360
Anlaşıldı değil mi?

40:59.420 --> 41:02.200
O zaman onun kaynağını çalmamalıyız.

41:02.960 --> 41:03.740
İşte o zaman,

41:04.020 --> 41:05.360
bu fonksiyon çağrılacak.

41:06.220 --> 41:06.560
Ama,

41:08.000 --> 41:09.780
constraktora gelen argümanın,

41:10.020 --> 41:11.520
R value expression olması,

41:12.500 --> 41:13.680
onun kaynağının,

41:14.100 --> 41:15.060
güvenli bir şekilde,

41:15.800 --> 41:17.000
çalınabileceğine,

41:17.360 --> 41:18.100
işaret ediyor.

41:19.060 --> 41:19.860
Onu da,

41:20.120 --> 41:21.700
bu overload alacak,

41:22.240 --> 41:22.940
ve arkadaşlar,

41:23.760 --> 41:25.480
kaynağını çalacak.

41:25.480 --> 41:27.260
diğer nesneyi de,

41:27.840 --> 41:29.900
destructible bir stekle bırakacak.

41:30.500 --> 41:31.100
Böylece,

41:31.460 --> 41:32.960
destructor çağrıldığında,

41:33.280 --> 41:35.400
artık kaynağı geri vermeyecek.

41:36.500 --> 41:37.540
Aynı durum,

41:38.360 --> 41:39.940
atamalar için de geçerli.

41:40.240 --> 41:41.640
Şimdi de atamalara bakalım.

41:42.860 --> 41:43.300
Bu,

41:44.560 --> 41:46.280
pazartesi günü gördüğümüz,

41:47.220 --> 41:47.860
meşhur,

41:48.180 --> 41:48.980
copy assignment.

41:49.920 --> 41:51.060
Uzun uzun konuştuk.

41:51.060 --> 41:51.780
const,

41:52.540 --> 41:53.620
my class,

41:54.140 --> 41:54.480
ref.

41:56.940 --> 41:58.260
Eğer şimdi buraya,

41:58.360 --> 42:00.440
bir de şöyle bir fonksiyon koyarsam,

42:03.340 --> 42:03.940
tıkkı,

42:04.280 --> 42:04.840
constructor,

42:05.040 --> 42:05.840
move constructor,

42:06.040 --> 42:07.360
çiftinde olduğu gibi,

42:08.580 --> 42:09.460
bu da bir overload.

42:10.100 --> 42:12.240
Hatta öyle bir overload ki,

42:13.240 --> 42:14.400
L value'ları için,

42:14.940 --> 42:16.400
14. satırdaki,

42:17.120 --> 42:17.520
atama,

42:17.840 --> 42:19.520
operatör fonksiyonu çağrılacak.

42:19.520 --> 42:21.900
Ama R value argümanı için,

42:22.660 --> 42:24.740
yani eşitlerin sağındaki,

42:25.040 --> 42:27.400
atama operatörünün sağ operanda olan ifade,

42:28.080 --> 42:29.480
R value expression ise,

42:30.080 --> 42:31.420
o zaman da bu çağrılacak.

42:32.420 --> 42:33.400
Yine aynı şekilde,

42:34.300 --> 42:35.360
buradaki atamada,

42:35.660 --> 42:37.180
bir kopyalama yapılacak.

42:37.760 --> 42:39.100
Ama buradaki atamada,

42:39.700 --> 42:40.540
kaynak çalınacak.

42:40.660 --> 42:43.840
İşte o kaynağını çalmaya aslında taşıma diyoruz.

42:44.700 --> 42:45.420
Arkadaşlar,

42:46.200 --> 42:47.300
takip edebiliyor muyuz?

42:47.300 --> 42:50.320
Kaynağını çalmaya taşıma diyoruz.

42:50.940 --> 42:51.180
Evet.

42:52.260 --> 42:53.560
Necati şimdi mesela,

42:53.920 --> 42:55.180
string sınıfı böyle mi?

42:55.420 --> 42:56.560
Hiç şüpheniz olmasın.

42:57.220 --> 42:58.440
Standart kütüphanede,

42:58.760 --> 43:01.080
başta container sınıfları olmak üzere,

43:01.840 --> 43:02.900
bazı sınıflar,

43:03.040 --> 43:03.600
arkadaşlar,

43:04.280 --> 43:06.800
taşıma semantiğinden yoğun olarak faydalanıyor.

43:07.480 --> 43:09.180
Mesela vector sınıfını düşünün.

43:09.180 --> 43:11.340
Hem böyle bir konstruktörü var,

43:11.900 --> 43:13.500
hem de böyle bir konstruktörü var.

43:14.040 --> 43:16.400
Hem böyle bir atama operatör fonksiyonu var,

43:16.960 --> 43:19.480
hem de böyle bir atama operatör fonksiyonu var.

43:20.400 --> 43:22.100
Şimdi modern C++'ın,

43:22.680 --> 43:26.240
gerçekten de getirdiği en önemli avantajlardan biri,

43:26.820 --> 43:28.000
bu taşıma semantiği.

43:28.240 --> 43:28.480
Neden?

43:28.480 --> 43:33.240
Çünkü taşıma semantiği implemente edilmeseydi,

43:34.020 --> 43:36.600
gerçekten eskisi C++'da böyleydi.

43:37.680 --> 43:42.900
Aslında hiçbir kopyalama yapılmayacak durumlarda,

43:43.860 --> 43:46.740
gereksiz yere kopyalama yapılıyordu.

43:47.600 --> 43:48.200
Arkadaşlar,

43:48.280 --> 43:49.640
kopyalama deyip geçmeyin,

43:49.740 --> 43:51.620
sınıfın ne olduğuna bağlı olarak,

43:52.480 --> 43:53.920
kopyalama maliyeti,

43:54.480 --> 43:55.960
olağanüstü yüksek olabilir.

43:55.960 --> 43:59.080
Yani kopyalama yerine taşıma,

43:59.860 --> 44:03.080
daha fazla efficiency sağlar mı?

44:03.740 --> 44:04.440
It depends,

44:04.740 --> 44:06.300
sınıfın ne olduğuna bağlı.

44:06.960 --> 44:09.120
Burada da o kadar çok yanlış anlama var ki,

44:09.760 --> 44:10.100
arkadaşlar,

44:10.320 --> 44:12.780
mesela bazı arkadaşlarım da şöyle zannediyor,

44:13.560 --> 44:15.060
taşıma geldi,

44:15.500 --> 44:17.320
yani örneğin copy konstruktörü var,

44:17.420 --> 44:18.500
move konstruktörü var,

44:19.140 --> 44:22.560
o zaman move konstruktör her zaman bir avantaj sağlar.

44:22.680 --> 44:23.280
Hayır, hayır.

44:23.280 --> 44:28.360
Move konstruktörün her zaman bir avantaj sağlayacağını söyleyemeyiz.

44:29.000 --> 44:32.440
Çünkü move konstruktörün bir avantaj sağlaması için,

44:33.140 --> 44:34.760
ortada bir kaynağın olması,

44:35.700 --> 44:39.260
o kaynağı kopyalama alternatifine karşı,

44:40.260 --> 44:43.120
kopyalamayı tamamen ortadan kaldırıp,

44:43.660 --> 44:45.720
o kaynağı çalma, edinme,

44:45.880 --> 44:49.400
o kaynağın yeni sahibi olma seçeneğini,

44:49.620 --> 44:51.880
ya da alternatifini kullanmış oluyoruz.

44:51.880 --> 44:52.720
Peki,

44:53.380 --> 45:00.000
şimdi derleyicinin yazdığı move konstruktörün nasıl bir koda sahip olduğunu,

45:00.800 --> 45:06.180
yine daha önceki örneklerdeki sözde sınıfımız için bulacağım,

45:06.300 --> 45:07.880
buralarda bir yerde gösterelim.

45:08.740 --> 45:09.180
Evet, evet.

45:09.820 --> 45:10.540
Dedik ki,

45:11.060 --> 45:14.580
böyle bir my class sınıfımız olsun.

45:14.580 --> 45:18.360
Arkadaşlar,

45:18.640 --> 45:20.080
bu hatta en son,

45:20.860 --> 45:23.160
kopyalayan atama operatör fonksiyonunun,

45:23.900 --> 45:26.060
kodunun ne şekilde olduğunu,

45:26.700 --> 45:27.200
arkadaşlar,

45:27.860 --> 45:28.760
göstermişiz.

45:29.920 --> 45:30.200
Tabi,

45:30.280 --> 45:31.740
sentaks için,

45:31.920 --> 45:35.020
A, B, C sınıflarını oluşturmak yerine,

45:35.160 --> 45:35.400
şöyle,

45:35.660 --> 45:37.300
tek sosyası üstünde gösterelim.

45:37.300 --> 45:39.120
Şimdi sınıfın,

45:39.340 --> 45:39.840
arkadaşlar,

45:41.780 --> 45:43.080
move konstruktörü,

45:43.660 --> 45:44.300
buraya dikkat,

45:44.380 --> 45:45.840
bakın bu copy konstruktör,

45:45.920 --> 45:47.120
ne yaptığını görüyorsunuz.

45:48.000 --> 45:50.440
Derleyicinin yazdığı move konstruktör,

45:51.900 --> 45:53.320
az önce söylediğim gibi,

45:53.640 --> 45:54.740
konstruktör bir kere,

45:55.420 --> 45:57.060
ismi sınıf ismiyle aynı,

45:58.140 --> 45:58.720
fakat,

45:58.960 --> 45:59.720
arkadaşlar,

46:00.820 --> 46:03.460
parametresi sağ taraf referansı.

46:03.460 --> 46:06.340
Şimdi çok dikkatli izleyin.

46:07.280 --> 46:09.600
Derleyicinin yazdığı move konstruktör,

46:10.560 --> 46:12.680
elemanlara taşıma yapıyor,

46:13.040 --> 46:14.100
kopyalama yapmıyor.

46:15.160 --> 46:16.820
Yani elemanları da,

46:17.360 --> 46:19.460
copy konstruktörlama hayata getirecek,

46:19.580 --> 46:20.680
move konstruktörlama.

46:21.380 --> 46:21.840
Cevap,

46:22.380 --> 46:23.340
move konstruktörlama.

46:23.420 --> 46:23.680
Yani,

46:23.880 --> 46:26.000
A, B, C sınıflarının,

46:26.500 --> 46:26.900
Yusuf,

46:26.900 --> 46:28.800
hem copy konstruktörü,

46:28.860 --> 46:30.360
hem move konstruktörü varsa,

46:31.300 --> 46:32.760
derleyicinin yazdığı,

46:32.760 --> 46:34.180
move konstruktör,

46:34.720 --> 46:37.900
A, X, B, X, C, X'i,

46:38.020 --> 46:38.800
bu sınıfların,

46:39.220 --> 46:42.280
copy konstruktörüne yapılan çağrıyla mı oluşturacak,

46:42.860 --> 46:45.980
yoksa move konstruktörüne yapılan çağrıyla mı oluşturacak?

46:46.660 --> 46:47.400
Cevap,

46:47.960 --> 46:50.820
move konstruktörlerine yapılacak çağrıyla oluşturacak.

46:51.580 --> 46:51.960
Peki,

46:52.620 --> 46:53.040
soru,

46:53.720 --> 46:54.280
o zaman,

46:54.700 --> 46:55.620
şöyle yazsam,

46:56.160 --> 46:57.440
işimi halleder miyim?

46:57.440 --> 47:03.680
nasıl olsa sağ taraf değeri olan sınıf nesneleri için bu çağrılıyor.

47:04.680 --> 47:06.180
Evet ya da hayır deyin.

47:08.720 --> 47:09.360
Cevap,

47:09.560 --> 47:09.940
hayır.

47:10.440 --> 47:10.700
Bravo.

47:11.380 --> 47:11.660
Neden?

47:12.820 --> 47:13.440
Bakın bakın,

47:14.200 --> 47:16.480
her ne kadar bu move konstruktörü olsa da,

47:16.580 --> 47:16.740
R,

47:16.980 --> 47:19.860
bir R value referansı olsa da,

47:20.600 --> 47:21.380
hatırlayınız,

47:21.380 --> 47:24.060
isim formundaki ifadeler,

47:24.740 --> 47:26.240
L value kategorisinde.

47:27.100 --> 47:27.440
Yani,

47:27.680 --> 47:28.200
R'nin,

47:28.980 --> 47:30.640
R value referansı olması,

47:31.500 --> 47:32.620
R nokta A,

47:32.740 --> 47:34.000
X ifadesinin,

47:34.600 --> 47:37.820
R value expression olması sonucunu doğuruyor mu?

47:38.080 --> 47:38.540
Yoksa,

47:39.120 --> 47:40.100
R nokta A,

47:40.280 --> 47:40.380
X,

47:40.860 --> 47:41.740
R nokta B,

47:41.960 --> 47:42.020
X,

47:42.460 --> 47:43.320
R nokta C,

47:43.540 --> 47:43.600
X,

47:43.760 --> 47:45.580
bunlar halen L value mu?

47:46.800 --> 47:47.600
Bakınız,

47:47.800 --> 47:48.160
bravo,

47:48.260 --> 47:49.620
bunlar halen L value.

47:49.620 --> 47:50.820
Bakınız,

47:51.220 --> 47:58.060
en sık yapılan taşıma semantiğini yanlış algılama biçimi hatası,

47:58.920 --> 47:59.560
L value,

47:59.720 --> 48:01.960
R value referansı data type ile,

48:03.180 --> 48:05.300
yani bir değişkenin data type ile,

48:06.300 --> 48:08.760
o değişkenin oluşturduğu ifadenin,

48:08.980 --> 48:11.620
value kategorisini birbiriyle karıştırmak.

48:11.620 --> 48:13.120
O zaman,

48:13.660 --> 48:14.140
burada,

48:14.540 --> 48:14.760
A,

48:14.760 --> 48:15.460
X için,

48:15.880 --> 48:16.100
B,

48:16.160 --> 48:16.840
X için,

48:17.120 --> 48:17.300
C,

48:17.540 --> 48:18.020
X için,

48:18.980 --> 48:19.780
bu sınıfların,

48:20.200 --> 48:23.500
mu konstruktörünün çağrılmasını sağlamak istesek,

48:24.380 --> 48:24.880
o zaman,

48:25.220 --> 48:26.300
bu ifadelerin,

48:26.400 --> 48:27.280
L value değil,

48:27.600 --> 48:29.600
R value olmasını sağlamalıyız.

48:30.400 --> 48:30.580
İşte,

48:30.680 --> 48:31.320
normalde,

48:31.500 --> 48:32.460
L value iken,

48:33.020 --> 48:33.480
bravo,

48:34.000 --> 48:34.300
onu,

48:34.560 --> 48:35.520
compile time'da,

48:35.640 --> 48:37.500
bir R value expression olarak,

48:37.840 --> 48:39.560
kullanılmasını sağlayan,

48:39.560 --> 48:41.540
mu fonksiyonu.

48:42.440 --> 48:43.840
Mu fonksiyonu.

48:43.900 --> 48:44.940
Keşke bunun ismi,

48:45.120 --> 48:46.120
bence mu bir yerine,

48:46.240 --> 48:47.420
mu cast olsaydı.

48:47.920 --> 48:48.160
Ya da,

48:48.280 --> 48:49.700
R value cast olsaydı.

48:51.140 --> 48:51.540
O zaman,

48:51.680 --> 48:52.720
derleyicinin yazdığı,

48:52.820 --> 48:53.840
mu konstruktör,

48:54.160 --> 48:54.440
böyle.

48:56.360 --> 48:57.120
Arkadaşlar,

48:59.640 --> 48:59.980
yani,

49:00.340 --> 49:01.540
derleyicinin yazdığı,

49:01.660 --> 49:02.680
mu konstruktör,

49:05.580 --> 49:06.620
elemanlarında,

49:07.420 --> 49:08.760
mu konstruktörle hayata,

49:08.760 --> 49:10.060
getirilmesini sağlıyor.

49:10.380 --> 49:11.100
Son derece,

49:11.680 --> 49:12.020
açık.

49:12.600 --> 49:13.540
Fatih Akgül diyor ki,

49:13.620 --> 49:13.800
mesela,

49:13.940 --> 49:15.040
R cast olabilirdi.

49:15.140 --> 49:15.900
Olabilirdi valla.

49:16.080 --> 49:16.820
R value cast,

49:16.900 --> 49:17.480
tabi uzun,

49:18.140 --> 49:19.300
isim yazmaktansa,

49:19.920 --> 49:21.520
Fatih'in önerisi de gayet güzel.

49:22.160 --> 49:23.180
Bu fonksiyonun ismi,

49:23.440 --> 49:25.140
R cast olabilirdi.

49:26.480 --> 49:26.840
İşte,

49:26.960 --> 49:27.980
derleyicinin yazdığı,

49:28.060 --> 49:29.080
mu konstruktör,

49:29.400 --> 49:29.680
böyle.

49:30.580 --> 49:31.060
Arkadaşlar,

49:31.140 --> 49:31.700
bakın şimdi,

49:32.340 --> 49:32.820
özellikle,

49:33.600 --> 49:33.860
bana,

49:34.640 --> 49:35.740
telegramdan soru zormuş,

49:35.740 --> 49:36.820
arkadaşım vardı,

49:37.140 --> 49:37.580
Rasul.

49:37.920 --> 49:38.660
Rasul,

49:38.660 --> 49:39.360
siz de özellikle,

49:39.520 --> 49:40.860
daha dikkatli izleyin şimdi.

49:41.620 --> 49:41.940
Mesela,

49:42.000 --> 49:43.320
şöyle bir snap olsaydı,

49:44.360 --> 49:44.880
class,

49:46.420 --> 49:46.780
match,

49:48.400 --> 49:49.080
match'in,

49:49.080 --> 49:50.580
elemanları,

49:53.080 --> 49:54.080
örneğin,

49:54.580 --> 49:56.000
string türünden olsaydı,

49:56.080 --> 49:56.280
yani,

49:56.360 --> 49:57.280
kaynak kullanan,

49:58.120 --> 49:58.580
bir nesne,

49:59.120 --> 50:00.880
match'in elemanlarından biri,

50:01.200 --> 50:01.420
yine,

50:01.780 --> 50:03.580
bir container nesnesi,

50:03.580 --> 50:05.540
dinamik dizi nesnesi,

50:05.960 --> 50:06.260
örneğin,

50:06.360 --> 50:07.780
stu vektör olsaydı.

50:09.960 --> 50:10.260
Şimdi,

50:10.400 --> 50:11.120
bu sınıfın,

50:11.960 --> 50:13.180
mu konstruktörünü,

50:13.880 --> 50:15.260
ben yazmasam,

50:16.120 --> 50:17.320
derleyicinin yazdığı,

50:17.400 --> 50:18.440
mu konstruktör,

50:19.460 --> 50:20.820
bir match nesnesini,

50:21.080 --> 50:21.960
ayağına getiren,

50:22.080 --> 50:22.260
bir,

50:22.480 --> 50:24.500
r value match nesnesi olduğunda,

50:25.600 --> 50:26.620
derleyicinin yazdığı,

50:26.700 --> 50:28.400
mu konstruktör çağrılacaktı.

50:28.960 --> 50:30.260
Derleyicinin yazdığı,

50:30.360 --> 50:31.360
mu konstruktör,

50:31.360 --> 50:32.800
match'in,

50:33.100 --> 50:34.560
str elemanını,

50:35.160 --> 50:36.120
string sınıfının,

50:36.460 --> 50:37.440
mu konstruktörıyla,

50:37.560 --> 50:38.660
hayata getirecekti.

50:39.700 --> 50:40.060
Yani,

50:40.180 --> 50:40.960
hayata gelen,

50:41.080 --> 50:42.140
match nesnesi,

50:42.840 --> 50:44.220
kaynak olarak kullanılan,

50:44.340 --> 50:45.240
match nesnesinin,

50:45.420 --> 50:46.060
stringinin,

50:46.760 --> 50:48.100
kaynağını çalacaktı.

50:48.360 --> 50:48.940
Vektörün,

50:49.040 --> 50:50.060
kaynağını çalacaktı.

50:50.140 --> 50:50.760
Benim bu durumda,

50:50.820 --> 50:52.180
bir şey yapmam gerekiyor mu?

50:53.180 --> 50:53.480
Hayır.

50:54.640 --> 50:55.020
Ama,

50:55.240 --> 50:55.580
ama,

50:55.860 --> 50:56.200
ama,

50:56.900 --> 50:57.320
yine,

50:58.100 --> 50:58.420
bizim,

50:58.420 --> 50:59.040
birazdan,

50:59.140 --> 50:59.820
string sınıfına,

50:59.920 --> 51:00.580
geri döneceğim,

51:00.580 --> 51:03.420
bizim string sınıfımızda olduğu gibi,

51:04.420 --> 51:04.800
eğer,

51:04.980 --> 51:06.700
handle elemanlar varsa,

51:07.760 --> 51:08.800
taşıma semantinin,

51:09.020 --> 51:10.300
implementasyonunu,

51:11.000 --> 51:12.600
kendim yapmalıyım.

51:13.240 --> 51:13.540
Neden?

51:14.360 --> 51:14.520
E,

51:14.580 --> 51:14.900
çünkü,

51:15.320 --> 51:16.800
kopyalama yapmak yerine,

51:17.080 --> 51:17.460
sadece,

51:17.900 --> 51:18.520
pointer'ı,

51:18.680 --> 51:19.440
kopyalayacağım,

51:20.220 --> 51:21.580
ve diğer nesneyi,

51:22.120 --> 51:22.600
arkadaşlar,

51:22.780 --> 51:24.740
destruktör'a çağrıldığı zaman,

51:25.540 --> 51:26.460
herhangi bir şekilde,

51:26.460 --> 51:28.320
bir sorun oluşturmayacak,

51:28.540 --> 51:29.120
state'e,

51:29.440 --> 51:29.960
getireceğim.

51:29.960 --> 51:31.600
hadi onu yapalım.

51:32.420 --> 51:32.880
Gelin,

51:33.020 --> 51:34.640
bizim string sınıfımız için,

51:35.180 --> 51:35.500
bir,

51:35.880 --> 51:37.200
move constructor yazalım.

51:47.120 --> 51:47.760
Arkadaşlar,

51:47.820 --> 51:48.380
bu arada bakın,

51:48.480 --> 51:49.220
tekrar söylüyorum.

51:49.900 --> 51:51.680
Move copy constructor'ın,

51:52.520 --> 51:54.480
derleyici tarafından yazılması,

51:54.480 --> 51:56.480
eğer sınıfımın,

51:56.480 --> 51:58.020
eğer sınıfımın elemanları,

51:58.260 --> 51:59.500
ya da elemanlarından biri,

51:59.760 --> 52:00.480
handle ise,

52:01.840 --> 52:02.960
felakete neden oluyor.

52:03.920 --> 52:04.240
Ama,

52:04.740 --> 52:07.380
sınıfın move constructor'ının olmaması,

52:08.940 --> 52:09.200
yani,

52:09.320 --> 52:10.560
olması daha iyiyken,

52:10.700 --> 52:11.300
olmaması,

52:11.380 --> 52:12.900
bir felaket senaryosu değil.

52:13.260 --> 52:13.780
Sadece,

52:14.480 --> 52:16.520
efficiency açısından zararı var.

52:17.360 --> 52:18.240
Anlaşıldı değil mi?

52:18.980 --> 52:19.420
Mesela,

52:19.840 --> 52:22.060
ben string sınıfını böyle bıraksaydım.

52:23.160 --> 52:24.400
Burası çok önemli.

52:25.200 --> 52:27.700
Ben string sınıfını böyle bıraksaydım.

52:28.700 --> 52:29.160
Yani,

52:29.520 --> 52:30.620
copy constructor'ı var,

52:30.740 --> 52:32.020
copy assignment'ı var.

52:32.020 --> 52:33.060
Fakat,

52:33.160 --> 52:35.440
move constructor'ı ve move assignment'ı yok.

52:36.520 --> 52:36.800
Bu,

52:37.320 --> 52:39.460
undefined behavior oluşturur muydu?

52:39.880 --> 52:41.220
Böyle bir sınıfın kullanımı,

52:41.340 --> 52:42.380
normal kullanımı,

52:42.500 --> 52:42.680
yani,

52:42.800 --> 52:44.240
kullanan kodla.

52:44.320 --> 52:44.560
Hayır.

52:45.480 --> 52:45.700
Ama,

52:45.960 --> 52:47.120
neye neden olabilirdi?

52:47.380 --> 52:47.860
Kaveh,

52:47.980 --> 52:48.500
Oğuzhan,

52:49.500 --> 52:50.500
taşımanın,

52:51.320 --> 52:52.660
dini anlamda söylemiyorum,

52:52.900 --> 52:55.520
nimetlerinden faydalanmak yerine,

52:56.900 --> 52:57.580
gidip yine,

52:57.820 --> 52:59.500
çok daha yüksek maliyetli,

52:59.500 --> 53:02.840
kopyalama yapacağım senaryolar olurdu.

53:04.060 --> 53:04.560
Dolayısıyla,

53:04.680 --> 53:07.780
move constructor ve move assignment'ın varlığı,

53:08.380 --> 53:08.820
arkadaşlar,

53:09.060 --> 53:11.620
bir hata durumuna engellemekten ziyade,

53:12.620 --> 53:13.260
nedir?

53:14.560 --> 53:16.200
Daha verimli hale getirmek,

53:16.800 --> 53:18.800
gereksiz kopyalamalardan kaçınmak.

53:18.880 --> 53:19.120
Bakın,

53:19.160 --> 53:19.860
bu kadar basit.

53:19.940 --> 53:22.740
Move constructor ve move assignment,

53:22.740 --> 53:24.620
varlık nedenleri,

53:25.400 --> 53:28.240
gereksiz kopyalamalardan kaçınmak,

53:28.240 --> 53:30.840
gereksiz kopyalama yerine,

53:31.560 --> 53:33.560
kopyalamayı ortadan kaldırıp,

53:34.360 --> 53:35.060
kaynağın,

53:35.480 --> 53:36.200
bir nesneden,

53:36.300 --> 53:37.560
adeta bir nesneye,

53:38.120 --> 53:39.760
geçmesini sağlamak.

53:40.440 --> 53:40.720
Peki,

53:41.640 --> 53:44.220
böyle bir string sınıfı nesnesi için,

53:45.020 --> 53:46.920
move constructor nasıl yazılmalı?

53:47.700 --> 53:47.980
Hadi,

53:48.520 --> 53:49.520
yazmaya çalışalım.

53:49.520 --> 53:50.640
Bir kere,

53:51.640 --> 53:52.020
yine,

53:52.560 --> 53:53.840
derleyicinin yazdığı,

53:55.040 --> 53:55.500
efendim,

53:56.040 --> 53:57.340
parametrik yapıda yazacağım.

53:57.640 --> 53:57.920
Yani,

53:59.420 --> 54:00.840
fonksiyonun parametriyesi,

54:01.440 --> 54:03.180
rvalue referans.

54:06.300 --> 54:07.220
Arkadaşlar,

54:07.900 --> 54:08.480
izleyin.

54:08.480 --> 54:10.380
normalde ben,

54:11.340 --> 54:12.220
mp'nin,

54:13.460 --> 54:15.220
copy constructor'da,

54:15.860 --> 54:16.500
değerini,

54:16.800 --> 54:18.360
yeni allocate ettiğim,

54:18.600 --> 54:20.220
bellek bloğunun adresi yapmıştım.

54:20.300 --> 54:20.700
Ama bakın,

54:20.780 --> 54:21.540
şimdi ne yapıyorum?

54:21.800 --> 54:22.300
mp,

54:23.760 --> 54:24.940
other'ın mp'si.

54:26.460 --> 54:27.420
Takip edebiliyor muyuz?

54:27.520 --> 54:27.880
Resmen,

54:27.880 --> 54:29.040
pointer'ı kopyaladım.

54:30.040 --> 54:30.720
Böylece,

54:31.460 --> 54:31.880
bu kopyalamayla,

54:32.660 --> 54:33.420
benim nesnem,

54:34.180 --> 54:34.560
aslında,

54:34.800 --> 54:35.160
zaten,

54:35.160 --> 54:36.340
diğer nesnenin,

54:36.420 --> 54:37.400
allocate ettiği,

54:37.720 --> 54:38.720
bellek bloğunun,

54:39.400 --> 54:41.060
adresini tutmuş oldu.

54:41.320 --> 54:41.540
Yani,

54:41.620 --> 54:42.420
bu veri elemanı,

54:42.460 --> 54:43.840
mp isimli veri elemanı.

54:44.500 --> 54:45.580
Takip edebiliyor muyuz?

54:46.060 --> 54:47.100
Yine aynı şekilde,

54:47.920 --> 54:48.380
arkadaşlar,

54:49.280 --> 54:49.880
len'i de,

54:50.240 --> 54:51.060
kopyalayabilirim.

54:51.140 --> 54:52.420
Onda da bir sakınca yok.

54:53.080 --> 54:53.440
O zaman,

54:53.720 --> 54:54.200
onu da,

54:54.820 --> 54:55.840
uygun sırayla yazayım.

54:55.840 --> 54:56.520
mlen,

54:57.340 --> 54:58.020
other'ın,

54:58.580 --> 54:59.840
mlen'i.

55:00.960 --> 55:02.060
Takip edebiliyor muyuz?

55:02.440 --> 55:02.780
Ama,

55:02.780 --> 55:05.540
bir problem daha var.

55:06.860 --> 55:07.400
Bakın şimdi,

55:08.080 --> 55:09.800
string sınıfının destraktörüne,

55:09.900 --> 55:11.400
tekrar bakacak olursak,

55:12.200 --> 55:14.060
string sınıfının destraktörü,

55:14.940 --> 55:15.740
mp'nin,

55:16.040 --> 55:17.280
değeri olan adres,

55:17.560 --> 55:19.020
null pointer değilse,

55:19.700 --> 55:20.320
kriye ediyor.

55:21.220 --> 55:21.660
Şimdi,

55:22.240 --> 55:22.460
yine,

55:23.260 --> 55:24.320
belki anlamakta,

55:24.320 --> 55:26.980
biraz zorluk çekilen noktalardan biri burası.

55:27.820 --> 55:29.920
Biz nesnenin kaynağını çaldık,

55:30.820 --> 55:31.540
çalmasına,

55:31.540 --> 55:33.400
çünkü pointer'ı kopyaladık.

55:34.320 --> 55:34.640
Ama,

55:35.320 --> 55:36.400
diğer nesnenin,

55:36.460 --> 55:37.260
mp'sinin,

55:37.620 --> 55:38.320
değeri de aynı.

55:38.460 --> 55:39.280
Sanki şöyle bir,

55:39.980 --> 55:41.400
durum varmış gibi düşünüyor.

55:41.500 --> 55:43.140
Bu adamın çok yapıldığını düşünüyorum.

55:43.680 --> 55:45.220
Biz onun kaynağını çaldık ya,

55:45.420 --> 55:47.060
sanki o destroy olmayacak.

55:48.740 --> 55:49.800
Other isimli,

55:49.880 --> 55:50.500
referansın,

55:50.580 --> 55:51.960
bağlandığı nesne içinde,

55:52.100 --> 55:53.640
destraktör çağrılacak mı?

55:53.820 --> 55:54.000
Aa,

55:54.080 --> 55:54.300
evet,

55:54.380 --> 55:54.820
veya hayır.

55:54.820 --> 55:58.600
cevap,

55:58.600 --> 55:59.300
cevap,

55:59.420 --> 55:59.740
evet.

56:00.600 --> 56:00.840
Peki,

56:00.920 --> 56:03.020
onun için destraktör çağrılırsa,

56:04.060 --> 56:04.980
halen onun,

56:05.260 --> 56:07.000
mp isimli pointer'ı,

56:07.040 --> 56:08.320
null pointer değil ki.

56:09.740 --> 56:09.940
Onun,

56:10.000 --> 56:10.880
mp isimli,

56:11.600 --> 56:13.100
veri elemanı olan pointer,

56:13.600 --> 56:14.100
halen,

56:14.680 --> 56:16.220
aynı değerde.

56:16.220 --> 56:18.160
O zaman,

56:18.700 --> 56:19.020
onu,

56:19.980 --> 56:22.140
onun için destraktör çağrıldığında,

56:22.920 --> 56:24.820
bizim çaldığımız kaynağı,

56:24.900 --> 56:27.120
onun geri vermemesini sağlamalıyız,

56:27.200 --> 56:27.520
değil mi?

56:28.240 --> 56:28.460
Peki,

56:28.520 --> 56:29.580
bunu nasıl yapacağız?

56:29.820 --> 56:29.960
Ya,

56:30.020 --> 56:31.020
son derece basit.

56:34.940 --> 56:36.040
mp pointer'ına,

56:36.100 --> 56:36.940
bravo Fatih,

56:37.420 --> 56:38.600
mp pointer'ına,

56:39.180 --> 56:40.640
null pointer değeri atacağız.

56:41.840 --> 56:42.100
Tabii,

56:42.580 --> 56:43.500
burayı daha sonra,

56:43.620 --> 56:45.700
biraz daha detaylı konuşmalıyız.

56:46.220 --> 56:46.840
Arkadaşlar,

56:46.960 --> 56:47.440
örneğin,

56:48.020 --> 56:49.840
mlen değişkenine de,

56:50.480 --> 56:51.740
sıfır değerini,

56:52.280 --> 56:53.120
atayabilirim.

56:53.280 --> 56:54.940
other'ın mp'si yazmamışım.

56:55.240 --> 56:56.360
other'ın mp'si,

56:56.440 --> 56:56.940
null pointer,

56:57.540 --> 56:58.420
other'ın,

56:58.420 --> 56:59.660
yazdım zannettim,

56:59.740 --> 57:00.840
other'ın mleni,

57:01.400 --> 57:02.220
eşittir sıfır.

57:02.740 --> 57:03.540
Buraya da,

57:04.120 --> 57:05.140
daha sonra geri döneceğim.

57:05.240 --> 57:07.080
Bunun gereksiz olduğunu düşünebilirsiniz.

57:07.240 --> 57:09.020
Ama neden gerekli olduğu konusunda,

57:09.700 --> 57:11.240
daha sonra konuşacağız.

57:12.060 --> 57:12.340
Evet,

57:12.900 --> 57:13.660
işte bu kadar.

57:14.840 --> 57:15.120
Yani,

57:15.120 --> 57:16.500
move constructor dediğim,

57:16.560 --> 57:17.720
bu kadar basit.

57:18.220 --> 57:18.940
Böylece,

57:19.460 --> 57:19.700
bakın,

57:19.780 --> 57:20.060
bakın,

57:20.700 --> 57:21.480
eğer ben,

57:22.440 --> 57:24.100
şöyle bir kod yazarsam,

57:24.980 --> 57:25.540
elimde,

57:25.920 --> 57:27.360
bir string nesnesi var,

57:27.920 --> 57:28.340
arkadaşlar,

57:28.680 --> 57:31.040
ya da yeni bir string nesnesi oluşturmak istiyorum.

57:32.180 --> 57:32.520
Ama,

57:33.780 --> 57:35.220
argüman olarak verdiğim,

57:35.220 --> 57:36.420
string nesnesi,

57:37.100 --> 57:38.260
rvalue expression.

57:39.160 --> 57:39.800
Arkadaşlar,

57:39.800 --> 57:41.180
yani örneğin,

57:41.180 --> 57:41.800
string,

57:41.800 --> 57:42.320
yani örneğin,

57:42.320 --> 57:42.400
string,

57:42.400 --> 57:44.320
bugün,

57:48.720 --> 57:49.400
yine,

57:49.400 --> 57:50.820
çok,

57:51.180 --> 57:51.960
sıcak,

57:52.600 --> 57:53.180
bir,

57:53.180 --> 57:54.020
hava,

57:54.460 --> 57:54.900
vardı.

57:55.120 --> 57:55.720
Cümlenin,

57:55.720 --> 57:57.780
mantığıyla ilgilenmeyiniz.

57:58.460 --> 57:59.020
Arkadaşlar,

57:59.080 --> 57:59.340
bakın,

57:59.820 --> 58:00.040
bu,

58:00.300 --> 58:01.640
rvalue expression mi?

58:01.840 --> 58:02.200
Evet.

58:02.400 --> 58:02.620
Çünkü,

58:02.720 --> 58:03.640
temporal object.

58:04.000 --> 58:05.480
Daha sonra detaylı göreceğiz.

58:05.480 --> 58:08.500
O zaman bu bir rvalue expression.

58:08.720 --> 58:10.760
O zaman hangi fonksiyon çağrılacak?

58:11.600 --> 58:12.760
Bu fonksiyon çağrılacak.

58:12.880 --> 58:13.060
Yani,

58:13.120 --> 58:14.500
move constructor çağrılacak.

58:15.320 --> 58:18.640
Move constructor da bu nesnenin kaynağını kopyalamak yerine,

58:18.840 --> 58:20.860
onun kaynağını çalacak.

58:21.840 --> 58:23.500
Buraya kadar takip edebildik mi?

58:24.640 --> 58:25.260
Arkadaşlar,

58:25.540 --> 58:26.360
burada yalnız,

58:26.720 --> 58:28.040
enteresan bir durum var.

58:28.840 --> 58:29.080
İşte,

58:29.220 --> 58:31.480
en fazla kafa karıştıran durumlardan biri.

58:32.700 --> 58:33.120
Eğer,

58:33.680 --> 58:34.660
böyle bir durumda,

58:34.660 --> 58:35.620
yani,

58:36.120 --> 58:37.660
string sınıfında olduğu gibi,

58:38.540 --> 58:39.240
sdl'in,

58:39.560 --> 58:41.420
container sınıfları diyeceğimiz,

58:41.500 --> 58:43.680
daha sonra öğreneceğimiz sınıflarda olduğu gibi,

58:44.660 --> 58:46.440
sınıfın hem copy constructorı,

58:46.480 --> 58:48.020
hem move constructorı varsa,

58:48.820 --> 58:49.000
bakın,

58:49.120 --> 58:51.040
aslında bizim bir şey yapmamız gerekmiyor.

58:52.060 --> 58:52.320
Yani,

58:52.440 --> 58:53.900
siz şöyle bir düşünecek misiniz?

58:54.060 --> 58:55.520
Copy constructorımı çağrılsın,

58:55.580 --> 58:56.600
move constructorımı?

58:57.260 --> 58:57.440
Hayır,

58:57.500 --> 58:57.580
hayır,

58:57.580 --> 58:59.000
o sizi ilgilendirmiyor ki.

59:00.000 --> 59:00.600
Sizin,

59:00.600 --> 59:02.900
argüman olarak verdiğiniz ifade,

59:03.020 --> 59:04.340
rvalue expression ise,

59:04.660 --> 59:05.620
derleyici,

59:05.720 --> 59:07.540
function overload resolution ile,

59:08.200 --> 59:09.640
move constructorı seçecek,

59:10.280 --> 59:11.740
lvalue expression ise,

59:12.360 --> 59:14.120
o zaman copy constructorı seçecek.

59:14.820 --> 59:15.140
Yani,

59:15.280 --> 59:17.000
sizin taşıma semantinden,

59:17.220 --> 59:18.920
kodu yazan programcı olarak,

59:20.000 --> 59:21.760
bir sınıfı kullanırken,

59:22.000 --> 59:22.220
mesela,

59:22.220 --> 59:23.820
sdl'in stl'in stl string,

59:23.940 --> 59:24.560
stl vektör,

59:24.660 --> 59:26.700
stl list gibi sınıflarını kullanırken,

59:27.560 --> 59:29.820
şöyle bir endişe duymanıza gerek yok.

59:30.400 --> 59:30.800
Efendim,

59:30.920 --> 59:32.760
ben move constructorı çağırayım da,

59:32.900 --> 59:34.060
daha etkili olsun.

59:34.440 --> 59:35.060
Tipik olarak,

59:35.180 --> 59:35.720
altın çizim,

59:35.760 --> 59:36.860
böyle bir endişeye gerek yok.

59:36.940 --> 59:37.120
Çünkü,

59:37.260 --> 59:38.140
verdiğiniz argüman,

59:38.140 --> 59:45.660
L-Value ise Copy Constructor çağrılacak, R-Value ise Move Constructor çağrılacak.

59:46.620 --> 59:53.220
Böylece arkadaşlar hayatı devam etmekte olan nesnelerin kaynağını çalmayacağız.

59:53.520 --> 59:57.640
Şöyle nesneler hemen Persistent nesneler diyorum.

59:57.640 --> 01:00:03.660
Ama hayata bitecek başka kodun onu kullanmayacağı nesneler.

01:00:03.660 --> 01:00:15.140
Onun için de böyle popüler kullanılan İngilizce nitelice ephemeral yani bir mevsim hayatı bitecek anlamında onun için de Move Constructor çağrılacak.

01:00:15.760 --> 01:00:21.300
Burayı anladık mı? Ama bir özel durumdan bahsedeceğim birazdan biraz sabırlı olursanız tabii.

01:00:22.440 --> 01:00:30.980
Şimdi mülakatlarda C++ programcılarıyla yapılan mülakatlarda herhalde orada da ben bir rekor kırmış olabilirim.

01:00:30.980 --> 01:00:33.260
Çünkü çok fazla mülakat yapıyorum işim gereği.

01:00:33.660 --> 01:00:42.580
Programcıların neyi yanlış anladığını siz onlarla konuştukça, mülakat yaptıkça daha iyi anlıyorsunuz.

01:00:42.920 --> 01:00:44.940
Ya da onların yazdığı kodlara baktıkça.

01:00:45.940 --> 01:00:55.280
Benim de en fazla yanlış anlaşıldığını gördüğüm yerler olduğu için taşıma semantiğiyle ilgili onunla ilgili sorular soruyorum.

01:00:55.280 --> 01:00:57.440
Mesela sorduğum sorulardan biri şu.

01:00:58.480 --> 01:00:59.640
İzleyin arkadaşlar.

01:01:00.940 --> 01:01:06.400
Diyorum ki burada bir MyClass nesnesi var.

01:01:06.940 --> 01:01:07.760
MyClass M.

01:01:07.760 --> 01:01:16.680
Şunları da ya da string de olabilir ama şimdilik sildeyim.

01:01:17.080 --> 01:01:18.020
Buraya geri döneceğim.

01:01:22.020 --> 01:01:25.660
Herhangi bir sınıf olsun taşıma semantiğinden faydalanabilecek.

01:01:25.760 --> 01:01:26.680
Class MyClass.

01:01:26.680 --> 01:01:28.740
Arkadaşlar.

01:01:31.500 --> 01:01:34.380
Burada da şöyle bir fonksiyon olsun.

01:01:34.380 --> 01:01:35.540
VoidFunk.

01:01:36.540 --> 01:01:37.680
MyClass.

01:01:38.540 --> 01:01:39.060
Refref.

01:01:39.060 --> 01:01:42.140
Takip edebiliyor muyuz?

01:01:44.820 --> 01:01:46.760
Diyorum ki soru.

01:01:48.220 --> 01:01:50.440
Hatta bakın fonksiyonun şu anda kodu.

01:01:50.880 --> 01:01:51.420
Kod olsun.

01:01:53.600 --> 01:01:54.320
Soru.

01:01:55.420 --> 01:01:57.260
Konk fonksiyonuna çağrı yapıyorum.

01:01:58.760 --> 01:02:02.600
My'yi örneğin sağ taraf değeri haline getirmek için.

01:02:02.600 --> 01:02:08.940
ona sağ taraf değeri haline getirecek ifadeyi.

01:02:09.720 --> 01:02:11.680
StudMove fonksiyonunu kullanıyorum.

01:02:12.760 --> 01:02:13.840
Ve şu soruyu soruyorum.

01:02:13.960 --> 01:02:14.820
Size de soruyorum.

01:02:16.200 --> 01:02:18.300
19. satırdan sonra

01:02:18.300 --> 01:02:22.120
My nesnesinin kaynağı çalınmış mıdır?

01:02:26.220 --> 01:02:26.940
Bravo.

01:02:27.100 --> 01:02:29.640
Bakın bu sefer neredeyse herkes doğru cevap verdi.

01:02:29.820 --> 01:02:30.700
Tabii ki hayır.

01:02:30.700 --> 01:02:33.700
Yani bir nesneyi

01:02:33.700 --> 01:02:36.200
bir sağ taraf referansına bağlamak

01:02:36.200 --> 01:02:38.660
onun kaynağını çalmak demek değil.

01:02:39.640 --> 01:02:40.800
Hiçbir alakası yok.

01:02:41.760 --> 01:02:42.360
Ne alaka?

01:02:43.220 --> 01:02:44.860
Referans bildiğiniz pointer.

01:02:45.120 --> 01:02:47.880
Yani siz şimdi bunun assembly koduna baksanız

01:02:47.880 --> 01:02:51.000
aslında assembly kodda neyi göreceksiniz?

01:02:51.700 --> 01:02:53.540
Funk'ın parametresi bir pointer

01:02:53.540 --> 01:02:57.040
ve MyClass nesnesinin adresine oluyor.

01:02:57.040 --> 01:03:01.300
Peki kaynağın çalınmasını sağlayan ne olacak?

01:03:01.720 --> 01:03:03.120
Burayı çok dikkatli izleyelim.

01:03:03.900 --> 01:03:04.600
Arkadaşlar.

01:03:05.800 --> 01:03:08.040
Siz bu sağ taraf referansı.

01:03:08.040 --> 01:03:09.060
Bravo Alp Yıldırım.

01:03:09.180 --> 01:03:09.460
Bravo.

01:03:09.720 --> 01:03:11.540
Funk içindeki implementasyon.

01:03:11.640 --> 01:03:12.340
Süper cevap.

01:03:13.460 --> 01:03:17.200
Yani funk içinde öyle bir implementasyon olmalı ki

01:03:17.200 --> 01:03:22.180
bu sağ taraf referansının bağlandığı nesnenin

01:03:22.180 --> 01:03:23.660
kaynağını çalmalı.

01:03:24.660 --> 01:03:26.180
Onun da iki tane yolu var.

01:03:27.100 --> 01:03:28.880
Ya bir MyClass nesnesini

01:03:28.880 --> 01:03:30.560
hayata getireceğim

01:03:30.560 --> 01:03:34.680
ya da bir MyClass nesnesine

01:03:34.680 --> 01:03:35.880
atama yapacağım.

01:03:36.880 --> 01:03:37.960
Burayı anladık mı?

01:03:38.180 --> 01:03:39.960
Ya bir MyClass nesnesini

01:03:39.960 --> 01:03:41.100
hayata getireceğim

01:03:41.100 --> 01:03:43.880
ya da bir MyClass nesnesine

01:03:43.880 --> 01:03:44.840
atama yapacağım.

01:03:44.840 --> 01:03:48.520
Peki MyClass mx eşittir r.

01:03:48.800 --> 01:03:50.720
Şimdi soruya cevap vermeye çalışacağım.

01:03:51.620 --> 01:03:56.100
Bu kod 17. satırdaki m'nin kaynağını çalmış olur mu?

01:03:58.160 --> 01:03:59.900
A olur, B olmaz.

01:03:59.900 --> 01:04:05.920
Alihan Bozkur olur diyor.

01:04:07.380 --> 01:04:08.700
Alp Yıldırım olur diyor.

01:04:10.540 --> 01:04:12.240
Doğru cevap olmaz.

01:04:13.280 --> 01:04:13.800
Olmaz.

01:04:14.080 --> 01:04:14.900
Neden olmaz?

01:04:15.900 --> 01:04:17.240
Hep aynı yere gelin.

01:04:17.300 --> 01:04:19.900
Neden o kadar sık tekrar ettiğimi görüyorsunuz değil mi?

01:04:20.520 --> 01:04:23.760
Peki bu ifade L value mu R value mu?

01:04:25.640 --> 01:04:26.900
Cevap L value.

01:04:26.900 --> 01:04:29.780
Bu ifade L value olduğuna göre

01:04:29.780 --> 01:04:32.780
o zaman buradaki mx için

01:04:32.780 --> 01:04:34.520
copy constructor mu çağrılacak?

01:04:34.640 --> 01:04:36.160
Move constructor mu çağrılacak?

01:04:37.280 --> 01:04:39.520
Cevap copy constructor çağrılacak.

01:04:39.660 --> 01:04:42.140
O zaman kaynağı çalmayacak ki kopyalayacak.

01:04:42.980 --> 01:04:45.080
Peki kaynağı çalması için

01:04:45.080 --> 01:04:47.620
buradaki mx'i

01:04:47.620 --> 01:04:49.540
hayata getirirken

01:04:49.540 --> 01:04:51.160
kullandığımız nesnenin

01:04:51.160 --> 01:04:53.600
r value expression olması gerekir değil mi?

01:04:54.540 --> 01:04:55.220
Kesinlikle.

01:04:55.220 --> 01:04:57.900
peki nasıl onu r value expression yapacağız?

01:04:58.100 --> 01:04:59.120
Yine stud mu ile.

01:05:00.600 --> 01:05:02.140
Şimdi espriyi anladınız mı?

01:05:03.060 --> 01:05:05.280
İşte böyle bir kod varsa

01:05:05.280 --> 01:05:07.280
bu fonksiyon

01:05:07.280 --> 01:05:10.320
kendisine gelen nesnenin

01:05:10.320 --> 01:05:11.560
kaynağını çalar.

01:05:12.100 --> 01:05:13.520
Çünkü mx

01:05:13.520 --> 01:05:15.100
mu construct edilir.

01:05:16.100 --> 01:05:17.260
Gelin durumu biraz

01:05:17.260 --> 01:05:18.000
toparlayalım.

01:05:18.140 --> 01:05:19.900
Şimdi mean'i boş verin

01:05:19.900 --> 01:05:21.020
arkadaşlar

01:05:21.020 --> 01:05:23.060
bu tür durumlarda

01:05:23.060 --> 01:05:25.760
tipik alternatif yapı şu

01:05:25.760 --> 01:05:27.740
birçok örneğini göreceksiniz.

01:05:27.900 --> 01:05:29.220
Çok çok dikkatli izleyin şimdi.

01:05:31.420 --> 01:05:32.020
Tıpkı

01:05:32.020 --> 01:05:34.160
copy constructor mu constructer

01:05:34.160 --> 01:05:34.880
da olduğu gibi

01:05:34.880 --> 01:05:36.820
iki tane ayrı overload olacak.

01:05:43.820 --> 01:05:44.620
Arkadaşlar

01:05:44.620 --> 01:05:48.920
şimdi böyle iki overload olursa

01:05:48.920 --> 01:05:50.680
oraya geleceğim.

01:05:51.800 --> 01:05:53.460
Sağ taraf değerini

01:05:53.460 --> 01:05:55.320
yukarıdaki alacak değil mi?

01:05:55.540 --> 01:05:56.460
Sol taraf değerini

01:05:56.460 --> 01:05:57.460
aşağıdaki alacak.

01:05:58.680 --> 01:05:59.640
O zaman biz

01:05:59.640 --> 01:06:01.440
üsttekinin

01:06:01.440 --> 01:06:03.000
implementasyonunda

01:06:03.000 --> 01:06:04.340
r'nin

01:06:04.340 --> 01:06:05.940
bağlandığı nesnenin

01:06:05.940 --> 01:06:06.480
kaynağını

01:06:06.480 --> 01:06:07.060
çalacağız.

01:06:07.060 --> 01:06:09.800
alttaki

01:06:09.800 --> 01:06:11.160
implementasyonda

01:06:11.160 --> 01:06:11.760
r'nin

01:06:11.760 --> 01:06:12.520
bağlandığı

01:06:12.520 --> 01:06:13.340
nesnenin

01:06:13.340 --> 01:06:14.200
kaynağını

01:06:14.200 --> 01:06:15.380
kopyalayacağız.

01:06:16.220 --> 01:06:16.920
İşte bu kadar.

01:06:18.120 --> 01:06:18.600
En çok

01:06:18.600 --> 01:06:19.280
kullanılan

01:06:19.280 --> 01:06:21.140
yapılardan biri

01:06:21.140 --> 01:06:22.360
işte

01:06:22.360 --> 01:06:23.500
l-value

01:06:23.500 --> 01:06:25.440
ve r-value

01:06:25.440 --> 01:06:25.780
için

01:06:25.780 --> 01:06:26.880
ayrı fonksiyon

01:06:26.880 --> 01:06:27.480
yazmak.

01:06:28.720 --> 01:06:29.320
l-value

01:06:29.320 --> 01:06:30.320
için yazılan

01:06:30.320 --> 01:06:31.320
fonksiyonun

01:06:31.320 --> 01:06:32.100
bir

01:06:32.100 --> 01:06:32.780
kopyalama

01:06:32.780 --> 01:06:33.400
yapmasını

01:06:33.400 --> 01:06:34.200
sağlamak.

01:06:35.040 --> 01:06:35.260
Ama

01:06:35.260 --> 01:06:36.180
r-value

01:06:36.180 --> 01:06:37.500
alan

01:06:37.500 --> 01:06:38.740
fonksiyonun

01:06:38.740 --> 01:06:39.820
kopyalama

01:06:39.820 --> 01:06:40.360
yerine

01:06:40.360 --> 01:06:41.060
taşıma

01:06:41.060 --> 01:06:41.680
yapmasını

01:06:41.680 --> 01:06:42.420
sağlamak.

01:06:43.820 --> 01:06:44.240
O zaman

01:06:44.240 --> 01:06:45.040
tekrar edelim.

01:06:45.660 --> 01:06:46.540
Siz bir

01:06:46.540 --> 01:06:47.540
sağ taraf

01:06:47.540 --> 01:06:47.980
değeri

01:06:47.980 --> 01:06:48.720
nesneyi

01:06:48.720 --> 01:06:49.260
sağ taraf

01:06:49.260 --> 01:06:50.000
referansına

01:06:50.000 --> 01:06:50.900
bağlayarak

01:06:50.900 --> 01:06:52.080
taşıma

01:06:52.080 --> 01:06:52.940
semantiğinden

01:06:52.940 --> 01:06:53.720
faydalanmış

01:06:53.720 --> 01:06:54.420
olmuyorsunuz.

01:06:54.480 --> 01:06:54.860
Kavey

01:06:54.860 --> 01:06:55.280
az önce

01:06:55.280 --> 01:06:56.020
güzel bir cümle

01:06:56.020 --> 01:06:56.440
yazdı.

01:06:57.080 --> 01:06:57.560
Sadece

01:06:57.560 --> 01:06:58.240
taşıma

01:06:58.240 --> 01:06:59.100
semantiğini

01:06:59.100 --> 01:06:59.560
zemin

01:06:59.560 --> 01:07:00.140
hazırlamış

01:07:00.140 --> 01:07:00.920
oluyorsunuz.

01:07:01.880 --> 01:07:02.280
Taşıma

01:07:02.280 --> 01:07:03.200
semantiğini

01:07:03.200 --> 01:07:04.120
gerçekleştiren

01:07:04.120 --> 01:07:04.760
taşımayı

01:07:04.760 --> 01:07:05.800
gerçekleştiren

01:07:05.800 --> 01:07:07.120
burada

01:07:07.120 --> 01:07:08.860
bu referansın

01:07:08.860 --> 01:07:09.520
bağlandığı

01:07:09.520 --> 01:07:10.060
nesneyi

01:07:10.060 --> 01:07:10.780
kullanarak

01:07:10.780 --> 01:07:11.680
yeni bir

01:07:11.680 --> 01:07:12.020
nesne

01:07:12.020 --> 01:07:13.060
oluşturmanız

01:07:13.060 --> 01:07:13.620
ya da

01:07:13.620 --> 01:07:14.360
birazdan

01:07:14.360 --> 01:07:15.200
mu ve

01:07:15.200 --> 01:07:15.700
segment'e

01:07:15.700 --> 01:07:16.320
geldiğimizde

01:07:16.320 --> 01:07:16.880
göreceğiz

01:07:16.880 --> 01:07:18.140
var olan

01:07:18.140 --> 01:07:19.060
bir nesneyi

01:07:19.060 --> 01:07:19.520
atama

01:07:19.520 --> 01:07:20.160
yapmanız.

01:07:20.840 --> 01:07:21.120
Bakın

01:07:21.120 --> 01:07:21.320
şimdi

01:07:21.320 --> 01:07:21.740
bunun

01:07:21.740 --> 01:07:22.380
ben size

01:07:22.380 --> 01:07:23.080
çok tipik

01:07:23.080 --> 01:07:23.620
bir örneğini

01:07:23.620 --> 01:07:24.340
göstereyim

01:07:24.340 --> 01:07:25.300
arkadaşlar.

01:07:26.300 --> 01:07:26.740
İzleyin

01:07:26.740 --> 01:07:27.020
lütfen.

01:07:27.920 --> 01:07:28.140
Bakın

01:07:28.140 --> 01:07:28.680
çok tipik

01:07:28.680 --> 01:07:29.260
bir örnek.

01:07:31.120 --> 01:07:31.720
Vektör

01:07:31.720 --> 01:07:32.500
nasıl bir

01:07:32.500 --> 01:07:32.900
sınıf

01:07:32.900 --> 01:07:33.200
yani

01:07:33.200 --> 01:07:33.380
hiç

01:07:33.380 --> 01:07:33.840
bilmeniz

01:07:33.840 --> 01:07:34.380
gerekmiyor.

01:07:35.000 --> 01:07:35.440
Ben biraz

01:07:35.440 --> 01:07:36.020
bahsedeceğim

01:07:36.020 --> 01:07:36.560
dinamik

01:07:36.560 --> 01:07:36.880
dizi

01:07:36.880 --> 01:07:37.540
sınıfı.

01:07:38.200 --> 01:07:38.560
İleride

01:07:38.560 --> 01:07:39.240
çok detaylı

01:07:39.240 --> 01:07:39.840
göreceğiz.

01:07:40.440 --> 01:07:40.620
Yani

01:07:40.620 --> 01:07:41.380
dinamik

01:07:41.380 --> 01:07:41.860
dizi

01:07:41.860 --> 01:07:42.240
veri

01:07:42.240 --> 01:07:42.820
yapısını

01:07:42.820 --> 01:07:43.520
dynamic

01:07:43.520 --> 01:07:44.120
array

01:07:44.120 --> 01:07:45.260
data

01:07:45.260 --> 01:07:45.980
structure'ı

01:07:45.980 --> 01:07:46.700
implemente

01:07:46.700 --> 01:07:47.040
eden

01:07:47.040 --> 01:07:47.680
ona uygun

01:07:47.680 --> 01:07:47.860
bir

01:07:47.860 --> 01:07:48.440
interfej

01:07:48.440 --> 01:07:49.100
sağlayan

01:07:49.100 --> 01:07:50.440
standart

01:07:50.440 --> 01:07:51.160
kütüphanemizin

01:07:51.160 --> 01:07:51.420
o

01:07:51.420 --> 01:07:52.200
STL

01:07:52.200 --> 01:07:52.860
standart

01:07:52.860 --> 01:07:53.200
template

01:07:53.200 --> 01:07:53.700
library

01:07:53.700 --> 01:07:54.180
dediğimiz

01:07:54.180 --> 01:07:54.900
bileşeninin

01:07:54.900 --> 01:07:56.120
belki de

01:07:56.120 --> 01:07:56.600
en sık

01:07:56.600 --> 01:07:57.200
kullanılan

01:07:57.200 --> 01:07:58.200
birkaç

01:07:58.200 --> 01:07:58.760
sınıfından

01:07:58.760 --> 01:07:59.080
biri.

01:07:59.300 --> 01:07:59.540
Biri

01:07:59.540 --> 01:07:59.900
string

01:07:59.900 --> 01:08:00.180
biri

01:08:00.180 --> 01:08:00.860
vektör.

01:08:00.860 --> 01:08:02.580
Arkadaşlar

01:08:02.580 --> 01:08:04.800
çok dikkatli

01:08:04.800 --> 01:08:05.280
izlemenizi

01:08:05.280 --> 01:08:05.860
istiyorum ama

01:08:05.860 --> 01:08:06.940
bakalım yakalayabilecek

01:08:06.940 --> 01:08:07.260
misiniz

01:08:07.260 --> 01:08:07.740
buradaki

01:08:07.740 --> 01:08:08.100
küçük

01:08:08.100 --> 01:08:08.760
ayrıntıyı.

01:08:10.040 --> 01:08:10.620
Pushback

01:08:10.620 --> 01:08:12.200
fonksiyonu

01:08:12.200 --> 01:08:12.600
ne yapıyor?

01:08:12.780 --> 01:08:13.280
İsminden

01:08:13.280 --> 01:08:13.500
bile

01:08:13.500 --> 01:08:14.400
anlayabilirsiniz.

01:08:14.780 --> 01:08:15.240
Dinamik

01:08:15.240 --> 01:08:15.560
diziye

01:08:15.560 --> 01:08:15.980
sondan

01:08:15.980 --> 01:08:16.320
ekleme

01:08:16.320 --> 01:08:16.700
yapıyor.

01:08:18.540 --> 01:08:18.760
Öyle

01:08:18.760 --> 01:08:19.140
değil mi?

01:08:19.400 --> 01:08:19.880
Dinamik

01:08:19.880 --> 01:08:20.180
diziye

01:08:20.180 --> 01:08:20.600
sondan

01:08:20.600 --> 01:08:20.940
ekleme

01:08:20.940 --> 01:08:21.240
yapıyor.

01:08:21.880 --> 01:08:22.260
Yani

01:08:22.260 --> 01:08:23.440
diyelim ki

01:08:23.440 --> 01:08:24.160
benim

01:08:24.160 --> 01:08:24.500
bir

01:08:24.500 --> 01:08:25.220
vektör

01:08:25.220 --> 01:08:25.980
neslem var.

01:08:26.220 --> 01:08:26.480
İsmi

01:08:26.480 --> 01:08:26.740
vek

01:08:26.740 --> 01:08:27.120
olsun.

01:08:28.300 --> 01:08:28.620
Ben

01:08:28.620 --> 01:08:29.600
vekin

01:08:29.600 --> 01:08:30.440
pushback

01:08:30.440 --> 01:08:31.160
fonksiyonunu

01:08:31.160 --> 01:08:32.160
çağırdığımda

01:08:32.160 --> 01:08:33.500
arkadaşlar

01:08:33.500 --> 01:08:35.080
aslında

01:08:35.080 --> 01:08:36.440
vektördeki

01:08:36.440 --> 01:08:37.100
dinamik

01:08:37.100 --> 01:08:37.580
dizideki

01:08:37.580 --> 01:08:38.240
öe sayısı

01:08:38.240 --> 01:08:38.940
onken

01:08:38.940 --> 01:08:40.440
on birinciyi

01:08:40.440 --> 01:08:40.860
eklemiş

01:08:40.860 --> 01:08:41.340
oluyorum.

01:08:42.440 --> 01:08:43.220
Takip

01:08:43.220 --> 01:08:43.580
edebiliyor

01:08:43.580 --> 01:08:44.120
musunuz?

01:08:44.740 --> 01:08:45.020
Şu

01:08:45.020 --> 01:08:46.360
eklediğim

01:08:46.360 --> 01:08:47.440
on birinci

01:08:47.440 --> 01:08:47.880
öe

01:08:47.880 --> 01:08:49.060
yani vektördeki

01:08:49.060 --> 01:08:49.780
son öe

01:08:49.780 --> 01:08:50.380
olacak ki

01:08:50.380 --> 01:08:50.740
bu da

01:08:50.740 --> 01:08:51.780
biliyorsunuz

01:08:51.780 --> 01:08:52.380
amortize

01:08:52.380 --> 01:08:53.220
constant time

01:08:53.220 --> 01:08:54.720
algoritmadır.

01:08:54.720 --> 01:08:55.920
O zaman

01:08:55.920 --> 01:08:56.660
o değerini

01:08:56.660 --> 01:08:57.500
arktan alıyor

01:08:57.500 --> 01:08:57.980
değil mi?

01:08:57.980 --> 01:08:59.280
peki

01:08:59.280 --> 01:08:59.580
şimdi

01:08:59.580 --> 01:09:00.160
soru

01:09:00.160 --> 01:09:01.660
sizce

01:09:01.660 --> 01:09:02.200
pushback

01:09:02.200 --> 01:09:03.100
fonksiyonunun

01:09:03.100 --> 01:09:04.600
bir tane

01:09:04.600 --> 01:09:04.780
mi

01:09:04.780 --> 01:09:05.340
overloadu

01:09:05.340 --> 01:09:05.480
var

01:09:05.480 --> 01:09:06.000
iki tane

01:09:06.000 --> 01:09:06.160
mi

01:09:06.160 --> 01:09:06.700
overloadu

01:09:06.700 --> 01:09:06.940
var?

01:09:08.080 --> 01:09:08.580
Cevap

01:09:08.580 --> 01:09:10.100
kesinlikle

01:09:10.100 --> 01:09:10.640
iki tane

01:09:10.640 --> 01:09:11.180
overloadu

01:09:11.180 --> 01:09:11.320
var.

01:09:11.440 --> 01:09:11.660
Neden

01:09:11.660 --> 01:09:12.240
iki tane

01:09:12.240 --> 01:09:12.840
overloadu

01:09:12.840 --> 01:09:13.080
var?

01:09:13.740 --> 01:09:14.160
Ya son

01:09:14.160 --> 01:09:14.520
derece

01:09:14.520 --> 01:09:15.040
basit.

01:09:15.880 --> 01:09:16.260
Eğer

01:09:16.260 --> 01:09:17.140
bir tane

01:09:17.140 --> 01:09:17.880
overloadu

01:09:17.880 --> 01:09:18.620
olsaydı

01:09:18.620 --> 01:09:19.660
bu

01:09:19.660 --> 01:09:20.240
hem

01:09:20.240 --> 01:09:20.860
l value

01:09:20.860 --> 01:09:21.160
hem

01:09:21.160 --> 01:09:21.800
r value

01:09:21.800 --> 01:09:22.140
için

01:09:22.140 --> 01:09:22.420
bu

01:09:22.420 --> 01:09:23.420
çağrılsaydı

01:09:23.420 --> 01:09:24.320
o zaman

01:09:24.320 --> 01:09:25.460
kopyalama yapmak

01:09:25.460 --> 01:09:26.160
kaçınılmaz

01:09:26.160 --> 01:09:26.600
olurdu

01:09:26.600 --> 01:09:27.020
değil mi?

01:09:27.920 --> 01:09:28.220
Yani

01:09:28.220 --> 01:09:29.180
vektörde

01:09:29.180 --> 01:09:30.060
son eleman

01:09:30.060 --> 01:09:30.420
olarak

01:09:30.420 --> 01:09:31.060
tutulacak

01:09:31.060 --> 01:09:31.700
nesneyi

01:09:31.700 --> 01:09:32.320
hayata

01:09:32.320 --> 01:09:33.240
copy

01:09:33.240 --> 01:09:34.020
constructorla

01:09:34.020 --> 01:09:34.920
getirecektik.

01:09:35.800 --> 01:09:36.000
Ama

01:09:36.000 --> 01:09:36.300
şimdi

01:09:36.300 --> 01:09:36.780
bizim ne

01:09:36.780 --> 01:09:37.280
yapmamız

01:09:37.280 --> 01:09:37.940
gerekiyor?

01:09:38.500 --> 01:09:38.960
Vektörü

01:09:38.960 --> 01:09:39.540
düşünün

01:09:39.540 --> 01:09:40.160
kafamızı

01:09:40.160 --> 01:09:40.400
hatta

01:09:40.400 --> 01:09:40.760
şöyle bir

01:09:40.760 --> 01:09:41.100
şekilde

01:09:41.100 --> 01:09:41.800
çizeyim

01:09:41.800 --> 01:09:42.400
arkadaşlar

01:09:42.400 --> 01:09:42.900
tüm

01:09:42.900 --> 01:09:43.960
yeteneksizliğime

01:09:43.960 --> 01:09:45.160
karşın

01:09:45.160 --> 01:09:46.040
şu

01:09:46.040 --> 01:09:46.740
bizim

01:09:46.740 --> 01:09:47.920
vektörümüzdeki

01:09:47.920 --> 01:09:49.020
diyelim ki

01:09:49.020 --> 01:09:50.220
sınıf

01:09:50.220 --> 01:09:50.860
nesneleri

01:09:50.860 --> 01:09:51.280
örneğin

01:09:51.280 --> 01:09:51.920
stringler

01:09:51.920 --> 01:09:52.560
vektör

01:09:52.560 --> 01:09:53.240
dinamik dizide

01:09:53.240 --> 01:09:54.100
string tutuluyor.

01:09:54.100 --> 01:09:56.200
şu anda

01:09:56.200 --> 01:09:57.440
üç tane

01:09:57.440 --> 01:09:58.100
öde

01:09:58.100 --> 01:09:58.700
bir de

01:09:58.700 --> 01:09:59.000
benden

01:09:59.000 --> 01:09:59.780
dört tane

01:09:59.780 --> 01:10:01.000
v olsun.

01:10:01.780 --> 01:10:02.180
Pushback

01:10:02.180 --> 01:10:02.780
fonksiyonu

01:10:02.780 --> 01:10:03.480
çağrılacak.

01:10:04.260 --> 01:10:04.660
Pushback

01:10:04.660 --> 01:10:05.980
fonksiyonu

01:10:05.980 --> 01:10:06.840
şu bellek

01:10:06.840 --> 01:10:07.480
alanında

01:10:07.480 --> 01:10:07.900
onun

01:10:07.900 --> 01:10:08.580
rengini

01:10:08.580 --> 01:10:09.660
farklı

01:10:09.660 --> 01:10:10.160
yapayım.

01:10:10.740 --> 01:10:11.340
Şu bellek

01:10:11.340 --> 01:10:11.940
alanında

01:10:11.940 --> 01:10:12.860
bir

01:10:12.860 --> 01:10:13.400
string

01:10:13.400 --> 01:10:13.980
nesnesini

01:10:13.980 --> 01:10:14.380
hayata

01:10:14.380 --> 01:10:15.000
getirecek.

01:10:15.500 --> 01:10:15.740
Şimdi

01:10:15.740 --> 01:10:16.200
iki tane

01:10:16.200 --> 01:10:16.740
seçenek

01:10:16.740 --> 01:10:17.020
var.

01:10:17.700 --> 01:10:17.820
Bu

01:10:17.820 --> 01:10:18.280
bellek

01:10:18.280 --> 01:10:18.880
alanında

01:10:18.880 --> 01:10:19.780
hayata

01:10:19.780 --> 01:10:20.880
getireceği

01:10:20.880 --> 01:10:21.680
vektördeki

01:10:21.680 --> 01:10:22.300
son eleman

01:10:22.300 --> 01:10:22.560
olan

01:10:22.560 --> 01:10:22.920
string

01:10:22.920 --> 01:10:23.480
nesnesi

01:10:23.480 --> 01:10:23.920
için

01:10:23.920 --> 01:10:25.060
string

01:10:25.060 --> 01:10:25.560
sınıfının

01:10:25.560 --> 01:10:25.920
copy

01:10:25.920 --> 01:10:26.740
konstruktörünü

01:10:26.740 --> 01:10:27.580
çağırabilir.

01:10:28.320 --> 01:10:28.720
String

01:10:28.720 --> 01:10:29.260
sınıfının

01:10:29.260 --> 01:10:29.820
move

01:10:29.820 --> 01:10:30.600
konstruktörünü

01:10:30.600 --> 01:10:31.380
çağırabilir.

01:10:32.020 --> 01:10:32.260
Peki

01:10:32.260 --> 01:10:32.540
bunu

01:10:32.540 --> 01:10:33.100
nasıl

01:10:33.100 --> 01:10:34.420
gerçekleştiriyor?

01:10:35.060 --> 01:10:35.660
Son derece

01:10:35.660 --> 01:10:36.200
basit.

01:10:36.940 --> 01:10:37.340
Pushback

01:10:37.340 --> 01:10:38.200
fonksiyonunun

01:10:38.200 --> 01:10:39.200
iki tane

01:10:39.200 --> 01:10:40.300
overloadu

01:10:40.300 --> 01:10:40.480
var.

01:10:40.620 --> 01:10:40.740
Şimdi

01:10:40.740 --> 01:10:41.340
kafamızda

01:10:41.340 --> 01:10:42.080
basitleştirilmiş

01:10:42.080 --> 01:10:42.460
şekilde

01:10:42.460 --> 01:10:42.900
vektör

01:10:42.900 --> 01:10:43.420
sınıfını

01:10:43.420 --> 01:10:44.360
düşünelim.

01:10:44.960 --> 01:10:45.420
Mesela

01:10:45.420 --> 01:10:46.140
vektör

01:10:46.140 --> 01:10:47.320
sınıfı

01:10:47.320 --> 01:10:48.060
sözde

01:10:48.060 --> 01:10:48.740
normalde

01:10:48.740 --> 01:10:48.940
tabii

01:10:48.940 --> 01:10:49.620
jenerik bir

01:10:49.620 --> 01:10:50.040
sınıf

01:10:50.040 --> 01:10:50.820
ama ben

01:10:50.820 --> 01:10:51.780
konu anlaşılsın

01:10:51.780 --> 01:10:52.080
diye

01:10:52.080 --> 01:10:53.420
vektörün

01:10:53.420 --> 01:10:54.460
şöyle bir sınıf

01:10:54.460 --> 01:10:54.940
olduğunu

01:10:54.940 --> 01:10:55.820
varsayayım.

01:10:55.940 --> 01:10:56.380
str

01:10:56.380 --> 01:10:56.940
vektör

01:10:56.940 --> 01:10:57.220
yani

01:10:57.220 --> 01:10:57.660
vektör

01:10:57.660 --> 01:10:58.400
dinamik dizide

01:10:58.400 --> 01:10:58.920
stringler

01:10:58.920 --> 01:10:59.520
tutuluyor.

01:11:02.160 --> 01:11:03.200
Bakın şimdi

01:11:03.200 --> 01:11:04.400
fonksiyonlardan

01:11:04.400 --> 01:11:05.160
biri şöyle

01:11:05.160 --> 01:11:06.920
void

01:11:06.920 --> 01:11:09.000
pushback

01:11:09.000 --> 01:11:12.540
const

01:11:12.540 --> 01:11:14.480
string

01:11:14.480 --> 01:11:15.860
ref

01:11:15.860 --> 01:11:18.220
hadi

01:11:18.220 --> 01:11:19.180
standart

01:11:19.180 --> 01:11:19.780
kütüphanenin

01:11:19.780 --> 01:11:20.360
string

01:11:20.360 --> 01:11:21.640
sınıfı

01:11:21.640 --> 01:11:21.880
olsun

01:11:21.880 --> 01:11:22.460
arkadaşlar.

01:11:25.960 --> 01:11:26.400
const

01:11:26.400 --> 01:11:27.540
string

01:11:27.540 --> 01:11:28.860
ref

01:11:28.860 --> 01:11:29.860
fakat

01:11:29.860 --> 01:11:30.220
diğer

01:11:30.220 --> 01:11:31.160
pushback

01:11:31.160 --> 01:11:31.960
overloadu

01:11:31.960 --> 01:11:32.960
şöyle

01:11:32.960 --> 01:11:37.840
const

01:11:37.840 --> 01:11:38.520
olmayan

01:11:38.520 --> 01:11:38.900
st

01:11:38.900 --> 01:11:39.480
string

01:11:39.480 --> 01:11:40.200
ref

01:11:40.200 --> 01:11:40.500
ref

01:11:40.500 --> 01:11:42.380
şimdi

01:11:42.380 --> 01:11:42.820
ben

01:11:42.820 --> 01:11:44.120
st

01:11:44.120 --> 01:11:44.900
vektör

01:11:44.900 --> 01:11:45.380
sınıfı

01:11:45.380 --> 01:11:45.980
türünden

01:11:45.980 --> 01:11:46.640
bir

01:11:46.640 --> 01:11:47.320
konteyner

01:11:47.320 --> 01:11:47.800
nesnem

01:11:47.800 --> 01:11:48.260
olsa

01:11:48.260 --> 01:11:51.160
arkadaşlar

01:11:51.160 --> 01:11:55.060
ve de

01:11:55.060 --> 01:11:55.640
elimde

01:11:55.640 --> 01:11:56.000
if

01:11:56.000 --> 01:11:56.320
string

01:11:56.320 --> 01:11:56.800
nesnem

01:11:56.800 --> 01:11:57.260
olsa

01:11:57.260 --> 01:11:57.820
st

01:11:57.820 --> 01:11:58.320
string

01:11:58.320 --> 01:12:00.040
s

01:12:00.040 --> 01:12:02.480
necati

01:12:02.480 --> 01:12:03.500
ergin

01:12:03.500 --> 01:12:06.980
svec

01:12:06.980 --> 01:12:08.120
nokta

01:12:08.120 --> 01:12:09.240
pushback

01:12:09.240 --> 01:12:10.520
s

01:12:10.520 --> 01:12:11.500
dediğim zaman

01:12:11.500 --> 01:12:12.940
derleyici

01:12:12.940 --> 01:12:13.200
koda

01:12:13.200 --> 01:12:13.780
bakacak

01:12:13.780 --> 01:12:15.320
s'in

01:12:15.320 --> 01:12:16.060
lvalue

01:12:16.060 --> 01:12:16.600
expression

01:12:16.600 --> 01:12:17.200
olduğunu

01:12:17.200 --> 01:12:18.340
anlayacak

01:12:18.340 --> 01:12:19.220
ve

01:12:19.220 --> 01:12:19.600
function

01:12:19.600 --> 01:12:20.040
overload

01:12:20.040 --> 01:12:20.680
resolution

01:12:20.680 --> 01:12:21.180
da bu

01:12:21.180 --> 01:12:21.660
pushback'i

01:12:21.660 --> 01:12:22.300
çağıracak.

01:12:23.480 --> 01:12:23.640
Bu

01:12:23.640 --> 01:12:24.280
pushback'in

01:12:24.280 --> 01:12:24.560
kodu

01:12:24.560 --> 01:12:24.860
nasıl

01:12:24.860 --> 01:12:25.480
implemente

01:12:25.480 --> 01:12:26.120
edilmiş

01:12:26.120 --> 01:12:26.760
tekrar

01:12:26.760 --> 01:12:27.360
resmimize

01:12:27.360 --> 01:12:28.140
geri dönelim

01:12:28.140 --> 01:12:29.040
bu

01:12:29.040 --> 01:12:29.460
benlek

01:12:29.460 --> 01:12:30.060
alanında

01:12:30.060 --> 01:12:30.640
hayata

01:12:30.640 --> 01:12:31.280
getireceği

01:12:31.280 --> 01:12:31.680
nesne

01:12:31.680 --> 01:12:32.120
için

01:12:32.120 --> 01:12:32.980
string

01:12:32.980 --> 01:12:33.560
sınıfının

01:12:33.560 --> 01:12:34.020
copy

01:12:34.020 --> 01:12:34.820
constructor'ını

01:12:34.820 --> 01:12:35.380
çağıracak.

01:12:36.380 --> 01:12:36.740
Ama

01:12:36.740 --> 01:12:37.120
şimdi

01:12:37.120 --> 01:12:37.780
diğer

01:12:37.780 --> 01:12:38.380
overload'a

01:12:38.380 --> 01:12:38.800
bakalım

01:12:38.800 --> 01:12:40.280
eğer

01:12:40.280 --> 01:12:41.180
argüman

01:12:41.180 --> 01:12:41.480
olan

01:12:41.480 --> 01:12:42.040
ifade

01:12:42.040 --> 01:12:43.120
bir

01:12:43.120 --> 01:12:43.800
sağ

01:12:43.800 --> 01:12:44.260
taraf

01:12:44.260 --> 01:12:44.820
değeri

01:12:44.820 --> 01:12:45.620
olsaydı

01:12:45.620 --> 01:12:47.800
mesela

01:12:47.800 --> 01:12:48.000
bu

01:12:48.000 --> 01:12:48.180
bir

01:12:48.180 --> 01:12:48.380
sağ

01:12:48.380 --> 01:12:48.700
taraf

01:12:48.700 --> 01:12:49.260
değeri

01:12:49.260 --> 01:12:56.300
o

01:12:56.300 --> 01:12:56.520
zaman

01:12:56.520 --> 01:12:57.260
derleyici

01:12:57.260 --> 01:12:58.320
bunun

01:12:58.320 --> 01:12:58.640
bir

01:12:58.640 --> 01:12:59.300
rvalue

01:12:59.300 --> 01:12:59.840
expression

01:12:59.840 --> 01:13:00.300
olduğunu

01:13:00.300 --> 01:13:01.240
anlayacaktı

01:13:01.240 --> 01:13:02.040
ve

01:13:02.040 --> 01:13:02.540
bu

01:13:02.540 --> 01:13:03.220
fonksiyonu

01:13:03.220 --> 01:13:04.100
çağıracaktı.

01:13:04.820 --> 01:13:05.020
Peki

01:13:05.020 --> 01:13:05.240
bu

01:13:05.240 --> 01:13:05.880
fonksiyonun

01:13:05.880 --> 01:13:06.120
kodu

01:13:06.120 --> 01:13:06.380
nasıl

01:13:06.380 --> 01:13:07.160
çalışacak?

01:13:07.420 --> 01:13:07.700
Tekrar

01:13:07.700 --> 01:13:08.060
resme

01:13:08.060 --> 01:13:08.820
geri dönelim.

01:13:09.540 --> 01:13:09.780
Burada

01:13:09.780 --> 01:13:10.260
hayata

01:13:10.260 --> 01:13:10.940
getireceği

01:13:10.940 --> 01:13:11.260
string

01:13:11.260 --> 01:13:12.060
nesnesini

01:13:12.060 --> 01:13:12.920
string

01:13:12.920 --> 01:13:13.400
sınıfının

01:13:13.400 --> 01:13:13.740
copy

01:13:13.740 --> 01:13:14.480
constructor'ı

01:13:14.480 --> 01:13:14.960
ile değil

01:13:14.960 --> 01:13:15.860
move

01:13:15.860 --> 01:13:16.580
constructor'ı

01:13:16.580 --> 01:13:16.720
ile

01:13:16.720 --> 01:13:17.080
hayata

01:13:17.080 --> 01:13:17.760
getirecek.

01:13:18.620 --> 01:13:19.240
Böylece

01:13:19.240 --> 01:13:20.040
diğer

01:13:20.040 --> 01:13:20.760
nesnenin

01:13:20.760 --> 01:13:21.420
kaynağını

01:13:21.420 --> 01:13:22.000
çalacak.

01:13:22.740 --> 01:13:22.960
Buraya

01:13:22.960 --> 01:13:23.280
kadar

01:13:23.280 --> 01:13:24.240
anladıysanız

01:13:24.240 --> 01:13:24.600
çok

01:13:24.600 --> 01:13:24.920
iyi

01:13:24.920 --> 01:13:25.100
bir

01:13:25.100 --> 01:13:25.820
noktadayız

01:13:25.820 --> 01:13:26.380
arkadaşlar.

01:13:26.660 --> 01:13:26.980
Herkes

01:13:26.980 --> 01:13:27.580
anladı mı?

01:13:28.380 --> 01:13:28.520
Bu

01:13:28.520 --> 01:13:28.720
iki

01:13:28.720 --> 01:13:29.460
overload'un

01:13:29.460 --> 01:13:30.240
birbirinden

01:13:30.240 --> 01:13:30.880
farkını

01:13:30.880 --> 01:13:31.860
evet.

01:13:32.920 --> 01:13:33.140
Ama

01:13:33.140 --> 01:13:33.560
şimdi

01:13:33.560 --> 01:13:34.600
tekrar

01:13:34.600 --> 01:13:35.020
başa

01:13:35.020 --> 01:13:35.220
geri

01:13:35.220 --> 01:13:35.700
dönelim.

01:13:36.400 --> 01:13:36.900
Arkadaşlar

01:13:36.900 --> 01:13:37.180
move

01:13:37.180 --> 01:13:38.140
constructor'ın

01:13:38.140 --> 01:13:39.120
bir

01:13:39.120 --> 01:13:39.580
fayda

01:13:39.580 --> 01:13:40.580
sağlaması

01:13:40.580 --> 01:13:41.940
gerekiyor

01:13:41.940 --> 01:13:43.500
implement edilmesi

01:13:43.500 --> 01:13:43.940
için.

01:13:44.840 --> 01:13:45.140
Yoksa

01:13:45.140 --> 01:13:45.380
move

01:13:45.380 --> 01:13:46.120
constructor'ın

01:13:46.120 --> 01:13:46.760
sağladığı

01:13:46.760 --> 01:13:47.340
ilave bir

01:13:47.340 --> 01:13:47.720
fayda

01:13:47.720 --> 01:13:48.180
yoksa

01:13:48.180 --> 01:13:48.920
mesela bir

01:13:48.920 --> 01:13:49.660
örnek vereyim.

01:13:50.260 --> 01:13:50.440
Çok

01:13:50.440 --> 01:13:50.880
dikkatli

01:13:50.880 --> 01:13:51.240
izleyin.

01:13:51.820 --> 01:13:52.080
Şöyle

01:13:52.080 --> 01:13:52.260
bir

01:13:52.260 --> 01:13:52.680
sınıfınız

01:13:52.680 --> 01:13:53.340
olsaydı

01:13:53.340 --> 01:13:54.840
class

01:13:54.840 --> 01:13:56.440
my

01:13:56.440 --> 01:13:56.880
class

01:13:56.880 --> 01:13:59.340
private

01:13:59.340 --> 01:14:02.020
arkadaşlar

01:14:02.020 --> 01:14:03.160
int

01:14:03.160 --> 01:14:04.460
are

01:14:04.460 --> 01:14:07.180
bin

01:14:07.180 --> 01:14:11.220
diğer elemanların

01:14:11.220 --> 01:14:12.040
konuyla alakası

01:14:12.040 --> 01:14:12.560
olmadığını

01:14:12.560 --> 01:14:13.080
düşünün.

01:14:14.020 --> 01:14:14.320
Şimdi

01:14:14.320 --> 01:14:14.860
soru

01:14:14.860 --> 01:14:15.760
my

01:14:15.760 --> 01:14:16.060
class

01:14:16.060 --> 01:14:16.820
sınıfı

01:14:16.820 --> 01:14:18.380
nesneleri

01:14:18.380 --> 01:14:19.620
kendi

01:14:19.620 --> 01:14:20.340
işlerinde

01:14:20.340 --> 01:14:21.280
abarttım

01:14:21.280 --> 01:14:21.740
tabi böyle

01:14:21.740 --> 01:14:22.440
bir senaryo

01:14:22.440 --> 01:14:23.240
abartılmış

01:14:23.240 --> 01:14:23.900
bir senaryo

01:14:23.900 --> 01:14:24.140
ama

01:14:24.140 --> 01:14:25.620
bin elemanlı

01:14:25.620 --> 01:14:26.160
bir int

01:14:26.160 --> 01:14:27.040
dizi

01:14:27.040 --> 01:14:27.860
içeriyorlar.

01:14:29.380 --> 01:14:29.620
Şimdi

01:14:29.620 --> 01:14:30.480
bu sınıf

01:14:30.480 --> 01:14:30.700
için

01:14:30.700 --> 01:14:31.020
move

01:14:31.020 --> 01:14:31.640
constructor

01:14:31.640 --> 01:14:33.820
yazmanın

01:14:33.820 --> 01:14:34.620
bu sınıfın

01:14:34.620 --> 01:14:35.100
ayrı

01:14:35.100 --> 01:14:35.340
copy

01:14:35.340 --> 01:14:36.100
constructor'ının

01:14:36.100 --> 01:14:36.580
dışında

01:14:36.580 --> 01:14:36.940
bir de

01:14:36.940 --> 01:14:37.200
move

01:14:37.200 --> 01:14:38.020
constructor'ının

01:14:38.020 --> 01:14:38.700
olması

01:14:38.700 --> 01:14:40.260
efficiency

01:14:40.260 --> 01:14:41.140
açısından

01:14:41.140 --> 01:14:41.700
bir fayda

01:14:41.700 --> 01:14:42.380
sağlar mı?

01:14:44.380 --> 01:14:45.180
Cevap

01:14:45.180 --> 01:14:45.640
hayır.

01:14:46.560 --> 01:14:46.900
Çünkü

01:14:46.900 --> 01:14:47.680
derleyiciye

01:14:47.680 --> 01:14:48.440
de bıraksanız

01:14:48.440 --> 01:14:49.280
sonuçta

01:14:49.280 --> 01:14:50.060
dizinin

01:14:50.060 --> 01:14:51.600
kopyalanması

01:14:51.600 --> 01:14:52.340
gerekecek.

01:14:53.380 --> 01:14:53.620
Yani

01:14:53.620 --> 01:14:54.160
elimde bir

01:14:54.160 --> 01:14:54.940
pointer yok ki

01:14:54.940 --> 01:14:55.760
o pointer'ın

01:14:55.760 --> 01:14:56.600
gösterdiği

01:14:56.600 --> 01:14:57.660
kaynağı

01:14:57.660 --> 01:14:57.980
kendi

01:14:57.980 --> 01:14:58.560
kaynağımı

01:14:58.560 --> 01:14:58.960
yapayım.

01:14:59.820 --> 01:15:00.100
Burayı

01:15:00.100 --> 01:15:00.820
anladınız mı?

01:15:01.220 --> 01:15:01.440
Mesela

01:15:01.440 --> 01:15:01.900
bu sınıfı

01:15:01.900 --> 01:15:02.100
için

01:15:02.100 --> 01:15:02.340
move

01:15:02.340 --> 01:15:03.040
constructor'ın

01:15:03.040 --> 01:15:04.140
burada da

01:15:04.140 --> 01:15:04.620
çok tipik

01:15:04.620 --> 01:15:05.060
bir yanlış

01:15:05.060 --> 01:15:05.700
anlama var.

01:15:05.800 --> 01:15:06.680
Zaman ediyorlar ki

01:15:06.680 --> 01:15:07.540
başta da bunu

01:15:07.540 --> 01:15:07.920
söyledim.

01:15:07.960 --> 01:15:08.140
Move

01:15:08.140 --> 01:15:08.720
constructor

01:15:08.720 --> 01:15:09.300
er derde

01:15:09.300 --> 01:15:09.740
deva.

01:15:10.060 --> 01:15:10.840
Ne alakası var?

01:15:10.940 --> 01:15:11.060
Şimdi

01:15:11.060 --> 01:15:11.280
move

01:15:11.280 --> 01:15:11.920
constructor'ın

01:15:11.920 --> 01:15:12.620
ses alacağı

01:15:12.620 --> 01:15:13.180
hiçbir fayda

01:15:13.180 --> 01:15:13.420
yok.

01:15:14.680 --> 01:15:15.160
Anlaşıldı

01:15:15.160 --> 01:15:15.560
değil mi?

01:15:16.300 --> 01:15:16.560
Evet.

01:15:17.160 --> 01:15:17.380
Ama

01:15:19.280 --> 01:15:20.000
olsaydı

01:15:20.000 --> 01:15:21.160
dikkatli

01:15:21.160 --> 01:15:21.680
izleyelim

01:15:21.680 --> 01:15:22.840
eğer şöyle

01:15:22.840 --> 01:15:23.700
olsaydı

01:15:23.700 --> 01:15:24.880
örneğin

01:15:24.880 --> 01:15:25.460
burada

01:15:25.460 --> 01:15:26.500
bir pointer

01:15:26.500 --> 01:15:27.560
olsaydı

01:15:27.560 --> 01:15:33.560
bu pointer

01:15:33.560 --> 01:15:35.200
binamik olarak

01:15:35.200 --> 01:15:36.180
allocate edilmiş

01:15:36.180 --> 01:15:36.800
bir bellek

01:15:36.800 --> 01:15:37.400
bloğundaki

01:15:37.400 --> 01:15:37.840
string

01:15:37.840 --> 01:15:38.820
nesnelerinin

01:15:38.820 --> 01:15:39.800
bulunduğu

01:15:39.800 --> 01:15:40.340
bir bellek

01:15:40.340 --> 01:15:40.660
bloğunun

01:15:40.660 --> 01:15:41.140
adresini

01:15:41.140 --> 01:15:41.580
tutuyor

01:15:41.580 --> 01:15:42.280
olsaydı

01:15:42.280 --> 01:15:43.320
move

01:15:43.320 --> 01:15:43.840
constructor

01:15:43.840 --> 01:15:44.200
burada

01:15:44.200 --> 01:15:44.820
hayati

01:15:44.820 --> 01:15:45.660
önem taşırdı.

01:15:45.660 --> 01:15:46.260
Çünkü bakın

01:15:46.260 --> 01:15:47.100
kopyalama

01:15:47.100 --> 01:15:47.900
semantiğiyle

01:15:47.900 --> 01:15:49.160
yetinirseniz

01:15:49.160 --> 01:15:50.800
sizin

01:15:50.800 --> 01:15:52.120
kopyalama

01:15:52.120 --> 01:15:52.560
yoluyla

01:15:52.560 --> 01:15:52.980
hayata

01:15:52.980 --> 01:15:53.760
getireceğiniz

01:15:53.760 --> 01:15:54.280
nesne

01:15:54.280 --> 01:15:54.880
gidecek

01:15:54.880 --> 01:15:55.460
ayrı bir

01:15:55.460 --> 01:15:55.800
bellek

01:15:55.800 --> 01:15:56.080
alanı

01:15:56.080 --> 01:15:56.380
allocate

01:15:56.380 --> 01:15:56.940
edecek

01:15:56.940 --> 01:15:57.600
ve

01:15:57.600 --> 01:15:58.040
üstelik

01:15:58.040 --> 01:15:58.400
orada

01:15:58.400 --> 01:15:58.800
string

01:15:58.800 --> 01:15:59.480
nesnelerini

01:15:59.480 --> 01:16:00.300
oluşturacak.

01:16:01.160 --> 01:16:01.480
Yani

01:16:01.480 --> 01:16:02.440
diğerinin

01:16:02.440 --> 01:16:03.800
allocate

01:16:03.800 --> 01:16:04.260
ettiği

01:16:04.260 --> 01:16:04.700
bellek

01:16:04.700 --> 01:16:05.080
bloğunda

01:16:05.080 --> 01:16:05.740
10 bin

01:16:05.740 --> 01:16:06.040
tane

01:16:06.040 --> 01:16:06.440
string

01:16:06.440 --> 01:16:06.980
nesnesi

01:16:06.980 --> 01:16:07.380
varsa

01:16:07.380 --> 01:16:08.720
sizin

01:16:08.720 --> 01:16:09.300
hayata

01:16:09.300 --> 01:16:10.060
getirdiğiniz

01:16:10.060 --> 01:16:10.880
nesne de

01:16:10.880 --> 01:16:11.800
o 10 bin

01:16:11.800 --> 01:16:12.080
tane

01:16:12.080 --> 01:16:12.460
string

01:16:12.460 --> 01:16:13.060
nesnesini

01:16:13.060 --> 01:16:13.440
hayata

01:16:13.440 --> 01:16:14.080
getirecek.

01:16:14.080 --> 01:16:14.960
Burada

01:16:14.960 --> 01:16:15.980
inanılmaz

01:16:15.980 --> 01:16:16.640
yüksek

01:16:16.640 --> 01:16:16.900
bir

01:16:16.900 --> 01:16:17.520
maliyet

01:16:17.520 --> 01:16:18.060
söz konusu

01:16:18.060 --> 01:16:18.540
olabilir.

01:16:19.340 --> 01:16:19.800
Anlaşıldı

01:16:19.800 --> 01:16:20.220
değil mi?

01:16:20.780 --> 01:16:21.000
Peki

01:16:21.000 --> 01:16:21.500
şimdi

01:16:21.500 --> 01:16:22.100
gelelim

01:16:22.100 --> 01:16:22.720
move

01:16:22.720 --> 01:16:23.520
assignment'a.

01:16:24.420 --> 01:16:25.220
Arkadaşlar

01:16:25.220 --> 01:16:26.540
benzer

01:16:26.540 --> 01:16:27.060
şekilde

01:16:27.060 --> 01:16:28.580
bir sınıf

01:16:28.580 --> 01:16:29.400
nesnesine

01:16:29.400 --> 01:16:32.380
bir

01:16:32.380 --> 01:16:33.360
R-value

01:16:33.360 --> 01:16:34.300
expression

01:16:34.300 --> 01:16:34.980
sınıf

01:16:34.980 --> 01:16:35.560
nesnesine

01:16:35.560 --> 01:16:36.600
atadığımızda

01:16:36.600 --> 01:16:38.600
aslında

01:16:38.600 --> 01:16:39.980
atama

01:16:39.980 --> 01:16:40.860
operatörünün

01:16:40.860 --> 01:16:41.120
sağ

01:16:41.120 --> 01:16:41.760
tarafındaki

01:16:41.760 --> 01:16:42.900
nesnenin

01:16:42.900 --> 01:16:43.260
artık

01:16:43.260 --> 01:16:43.640
bir daha

01:16:43.640 --> 01:16:44.860
kullanılmayacağını

01:16:44.860 --> 01:16:45.140
biliyor

01:16:45.140 --> 01:16:46.000
olsak da

01:16:46.000 --> 01:16:47.420
eğer

01:16:47.420 --> 01:16:48.020
move

01:16:48.020 --> 01:16:48.480
assignment

01:16:48.480 --> 01:16:49.020
dediğimiz

01:16:49.020 --> 01:16:49.600
fonksiyon

01:16:49.600 --> 01:16:50.260
olmasaydı

01:16:50.260 --> 01:16:50.560
orada

01:16:50.560 --> 01:16:51.300
kopyalama

01:16:51.300 --> 01:16:51.740
yapmaya

01:16:51.740 --> 01:16:52.320
zorlamış

01:16:52.320 --> 01:16:53.080
olacaktık.

01:16:54.380 --> 01:16:54.840
Necati

01:16:54.840 --> 01:16:55.180
o zaman

01:16:55.180 --> 01:16:55.680
aynısı

01:16:55.680 --> 01:16:55.960
olacak.

01:16:56.120 --> 01:16:56.880
Kesinlikle

01:16:56.880 --> 01:16:58.040
kesinlikle

01:16:58.040 --> 01:16:59.000
bakın bakın

01:16:59.000 --> 01:16:59.700
tekrar buraya

01:16:59.700 --> 01:17:00.540
geri dönelim.

01:17:01.360 --> 01:17:02.120
Şimdi de

01:17:02.120 --> 01:17:03.360
arkadaşlar

01:17:03.360 --> 01:17:05.080
böyle bir

01:17:05.080 --> 01:17:05.940
sınıf için

01:17:05.940 --> 01:17:07.100
derleyicinin

01:17:07.100 --> 01:17:07.880
yazdığı

01:17:07.880 --> 01:17:08.460
move

01:17:08.460 --> 01:17:08.940
assignment

01:17:08.940 --> 01:17:09.600
nasıl bir

01:17:09.600 --> 01:17:10.220
fonksiyon

01:17:10.220 --> 01:17:11.520
onu görelim.

01:17:11.520 --> 01:17:12.860
izleyin.

01:17:12.920 --> 01:17:13.120
Bakın

01:17:13.120 --> 01:17:13.260
bu

01:17:13.260 --> 01:17:13.520
copy

01:17:13.520 --> 01:17:14.120
constructor

01:17:14.120 --> 01:17:14.860
hatta

01:17:14.860 --> 01:17:15.180
hepsini

01:17:15.180 --> 01:17:15.480
birlikte

01:17:15.480 --> 01:17:15.980
görelim

01:17:15.980 --> 01:17:16.160
hem

01:17:16.160 --> 01:17:16.500
tekrar

01:17:16.500 --> 01:17:16.880
etmiş

01:17:16.880 --> 01:17:17.400
oluruz.

01:17:18.140 --> 01:17:18.300
Şu

01:17:18.300 --> 01:17:18.540
copy

01:17:18.540 --> 01:17:19.160
constructor

01:17:19.160 --> 01:17:20.300
yanına

01:17:20.300 --> 01:17:20.720
yorum

01:17:20.720 --> 01:17:21.120
satırı

01:17:21.120 --> 01:17:21.260
ile

01:17:21.260 --> 01:17:21.780
ekleyeyim.

01:17:22.580 --> 01:17:22.800
Copy

01:17:22.800 --> 01:17:23.480
constructor

01:17:23.480 --> 01:17:25.260
altındaki

01:17:25.260 --> 01:17:26.080
move

01:17:26.080 --> 01:17:26.860
constructor

01:17:26.860 --> 01:17:29.040
derleyicinin

01:17:29.040 --> 01:17:29.640
yazdığı

01:17:29.640 --> 01:17:31.060
bu arada

01:17:31.060 --> 01:17:32.140
her biri

01:17:32.140 --> 01:17:32.560
için şunu

01:17:32.560 --> 01:17:33.260
tekrar etmem

01:17:33.260 --> 01:17:33.760
gerekiyordu

01:17:33.760 --> 01:17:33.980
ama

01:17:33.980 --> 01:17:34.520
etmedim.

01:17:35.400 --> 01:17:35.720
Hepsi

01:17:35.720 --> 01:17:35.920
için

01:17:35.920 --> 01:17:36.280
tekrar

01:17:36.280 --> 01:17:36.780
ettiğimi

01:17:36.780 --> 01:17:37.320
düşünün.

01:17:37.900 --> 01:17:38.380
Derleyicinin

01:17:38.380 --> 01:17:38.860
yazdığı

01:17:38.860 --> 01:17:39.120
move

01:17:39.120 --> 01:17:39.640
constructor

01:17:39.640 --> 01:17:40.420
yine sınıfın

01:17:40.420 --> 01:17:41.060
non-static

01:17:41.060 --> 01:17:41.560
inline

01:17:41.560 --> 01:17:42.180
public

01:17:42.180 --> 01:17:43.000
dünya

01:17:43.000 --> 01:17:43.740
fonksiyonu.

01:17:44.220 --> 01:17:44.500
Şu

01:17:44.500 --> 01:17:44.780
copy

01:17:44.780 --> 01:17:45.320
assignment

01:17:45.320 --> 01:17:48.200
my

01:17:48.200 --> 01:17:48.580
class

01:17:48.580 --> 01:17:48.980
ref

01:17:48.980 --> 01:17:50.040
arkadaşlar

01:17:50.040 --> 01:17:52.000
operatör

01:17:52.000 --> 01:17:52.460
atamı

01:17:52.460 --> 01:17:54.660
const

01:17:54.660 --> 01:17:54.980
my

01:17:54.980 --> 01:17:55.420
class

01:17:55.420 --> 01:17:56.700
ref

01:17:56.700 --> 01:17:58.420
re

01:17:58.420 --> 01:18:03.840
ax

01:18:03.840 --> 01:18:04.700
eşittir

01:18:04.700 --> 01:18:06.840
re'nin

01:18:06.840 --> 01:18:07.360
ax

01:18:07.360 --> 01:18:10.360
bx

01:18:10.360 --> 01:18:10.380
bx

01:18:10.380 --> 01:18:11.140
eşittir

01:18:11.140 --> 01:18:12.920
re'nin

01:18:12.920 --> 01:18:13.580
bx

01:18:13.580 --> 01:18:16.420
cx

01:18:16.420 --> 01:18:17.160
eşittir

01:18:17.160 --> 01:18:17.980
re'nin

01:18:17.980 --> 01:18:18.660
cx

01:18:18.660 --> 01:18:20.100
ve

01:18:20.100 --> 01:18:21.320
return

01:18:21.320 --> 01:18:22.160
yıldız

01:18:22.160 --> 01:18:22.500
this

01:18:22.500 --> 01:18:25.300
şimdi

01:18:25.300 --> 01:18:26.080
geldik

01:18:26.080 --> 01:18:27.020
derleyicinin

01:18:27.020 --> 01:18:27.760
yazdığı

01:18:27.760 --> 01:18:28.660
move

01:18:28.660 --> 01:18:29.520
assignment'a

01:18:29.520 --> 01:18:30.880
derleyicinin

01:18:30.880 --> 01:18:31.280
yazdığı

01:18:31.280 --> 01:18:31.560
move

01:18:31.560 --> 01:18:32.000
assignment

01:18:32.000 --> 01:18:33.100
fonksiyonu

01:18:33.100 --> 01:18:34.040
yine

01:18:34.040 --> 01:18:35.240
geri dönüş

01:18:35.240 --> 01:18:35.780
değeri

01:18:35.780 --> 01:18:36.900
sınıf

01:18:36.900 --> 01:18:37.440
türünden

01:18:37.440 --> 01:18:38.300
l-value

01:18:38.300 --> 01:18:38.960
referans

01:18:38.960 --> 01:18:40.860
fakat

01:18:40.860 --> 01:18:42.160
parametresi

01:18:42.160 --> 01:18:43.400
const

01:18:43.400 --> 01:18:43.940
sınıf

01:18:43.940 --> 01:18:44.400
türünden

01:18:44.400 --> 01:18:45.060
l-value

01:18:45.060 --> 01:18:45.620
referans

01:18:45.620 --> 01:18:46.120
yerine

01:18:46.120 --> 01:18:47.100
yine

01:18:47.100 --> 01:18:48.060
r-value

01:18:48.060 --> 01:18:48.600
referans

01:18:48.600 --> 01:18:50.680
arkadaşlar bu arada bir şeyde

01:18:50.680 --> 01:18:51.880
dikkat etmenizi istiyorum

01:18:51.880 --> 01:18:52.220
bakın

01:18:52.220 --> 01:18:53.240
bizim

01:18:53.240 --> 01:18:54.920
string sınıfı için yazdığımız

01:18:54.920 --> 01:18:55.960
deminki kodda

01:18:55.960 --> 01:18:58.120
diğer nesnenin

01:18:58.120 --> 01:18:58.780
pointer'ını

01:18:58.780 --> 01:19:00.120
null pointer yaptık ya

01:19:00.120 --> 01:19:01.260
şöyle bir kod yazdık ya

01:19:01.260 --> 01:19:01.760
other

01:19:01.760 --> 01:19:02.840
dot

01:19:02.840 --> 01:19:03.920
mp

01:19:03.920 --> 01:19:05.380
null

01:19:05.380 --> 01:19:05.980
ptr

01:19:05.980 --> 01:19:07.900
bunu yapabilmemiz

01:19:07.900 --> 01:19:08.360
için

01:19:08.360 --> 01:19:09.700
referans

01:19:09.700 --> 01:19:10.560
değişkenin

01:19:10.560 --> 01:19:11.520
const olmaması

01:19:11.520 --> 01:19:12.120
gerekiyor

01:19:12.120 --> 01:19:13.720
o yüzden

01:19:13.720 --> 01:19:14.260
move

01:19:14.260 --> 01:19:14.920
constructor

01:19:14.920 --> 01:19:15.300
move

01:19:15.300 --> 01:19:15.840
assignment

01:19:15.840 --> 01:19:17.780
bunların parametreleri

01:19:17.780 --> 01:19:18.920
const olmayan

01:19:18.920 --> 01:19:19.420
r-value

01:19:19.420 --> 01:19:20.040
referans

01:19:20.040 --> 01:19:21.640
const olan

01:19:21.640 --> 01:19:22.140
r-value

01:19:22.140 --> 01:19:22.680
referans

01:19:22.680 --> 01:19:23.640
yapsaydık

01:19:23.640 --> 01:19:24.960
re'nin

01:19:24.960 --> 01:19:25.960
diğer örnek

01:19:25.960 --> 01:19:26.660
için söylüyorum

01:19:26.660 --> 01:19:27.380
other'ın

01:19:27.380 --> 01:19:27.840
mp

01:19:27.840 --> 01:19:28.560
s eşittir

01:19:28.560 --> 01:19:29.260
null pointer

01:19:29.260 --> 01:19:30.060
dediğimizde

01:19:30.060 --> 01:19:30.900
zaten

01:19:30.900 --> 01:19:32.160
syntax hatası

01:19:32.160 --> 01:19:32.760
olurdu

01:19:32.760 --> 01:19:34.020
peki

01:19:34.020 --> 01:19:35.780
tahmin edin bakalım

01:19:35.780 --> 01:19:37.020
o zaman

01:19:37.020 --> 01:19:38.340
sağ taraf değeri

01:19:38.340 --> 01:19:39.380
argümanlar için

01:19:39.380 --> 01:19:40.340
bu çağrılacak

01:19:40.340 --> 01:19:42.380
eğer ben kodu yine

01:19:42.380 --> 01:19:43.840
böyle yazsaydım

01:19:43.840 --> 01:19:46.160
ki doğru olmayacaktı

01:19:46.160 --> 01:19:47.740
elemanlar

01:19:47.740 --> 01:19:48.380
yine

01:19:48.380 --> 01:19:50.460
copy assignment'la

01:19:50.460 --> 01:19:51.280
kendilerini

01:19:51.280 --> 01:19:52.000
atama yapmış

01:19:52.000 --> 01:19:52.740
olacaktık

01:19:52.740 --> 01:19:53.780
çünkü

01:19:53.780 --> 01:19:54.880
bu

01:19:54.880 --> 01:19:56.000
ifadeler

01:19:56.000 --> 01:19:56.760
birer

01:19:56.760 --> 01:19:57.480
l-value

01:19:57.480 --> 01:19:58.060
expression

01:19:58.060 --> 01:19:59.560
r'nin

01:19:59.560 --> 01:20:00.480
r-value

01:20:00.480 --> 01:20:01.060
reference

01:20:01.060 --> 01:20:01.800
data type

01:20:01.800 --> 01:20:03.560
sahip olması

01:20:03.560 --> 01:20:04.180
data type

01:20:04.180 --> 01:20:05.040
sahip olması

01:20:05.040 --> 01:20:06.700
bu ifadeleri

01:20:06.700 --> 01:20:07.380
l-value

01:20:07.380 --> 01:20:08.000
expression

01:20:08.000 --> 01:20:08.640
yapmıyor

01:20:08.640 --> 01:20:09.480
o zaman

01:20:09.480 --> 01:20:10.800
sadece ne değişecek

01:20:10.800 --> 01:20:11.220
yusuf

01:20:11.220 --> 01:20:11.660
barış

01:20:11.660 --> 01:20:12.180
rassol

01:20:12.180 --> 01:20:13.320
burada

01:20:13.320 --> 01:20:14.120
yine

01:20:14.120 --> 01:20:14.820
molcast

01:20:14.820 --> 01:20:15.360
yapmak

01:20:15.360 --> 01:20:16.120
durumunda

01:20:16.120 --> 01:20:24.100
öyle değil mi

01:20:24.100 --> 01:20:25.720
ax eşittir

01:20:25.720 --> 01:20:27.660
bx eşittir

01:20:27.660 --> 01:20:32.840
cx eşittir

01:20:32.840 --> 01:20:34.580
bu kadar

01:20:34.580 --> 01:20:37.920
ama

01:20:37.920 --> 01:20:39.460
arkadaşlar

01:20:39.460 --> 01:20:41.160
bu derleyicinin

01:20:41.160 --> 01:20:41.720
yazdığı

01:20:41.720 --> 01:20:42.700
molkonstruktör

01:20:42.700 --> 01:20:44.120
şimdi biz

01:20:44.120 --> 01:20:44.920
sınıf için

01:20:44.920 --> 01:20:46.020
molkonstruktör'ı

01:20:46.020 --> 01:20:47.000
yazdığımızda

01:20:47.000 --> 01:20:48.380
neye de dikkat

01:20:48.380 --> 01:20:49.460
etmemiz gerekiyor

01:20:49.460 --> 01:20:50.640
arkadaşlar

01:20:50.640 --> 01:20:51.960
evet

01:20:51.960 --> 01:20:53.340
diğer nesnenin

01:20:53.340 --> 01:20:53.900
kaynağını

01:20:53.900 --> 01:20:54.580
çalacağız

01:20:54.580 --> 01:20:56.540
diğer nesneyi

01:20:56.540 --> 01:20:56.900
yine

01:20:56.900 --> 01:20:57.960
destroy

01:20:57.960 --> 01:20:59.140
edilebilecek

01:20:59.140 --> 01:20:59.720
bir durumda

01:20:59.720 --> 01:21:00.460
bırakacağız

01:21:00.460 --> 01:21:01.600
ama

01:21:01.600 --> 01:21:02.920
aynı zamanda

01:21:02.920 --> 01:21:04.060
bu işlemleri

01:21:04.060 --> 01:21:05.000
yapmadan önce

01:21:05.000 --> 01:21:06.760
kendi kaynağımızı da

01:21:06.760 --> 01:21:08.220
geri vereceğiz

01:21:08.220 --> 01:21:09.260
o zaman

01:21:09.260 --> 01:21:09.760
tekrar

01:21:09.760 --> 01:21:11.380
para vermeden

01:21:11.380 --> 01:21:11.940
o koda

01:21:11.940 --> 01:21:13.080
geri dönersek

01:21:13.080 --> 01:21:17.060
biraz bekleteceğim

01:21:17.060 --> 01:21:17.980
bakın çok büyük

01:21:17.980 --> 01:21:18.820
bir batur tutuyor

01:21:18.820 --> 01:21:19.340
süper

01:21:19.340 --> 01:21:21.140
geldik

01:21:21.140 --> 01:21:26.340
evet

01:21:26.340 --> 01:21:28.800
şöyle bir daha

01:21:28.800 --> 01:21:29.340
bakalım

01:21:29.340 --> 01:21:31.120
string sınıfının

01:21:31.120 --> 01:21:32.080
copy

01:21:32.080 --> 01:21:33.100
konstruktör'ı

01:21:33.100 --> 01:21:34.900
string sınıfının

01:21:34.900 --> 01:21:35.580
move

01:21:35.580 --> 01:21:36.680
konstruktör'ı

01:21:36.680 --> 01:21:38.340
string sınıfının

01:21:38.340 --> 01:21:38.920
copy

01:21:38.920 --> 01:21:39.440
assignment

01:21:39.440 --> 01:21:40.300
function'ı

01:21:40.300 --> 01:21:41.340
ama

01:21:41.340 --> 01:21:42.160
bir de şimdi

01:21:42.160 --> 01:21:42.600
buraya

01:21:42.600 --> 01:21:44.300
move

01:21:44.300 --> 01:21:44.780
assignment

01:21:44.780 --> 01:21:45.440
yazıyoruz

01:21:45.440 --> 01:21:48.820
evet

01:21:48.820 --> 01:21:49.380
sıfırdan

01:21:49.380 --> 01:21:49.920
yazalım

01:21:49.920 --> 01:21:51.500
önce

01:21:51.500 --> 01:21:52.100
parametrik

01:21:52.100 --> 01:21:52.720
yapısı

01:21:52.720 --> 01:21:55.020
string

01:21:55.020 --> 01:21:55.920
ref döndüren

01:21:55.920 --> 01:21:57.400
operatör

01:21:57.400 --> 01:21:57.800
atama

01:21:57.800 --> 01:21:58.580
string

01:21:58.580 --> 01:21:59.100
ref

01:21:59.100 --> 01:21:59.360
ref

01:21:59.360 --> 01:21:59.760
other

01:21:59.760 --> 01:22:05.280
mecate

01:22:05.280 --> 01:22:06.580
eğer böyle

01:22:06.580 --> 01:22:07.340
yapıyorsak

01:22:07.340 --> 01:22:08.280
zaten ben

01:22:08.280 --> 01:22:08.800
sormadan

01:22:08.800 --> 01:22:09.220
Fatih

01:22:09.220 --> 01:22:09.520
sormuş

01:22:09.520 --> 01:22:09.780
yine

01:22:09.780 --> 01:22:10.140
self

01:22:10.140 --> 01:22:10.520
assignment

01:22:10.520 --> 01:22:11.140
kontrolü

01:22:11.140 --> 01:22:11.560
yapmalı

01:22:11.560 --> 01:22:11.920
mıyız

01:22:11.920 --> 01:22:12.840
kesinlikle

01:22:12.840 --> 01:22:14.060
kesinlikle

01:22:14.060 --> 01:22:14.320
yine

01:22:14.320 --> 01:22:14.680
self

01:22:14.680 --> 01:22:15.040
assignment

01:22:15.040 --> 01:22:15.840
kontrolü

01:22:15.840 --> 01:22:17.300
yapmalısınız

01:22:17.300 --> 01:22:18.180
ama

01:22:18.180 --> 01:22:18.740
işte o

01:22:18.740 --> 01:22:19.000
copy

01:22:19.000 --> 01:22:19.400
swap

01:22:19.400 --> 01:22:19.960
videomunu

01:22:19.960 --> 01:22:20.860
kullansaydık

01:22:20.860 --> 01:22:21.260
self

01:22:21.260 --> 01:22:21.660
assignment

01:22:21.660 --> 01:22:22.360
kontrolü

01:22:22.360 --> 01:22:23.020
yapmamıza

01:22:23.020 --> 01:22:23.260
gerek

01:22:23.260 --> 01:22:24.280
kalmayacaktı

01:22:24.280 --> 01:22:25.240
if

01:22:25.240 --> 01:22:26.080
this

01:22:26.080 --> 01:22:28.020
eşit eşit

01:22:28.020 --> 01:22:29.540
address of

01:22:29.540 --> 01:22:30.520
other

01:22:30.520 --> 01:22:32.900
return

01:22:32.900 --> 01:22:34.060
start this

01:22:34.060 --> 01:22:39.000
ama

01:22:39.000 --> 01:22:39.460
şimdi

01:22:39.460 --> 01:22:40.760
önce

01:22:40.760 --> 01:22:41.220
kendi

01:22:41.220 --> 01:22:42.100
kaynağımızı

01:22:42.100 --> 01:22:43.320
geri vereceğiz

01:22:43.320 --> 01:22:43.800
değil mi

01:22:43.800 --> 01:22:44.620
arkadaşlar

01:22:44.620 --> 01:22:46.600
free

01:22:46.600 --> 01:22:49.840
şuradaki kodu

01:22:49.840 --> 01:22:58.860
şu atamalar olacak

01:22:58.860 --> 01:23:00.060
ama önce

01:23:00.060 --> 01:23:01.200
kaynağı geri verelim

01:23:01.200 --> 01:23:04.900
şimdi

01:23:04.900 --> 01:23:07.320
mlen eşittir

01:23:07.320 --> 01:23:10.700
other'ın

01:23:10.700 --> 01:23:11.640
mleni

01:23:11.640 --> 01:23:15.840
mp eşittir

01:23:15.840 --> 01:23:17.980
other'ın

01:23:17.980 --> 01:23:18.880
mp'si

01:23:18.880 --> 01:23:19.220
bakın

01:23:19.220 --> 01:23:19.240
bakın

01:23:19.240 --> 01:23:20.180
eğer

01:23:20.180 --> 01:23:22.440
şunu yazmasaydık

01:23:22.440 --> 01:23:23.940
kaynak

01:23:23.940 --> 01:23:24.780
sızıntısı

01:23:24.780 --> 01:23:25.260
olurdu

01:23:25.260 --> 01:23:25.740
değil mi

01:23:25.740 --> 01:23:27.280
pointer'a yeni bir değer

01:23:27.280 --> 01:23:28.060
atamamız

01:23:28.060 --> 01:23:29.240
o pointer'ın

01:23:29.240 --> 01:23:29.900
gösterdiği

01:23:29.900 --> 01:23:30.440
kaynağın

01:23:30.440 --> 01:23:31.140
geri verildiği

01:23:31.140 --> 01:23:31.760
anlamına

01:23:31.760 --> 01:23:32.480
gelmiyor

01:23:32.480 --> 01:23:34.200
mp eşittir

01:23:34.200 --> 01:23:34.680
other'ın

01:23:34.680 --> 01:23:35.400
mp'si

01:23:35.400 --> 01:23:36.160
şimdi kaynak

01:23:36.160 --> 01:23:36.920
çalma kısmı

01:23:36.920 --> 01:23:37.820
tamamlandı

01:23:37.820 --> 01:23:38.700
ama

01:23:38.700 --> 01:23:40.640
diğer nesneyi de

01:23:40.640 --> 01:23:40.980
yine

01:23:40.980 --> 01:23:42.520
destroyable

01:23:42.520 --> 01:23:43.300
bir state'e

01:23:43.300 --> 01:23:44.300
sokmak için

01:23:44.300 --> 01:23:45.700
other'ın

01:23:45.700 --> 01:23:46.560
mp'si

01:23:46.560 --> 01:23:51.320
eşittir

01:23:51.320 --> 01:23:52.360
null pointer

01:23:52.360 --> 01:23:54.340
ve

01:23:54.340 --> 01:23:55.680
other'ın

01:23:55.680 --> 01:23:57.080
bunu konuşacağız

01:23:57.080 --> 01:23:57.660
demiştik

01:23:57.660 --> 01:23:58.560
mleni

01:23:58.560 --> 01:24:02.600
eşittir

01:24:02.600 --> 01:24:03.520
sıfır

01:24:03.520 --> 01:24:05.780
return

01:24:05.780 --> 01:24:08.220
start this

01:24:08.220 --> 01:24:09.100
bu kadar

01:24:09.100 --> 01:24:11.260
görecek

01:24:11.260 --> 01:24:12.980
örnek sınıfımız için

01:24:12.980 --> 01:24:13.940
move

01:24:13.940 --> 01:24:14.640
konstruktör'ı

01:24:14.640 --> 01:24:14.860
copy

01:24:14.860 --> 01:24:15.560
konstruktör'ı

01:24:15.560 --> 01:24:16.420
move assignment'ı

01:24:16.420 --> 01:24:17.580
copy assignment'ı

01:24:17.580 --> 01:24:19.140
implemente etmiş olduk

01:24:19.140 --> 01:24:20.100
şimdi

01:24:20.100 --> 01:24:21.420
hem Russell

01:24:21.420 --> 01:24:22.040
hem de diğer

01:24:22.040 --> 01:24:23.180
arkadaşlarım için

01:24:23.180 --> 01:24:24.560
eğer

01:24:24.560 --> 01:24:25.820
ben bu sınıfı

01:24:25.820 --> 01:24:26.960
böyle yazmışsam

01:24:26.960 --> 01:24:28.420
örneğin

01:24:28.420 --> 01:24:29.060
Kaveh

01:24:29.060 --> 01:24:29.780
Fatih

01:24:29.780 --> 01:24:30.420
Ozan

01:24:30.420 --> 01:24:32.360
kendi yazacağı

01:24:32.360 --> 01:24:33.180
sınıflarda

01:24:33.180 --> 01:24:34.560
sınıflardan

01:24:34.560 --> 01:24:35.500
herhangi birinde

01:24:35.500 --> 01:24:36.080
ya da birden

01:24:36.080 --> 01:24:36.860
fazlasında

01:24:36.860 --> 01:24:38.220
benim

01:24:38.220 --> 01:24:39.140
string sınıfım

01:24:39.140 --> 01:24:39.740
türünden

01:24:39.740 --> 01:24:40.720
elemanlar

01:24:40.720 --> 01:24:41.360
koyarsa

01:24:41.360 --> 01:24:43.840
o zaman

01:24:43.840 --> 01:24:45.600
kendi yazacağı sınıflar

01:24:45.600 --> 01:24:46.040
için

01:24:46.040 --> 01:24:46.880
copy

01:24:46.880 --> 01:24:47.520
konstruktör

01:24:47.520 --> 01:24:47.780
move

01:24:47.780 --> 01:24:48.420
konstruktör

01:24:48.420 --> 01:24:48.700
copy

01:24:48.700 --> 01:24:49.160
assignment

01:24:49.160 --> 01:24:49.440
move

01:24:49.440 --> 01:24:49.900
assignment

01:24:49.900 --> 01:24:50.800
yazmasına

01:24:50.800 --> 01:24:51.620
başka bir neden

01:24:51.620 --> 01:24:52.000
yoksa

01:24:52.000 --> 01:24:52.540
tabii gerek

01:24:52.540 --> 01:24:53.260
olacak mı?

01:24:53.260 --> 01:24:54.340
hayır

01:24:54.340 --> 01:24:56.040
derleyicinin yazdığı

01:24:56.040 --> 01:24:56.300
copy

01:24:56.300 --> 01:24:56.960
konstruktör

01:24:56.960 --> 01:24:57.620
benim yazdığım

01:24:57.620 --> 01:24:58.000
sınıfın

01:24:58.000 --> 01:24:58.260
copy

01:24:58.260 --> 01:24:59.120
konstruktör'ını

01:24:59.120 --> 01:25:00.780
derleyicinin yazdığı

01:25:00.780 --> 01:25:00.980
move

01:25:00.980 --> 01:25:01.740
konstruktör

01:25:01.740 --> 01:25:02.680
benim sınıfımın

01:25:02.680 --> 01:25:02.920
move

01:25:02.920 --> 01:25:03.740
konstruktör'ını

01:25:03.740 --> 01:25:05.580
derleyicinin yazdığı

01:25:05.580 --> 01:25:05.980
efendim

01:25:05.980 --> 01:25:06.260
copy

01:25:06.260 --> 01:25:06.860
assignment

01:25:06.860 --> 01:25:07.620
benim

01:25:07.620 --> 01:25:08.640
sınıfımın

01:25:08.640 --> 01:25:08.880
copy

01:25:08.880 --> 01:25:09.660
assignment'ını

01:25:09.660 --> 01:25:10.520
nokta nokta

01:25:10.520 --> 01:25:11.300
çağıracak

01:25:11.300 --> 01:25:12.960
anlaşıldı mı?

01:25:13.360 --> 01:25:13.560
Evet

01:25:13.560 --> 01:25:14.660
ama şimdi

01:25:14.660 --> 01:25:16.680
çok özel

01:25:16.680 --> 01:25:17.460
biraz da zor

01:25:17.460 --> 01:25:19.060
bir alt başlığımız

01:25:19.060 --> 01:25:19.460
var

01:25:19.460 --> 01:25:20.920
arkadaşlar

01:25:20.920 --> 01:25:21.720
eğer

01:25:21.720 --> 01:25:24.640
kopyalamada

01:25:24.640 --> 01:25:25.600
kullandığımız

01:25:25.600 --> 01:25:26.700
hani o değerini

01:25:26.700 --> 01:25:27.320
alacağımız

01:25:27.320 --> 01:25:28.220
nesne

01:25:28.220 --> 01:25:29.100
ifadesi

01:25:29.100 --> 01:25:29.620
rvalue

01:25:29.620 --> 01:25:30.600
expression'sa

01:25:30.600 --> 01:25:32.160
bizim hiçbir şey

01:25:32.160 --> 01:25:32.700
yapmamız

01:25:32.700 --> 01:25:33.280
gerekmiyor

01:25:33.280 --> 01:25:34.420
ama

01:25:34.420 --> 01:25:35.580
öyle durumlar

01:25:35.580 --> 01:25:36.220
var ki

01:25:36.220 --> 01:25:37.860
bir nesne

01:25:37.860 --> 01:25:38.540
hayatta

01:25:38.540 --> 01:25:39.640
olduğu

01:25:39.640 --> 01:25:40.760
olmasına rağmen

01:25:40.760 --> 01:25:41.400
bir nesnenin

01:25:41.400 --> 01:25:42.100
hayata devam

01:25:42.100 --> 01:25:43.160
etmesine rağmen

01:25:43.160 --> 01:25:44.680
yani

01:25:44.680 --> 01:25:45.420
nesnenin

01:25:45.420 --> 01:25:45.820
hayatı

01:25:45.820 --> 01:25:46.520
bitmeyecek

01:25:46.520 --> 01:25:47.580
elimizde bir

01:25:47.580 --> 01:25:48.300
biraz daha

01:25:48.300 --> 01:25:49.540
farklı şekilde

01:25:49.540 --> 01:25:50.560
ifade edersek

01:25:50.560 --> 01:25:51.740
elimizde bir

01:25:51.740 --> 01:25:53.100
l-value expression

01:25:53.100 --> 01:25:54.980
biçiminde

01:25:54.980 --> 01:25:56.240
value kategorisinde

01:25:56.240 --> 01:25:57.880
bir sınıf nesnesi

01:25:57.880 --> 01:25:58.920
olmasına rağmen

01:25:58.920 --> 01:26:00.120
yine de

01:26:00.120 --> 01:26:00.380
onun

01:26:00.380 --> 01:26:01.080
kaynağını

01:26:01.080 --> 01:26:01.580
çalmak

01:26:01.580 --> 01:26:02.160
istiyoruz

01:26:02.160 --> 01:26:03.420
bunun

01:26:03.420 --> 01:26:05.100
yapılacağı

01:26:05.100 --> 01:26:06.240
hatta yapılmasının

01:26:06.240 --> 01:26:07.020
iyi olduğu

01:26:07.020 --> 01:26:07.480
bir sürü

01:26:07.480 --> 01:26:08.320
senaryo var

01:26:08.320 --> 01:26:09.000
yani bu

01:26:09.000 --> 01:26:10.260
çok ütopik

01:26:10.260 --> 01:26:11.140
ya da

01:26:11.140 --> 01:26:11.880
marjinal

01:26:11.880 --> 01:26:12.800
bir senaryo

01:26:12.800 --> 01:26:13.100
değil

01:26:13.100 --> 01:26:14.760
mesela kafamızda

01:26:14.760 --> 01:26:15.520
canlandırılmış

01:26:15.520 --> 01:26:15.960
şimdi biz

01:26:15.960 --> 01:26:16.420
orijinal

01:26:16.420 --> 01:26:17.460
string sınıfından

01:26:17.460 --> 01:26:18.480
örneği verelim

01:26:18.480 --> 01:26:20.460
değerli arkadaşlarım

01:26:20.460 --> 01:26:21.140
diyelim ki

01:26:21.140 --> 01:26:21.880
benim

01:26:21.880 --> 01:26:22.660
string sınıfı

01:26:22.660 --> 01:26:23.040
türünden

01:26:23.040 --> 01:26:24.080
bir nesnem var

01:26:24.080 --> 01:26:25.000
string

01:26:25.000 --> 01:26:26.500
stl

01:26:26.500 --> 01:26:27.380
kodu açıklayacağım

01:26:27.380 --> 01:26:28.300
merak etmeyin

01:26:28.300 --> 01:26:30.920
on bin tane

01:26:30.920 --> 01:26:33.040
a karakterinden

01:26:33.040 --> 01:26:33.520
oluşan

01:26:33.520 --> 01:26:34.180
bir yazıyı

01:26:34.180 --> 01:26:34.900
tutuyor

01:26:34.900 --> 01:26:36.620
string sınıfının

01:26:36.620 --> 01:26:37.020
böyle bir

01:26:37.020 --> 01:26:37.780
konstruktörü var

01:26:37.780 --> 01:26:38.520
bu konstruktör

01:26:38.520 --> 01:26:39.440
hep popüler olarak

01:26:39.440 --> 01:26:40.320
feel

01:26:40.320 --> 01:26:41.780
konstruktör deniyor

01:26:41.780 --> 01:26:43.560
birinci parametre

01:26:43.560 --> 01:26:44.640
tane adet

01:26:44.640 --> 01:26:46.080
ikinci parametre

01:26:46.080 --> 01:26:47.200
hangi karakterden

01:26:47.200 --> 01:26:48.480
yani şimdi

01:26:48.480 --> 01:26:50.000
str nesnesini

01:26:50.000 --> 01:26:51.600
bu konstruktör

01:26:51.600 --> 01:26:52.840
hayata getirdiğinde

01:26:52.840 --> 01:26:54.480
str'nin tuttuğu

01:26:54.480 --> 01:26:55.020
yazı ne

01:26:55.020 --> 01:26:55.620
kaveh

01:26:55.620 --> 01:26:56.860
on bin tane

01:26:56.860 --> 01:26:57.980
a karakteri

01:26:57.980 --> 01:26:59.660
anlaşıldı

01:26:59.660 --> 01:27:00.120
değil mi

01:27:00.120 --> 01:27:00.760
tamam

01:27:00.760 --> 01:27:02.160
şimdi ben

01:27:02.160 --> 01:27:03.780
yeni bir

01:27:03.780 --> 01:27:04.620
string nesnesi

01:27:04.620 --> 01:27:05.480
oluştursam

01:27:05.480 --> 01:27:06.760
stut string

01:27:06.760 --> 01:27:08.540
efendim

01:27:08.540 --> 01:27:09.400
sx

01:27:09.400 --> 01:27:09.940
olsun

01:27:09.940 --> 01:27:10.520
ismi

01:27:10.520 --> 01:27:12.080
eşittir

01:27:12.080 --> 01:27:13.120
stl

01:27:13.120 --> 01:27:15.120
burada

01:27:15.120 --> 01:27:15.980
sx için

01:27:15.980 --> 01:27:16.300
copy

01:27:16.300 --> 01:27:16.940
konstruktör

01:27:16.940 --> 01:27:17.060
mı

01:27:17.060 --> 01:27:17.580
çağrılır

01:27:17.580 --> 01:27:17.740
mu

01:27:17.740 --> 01:27:18.520
konstruktör

01:27:18.520 --> 01:27:18.720
mı

01:27:18.720 --> 01:27:21.120
cevap

01:27:21.120 --> 01:27:21.860
copy

01:27:21.860 --> 01:27:22.580
konstruktör

01:27:22.580 --> 01:27:23.880
peki öyle bir

01:27:23.880 --> 01:27:24.980
senaryo olsun ki

01:27:24.980 --> 01:27:26.220
barış doğa

01:27:26.220 --> 01:27:26.760
oğuzhan

01:27:26.760 --> 01:27:27.200
esin

01:27:27.200 --> 01:27:27.980
öyle bir

01:27:27.980 --> 01:27:29.240
senaryo olsun ki

01:27:29.240 --> 01:27:30.480
ben şunu

01:27:30.480 --> 01:27:30.920
bilerek

01:27:30.920 --> 01:27:31.620
isteyerek

01:27:31.620 --> 01:27:33.200
seçeyim

01:27:33.200 --> 01:27:34.060
evet

01:27:34.060 --> 01:27:34.440
evet

01:27:34.440 --> 01:27:35.580
stl'nin

01:27:35.580 --> 01:27:36.680
hayatının devam

01:27:36.680 --> 01:27:37.240
ettiğini

01:27:37.240 --> 01:27:38.020
biliyorum

01:27:38.020 --> 01:27:39.160
ama ben

01:27:39.160 --> 01:27:39.860
stl'yi

01:27:39.860 --> 01:27:40.360
artık

01:27:40.360 --> 01:27:41.480
kullanmayacağım

01:27:41.480 --> 01:27:42.880
dolayısıyla

01:27:42.880 --> 01:27:43.920
sx'in

01:27:43.920 --> 01:27:45.740
stl'nin

01:27:45.740 --> 01:27:46.520
kaynağını

01:27:46.520 --> 01:27:47.420
kopyalamasını

01:27:47.420 --> 01:27:47.680
değil

01:27:47.680 --> 01:27:48.520
çalmasını

01:27:48.520 --> 01:27:49.060
istiyorum

01:27:49.060 --> 01:27:50.900
bunu yapmak

01:27:50.900 --> 01:27:51.560
mümkün mü

01:27:51.560 --> 01:27:52.160
işte

01:27:52.160 --> 01:27:53.400
studmovla

01:27:53.400 --> 01:27:54.220
bunu yapabilirim

01:27:54.220 --> 01:27:54.480
değil mi

01:27:54.480 --> 01:27:54.940
çünkü bu

01:27:54.940 --> 01:27:55.560
l value

01:27:55.560 --> 01:27:56.640
ama

01:27:56.640 --> 01:27:58.040
ben

01:27:58.040 --> 01:28:01.540
hayata getirecek

01:28:01.540 --> 01:28:02.080
nesneyi

01:28:02.080 --> 01:28:02.440
bir

01:28:02.440 --> 01:28:03.020
r value

01:28:03.020 --> 01:28:03.520
expression

01:28:03.520 --> 01:28:04.400
yaparsam

01:28:04.400 --> 01:28:05.480
şimdi

01:28:05.480 --> 01:28:07.200
stl'nin

01:28:07.200 --> 01:28:08.160
kaynağını

01:28:08.160 --> 01:28:09.440
çaldım

01:28:09.440 --> 01:28:12.080
stl'nin

01:28:12.080 --> 01:28:12.920
buraya çok dikkatli

01:28:12.920 --> 01:28:13.280
izleyelim

01:28:13.280 --> 01:28:13.620
üstten

01:28:13.620 --> 01:28:14.480
stl'nin

01:28:14.480 --> 01:28:15.380
kaynağını

01:28:15.380 --> 01:28:17.060
çaldım

01:28:17.060 --> 01:28:19.200
arkadaşlar

01:28:19.200 --> 01:28:21.980
işte

01:28:21.980 --> 01:28:23.160
bu noktadaki

01:28:23.160 --> 01:28:24.080
stl'nin

01:28:24.080 --> 01:28:25.280
gibi nesnelerin

01:28:25.280 --> 01:28:26.120
state'ine

01:28:26.120 --> 01:28:28.380
move

01:28:28.380 --> 01:28:29.380
from

01:28:29.380 --> 01:28:31.180
state

01:28:31.180 --> 01:28:31.640
ya da

01:28:31.640 --> 01:28:32.100
object

01:28:32.100 --> 01:28:32.660
nesneden

01:28:32.660 --> 01:28:33.600
bahsediyorsam

01:28:33.600 --> 01:28:34.540
deniyor

01:28:34.540 --> 01:28:35.840
yani

01:28:35.840 --> 01:28:36.800
nesne halen

01:28:36.800 --> 01:28:37.440
hayatta

01:28:37.440 --> 01:28:38.420
ama

01:28:38.420 --> 01:28:39.140
kaynağı

01:28:39.140 --> 01:28:39.840
çalınmış

01:28:39.840 --> 01:28:41.640
buraya kadar

01:28:41.640 --> 01:28:42.260
anladık mı

01:28:42.260 --> 01:28:43.100
arkadaşlar

01:28:43.100 --> 01:28:44.260
bazı kitaplarda

01:28:44.260 --> 01:28:45.640
ya da makalelerde

01:28:45.640 --> 01:28:46.280
ya da blog

01:28:46.280 --> 01:28:46.900
yazılarında

01:28:46.900 --> 01:28:47.220
konu

01:28:47.220 --> 01:28:48.180
tamamen yanlış

01:28:48.180 --> 01:28:48.700
anlatılmış

01:28:48.700 --> 01:28:49.300
o kadar çok

01:28:49.300 --> 01:28:50.260
kitap görüyorum ki

01:28:50.260 --> 01:28:51.880
asla bunu yapmayın

01:28:51.880 --> 01:28:52.560
falan gibi

01:28:52.560 --> 01:28:53.120
zırva

01:28:53.120 --> 01:28:53.640
olur mu

01:28:53.640 --> 01:28:54.600
bunu yapacağımız

01:28:54.600 --> 01:28:55.880
tabii ki bu örnekte

01:28:55.880 --> 01:28:57.820
ihtiyaç noktası

01:28:57.820 --> 01:28:58.300
görülmüyor

01:28:58.300 --> 01:28:59.440
ama bunu bilerek

01:28:59.440 --> 01:29:00.000
isteyerek

01:29:00.000 --> 01:29:01.060
yapacağımız yerler

01:29:01.060 --> 01:29:01.520
var mı

01:29:01.520 --> 01:29:02.000
var

01:29:02.000 --> 01:29:03.720
şimdi

01:29:03.720 --> 01:29:05.440
bu durumda

01:29:05.440 --> 01:29:06.200
şu soruyu

01:29:06.200 --> 01:29:07.320
sormam gerekiyor

01:29:07.320 --> 01:29:08.640
peki

01:29:08.640 --> 01:29:09.940
herhangi bir problem

01:29:09.940 --> 01:29:11.020
olmaması için

01:29:11.020 --> 01:29:12.080
böyle durumlarda

01:29:12.080 --> 01:29:14.080
neler yapabilirim

01:29:14.080 --> 01:29:15.300
yani gerçekten

01:29:15.300 --> 01:29:15.960
kaynağını

01:29:15.960 --> 01:29:16.520
çaldım

01:29:16.520 --> 01:29:17.780
arkadaşlar

01:29:17.780 --> 01:29:19.480
birinci ihtimal

01:29:19.480 --> 01:29:20.300
birinci seçenek

01:29:20.300 --> 01:29:20.920
şu olabilir

01:29:20.920 --> 01:29:22.040
artık

01:29:22.040 --> 01:29:22.740
stl'yi

01:29:22.740 --> 01:29:23.900
hiç kullanmazsınız

01:29:23.900 --> 01:29:25.220
yani

01:29:25.220 --> 01:29:26.160
stl'nin

01:29:26.160 --> 01:29:26.740
kaynağı

01:29:26.740 --> 01:29:27.580
çalınmıştır

01:29:27.580 --> 01:29:29.480
ve ne zaman

01:29:29.480 --> 01:29:30.960
stl'nin

01:29:30.960 --> 01:29:32.020
destraktör'ı

01:29:32.020 --> 01:29:33.060
çağrılacak olsa

01:29:33.060 --> 01:29:33.800
mesela bu

01:29:33.800 --> 01:29:34.740
şöyle bir blok

01:29:34.740 --> 01:29:35.780
olduğunu düşünelim

01:29:35.780 --> 01:29:37.540
buraya geldiğinde

01:29:37.540 --> 01:29:38.240
stl'nin

01:29:38.240 --> 01:29:38.900
destraktör'ı

01:29:38.900 --> 01:29:39.420
çağrılacak

01:29:39.420 --> 01:29:39.680
değil mi

01:29:39.680 --> 01:29:40.240
stl'nin

01:29:40.240 --> 01:29:41.000
destraktör'ının

01:29:41.000 --> 01:29:41.860
çağrılması

01:29:41.860 --> 01:29:43.340
herhangi bir

01:29:43.340 --> 01:29:44.440
soruna yol açacak mı

01:29:44.440 --> 01:29:45.080
evet ya da

01:29:45.080 --> 01:29:45.580
hayır değil

01:29:45.580 --> 01:29:47.200
cevap

01:29:47.200 --> 01:29:47.680
hayır

01:29:47.680 --> 01:29:48.200
çünkü onun

01:29:48.200 --> 01:29:49.260
mu konstraktör'ı

01:29:49.260 --> 01:29:50.240
ona göre yazılmış

01:29:50.240 --> 01:29:52.840
peki

01:29:52.840 --> 01:29:54.240
şimdi burada

01:29:54.240 --> 01:29:55.080
çok önemli

01:29:55.080 --> 01:29:55.580
bir soru

01:29:55.580 --> 01:29:56.120
daha var

01:29:56.120 --> 01:29:57.900
ben stl'yi

01:29:57.900 --> 01:29:59.020
kullanabilir miyim

01:29:59.020 --> 01:30:01.040
yani stl'nin

01:30:01.040 --> 01:30:01.540
kaynağını

01:30:01.540 --> 01:30:02.080
çaldım ama

01:30:02.080 --> 01:30:02.720
stl'yi

01:30:02.720 --> 01:30:03.680
kullanabilir miyim

01:30:03.680 --> 01:30:05.180
arkadaşlar

01:30:05.180 --> 01:30:06.840
aksi yönde

01:30:06.840 --> 01:30:07.980
hayır

01:30:07.980 --> 01:30:08.540
kesinlikle

01:30:08.540 --> 01:30:08.940
undefined

01:30:08.940 --> 01:30:09.300
behavior

01:30:09.300 --> 01:30:09.600
değil

01:30:09.600 --> 01:30:10.140
olsanız

01:30:10.140 --> 01:30:10.720
undefined

01:30:10.720 --> 01:30:11.060
behavior

01:30:11.060 --> 01:30:11.660
diyenler

01:30:11.660 --> 01:30:12.360
eğer daha önce

01:30:12.360 --> 01:30:13.340
öyle öğrendiyseniz

01:30:13.340 --> 01:30:14.340
kesinlikle

01:30:14.340 --> 01:30:15.180
yanlış cevap

01:30:15.180 --> 01:30:16.480
arkadaşlar

01:30:16.480 --> 01:30:17.960
standart

01:30:17.960 --> 01:30:18.760
kütüphanenin

01:30:18.760 --> 01:30:20.100
türleri

01:30:20.100 --> 01:30:20.900
yani

01:30:20.900 --> 01:30:21.780
stl'n gibi

01:30:21.780 --> 01:30:22.840
stl'n gibi

01:30:22.840 --> 01:30:23.800
ve

01:30:23.800 --> 01:30:24.280
üçüncü

01:30:24.280 --> 01:30:24.600
parti

01:30:24.600 --> 01:30:25.800
kütüphanelerinde

01:30:25.800 --> 01:30:27.180
eğer özel bir durum

01:30:27.180 --> 01:30:27.780
yoksa

01:30:27.780 --> 01:30:28.960
sınıfları

01:30:28.960 --> 01:30:30.740
kaynağa çalınmış

01:30:30.740 --> 01:30:31.820
nesneler için

01:30:31.820 --> 01:30:33.060
tipik olarak

01:30:33.060 --> 01:30:33.820
şu garantiyi

01:30:33.820 --> 01:30:34.260
veriyor

01:30:34.260 --> 01:30:35.200
mesela

01:30:35.200 --> 01:30:35.880
string sınıfı

01:30:35.880 --> 01:30:36.560
için bu garanti

01:30:36.560 --> 01:30:36.780
var

01:30:36.780 --> 01:30:37.440
diyor ki

01:30:37.440 --> 01:30:39.200
kaynağa çalınmış

01:30:39.200 --> 01:30:39.960
bir nesne

01:30:39.960 --> 01:30:41.080
bir kere

01:30:41.080 --> 01:30:42.960
valid state

01:30:42.960 --> 01:30:43.640
de olacak

01:30:43.640 --> 01:30:44.620
a

01:30:44.620 --> 01:30:46.500
türçe yazacağım

01:30:46.500 --> 01:30:48.060
resul anlamadığınız

01:30:48.060 --> 01:30:49.200
türkçe terim olursa

01:30:49.200 --> 01:30:50.060
tekrar etmemi

01:30:50.060 --> 01:30:50.580
isteyin

01:30:50.580 --> 01:30:51.960
kaynağı

01:30:51.960 --> 01:30:54.020
çılınmış

01:30:54.020 --> 01:30:55.100
nesne

01:30:55.100 --> 01:30:57.060
arkadaşlar

01:30:57.060 --> 01:30:58.540
ne halde

01:30:58.540 --> 01:30:59.080
olacak

01:30:59.080 --> 01:31:00.120
in a

01:31:00.120 --> 01:31:00.920
valid

01:31:00.920 --> 01:31:01.920
state

01:31:01.920 --> 01:31:03.580
bu ne demek

01:31:03.580 --> 01:31:05.220
bir nesnenin

01:31:05.220 --> 01:31:06.020
valid state

01:31:06.020 --> 01:31:07.060
olması ne demek

01:31:07.060 --> 01:31:08.140
geçerli durumda

01:31:08.140 --> 01:31:09.600
arkadaşlar

01:31:09.600 --> 01:31:10.740
sınıfın

01:31:10.740 --> 01:31:12.020
invariantları

01:31:12.020 --> 01:31:12.620
korunmuş

01:31:12.620 --> 01:31:13.120
olacak

01:31:13.120 --> 01:31:14.320
invariant ne demek

01:31:14.320 --> 01:31:15.220
onu da açıklayacağım

01:31:15.220 --> 01:31:16.080
yani

01:31:16.080 --> 01:31:17.040
invariantları

01:31:17.040 --> 01:31:18.020
bozulmayacak

01:31:18.020 --> 01:31:20.160
b

01:31:20.160 --> 01:31:21.820
buraya dikkat

01:31:21.820 --> 01:31:22.180
b

01:31:22.180 --> 01:31:24.200
destraktörün

01:31:24.200 --> 01:31:25.000
çağrılması

01:31:25.000 --> 01:31:25.800
herhangi bir şekilde

01:31:25.800 --> 01:31:27.320
bir soruna yol açmayacak

01:31:27.320 --> 01:31:28.460
arkadaşlar

01:31:28.460 --> 01:31:30.040
nesne

01:31:30.040 --> 01:31:35.120
hangi durumda

01:31:35.120 --> 01:31:36.120
destraktible

01:31:36.120 --> 01:31:37.160
yani kaynağa

01:31:37.160 --> 01:31:38.260
çalınmış olması

01:31:38.260 --> 01:31:40.060
destraktörünün

01:31:40.060 --> 01:31:40.720
çağrılması

01:31:40.720 --> 01:31:41.200
durumunda

01:31:41.200 --> 01:31:41.860
bir problem

01:31:41.860 --> 01:31:43.060
olmayacağı

01:31:43.060 --> 01:31:43.840
garantisini de

01:31:43.840 --> 01:31:44.200
veriyor

01:31:44.200 --> 01:31:45.380
standart

01:31:45.380 --> 01:31:46.500
eğer sınıf

01:31:46.500 --> 01:31:47.060
doğru bir şekilde

01:31:47.060 --> 01:31:47.980
implement edilmiş

01:31:47.980 --> 01:31:49.780
burayı anladık mı

01:31:49.780 --> 01:31:52.040
ama

01:31:52.040 --> 01:31:53.240
arkadaşlar

01:31:53.240 --> 01:31:54.780
nesnenin değeri

01:31:54.780 --> 01:31:55.760
buraya dikkat

01:31:55.760 --> 01:31:57.180
nesnenin değeri

01:31:57.180 --> 01:31:59.500
garanti altında

01:31:59.500 --> 01:31:59.820
değil

01:31:59.820 --> 01:32:00.140
bakın

01:32:00.140 --> 01:32:00.960
valid state

01:32:00.960 --> 01:32:01.580
olması

01:32:01.580 --> 01:32:02.180
başka

01:32:02.180 --> 01:32:03.860
nesnenin

01:32:03.860 --> 01:32:04.420
değerinin

01:32:04.420 --> 01:32:05.020
ne olduğu

01:32:05.020 --> 01:32:05.580
başka

01:32:05.580 --> 01:32:06.980
mesela

01:32:06.980 --> 01:32:08.180
standart

01:32:08.180 --> 01:32:08.800
kütüphanenin

01:32:08.800 --> 01:32:09.660
string sınıfı

01:32:09.660 --> 01:32:10.000
için

01:32:10.000 --> 01:32:11.480
biz bir

01:32:11.480 --> 01:32:12.500
string nesnesinin

01:32:12.500 --> 01:32:13.100
kaynağını

01:32:13.100 --> 01:32:13.780
çalsak

01:32:13.780 --> 01:32:15.080
ve

01:32:15.080 --> 01:32:17.040
string nesnesinin

01:32:17.040 --> 01:32:17.840
arkadaşlar

01:32:17.840 --> 01:32:18.540
o kaynağa

01:32:18.540 --> 01:32:19.000
çalınmış

01:32:19.000 --> 01:32:19.840
nesnenin

01:32:19.840 --> 01:32:21.160
tuttuğu

01:32:21.160 --> 01:32:21.720
yazıyı

01:32:21.720 --> 01:32:22.500
bir şekilde

01:32:22.500 --> 01:32:23.320
yazdırsak

01:32:23.320 --> 01:32:24.240
ve o yazı

01:32:24.240 --> 01:32:25.260
fatih yazı

01:32:25.260 --> 01:32:25.620
olsa

01:32:25.620 --> 01:32:26.500
halen

01:32:26.500 --> 01:32:27.280
fatih yazısını

01:32:27.280 --> 01:32:27.700
tutuyor

01:32:27.700 --> 01:32:29.220
sınıfın

01:32:29.220 --> 01:32:30.440
length fonksiyonu

01:32:30.440 --> 01:32:32.420
string sınıfı

01:32:32.420 --> 01:32:33.200
nesnesinin

01:32:33.200 --> 01:32:34.300
tuttuğu yazının

01:32:34.300 --> 01:32:35.080
uzunluğunu

01:32:35.080 --> 01:32:35.660
döndürüyor

01:32:35.660 --> 01:32:36.520
bu durumda

01:32:36.520 --> 01:32:37.820
length fonksiyonunun

01:32:37.820 --> 01:32:39.160
5 değerini

01:32:39.160 --> 01:32:39.840
döndürmesi

01:32:39.840 --> 01:32:40.760
garanti altında

01:32:40.760 --> 01:32:41.060
mı

01:32:41.060 --> 01:32:45.180
takip edebiliyor

01:32:45.180 --> 01:32:45.640
muyuz

01:32:45.640 --> 01:32:49.720
cevap

01:32:49.720 --> 01:32:50.020
evet

01:32:50.020 --> 01:32:51.080
garanti altında

01:32:51.080 --> 01:32:52.000
valid state

01:32:52.000 --> 01:32:52.440
olması

01:32:52.440 --> 01:32:52.760
bu

01:32:52.760 --> 01:32:53.180
demek

01:32:53.180 --> 01:32:54.520
yani

01:32:54.520 --> 01:32:55.880
sınıf nesnesinin

01:32:55.880 --> 01:32:57.020
üye fonksiyonları

01:32:57.020 --> 01:32:57.980
çağrıldığında

01:32:57.980 --> 01:32:59.600
herhangi bir şekilde

01:32:59.600 --> 01:33:00.260
bir problem

01:33:00.260 --> 01:33:00.780
yok

01:33:00.780 --> 01:33:01.620
ama

01:33:01.620 --> 01:33:02.360
değerinin

01:33:02.360 --> 01:33:03.000
ne olduğunu

01:33:03.000 --> 01:33:03.840
bilmiyoruz

01:33:03.840 --> 01:33:04.800
bunu tıpkı

01:33:04.800 --> 01:33:05.980
şuna benzetebilirsiniz

01:33:05.980 --> 01:33:06.940
sorularınıza cevap

01:33:06.940 --> 01:33:07.300
vereceğim

01:33:07.300 --> 01:33:07.940
burası biraz

01:33:07.940 --> 01:33:08.500
zorlayıcı

01:33:08.500 --> 01:33:09.660
mesela

01:33:09.660 --> 01:33:11.460
bir fonksiyonun

01:33:11.460 --> 01:33:12.700
parametresi

01:33:12.700 --> 01:33:13.640
string türünden

01:33:13.640 --> 01:33:14.440
olsaydı

01:33:14.440 --> 01:33:17.640
ben size

01:33:17.640 --> 01:33:18.520
şöyle bir soru

01:33:18.520 --> 01:33:19.240
sorsaydım

01:33:19.240 --> 01:33:20.360
buraya çok dikkatli

01:33:20.360 --> 01:33:20.800
izleyin

01:33:20.800 --> 01:33:22.600
buraya gelen

01:33:22.600 --> 01:33:23.660
x'in

01:33:23.660 --> 01:33:24.340
değeri

01:33:24.340 --> 01:33:25.200
hangi yazı

01:33:25.200 --> 01:33:27.140
siz ne cevap

01:33:27.140 --> 01:33:27.680
verdiniz

01:33:27.680 --> 01:33:28.460
ne bileyim

01:33:28.460 --> 01:33:28.800
ben

01:33:28.800 --> 01:33:30.140
ne gönderildiyse

01:33:30.140 --> 01:33:30.460
o

01:33:30.460 --> 01:33:31.460
peki

01:33:31.460 --> 01:33:32.220
buraya gelen

01:33:32.220 --> 01:33:32.960
stringin

01:33:32.960 --> 01:33:34.320
tuttuğu yazı

01:33:34.320 --> 01:33:34.900
k vs

01:33:34.900 --> 01:33:37.000
length fonksiyonunu

01:33:37.000 --> 01:33:37.720
çağırdığımda

01:33:37.720 --> 01:33:39.120
5 değerini döndürür mü

01:33:39.120 --> 01:33:40.220
evet

01:33:40.220 --> 01:33:41.700
buraya gelen

01:33:41.700 --> 01:33:42.700
string nesnesinin

01:33:42.700 --> 01:33:43.500
tuttuğu yazı

01:33:43.500 --> 01:33:44.160
boş ise

01:33:44.160 --> 01:33:46.000
empty string ise

01:33:46.000 --> 01:33:48.140
length fonksiyonunu

01:33:48.140 --> 01:33:49.120
çağırdığımda

01:33:49.120 --> 01:33:50.340
0 değerini

01:33:50.340 --> 01:33:51.160
döndürür mü

01:33:51.160 --> 01:33:52.960
kesinlikle

01:33:52.960 --> 01:33:54.060
burayı anladık mı

01:33:54.060 --> 01:33:56.180
o zaman

01:33:56.180 --> 01:33:57.240
buraya geri döneceğiz

01:33:57.240 --> 01:33:58.980
kaynağı çalınmış

01:33:58.980 --> 01:33:59.540
nesne

01:33:59.540 --> 01:34:00.840
in a valid state

01:34:00.840 --> 01:34:02.340
geçerli bir değerde

01:34:02.340 --> 01:34:03.560
invariantları

01:34:03.560 --> 01:34:03.980
tutuyor

01:34:03.980 --> 01:34:05.080
invariantlarının

01:34:05.080 --> 01:34:05.880
tutması ne demek

01:34:05.880 --> 01:34:06.920
mesela

01:34:06.920 --> 01:34:08.200
uzunluk değeri

01:34:08.200 --> 01:34:08.740
gerçekten

01:34:08.740 --> 01:34:09.200
yazının

01:34:09.200 --> 01:34:10.200
uzunluk değeri

01:34:10.200 --> 01:34:11.760
stringin

01:34:11.760 --> 01:34:13.000
tuttuğu yazı

01:34:13.000 --> 01:34:13.940
necati yazısı

01:34:13.940 --> 01:34:14.200
ise

01:34:14.200 --> 01:34:14.780
uzunluğu

01:34:14.780 --> 01:34:15.100
6

01:34:15.100 --> 01:34:16.660
stringin

01:34:16.660 --> 01:34:17.580
tuttuğu nesne

01:34:17.580 --> 01:34:18.400
boş yazı

01:34:18.400 --> 01:34:18.600
ise

01:34:18.600 --> 01:34:18.920
yazı

01:34:18.920 --> 01:34:19.480
boş yazı

01:34:19.480 --> 01:34:19.680
ise

01:34:19.680 --> 01:34:20.260
uzunluğu

01:34:20.260 --> 01:34:20.660
0

01:34:20.660 --> 01:34:22.340
takip edebiliyor muyuz

01:34:22.340 --> 01:34:23.180
boş yazı

01:34:23.180 --> 01:34:23.700
tutuyorsa

01:34:23.700 --> 01:34:24.760
empty fonksiyonu

01:34:24.760 --> 01:34:25.760
true döndürecek

01:34:25.760 --> 01:34:26.220
gibi

01:34:26.220 --> 01:34:27.820
nesnenin

01:34:27.820 --> 01:34:28.760
destroy edilmesine

01:34:28.760 --> 01:34:29.680
bir problem yok

01:34:29.680 --> 01:34:30.100
ama

01:34:30.100 --> 01:34:30.940
en önemli

01:34:30.940 --> 01:34:31.560
garantiye

01:34:31.560 --> 01:34:32.040
bakalım

01:34:32.040 --> 01:34:32.980
buraya

01:34:32.980 --> 01:34:33.600
dikkat

01:34:33.600 --> 01:34:34.640
arkadaşlar

01:34:34.640 --> 01:34:36.280
nesneye

01:34:36.280 --> 01:34:37.980
yeni bir

01:34:37.980 --> 01:34:38.480
değer

01:34:38.480 --> 01:34:39.920
atayarak

01:34:39.920 --> 01:34:41.520
tekrar

01:34:41.520 --> 01:34:42.640
kullanabiliriz

01:34:42.640 --> 01:34:44.460
onu

01:34:44.460 --> 01:34:45.760
tekrar

01:34:45.760 --> 01:34:47.360
kullanabiliriz

01:34:47.360 --> 01:34:48.340
işte

01:34:48.340 --> 01:34:49.140
standart

01:34:49.140 --> 01:34:49.920
kütüphanenin

01:34:49.920 --> 01:34:51.840
move from state

01:34:51.840 --> 01:34:52.660
teki nesneler

01:34:52.660 --> 01:34:52.920
için

01:34:52.920 --> 01:34:53.360
verdiği

01:34:53.360 --> 01:34:53.940
garanti bu

01:34:53.940 --> 01:34:54.800
bir kez daha

01:34:54.800 --> 01:34:55.900
tekrar edelim mi

01:34:55.900 --> 01:34:57.560
move from state

01:34:57.560 --> 01:34:58.000
teki

01:34:58.000 --> 01:34:59.220
nesnenin

01:34:59.220 --> 01:34:59.940
değerinin

01:34:59.940 --> 01:35:01.140
ne olacağı

01:35:01.140 --> 01:35:01.880
değerliyiciye

01:35:01.880 --> 01:35:02.260
bağlı

01:35:02.260 --> 01:35:03.560
ama

01:35:03.560 --> 01:35:03.940
nesne

01:35:03.940 --> 01:35:04.420
geçerli

01:35:04.420 --> 01:35:05.020
bir durumda

01:35:05.020 --> 01:35:05.700
yani

01:35:05.700 --> 01:35:06.340
o değeri

01:35:06.340 --> 01:35:08.380
kullanabilirim

01:35:08.380 --> 01:35:09.020
işime

01:35:09.020 --> 01:35:09.600
geliyorsa

01:35:09.600 --> 01:35:10.840
anlaşıldı

01:35:10.840 --> 01:35:11.280
değil mi

01:35:11.280 --> 01:35:12.460
o değeri

01:35:12.460 --> 01:35:13.120
kullanmak

01:35:13.120 --> 01:35:13.620
herhangi bir

01:35:13.620 --> 01:35:13.860
şekilde

01:35:13.860 --> 01:35:14.620
bir tanımsız

01:35:14.620 --> 01:35:15.160
davranış

01:35:15.160 --> 01:35:15.580
değil

01:35:15.580 --> 01:35:16.900
mesela

01:35:16.900 --> 01:35:17.580
nesnenin

01:35:17.580 --> 01:35:18.020
tuttuğu

01:35:18.020 --> 01:35:18.280
değer

01:35:18.280 --> 01:35:18.880
halen

01:35:18.880 --> 01:35:19.980
fatih

01:35:19.980 --> 01:35:20.400
yazısı

01:35:20.400 --> 01:35:20.820
ise

01:35:20.820 --> 01:35:21.960
onun

01:35:21.960 --> 01:35:22.700
yazının

01:35:22.700 --> 01:35:23.120
iki

01:35:23.120 --> 01:35:23.800
indekste

01:35:23.800 --> 01:35:25.100
karakterinin

01:35:25.100 --> 01:35:26.400
arkadaşlar

01:35:26.400 --> 01:35:27.900
t

01:35:27.900 --> 01:35:28.440
olduğu

01:35:28.440 --> 01:35:28.960
garanti

01:35:28.960 --> 01:35:29.480
altında

01:35:29.480 --> 01:35:30.860
nesneye

01:35:30.860 --> 01:35:31.160
yenide

01:35:31.160 --> 01:35:31.860
yer atarsak

01:35:31.860 --> 01:35:32.840
invariantlarının

01:35:32.840 --> 01:35:33.600
durumu ne olur

01:35:33.600 --> 01:35:33.980
yine

01:35:33.980 --> 01:35:34.820
invariantlar

01:35:34.820 --> 01:35:35.640
ingilizcesi

01:35:35.640 --> 01:35:36.320
hold eder

01:35:36.320 --> 01:35:36.620
yani

01:35:36.620 --> 01:35:37.340
invariantlar

01:35:37.340 --> 01:35:37.860
yine doğru

01:35:37.860 --> 01:35:38.600
durumda olur

01:35:38.600 --> 01:35:39.480
yani

01:35:39.480 --> 01:35:40.240
bozulmaz

01:35:40.240 --> 01:35:42.120
anlaşıldı mı

01:35:42.120 --> 01:35:43.120
şimdi

01:35:43.120 --> 01:35:43.600
nedense

01:35:43.600 --> 01:35:44.120
burayı

01:35:44.120 --> 01:35:45.140
genelde kitaplar

01:35:45.140 --> 01:35:46.100
yanlış anlatıyor

01:35:46.100 --> 01:35:46.840
ve hep

01:35:46.840 --> 01:35:47.080
şunu

01:35:47.080 --> 01:35:47.640
görüyorum

01:35:47.640 --> 01:35:48.620
arkadaşlar

01:35:48.620 --> 01:35:49.900
move from state

01:35:49.900 --> 01:35:50.720
teki nesneyi

01:35:50.720 --> 01:35:51.280
kullanmak

01:35:51.280 --> 01:35:51.840
tanımsız

01:35:51.840 --> 01:35:52.360
davranış

01:35:52.360 --> 01:35:52.980
alakası

01:35:52.980 --> 01:35:53.500
böyle bir şey

01:35:53.500 --> 01:35:53.720
yok

01:35:53.720 --> 01:35:54.680
kim uydurmuşsa

01:35:54.680 --> 01:35:55.760
anlaşıldı

01:35:55.760 --> 01:35:56.160
değil mi

01:35:56.160 --> 01:35:57.380
hatta tam

01:35:57.380 --> 01:35:58.320
tersi

01:35:58.320 --> 01:35:59.000
şimdi bir örnek

01:35:59.000 --> 01:36:00.700
saatte 21.07

01:36:00.700 --> 01:36:01.120
olmuş

01:36:01.120 --> 01:36:01.780
ara vermeyi

01:36:01.780 --> 01:36:02.460
de unutmuşum

01:36:02.460 --> 01:36:03.720
ara verdikten

01:36:03.720 --> 01:36:04.080
sonra

01:36:04.080 --> 01:36:05.180
bir kod örneği

01:36:05.180 --> 01:36:06.040
göstereceğim

01:36:06.040 --> 01:36:07.040
kod review'larda

01:36:07.040 --> 01:36:07.540
beni çok

01:36:07.540 --> 01:36:08.360
sık karşıma

01:36:08.360 --> 01:36:08.800
çıkıyor

01:36:08.800 --> 01:36:10.000
mesela

01:36:10.000 --> 01:36:11.320
arkadaşlar

01:36:11.320 --> 01:36:12.760
kaynağı

01:36:12.760 --> 01:36:13.360
bilerek

01:36:13.360 --> 01:36:13.960
isteyerek

01:36:13.960 --> 01:36:14.900
çalmanın

01:36:14.900 --> 01:36:16.240
yani

01:36:16.240 --> 01:36:17.120
nesneyi

01:36:17.120 --> 01:36:17.520
hayatta

01:36:17.520 --> 01:36:18.020
tutarak

01:36:18.020 --> 01:36:18.640
kaynağını

01:36:18.640 --> 01:36:19.540
çalmanın

01:36:19.540 --> 01:36:20.140
çok tipik

01:36:20.140 --> 01:36:20.660
bir örneğini

01:36:20.660 --> 01:36:21.180
vereceğim

01:36:21.180 --> 01:36:22.540
ama önce

01:36:22.540 --> 01:36:22.900
bir ara

01:36:22.900 --> 01:36:23.280
verelim

01:36:23.280 --> 01:36:23.780
isterseniz

01:36:23.780 --> 01:36:25.440
saat 21.08

01:36:25.440 --> 01:36:27.740
21.25

01:36:27.740 --> 01:36:28.240
de devam

01:36:28.240 --> 01:36:28.660
edelim

01:36:28.660 --> 01:36:36.820
arkadaşlar

01:36:36.820 --> 01:36:37.580
şimdi sorulan

01:36:37.580 --> 01:36:38.220
bir soru var

01:36:38.220 --> 01:36:39.180
önce ona bir cevap

01:36:39.180 --> 01:36:39.520
vereyim

01:36:39.520 --> 01:36:41.320
hocam az önceki örnekte

01:36:41.320 --> 01:36:42.200
taşıdığımızda

01:36:42.200 --> 01:36:43.200
null pointer

01:36:43.200 --> 01:36:44.100
ataması yaptık

01:36:44.100 --> 01:36:44.840
ya da erişmeye

01:36:44.840 --> 01:36:45.600
çalıştığımızda

01:36:45.600 --> 01:36:46.240
null pointer

01:36:46.240 --> 01:36:46.980
d referans

01:36:46.980 --> 01:36:47.320
etmiş

01:36:47.320 --> 01:36:48.120
olmaz mıyız

01:36:48.120 --> 01:36:49.420
arkadaşlar

01:36:49.420 --> 01:36:50.000
ben sadece

01:36:50.000 --> 01:36:51.120
kodun bir kısmını

01:36:51.120 --> 01:36:51.760
gösterdim

01:36:51.760 --> 01:36:52.460
sınıfın

01:36:52.460 --> 01:36:52.960
tamamını

01:36:52.960 --> 01:36:53.520
implemente

01:36:53.520 --> 01:36:53.960
etmedim

01:36:53.960 --> 01:36:54.860
ama

01:36:54.860 --> 01:36:55.800
standart

01:36:55.800 --> 01:36:56.460
kütüphanenin

01:36:56.460 --> 01:36:57.500
string sınıfı

01:36:57.500 --> 01:36:57.920
gibi

01:36:57.920 --> 01:36:58.980
mood

01:36:58.980 --> 01:36:59.740
from state

01:36:59.740 --> 01:37:00.140
deki

01:37:00.140 --> 01:37:00.700
string

01:37:00.700 --> 01:37:01.300
nesneleri

01:37:01.300 --> 01:37:01.840
için

01:37:01.840 --> 01:37:03.500
az önce

01:37:03.500 --> 01:37:04.340
bahsettiğim

01:37:04.340 --> 01:37:05.260
garantileri

01:37:05.260 --> 01:37:05.660
veriyor

01:37:05.660 --> 01:37:06.480
olsaydım

01:37:06.480 --> 01:37:07.780
sizin dediğiniz

01:37:07.780 --> 01:37:07.960
gibi

01:37:07.960 --> 01:37:08.620
hiçbir problem

01:37:08.620 --> 01:37:09.580
olmayacaktı

01:37:09.580 --> 01:37:10.420
ama ben

01:37:10.420 --> 01:37:10.940
gerçek bir

01:37:10.940 --> 01:37:11.860
implementasyon

01:37:11.860 --> 01:37:12.660
yapmadım

01:37:12.660 --> 01:37:14.000
ama örneğin

01:37:14.000 --> 01:37:14.340
bir şey

01:37:14.340 --> 01:37:14.920
dikkatinizi

01:37:14.920 --> 01:37:15.560
çekti mi

01:37:15.560 --> 01:37:16.720
en azından

01:37:16.720 --> 01:37:17.580
kodu

01:37:17.580 --> 01:37:18.900
kopyalamadık

01:37:18.900 --> 01:37:19.340
sanıyorum

01:37:19.340 --> 01:37:20.360
en son haliyle

01:37:20.360 --> 01:37:21.640
ama en azından

01:37:21.640 --> 01:37:22.580
şunu yaptık

01:37:22.580 --> 01:37:23.480
olsan

01:37:23.480 --> 01:37:24.980
orada

01:37:24.980 --> 01:37:25.660
zaten

01:37:25.660 --> 01:37:26.160
vurgu

01:37:26.160 --> 01:37:26.800
onun için

01:37:26.800 --> 01:37:27.280
yaptım

01:37:27.280 --> 01:37:28.020
buraya bakın

01:37:28.020 --> 01:37:29.600
dikkat ederseniz

01:37:29.600 --> 01:37:30.260
other'ın

01:37:30.260 --> 01:37:31.120
emlenini de

01:37:31.120 --> 01:37:32.060
sıfır yaptım

01:37:32.060 --> 01:37:33.260
yani

01:37:33.260 --> 01:37:33.820
bu

01:37:33.820 --> 01:37:34.640
move assignment

01:37:34.640 --> 01:37:35.220
ya da

01:37:35.220 --> 01:37:35.640
move

01:37:35.640 --> 01:37:36.260
constructor

01:37:36.260 --> 01:37:37.440
çağrıldığında

01:37:37.440 --> 01:37:38.480
mood

01:37:38.480 --> 01:37:39.080
from state

01:37:39.080 --> 01:37:39.340
teki

01:37:39.340 --> 01:37:40.080
nesneyi

01:37:40.080 --> 01:37:40.980
benim kodum

01:37:40.980 --> 01:37:42.000
mp

01:37:42.000 --> 01:37:42.700
pointer'ını

01:37:42.700 --> 01:37:43.360
null pointer

01:37:43.360 --> 01:37:43.840
yaptı

01:37:43.840 --> 01:37:44.600
emleni

01:37:44.600 --> 01:37:45.340
arkadaşlar

01:37:45.340 --> 01:37:46.980
sıfır yaptı

01:37:46.980 --> 01:37:47.500
şimdi

01:37:47.500 --> 01:37:48.860
ben eğer

01:37:48.860 --> 01:37:50.200
diğer fonksiyonları

01:37:50.200 --> 01:37:51.500
çağırsaydım

01:37:51.500 --> 01:37:52.760
örneğin

01:37:52.760 --> 01:37:54.760
empty fonksiyonu

01:37:54.760 --> 01:37:56.120
emlen sıfırsa

01:37:56.120 --> 01:37:57.760
empty burada

01:37:57.760 --> 01:37:58.580
is empty

01:37:58.580 --> 01:37:59.100
anlamında

01:37:59.100 --> 01:38:00.000
yani boş mu

01:38:00.000 --> 01:38:00.820
anlamında

01:38:00.820 --> 01:38:01.480
true değer

01:38:01.480 --> 01:38:02.320
dönecekti

01:38:02.320 --> 01:38:04.380
yani diğer fonksiyonların

01:38:04.380 --> 01:38:05.460
çağrılmasında

01:38:05.460 --> 01:38:06.460
herhangi bir problem

01:38:06.460 --> 01:38:07.580
oluşmayacaktı

01:38:07.580 --> 01:38:08.140
sadece

01:38:08.140 --> 01:38:09.320
ne diyor

01:38:09.320 --> 01:38:10.180
standart

01:38:10.180 --> 01:38:11.660
mood from state

01:38:11.660 --> 01:38:12.580
teki nesnenin

01:38:12.580 --> 01:38:12.740
diyor

01:38:12.740 --> 01:38:13.660
değeri konusunda

01:38:13.660 --> 01:38:14.740
garanti vermiyorum

01:38:14.740 --> 01:38:16.080
mesela şöyle

01:38:16.080 --> 01:38:16.880
olabilir mi

01:38:16.880 --> 01:38:17.840
güzel bir soru

01:38:17.840 --> 01:38:18.960
şöyle olabilir mi

01:38:18.960 --> 01:38:20.060
standart

01:38:20.060 --> 01:38:20.640
kütüphanliğin

01:38:20.640 --> 01:38:21.400
string sınıfından

01:38:21.400 --> 01:38:22.200
bahsediyorum

01:38:22.200 --> 01:38:23.580
nesnenin

01:38:23.580 --> 01:38:25.200
tuttuğu yazı

01:38:25.200 --> 01:38:26.260
Oğuzhan Esin

01:38:26.260 --> 01:38:27.160
yazısıydı

01:38:27.160 --> 01:38:28.140
onun

01:38:28.140 --> 01:38:28.920
kaynağını

01:38:28.920 --> 01:38:29.660
çaldım

01:38:29.660 --> 01:38:30.900
fakat

01:38:30.900 --> 01:38:31.620
o kaynağa

01:38:31.620 --> 01:38:32.180
çalınmış

01:38:32.180 --> 01:38:33.740
nesnenin

01:38:33.740 --> 01:38:34.660
tuttuğu yazıyı

01:38:34.660 --> 01:38:35.860
ekrana yazdırdığımda

01:38:35.860 --> 01:38:37.000
yine Oğuzhan Esin

01:38:37.000 --> 01:38:37.660
yazdırıyor

01:38:37.660 --> 01:38:38.380
böyle bir durum

01:38:38.380 --> 01:38:39.080
olabilir mi

01:38:39.080 --> 01:38:39.620
olabilir

01:38:39.620 --> 01:38:41.020
bu durumda

01:38:41.020 --> 01:38:41.680
bir yanlışlık

01:38:41.680 --> 01:38:42.220
var mı

01:38:42.220 --> 01:38:42.700
yok

01:38:42.700 --> 01:38:43.720
ama

01:38:43.720 --> 01:38:44.400
eğer

01:38:44.400 --> 01:38:44.980
gerçekten

01:38:44.980 --> 01:38:45.660
örneğin

01:38:45.660 --> 01:38:47.420
Oğuzhan Esin

01:38:47.420 --> 01:38:47.920
yazısını

01:38:47.920 --> 01:38:48.760
yazdırıyorsa

01:38:48.760 --> 01:38:49.380
o zaman

01:38:49.380 --> 01:38:50.440
length fonksiyonunu

01:38:50.440 --> 01:38:51.340
çağırdığımda

01:38:51.340 --> 01:38:52.680
Oğuzhan Esin

01:38:52.680 --> 01:38:53.120
yazısının

01:38:53.120 --> 01:38:53.720
uzunluğunu

01:38:53.720 --> 01:38:54.460
göndürecek

01:38:54.460 --> 01:38:56.220
köşeli parantez

01:38:56.220 --> 01:38:57.220
fonksiyonuyla

01:38:57.220 --> 01:38:58.660
operatör fonksiyonuyla

01:38:58.660 --> 01:38:59.520
örneğin yazının

01:38:59.520 --> 01:39:00.720
ilk karakterine

01:39:00.720 --> 01:39:01.860
eriştiğimde

01:39:01.860 --> 01:39:02.440
o karakter

01:39:02.440 --> 01:39:03.720
O olmak zorunda

01:39:03.720 --> 01:39:04.620
yazının

01:39:04.620 --> 01:39:05.680
üçüncü karakterine

01:39:05.680 --> 01:39:06.240
eriştiğimde

01:39:06.240 --> 01:39:06.780
o karakter

01:39:06.780 --> 01:39:08.120
U olmak zorunda

01:39:08.120 --> 01:39:10.000
unspecified

01:39:10.000 --> 01:39:10.860
valid

01:39:10.860 --> 01:39:12.480
but unspecified

01:39:12.480 --> 01:39:13.240
value

01:39:13.240 --> 01:39:14.360
ama o değer

01:39:14.360 --> 01:39:15.120
geçerli olacak

01:39:15.120 --> 01:39:15.420
şimdi

01:39:15.420 --> 01:39:16.960
eğer herkes

01:39:16.960 --> 01:39:17.600
gelmişse

01:39:17.600 --> 01:39:17.840
evet

01:39:17.840 --> 01:39:18.660
saatte saatte

01:39:18.660 --> 01:39:19.400
21-27

01:39:19.400 --> 01:39:20.000
olmuş

01:39:20.000 --> 01:39:21.220
şimdi ben

01:39:21.220 --> 01:39:23.060
bir örnek

01:39:23.060 --> 01:39:24.120
kod yazmak istiyorum

01:39:24.120 --> 01:39:24.960
bunu gösteren

01:39:24.960 --> 01:39:25.720
Necati

01:39:25.720 --> 01:39:27.000
Yusuf'un

01:39:27.000 --> 01:39:27.440
sorusu

01:39:27.440 --> 01:39:28.200
kaynakları

01:39:28.200 --> 01:39:29.280
çalan nesne

01:39:29.280 --> 01:39:31.200
yok edilirse

01:39:31.200 --> 01:39:32.640
mood from state

01:39:32.640 --> 01:39:33.500
statüsündeki

01:39:33.500 --> 01:39:34.520
olan nesne

01:39:34.520 --> 01:39:35.360
etkilenir mi

01:39:35.360 --> 01:39:35.840
hayır

01:39:35.840 --> 01:39:36.720
hayır

01:39:36.720 --> 01:39:38.340
onun kaynağını

01:39:38.340 --> 01:39:39.340
çalmış olmam

01:39:39.340 --> 01:39:41.200
bu ikisi arasında

01:39:41.200 --> 01:39:42.300
bir bağlantı

01:39:42.300 --> 01:39:43.160
olduğu anlamına

01:39:43.160 --> 01:39:43.660
gelmiyor

01:39:43.660 --> 01:39:44.560
bunlar yine

01:39:44.560 --> 01:39:45.580
bütün atama

01:39:45.580 --> 01:39:46.820
kopyalama işlemlerinde

01:39:46.820 --> 01:39:47.520
olduğu gibi

01:39:47.520 --> 01:39:49.320
yine birbirinden

01:39:49.320 --> 01:39:50.020
bağımsız

01:39:50.020 --> 01:39:50.720
nesneler

01:39:50.720 --> 01:39:52.120
anlaşıldı

01:39:52.120 --> 01:39:52.420
değil mi

01:39:52.420 --> 01:39:53.240
yani kaynağını

01:39:53.240 --> 01:39:54.220
çalan nesnede

01:39:54.220 --> 01:39:54.980
bir değişiklik

01:39:54.980 --> 01:39:55.460
olması

01:39:55.460 --> 01:39:56.580
Yusuf Bey'in

01:39:56.580 --> 01:39:57.280
sorusunu doğru

01:39:57.280 --> 01:39:57.960
anlamışsam

01:39:57.960 --> 01:39:59.080
kaynağa

01:39:59.080 --> 01:40:00.160
çalınan nesnede

01:40:00.160 --> 01:40:00.860
bir değişiklik

01:40:00.860 --> 01:40:01.280
olacağı

01:40:01.280 --> 01:40:01.800
anlamına

01:40:01.800 --> 01:40:02.420
gelmiyor

01:40:02.420 --> 01:40:03.620
arkadaşlar

01:40:03.620 --> 01:40:04.340
bakın şimdi

01:40:04.340 --> 01:40:05.700
yazacağım

01:40:05.700 --> 01:40:06.180
kod

01:40:06.180 --> 01:40:08.220
sizin bilmediğiniz

01:40:08.220 --> 01:40:09.140
öğeler içeriyor

01:40:09.140 --> 01:40:09.680
olacak

01:40:09.680 --> 01:40:11.100
yani en azından

01:40:11.100 --> 01:40:12.560
bu kursa katılmadan

01:40:12.560 --> 01:40:13.480
önce C++

01:40:13.480 --> 01:40:14.700
öğrenmediyseniz

01:40:14.700 --> 01:40:16.140
dolayısıyla

01:40:16.140 --> 01:40:18.080
kodu yazmamı

01:40:18.080 --> 01:40:18.700
bekleyin

01:40:18.700 --> 01:40:19.360
ve soruyu

01:40:19.360 --> 01:40:19.860
sormamı

01:40:19.860 --> 01:40:20.400
bekleyin

01:40:20.400 --> 01:40:21.460
anlamadığınız

01:40:21.460 --> 01:40:22.200
kısımları

01:40:22.200 --> 01:40:23.280
herhangi bir şekilde

01:40:23.280 --> 01:40:25.580
dikkate almayın

01:40:36.180 --> 01:41:05.480
o da açıklayacağım

01:41:05.480 --> 01:41:06.440
merak etmeyin

01:41:06.440 --> 01:41:06.500
merak etmeyin

01:41:06.500 --> 01:41:07.500
bekleyin

01:41:07.500 --> 01:41:22.880
aboneanni

01:41:22.880 --> 01:41:24.940
evet

01:41:24.940 --> 01:41:54.920
Altyazı M.K.

01:41:54.940 --> 01:42:24.920
Altyazı M.K.

01:42:24.940 --> 01:42:26.940
Altyazı M.K.

01:42:26.940 --> 01:42:28.940
Altyazı M.K.

01:42:28.940 --> 01:42:30.940
Altyazı M.K.

01:42:30.940 --> 01:42:32.940
Altyazı M.K.

01:42:32.940 --> 01:42:34.940
Altyazı M.K.

01:42:34.940 --> 01:42:36.940
Altyazı M.K.

01:42:36.940 --> 01:42:38.940
Altyazı M.K.

01:42:38.940 --> 01:42:43.240
Burada programçı şunu yapmak istiyor arkadaşlar.

01:42:44.080 --> 01:42:46.920
Bir dosyayı, tekst dosyasını açacak.

01:42:47.580 --> 01:42:51.020
Dosyadan satır satır okuma yapacak.

01:42:51.980 --> 01:42:55.440
Bunu C kodu olarak da yazmayı bildiğinizi varsayıyorum.

01:42:56.160 --> 01:43:00.880
Ve dosyadan okuduğu satırları string nesnelerinde tutacak.

01:43:00.880 --> 01:43:06.140
Ve bu string nesnelerinde bir dinamik diziye koyacak.

01:43:06.880 --> 01:43:26.340
Yani bu kod çalıştığı zaman Svec aslında dinamik dizi, elemanları string olan dinamik dizi ve Svec'in elemanları olan stringler ismi text.txt olan dosyadaki, text dosyasındaki satırları tutuyor.

01:43:26.340 --> 01:43:29.440
Buraya kadar yaptığım açıklamayı anladınız mı?

01:43:29.980 --> 01:43:32.880
Önce buna kodu anladınız mı diye sormuyorum.

01:43:33.060 --> 01:43:36.200
Ne yapıldığı konusunda yaptığım açıklamayı anladınız mı?

01:43:38.360 --> 01:43:40.620
Evet en az bir arkadaşım cevap verirse.

01:43:41.320 --> 01:43:42.240
Kaveh yes diyor.

01:43:42.480 --> 01:43:43.640
Evet herkes anladınız.

01:43:43.720 --> 01:43:44.060
Süper.

01:43:45.120 --> 01:43:52.500
Ama tabii arkadaşlar kodu detaylı olarak açıklasaydım bir sürü başka konuya gönderme yapacaktım.

01:43:53.380 --> 01:43:55.500
Şimdi bu arada şunu da konuşalım.

01:43:56.340 --> 01:44:01.460
Buradaki sınıf nesnelerinin tek tek bana gösterir misiniz?

01:44:01.820 --> 01:44:04.860
Bu sorunun şu andaki konumuzla alakası yok.

01:44:04.940 --> 01:44:06.740
Bir tekrar yapmak amaçlı tahmin.

01:44:07.480 --> 01:44:10.280
Mesela IFS bir sınıf nesnesi mi?

01:44:11.200 --> 01:44:12.000
Cevap.

01:44:12.400 --> 01:44:12.660
Evet.

01:44:14.660 --> 01:44:17.300
CRR bir sınıf nesnesi mi?

01:44:17.480 --> 01:44:18.600
Tahmin etmenizi istiyorum.

01:44:18.700 --> 01:44:19.480
Bilmenizi değil.

01:44:19.660 --> 01:44:19.940
Evet.

01:44:20.700 --> 01:44:22.440
Svec bir sınıf nesnesi mi?

01:44:23.660 --> 01:44:24.000
Evet.

01:44:24.000 --> 01:44:26.520
Sline bir sınıf nesnesi mi?

01:44:27.180 --> 01:44:27.400
Evet.

01:44:27.560 --> 01:44:36.400
Bakın gerçekten burada gerek Sline, Svec, IFS, CRR bunların hepsi bir arı sınıflar türünden nesneler.

01:44:36.400 --> 01:44:43.380
Ama şimdi kodun aslında anlamanızı istediğim kısmı burası.

01:44:44.520 --> 01:44:46.760
Arkadaşlar söyleyin bakalım.

01:44:47.160 --> 01:44:50.080
Az önce ben pushback fonksiyonunu anlatmıştım.

01:44:50.700 --> 01:44:55.840
Amacım vektör sınıfını anlatmak değildi ama ne dedim size pushback'in iki tane overloadu var.

01:44:55.840 --> 01:45:04.100
Biri argüman olarak aldığı stringi taşıyarak konteyner'a koyuyor.

01:45:04.460 --> 01:45:07.140
Diğeri kopyalayarak konteyner'a koyuyor.

01:45:07.140 --> 01:45:16.180
Şimdi kafanızda benim cümlelerime uygun şekilde bir görüntü oluşturmaya çalışın.

01:45:16.260 --> 01:45:22.600
Bu öyle bir tekst dosyası ki bu tekst dosyasındaki her bir satır çok uzun.

01:45:22.820 --> 01:45:25.980
Beş bin karakter, iki bin karakter, on bin karakter.

01:45:25.980 --> 01:45:41.760
Arkadaşlar söyleyin bakalım burada az önce söylediğim overloadlardan arkadaşlar parametresi const string ref olan pushback mi çalışacak yoksa string ref ref olan mı çalışacak?

01:45:41.860 --> 01:45:42.260
Hangisi?

01:45:45.840 --> 01:45:48.880
Cevap copy const string ref.

01:45:49.760 --> 01:45:50.240
Neden?

01:45:50.680 --> 01:45:52.220
Çünkü lvalue expression.

01:45:52.220 --> 01:45:57.000
O zaman bu kodun şöyle çalıştığını varsayabilir miyiz?

01:45:57.980 --> 01:46:03.100
Dosyadan okuduğumuz sline'ı okuduğumuz o okuma işini getline fonksiyonu yapıyor.

01:46:04.300 --> 01:46:12.900
Dosyadan file'dan sline'ı okuduğumuz her bir stringin kopyasını çıkartarak konteyner'a koyuyor.

01:46:13.560 --> 01:46:16.920
Yani her satır için bir kopyalama yapılıyor.

01:46:16.920 --> 01:46:30.460
Mesela ilk okuduğumuz satırda Cengiz Han beş bin karakterlik bir yazı varsa konteyner'ımıza onu koyarken string sınıfının copy constructor'ı mı çağırılacak?

01:46:30.620 --> 01:46:31.660
Move constructor'ı mı?

01:46:33.100 --> 01:46:36.040
Cevap copy constructor'ı çağırılacak.

01:46:36.160 --> 01:46:36.420
Bravo.

01:46:36.420 --> 01:46:43.640
Copy constructor'ın çağırılması demek o beş bin karakterlik bellek alanını allocate edecek.

01:46:44.500 --> 01:46:47.600
Diğerinden buraya kopyalama yapacak, deep copy yapacak.

01:46:47.600 --> 01:47:08.280
Peki şimdi söyleyin eğer sline yani argüman olan ifade sağ taraf değeri olsaydı, rvalue expression olsaydı bu sefer o dosyadan her satıra okuduğunda onu kopyasını çıkartmak yerine taşıma yapacaktı değil mi?

01:47:09.040 --> 01:47:10.800
Kesinlikle burayı anlıyor musunuz?

01:47:10.800 --> 01:47:21.280
Peki bir dakika ama burada döngünün bir sonraki turuna geçtiğimde ben mood from state'de olan sline'ı kullanmış oluyorum değil mi?

01:47:22.380 --> 01:47:35.920
Eğer şimdi o yanlış anlatan arkadaşların dediği doğru olsaydı mood from state'deki sline nesnesini kullanmam tanımsız davranışa yol açsaydı bu kodda undefined behavior olurdu değil mi?

01:47:35.920 --> 01:47:39.960
Oysa bu kodda undefined behavior var mı? Yok.

01:47:40.120 --> 01:47:50.400
Çünkü standart kütüphanemizin string sınıfı mood from state'deki nesneye yeni bir değer atanmasını, yeni bir değer yüklenmesini mümkün kılıyor değil mi?

01:47:50.440 --> 01:47:51.840
Bu garanti veriyor değil mi?

01:47:53.100 --> 01:47:54.560
Bu soru size de sorulabilir.

01:47:55.180 --> 01:47:58.520
O zaman soruda neyin sorgulandığını anladınız değil mi?

01:47:58.600 --> 01:48:00.420
Siz de deneyin bu kodu gösterin.

01:48:01.080 --> 01:48:03.800
Bu kodda herhangi bir problem ya da bir eksiklik var mı?

01:48:03.800 --> 01:48:05.240
Yorum yapmasını isteyin.

01:48:05.840 --> 01:48:10.020
Gerçekten bakın mülakatlara katlanan PPP bunlar da yeni başlayanlar değil.

01:48:10.580 --> 01:48:17.720
Arkadaşlar 4-5 senedir belki C++ kodu yazanlar dahi bu koddaki eksik noktayı göremiyorlar.

01:48:18.340 --> 01:48:21.600
Ama arada çok ciddi bir performans farkı var.

01:48:22.480 --> 01:48:23.360
Anlaşıldı değil mi?

01:48:24.000 --> 01:48:24.680
Oysa nesin?

01:48:24.920 --> 01:48:27.880
Hocam bu sınıfların bu garantiyi verdiğine nasıl emin oluruz?

01:48:28.400 --> 01:48:31.260
Hepsini böyle kabul ederek yazmamızda bir sakınca olur mu?

01:48:31.380 --> 01:48:32.480
Çok çok güzel bir soru.

01:48:32.480 --> 01:48:34.280
Çok güzel bir soru.

01:48:34.960 --> 01:48:38.860
Bu sınıfların bu garantiyi verdiğini bize standart söylüyor.

01:48:39.200 --> 01:48:40.960
C++ standartı söylüyor.

01:48:41.860 --> 01:48:43.740
Dolayısıyla yanlış anlaşılmasın.

01:48:44.280 --> 01:48:51.160
Mesela 3. parti bir kütüphanedeki bir sınıfında bu garantiyi verdiğinden emin olabilir misiniz?

01:48:51.500 --> 01:48:51.760
Hayır.

01:48:52.840 --> 01:48:54.420
Ama genelde eğilim şu.

01:48:55.100 --> 01:48:59.580
Eğer doğru bir şekilde dokümante edilmişse bunu bildirir.

01:49:00.240 --> 01:49:01.240
Bildirmesi lazım.

01:49:01.240 --> 01:49:07.980
Yani örneğin move from state'teki nesnenin invalid state'te olduğunu yazması gerekir.

01:49:08.500 --> 01:49:09.680
Anlaşıldı değil mi?

01:49:10.220 --> 01:49:14.800
Yani sınıfın uygun şekilde dokümante edilmesi gerekir.

01:49:15.520 --> 01:49:20.120
Standart kütüphanenin konteyner sınıfları için bu garanti kesinlikle veriliyor.

01:49:20.340 --> 01:49:21.620
Vektör sınıfı için.

01:49:22.220 --> 01:49:23.280
String sınıfı için.

01:49:23.280 --> 01:49:26.900
Ama bakın verilmeyen bir garantiyi söyleyeyim.

01:49:27.400 --> 01:49:28.120
Buraya dikkat.

01:49:28.660 --> 01:49:30.980
Verilmeyen bir garantiyi söyleyeyim.

01:49:31.460 --> 01:49:33.220
Şimdi burada bir string teslim olsa.

01:49:33.580 --> 01:49:34.440
String sınıfı için.

01:49:34.980 --> 01:49:36.560
Lütfen bunu genelleştirmeyin.

01:49:36.720 --> 01:49:38.340
Verdiğim örnek string sınıfı için.

01:49:38.340 --> 01:49:51.080
String str, Oğuzhan Esin ve Fatih Akgül C++ programcıları.

01:49:52.080 --> 01:49:54.400
Böyle bir yazı olsun arkadaşlar.

01:49:54.580 --> 01:49:55.820
Şimdi şöyle bir kod yazıyorum.

01:49:55.820 --> 01:50:01.700
Oto S eşittir move str.

01:50:02.980 --> 01:50:04.360
Takip edebiliyor muyuz?

01:50:05.000 --> 01:50:09.620
Peki şimdi standart kütüphane standart C++ standartı şunu mu söylüyor?

01:50:09.840 --> 01:50:11.540
String boş olmak zorunda.

01:50:12.760 --> 01:50:13.860
Böyle bir garanti var mı?

01:50:14.640 --> 01:50:14.900
Yok.

01:50:15.980 --> 01:50:18.140
String valid state'te olacak.

01:50:18.680 --> 01:50:22.420
Hadi bu valid state'in ne olduğunu ben size söyleyeyim arkadaşlar.

01:50:22.420 --> 01:50:27.580
Mesela S'in Length'i.

01:50:27.740 --> 01:50:33.420
String sınıfının Length ya da Size üye fonksiyonları tutulan yazının uzunluğunu döndürüyor.

01:50:38.080 --> 01:50:39.880
S demişim özür dilerim.

01:50:39.960 --> 01:50:40.420
String diyecektim.

01:50:41.880 --> 01:50:42.660
Yazdıralım.

01:50:42.960 --> 01:50:43.460
Arkadaşlar.

01:50:43.560 --> 01:50:46.140
String'in Length'i.

01:50:46.840 --> 01:50:47.920
Takip edebiliyor muyuz?

01:50:47.920 --> 01:50:48.420
Evet.

01:50:52.420 --> 01:50:56.880
Uzunluk kaçmış Oğuzhan?

01:50:57.820 --> 01:50:58.360
Sıfır.

01:50:58.880 --> 01:51:06.580
Yani benim implementasyonum move from state'teki string destesinin uzunluğunu ne olarak bırakmış?

01:51:07.100 --> 01:51:08.460
Cevap vermeye çalışan sıfır.

01:51:08.960 --> 01:51:10.000
Peki şimdi soru.

01:51:11.000 --> 01:51:18.780
Standart kütüphanenin verdiği garantiyle örneğin şöyle bir fonksiyon çağırsam arkadaşlar.

01:51:18.780 --> 01:51:26.700
Evet boş yazı.

01:51:27.500 --> 01:51:31.140
İpin doğru kısmına girme garantisi var mı?

01:51:31.220 --> 01:51:33.080
Empty fonksiyonu is empty anlamında.

01:51:33.200 --> 01:51:35.780
Yani yazı boş bu sorusuna cevap veriyor.

01:51:36.580 --> 01:51:37.120
Cevap.

01:51:37.760 --> 01:51:39.380
Evet arkadaşlar bu garanti var.

01:51:39.540 --> 01:51:42.820
Uzunluğu sıfırsa yazı da boş demektir.

01:51:42.820 --> 01:51:44.300
Ya da şu koda bakın.

01:51:44.400 --> 01:51:48.320
Şimdi valid state'ten ne anlaşıldığını daha iyi anlıyorsunuz değil mi?

01:51:48.420 --> 01:51:50.000
Mesela şöyle bir kod yazsam.

01:51:51.460 --> 01:51:53.600
String'in bunları öğreneceğiz.

01:51:54.140 --> 01:51:54.740
Arkadaşlar.

01:51:55.140 --> 01:51:56.780
String'in S demişim.

01:51:57.660 --> 01:51:58.220
STR.

01:51:58.620 --> 01:51:58.940
Bravo.

01:51:59.280 --> 01:52:00.220
Hatamı arkadaşlar.

01:52:00.220 --> 01:52:01.620
Bakınız.

01:52:02.100 --> 01:52:02.900
STR.

01:52:04.260 --> 01:52:05.220
Sadece izleyin.

01:52:06.260 --> 01:52:06.860
Arkadaşlar.

01:52:07.480 --> 01:52:09.440
Mesela böyle bir kod yazsam.

01:52:10.280 --> 01:52:14.400
Parantezin içinde hiçbir karakter olmayacağı garantisi var mı?

01:52:15.520 --> 01:52:15.860
Var.

01:52:16.280 --> 01:52:17.140
Anladınız değil mi?

01:52:17.140 --> 01:52:23.580
E çünkü STR madem uzunluğu sıfır.

01:52:23.700 --> 01:52:26.580
Uzunluğu sıfırsa boş olmak zorunda.

01:52:26.680 --> 01:52:27.560
Bu yazı da çıkacak.

01:52:27.760 --> 01:52:33.460
Uzunluğu sıfırsa yazıyı yazdırdığımda karakteri olmayan bir boş yazı olacak.

01:52:33.600 --> 01:52:34.480
Bakın derliyorum.

01:52:38.280 --> 01:52:39.000
Sıfır.

01:52:39.220 --> 01:52:40.360
Evet boş yazı dur.

01:52:40.360 --> 01:53:08.400
Peki diyelim ki implementasyon çok küçük bir ihtimal ama move from state'teki nesneyi halen bu değerle bırakmış olsaydı o zaman length fonksiyonunu çağırdığımda işte bu yazının uzunluğu kaçsa diyelim ki 58 58 döndürecekti burası false döndürecekti ve yazıyı yazdırdığımda bu yazı yazdırılacaktı.

01:53:08.400 --> 01:53:09.840
Şimdi her şey anlaşılıyor mu?

01:53:10.360 --> 01:53:13.460
Valid state'ten de kast edildiğini anlıyor musunuz?

01:53:13.900 --> 01:53:18.260
Ve bütün bunlardan sonra arkadaşlar devam ediyorum.

01:53:18.780 --> 01:53:28.200
Örneğin STR'ye barış doğa yavaş böyle bir atama yapsaydım.

01:53:29.200 --> 01:53:32.760
String sınıfını incelerken bütün bu fonksiyonları göreceğiz.

01:53:33.360 --> 01:53:35.960
Burada herhangi bir tanımsız davranış olacak mıydı?

01:53:35.960 --> 01:53:40.300
Muhammed barış herhangi bir tanımsız davranış olmayacaktı.

01:53:40.360 --> 01:53:49.560
Peki programın akışı bu noktaya geldiğinde STR nesnesi için destraktır çağrılacak mı?

01:53:49.960 --> 01:53:50.740
Cevap evet.

01:53:51.580 --> 01:53:54.800
Destraktırın çağrılması herhangi bir soruna yol açacak mı?

01:53:55.640 --> 01:53:55.900
Hayır.

01:53:55.900 --> 01:54:03.400
İşte standart kütüphanenin kendi türleri için verdiği garanti move from state'teki nesneler için bu.

01:54:04.160 --> 01:54:07.200
Şimdi bütün sınıflar bu garantileri vermek zorunda değil.

01:54:07.480 --> 01:54:11.500
Tekrar arkadaşımın güzel sorusuna geri dönecek olursak olsa nesinin.

01:54:11.500 --> 01:54:15.080
Bütün sınıflar böyle bir garantiyi vermek zorunda değil.

01:54:15.800 --> 01:54:21.080
Ama bu konuda en azından bir belgeleme yapmaları kesinlikle gerekir.

01:54:21.640 --> 01:54:22.880
Genelde de onu yapmıyorlar.

01:54:22.880 --> 01:54:28.800
Yani işte genelde kötü kod yazdığımız zaman bunlara da dikkat etmiyoruz.

01:54:29.420 --> 01:54:34.980
Yoksa şimdi ben hiç bilmediğim bir sınıfın örneğin Ali Ertaş bir sınıf yazıyor olsa,

01:54:35.780 --> 01:54:43.780
o sınıfın ben client'i olsam, move from state'teki bir sınıf nesnesini Ali Bey'in yazdığı kullansam,

01:54:43.780 --> 01:54:50.540
arkadaşlar onun invariantlarının korunacağı garantisi var mı?

01:54:50.800 --> 01:54:51.100
Yok.

01:54:52.160 --> 01:54:53.920
Ama bunu dokümante etmesi lazım.

01:54:53.920 --> 01:54:57.900
Yani burada gerçekten dokümantasyonun en fazla önem taşıdığı yerlerden biri.

01:54:58.060 --> 01:55:01.020
Çünkü başkalarını zor durumda bırakırsınız.

01:55:01.160 --> 01:55:04.620
Move from state'teki nesneyi kullanarak başını derde sokabilir.

01:55:04.740 --> 01:55:07.420
Ya da özel bir biçimde kullanarak başını derde sokabilir.

01:55:08.620 --> 01:55:10.920
Peki buraya kadar geldik.

01:55:11.740 --> 01:55:12.440
Gayet güzel.

01:55:12.440 --> 01:55:14.000
Bir soru daha.

01:55:14.260 --> 01:55:20.240
Peki Ölhan bu garantiyi vermeyen X bir klası Unique PTR ile sarmalarsak,

01:55:20.660 --> 01:55:23.560
yine garantiyi göz önüne almakta bir sakınca olur mu?

01:55:24.400 --> 01:55:26.260
Arkadaşlar şimdi bu soruya cevap vermeyeyim.

01:55:26.360 --> 01:55:28.560
Çünkü diğer arkadaşları demotive eder.

01:55:28.700 --> 01:55:30.440
Çok uzun konuşmam gerekiyor.

01:55:31.020 --> 01:55:32.440
Şimdi Unique PTR nedir?

01:55:32.540 --> 01:55:33.360
Ne işe yarar?

01:55:33.840 --> 01:55:38.800
O kadar çok konudan bahsetmem gerekiyor ki o soruya tam bir cevap verebilmem için.

01:55:38.800 --> 01:55:41.480
O yüzden şimdilik cevap vermeyeyim olur mu?

01:55:41.480 --> 01:55:44.500
Ama ileride mutlaka cevap veririm.

01:55:45.120 --> 01:55:48.660
Peki şimdi çok dikkatli izleyelim arkadaşlar.

01:55:48.660 --> 01:56:07.900
Sınıfların copy constructörü ya da copy assignment'ı varsa yani sınıf nesnelerinin kopyalanmasında herhangi bir problem yoksa böyle sınıflara copyable sınıflar diyebilirsiniz.

01:56:07.900 --> 01:56:09.140
Yani kopyalanabilir.

01:56:09.780 --> 01:56:11.920
Yani kopyalanmasında herhangi bir engel yok.

01:56:12.780 --> 01:56:21.760
Ama bazı durumlarda biz sınıfların, sınıf nesnelerinin kopyalanmasını engellemek istiyoruz.

01:56:21.960 --> 01:56:26.660
Yani kopyalama semantiğini sınıfa vermemek istiyoruz.

01:56:26.660 --> 01:56:35.160
Nedeni kopyalamanın o sınıf için anlamlı bir yapı oluşturmaması.

01:56:35.260 --> 01:56:40.400
Yani kopyalamanın semantik karşılığının olmaması arkadaşlar.

01:56:40.400 --> 01:57:00.200
Yani öyle sınıflar var ki problem domenindeki temsil ettikleri varlık nedeniyle temsil ettikleri kavram için zaten kopyalama ya bir anlam taşımıyor ya saçma ya problemli.

01:57:00.200 --> 01:57:04.640
Mesela bir dosyayı kontrol eden sınıf nesnesini düşünelim.

01:57:04.780 --> 01:57:08.720
Az önceki kodda öyle bir sınıf nesnesi vardı.

01:57:09.140 --> 01:57:11.980
İşte buradaki biraz daha geri gideyim.

01:57:13.140 --> 01:57:14.740
Mülakat sorsu demiştim ya.

01:57:15.180 --> 01:57:15.660
İFS.

01:57:16.180 --> 01:57:21.660
Arkadaşlar şimdi burada dosya işlemlerinin nasıl yapıldığı hakkında biraz fikir sahibiyseniz.

01:57:22.440 --> 01:57:27.660
Gerçekten bu nesnenin bir kopyasının çıkartılmasının anlamsız olduğunu.

01:57:27.660 --> 01:57:34.000
Yani böyle bir durumun zaten mantıksal olarak bir karşılığının olmadığını anlarsınız.

01:57:34.680 --> 01:57:39.660
İşte böyle sınıflarda tipik olarak sınıf kopyalamaya karşı kapatılıyor.

01:57:41.100 --> 01:57:49.060
Yani kopyalama yanlış kötü bir durum oluşturmak yerine kopyalama sentaks hatası haline getiriliyor.

01:57:49.060 --> 01:57:58.220
Bunu yapmanın da yolu tahmin edebildiğiniz gibi sınıfın kopyalayan özel fonksiyonlarını delete etmek.

01:57:58.920 --> 01:58:04.440
Yani örneğin class match.

01:58:05.060 --> 01:58:09.060
Ben match sınıfı türünden nesnelerin kopyalanmasını istemiyorsam.

01:58:10.800 --> 01:58:12.720
Bakın bunun birden fazla nedeni olabilir.

01:58:12.720 --> 01:58:22.980
Ama en tipik nedeni match sınıfı problem domeninde neyi temsil ediyorsa onun kopyalanmasının bir anlamının olmaması.

01:58:23.820 --> 01:58:29.840
Mesela arkadaşlar bir mutex'in kopyalanması anlamlı değil ya da doğru değil.

01:58:30.660 --> 01:58:38.400
Arkadaşlar o zaman match sınıfını kopyalamaya karşı kapatmak için ne yapacağım?

01:58:38.400 --> 01:58:43.140
Sınıfın copy konstruktörünü ve copy assignment'ını delete edeceğim.

01:58:43.320 --> 01:58:44.740
Diğer kodları göstermiyorum.

01:58:44.920 --> 01:58:47.400
Yani şöyle bir durum söz konusu olduğunu düşünün.

01:58:48.500 --> 01:58:55.440
Match const match ref eşittir delete.

01:58:57.400 --> 01:59:07.040
Match ref operatör atama const match ref eşittir delete.

01:59:07.040 --> 01:59:22.360
13. satırdaki bildirim sınıfın copy konstruktörünü delete bildirimi ve 14. satırdaki bildirim sınıfın arkadaşlar copy assignment'ının delete edilme bildirimi.

01:59:22.360 --> 01:59:28.180
Ve sınıfa bir default konstruktörü bildirelim ve bakın kodlara şimdi.

01:59:29.180 --> 01:59:34.820
Match türünden x, match türünden y, x.

01:59:34.820 --> 01:59:43.000
kopyalamanın söz konusu olduğu herhangi bir yerde doğrudan copy konstruktörün çağrılması gerekiyor.

01:59:43.100 --> 01:59:52.960
Ama copy konstruktörü delete edildiği için derli içi delete edilmiş fonksiyonla yapılan çağrı ifadesi sentaks hatası oluşturuyor değil mi?

01:59:53.360 --> 01:59:56.820
Bakın sentaks hatası olarak bu sözel yapıyı kullandı.

01:59:56.820 --> 01:59:59.280
Ama sadece bu durumda değil.

01:59:59.780 --> 02:00:05.880
Atama durumunda da örneğin match x, y, x eşittir y.

02:00:06.680 --> 02:00:12.680
Bu sefer de dilim kurallarına göre copy assignment fonksiyonunun çağrılması gerekiyor.

02:00:13.360 --> 02:00:20.740
Copy assignment fonksiyonunun çağrılması da copy assignment fonksiyonu delete edildiği için sentaks hatası oluşturuyor.

02:00:20.740 --> 02:00:32.080
Böyle sınıflardan bahsederken yani kopyalamaya karşı kapatılmış sınıflardan bahsederken onlara non-copyable diyoruz arkadaşlar.

02:00:32.520 --> 02:00:34.180
Non-copyable sınıflar.

02:00:34.900 --> 02:00:39.580
Mesela standart lütfhanede belirli sınıflar non-copyable.

02:00:40.260 --> 02:00:46.000
Mesela arkadaşlar az önceki örneklerden biri izleyin.

02:00:46.000 --> 02:00:54.500
Bakın ismi OFS olan bir sınıf nesnesi var.

02:00:55.340 --> 02:00:59.600
Oto x eşittir OFS.

02:01:02.000 --> 02:01:05.400
Arkadaşlar bakın derleyici nasıl bir sentaks hatası verdi?

02:01:06.480 --> 02:01:11.500
Yine delete edilmiş bir fonksiyona yapılan çağrının sentaks hatası olduğunu söyledi.

02:01:11.500 --> 02:01:24.560
Neden? Çünkü ileride öğreneceğimiz bu standart kütübhanemizin Offstream isimli sınıfı, bu isimde zaten bir türeş ismi Type Alias, kopyalamaya karşı kapatılmış.

02:01:25.640 --> 02:01:38.380
Fakat öyle sınıflar var ki bu sınıfların, bu sınıflar türünden nesnelerin kopyalanması istenmiyor ama taşıma semantiğine açık olması isteniyor.

02:01:38.380 --> 02:01:43.720
Yani kopyalaması yasak fakat taşıması serbest.

02:01:44.300 --> 02:01:53.740
Mesela az önce arkadaşımız sorusunda, Oğuzhan Bey'in sorusunda bahsettiği ya da adı geçen Unique PTR isimli bir sınıf var.

02:01:53.980 --> 02:01:55.380
Bir Smart Pointer sınıfı.

02:01:56.080 --> 02:01:57.860
İleride çok ayrıntılı göreceğiz.

02:01:57.860 --> 02:02:10.220
Mesela bu sınıf kopyalamaya karşı kapatılmış, İngilizcesiyle non-copyable ama taşımaya açık, but movable arkadaşlar.

02:02:10.960 --> 02:02:17.860
Evet, böyle sınıflar için ister non-copyable, but movable gibi uzun bir ifade kullanabilirsiniz.

02:02:17.860 --> 02:02:23.060
Ama daha çok kullanılan pratik terim move-only class.

02:02:25.060 --> 02:02:25.940
Popülerde.

02:02:26.600 --> 02:02:29.160
Move-only class derken kast edilen ne?

02:02:29.380 --> 02:02:30.960
Doğrudan az önce söylediğim.

02:02:31.520 --> 02:02:35.000
Yani kopyalaması yok fakat taşınması var.

02:02:35.000 --> 02:02:43.440
Mesela işte az önceki stream sınıfları genelde bunlar move-only sınıflar.

02:02:43.960 --> 02:02:51.620
Ya da stud-thread sınıfı örneğin kopyalamaya karşı kapatılmış ama taşımaya karşı açık bir sınıf.

02:02:52.260 --> 02:02:57.660
Şimdi geldik hem konunun hem de dersin en zor kısmına.

02:02:58.560 --> 02:03:02.540
Eğer şimdiye kadar zorlanmadıysanız şimdi biraz zorlanacaksınız.

02:03:02.540 --> 02:03:06.380
Ve şunu da söyleyeyim bir ezber yükü de gelecek.

02:03:07.620 --> 02:03:19.400
Arkadaşlar sınıfların özel üye fonksiyonları söz konusu olduğunda programcıların öğrenmekte zorluk çektiği yerlerden biri de biraz öğrenme yükü var.

02:03:20.360 --> 02:03:30.100
Derleyicinin hangi durumlarda sınıfların hangi special member function'ını implicitly declare edeceği.

02:03:30.100 --> 02:03:40.160
Yani örneğin size ben bir sınıf göstersem bu sınıfın move konstruktörü var mı, move assignment'ı var mı, copy konstruktörü var mı, copy assignment'ı var mı?

02:03:41.360 --> 02:03:45.000
Bunların cevabını biliyor olmanız gerekiyor.

02:03:45.160 --> 02:03:46.460
Dilin burada neleri var?

02:03:46.680 --> 02:03:48.120
Arkadaşlar kuralları var.

02:03:48.120 --> 02:03:51.680
Burada biraz sabırlı olmanızı başta isteyeceğim.

02:03:52.360 --> 02:03:54.420
Ondan sonra yavaş yavaş anlatacağım.

02:03:54.520 --> 02:04:00.160
Belirli bir noktadan sonra anlattıklarımı bir tablo olarak ifade edeceğim.

02:04:00.840 --> 02:04:02.520
Şimdi önce şunu anlamanız gerekiyor.

02:04:02.520 --> 02:04:19.840
Dilin kuralları hangi durumda derleyicinin hangi üye fonksiyonu arkadaşlar implicitli yani örtülü olarak declare ettiğini ve default ettiğini dilin kuralları beliriyor.

02:04:20.020 --> 02:04:22.000
Yani bu derleyiciye bağlı bir durum değil.

02:04:23.320 --> 02:04:25.640
Yani implementation defined bir durum değil.

02:04:25.640 --> 02:04:27.480
Yani şöyle bir şey olamaz.

02:04:28.180 --> 02:04:32.920
Aynı sınıf kodunu Ali Ertaş kendi derleyicisinde derliyor.

02:04:33.080 --> 02:04:34.760
Sınıfın move konstruktörü var.

02:04:35.700 --> 02:04:38.180
Ama Cengiz Han ayrı bir derleyici de derliyor.

02:04:38.320 --> 02:04:39.620
Orada move konstruktörü yok.

02:04:39.740 --> 02:04:40.820
Böyle bir senaryo olamaz.

02:04:40.980 --> 02:04:49.680
Dilin kuralları net olarak hangi durumda arkadaşlar sınıfın hangi özel üye fonksiyonunun,

02:04:49.680 --> 02:04:59.960
special member function'ın derleyici tarafından bildirildiğini doğrudan belirlemiş.

02:05:00.180 --> 02:05:01.760
O kuralları öğrenmemiz gerekiyor.

02:05:01.860 --> 02:05:02.740
Hemen de öğreniyoruz.

02:05:02.900 --> 02:05:03.680
Atla deve değil.

02:05:04.080 --> 02:05:05.160
Biraz belki yoracak.

02:05:05.640 --> 02:05:08.260
Ama sonunda feraha kavuşacağız.

02:05:09.200 --> 02:05:09.600
Göster.

02:05:10.260 --> 02:05:12.480
My class herhangi bir sınıf olsun.

02:05:14.520 --> 02:05:16.120
Beni izliyorsunuz.

02:05:16.120 --> 02:05:23.120
Eğer siz sınıfınız için hiçbir konstruktörü bildirmezseniz,

02:05:24.840 --> 02:05:30.480
yani hiçbir konstruktörü yok şu durumda, öyle değil mi?

02:05:31.680 --> 02:05:36.260
Derleyici özel üye fonksiyonların hiçbirinin bildirilmediğini görüyorsunuz.

02:05:37.100 --> 02:05:42.180
Derleyici bu durumda bütün özel üye fonksiyonları default ediyor.

02:05:42.180 --> 02:05:51.140
Bu şu demek, sınıfın böyle yazılması demek, aslında sınıfın şöyle olması demek.

02:05:51.380 --> 02:05:52.780
Tek tek gösteriyorum, bakınız.

02:05:53.320 --> 02:05:58.960
Yorum satırıyla ya da altına yazayım, yukarıya yorum satırını alırız.

02:05:59.420 --> 02:06:01.240
Ya da underscore koyayım olur mu?

02:06:01.820 --> 02:06:05.460
Aynı sınıftan bahsettiğim vurgulamak için yardımcı araç altını çizmesin.

02:06:05.960 --> 02:06:07.860
Sınıfın default konstruktörü var mı?

02:06:08.540 --> 02:06:08.820
Var.

02:06:08.820 --> 02:06:14.080
Sınıfın default konstruktörü derleyici tarafından mı yazıldı?

02:06:14.820 --> 02:06:15.060
Evet.

02:06:16.180 --> 02:06:18.760
Sınıfın topik konstruktörü var mı?

02:06:19.020 --> 02:06:19.340
Var.

02:06:22.920 --> 02:06:25.180
Burada biraz sabırlı olmanızı isteyeceğim.

02:06:25.280 --> 02:06:28.300
Sıkılabilirsiniz ama mutlaka iyi öğrenmemiz gerekiyor.

02:06:28.940 --> 02:06:29.140
Evet.

02:06:29.600 --> 02:06:31.960
Yine derleyici tarafından mı yazıldı?

02:06:32.280 --> 02:06:32.500
Evet.

02:06:32.840 --> 02:06:33.700
Yanlış anlaşılmasın.

02:06:33.780 --> 02:06:35.820
Size göstermek için böyle yazıyorum arkadaşlar.

02:06:35.820 --> 02:06:37.380
Arkadaşlar, evet.

02:06:38.040 --> 02:06:41.660
MyClass, const MyClass, rev eşittir.

02:06:42.000 --> 02:06:42.520
Default.

02:06:43.560 --> 02:06:45.580
Bu, copy konstruktör.

02:06:46.540 --> 02:06:47.360
Devam edelim.

02:06:47.780 --> 02:06:49.960
Pardon, burada underscore'u kullanmadığım için.

02:06:50.100 --> 02:06:51.560
Şöyle yapalım, daha pratik olsun.

02:06:52.100 --> 02:06:53.320
Şuna underscore yapayım.

02:06:54.140 --> 02:06:54.360
Evet.

02:06:55.480 --> 02:06:57.480
Ve buradaki underscore'u sileyim.

02:06:57.480 --> 02:06:58.020
şimdi oldu.

02:06:58.640 --> 02:07:00.320
Bu da derleyici tarafından yazılıyor.

02:07:01.520 --> 02:07:01.800
Evet.

02:07:01.900 --> 02:07:02.840
Moe konstruktör.

02:07:02.960 --> 02:07:03.300
Yes.

02:07:10.300 --> 02:07:12.840
Hatta yorum satırına da niye alıyorum ki?

02:07:13.060 --> 02:07:13.740
Öyle göstereyim.

02:07:14.820 --> 02:07:15.660
Copy assignment.

02:07:16.140 --> 02:07:16.460
Yes.

02:07:16.460 --> 02:07:16.540
Yes.

02:07:16.540 --> 02:07:16.600
Yes.

02:07:16.600 --> 02:07:16.660
Yes.

02:07:16.660 --> 02:07:16.700
Yes.

02:07:16.700 --> 02:07:16.740
Yes.

02:07:16.740 --> 02:07:18.660
Yes.

02:07:18.660 --> 02:07:20.660
Yes.

02:07:20.660 --> 02:07:20.700
Yes.

02:07:20.700 --> 02:07:21.660
Yes.

02:07:21.660 --> 02:07:22.660
Yes.

02:07:22.660 --> 02:07:24.660
Yes.

02:07:24.660 --> 02:07:25.660
Yes.

02:07:25.660 --> 02:07:26.660
Yes.

02:07:26.660 --> 02:07:46.560
Lütfen her bir durumu doğru anladığınızdan emin olunuz.

02:07:46.560 --> 02:07:48.280
Tekrar bakalım.

02:07:48.580 --> 02:07:58.920
Sınıfı böyle tanımlamak, bu fonksiyonların derleyici tarafından örtülü olarak bildirilmesi ve tanımının yapılması anlamına geliyor.

02:07:58.920 --> 02:08:03.640
Yani 6 özel üye fonksiyonunun 6'sı da var.

02:08:05.460 --> 02:08:06.480
Takip edebildik mi?

02:08:07.080 --> 02:08:07.280
Evet.

02:08:07.860 --> 02:08:11.940
Hadi bunu şöyle sonuna da yorum satırı koyalım.

02:08:11.940 --> 02:08:18.320
ve arkadaşlar notlar dosyamıza geri dönebilmek için koyalım.

02:08:18.320 --> 02:08:19.740
Şimdi ikinci senaryo.

02:08:20.800 --> 02:08:31.060
Eğer sınıfı special member function olmayan bir konstruktör koyarsanız, takip edebiliyor musunuz?

02:08:31.060 --> 02:08:35.340
Sadece ve sadece şu olmuyor.

02:08:35.340 --> 02:08:37.520
Yani default konstruktör olmuyor.

02:08:37.520 --> 02:08:44.880
Yani sınıfı böyle tanımlamanız demek, sınıfı aşağıdaki biçimde tanımlamanız demek.

02:08:45.720 --> 02:08:48.620
Arkadaşlar buradan şu kuralı da tekrar etmiş oluyoruz.

02:08:48.620 --> 02:09:02.960
Sınıfı herhangi bir konstruktör'ı special member function olsun ya da olmasın, user dikler yaptığınız zaman derleyici default konstruktör'ı artık indisip de dikler etmiyor.

02:09:03.680 --> 02:09:06.140
Yani bu sınıfın nesi yok arkadaşlar?

02:09:07.000 --> 02:09:08.420
Default konstruktör'ı yok.

02:09:09.060 --> 02:09:16.860
Peki destruktör, copy konstruktör, move konstruktör, copy assignment, move assignment bunlar var mı?

02:09:16.860 --> 02:09:19.160
Var. Burada anlamadığımız bir şey var mı?

02:09:21.560 --> 02:09:23.100
Süper. Devam.

02:09:28.820 --> 02:09:35.380
Eğer sınıfa default konstruktör bildirirseniz, takip edebiliyor muyuz?

02:09:36.020 --> 02:09:38.200
Yani default konstruktör user dikler.

02:09:38.200 --> 02:09:46.740
Bu durumda yine sınıfın diğer bütün özel üye fonksiyonları derleyici tarafından default ediliyor.

02:09:46.860 --> 02:09:59.960
Yani böyle olması demek, böyle olması demek, böyle olması demek.

02:10:01.140 --> 02:10:01.840
Anlaşıldı mı?

02:10:02.100 --> 02:10:08.000
Çağrı, alertaş, cengiz an anlamadığımız ya da itiraz etmek istediğimiz bir yer var mı?

02:10:08.000 --> 02:10:11.840
Evet, o zaman bunu da geçtik.

02:10:15.240 --> 02:10:22.740
Eğer sınıfa destruktör bildirirseniz, takip edin.

02:10:22.740 --> 02:10:38.920
destruktör'ı user dikler yapmış olursunuz ama diğer arkadaşlar, özel üye fonksiyonların derleyici tarafından yazılmasında herhangi bir şekilde bir engel yok.

02:10:39.080 --> 02:10:40.720
Ama burada bir durmamız gerekiyor.

02:10:41.660 --> 02:10:43.560
Bakın bakın, çok dikkatli izleyin.

02:10:43.560 --> 02:10:44.700
Tekrar ediyorum.

02:10:45.320 --> 02:10:51.180
Sınıfa destruktör bildirirseniz arkadaşlar, şunları sileyim.

02:10:52.680 --> 02:10:53.320
Durum şu.

02:10:54.840 --> 02:10:57.060
Burası epey kritik.

02:10:57.700 --> 02:11:06.140
Bir, arkadaşlar destruktör bildirdiğiniz zaman derleyici sınıfın move memberlarını default etmiyor.

02:11:06.920 --> 02:11:08.520
Yani move memberlar yok.

02:11:08.980 --> 02:11:09.820
Burayı anladık mı?

02:11:09.820 --> 02:11:11.440
Bu birinci sonuç.

02:11:12.160 --> 02:11:19.220
İkincisi, arkadaşlar, derleyici default constructor'ı default ediyor.

02:11:20.040 --> 02:11:23.920
Copy constructor'ı ve copy assignment'ı yine default ediyor.

02:11:24.760 --> 02:11:27.960
Ama bu durum son derece tehlikeli.

02:11:28.380 --> 02:11:32.080
Asla asla böyle bir duruma yol açmamanız gerekiyor.

02:11:32.860 --> 02:11:36.600
Ve standarda göre bu deprecated ilan edildi.

02:11:36.600 --> 02:11:51.320
Yani derleyicinin siz bir destruktör bildirdiğiniz zaman sınıfın copy constructor'ını ve copy assignment'ını default etmesi son derece tehlikeli.

02:11:51.540 --> 02:11:53.100
Asla buna başvurmayın.

02:11:53.860 --> 02:11:54.780
Ve deprecated.

02:11:55.420 --> 02:11:57.060
Yani deprecated olması ne demek?

02:11:57.220 --> 02:12:01.000
Gelecekteki bir standartta bu tamamen sentaks hatası yapılabilir.

02:12:01.000 --> 02:12:05.540
Buradan çıkan sonuca dikkat.

02:12:05.620 --> 02:12:09.280
Hatta şöyle dikkat başlığıyla yazayım.

02:12:09.480 --> 02:12:10.000
Dikkat.

02:12:10.820 --> 02:12:15.420
Bu durumda sınıfın move memberları yok.

02:12:15.420 --> 02:12:29.580
Cengiz Han yine sorunuza isterseniz daha sonra cevap vereyim olur mu?

02:12:29.800 --> 02:12:30.620
Yani soru güzel.

02:12:31.160 --> 02:12:32.680
Ama buradan kopmayalım.

02:12:33.340 --> 02:12:33.520
Evet.

02:12:35.080 --> 02:12:36.060
Sorunuzu not ettim.

02:12:36.460 --> 02:12:38.580
Şimdi burayı herkes anladı mı?

02:12:39.320 --> 02:12:41.360
Çünkü burası bir hayli kritik.

02:12:41.600 --> 02:12:41.740
Evet.

02:12:41.740 --> 02:12:43.760
Bir kez daha tekrar ediyorum o yüzden.

02:12:44.640 --> 02:12:49.580
Sınıfa destruktör bildirirseniz default constructor var.

02:12:50.400 --> 02:12:51.740
Destruktör user declared.

02:12:52.980 --> 02:12:57.520
Copy constructor ve copy assignment derleyici tarafından yazılıyor.

02:12:58.260 --> 02:13:02.000
Ama bu son derece problemli bir durum ve deprecated.

02:13:02.000 --> 02:13:04.680
Herkes anladı mı?

02:13:04.900 --> 02:13:07.180
Bir şeye daha dikkat etmenizi istiyorum.

02:13:07.300 --> 02:13:08.760
Tekrar yazdım buraya zaten.

02:13:09.440 --> 02:13:09.860
Dikkat.

02:13:10.000 --> 02:13:12.460
Bu durumda sınıfın move memberları yok.

02:13:13.480 --> 02:13:16.000
Yani bu sınıfın move constructorı yok.

02:13:16.340 --> 02:13:17.440
Delete edilmiş değil.

02:13:17.700 --> 02:13:18.840
Move constructorı yok.

02:13:19.000 --> 02:13:20.220
Move assignment'ı yok.

02:13:21.680 --> 02:13:26.060
Hani sınıfların özel üye fonksiyonları üç durumda olabiliyordu değil mi?

02:13:26.060 --> 02:13:32.340
User declared, implicitly declared, bir de not declared.

02:13:33.120 --> 02:13:36.460
Şu anda bu sınıfın move memberları not declared.

02:13:36.640 --> 02:13:37.800
Yani yoklar.

02:13:38.420 --> 02:13:41.460
Olmamasıyla delete edilmesi farklı şeyler.

02:13:41.820 --> 02:13:42.620
Bunu da yazdık.

02:13:48.960 --> 02:13:50.440
Şimdi nedeni değil.

02:13:50.540 --> 02:13:51.720
Önce kuralı öğrenelim.

02:13:52.260 --> 02:13:53.680
Dilin kurallarını öğreniyoruz.

02:13:53.680 --> 02:13:55.980
Takip edebiliyor muyuz?

02:13:56.320 --> 02:13:57.240
Tekrar söylüyorum.

02:13:57.680 --> 02:14:00.840
Şimdi eğer soru şuysa Resul neden böyle?

02:14:01.600 --> 02:14:02.680
Valla doğrusunu isterseniz.

02:14:03.920 --> 02:14:07.160
Zamanında belki sentaks hatası yapılsaydı.

02:14:07.540 --> 02:14:08.680
Eski kodlar kırılırdı.

02:14:10.320 --> 02:14:13.200
Eski geçmiş kodların legalitesini korumak için.

02:14:13.760 --> 02:14:15.880
Destructor'ın bildirilmesi durumunda.

02:14:16.240 --> 02:14:16.920
Arkadaşlar.

02:14:17.740 --> 02:14:23.020
Copy constructor'ın ve copy assignment'ın derleyici tarafından yazılmasına halen izin veriliyor.

02:14:23.680 --> 02:14:24.100
Evet.

02:14:24.460 --> 02:14:24.860
Devam.

02:14:25.860 --> 02:14:26.260
Eğer.

02:14:26.600 --> 02:14:28.940
Şimdi burası bundan sonrası biraz daha zor.

02:14:30.600 --> 02:14:30.920
Peki.

02:14:31.740 --> 02:14:33.680
Copy constructor bildirilmişse.

02:14:34.900 --> 02:14:35.680
My class.

02:14:37.380 --> 02:14:37.800
Cons.

02:14:38.280 --> 02:14:39.080
My class.

02:14:40.640 --> 02:14:41.080
Ref.

02:14:41.680 --> 02:14:43.340
Yanına da yazılan copy constructor.

02:14:43.340 --> 02:14:47.020
Buraya özellikle dikkat.

02:14:47.680 --> 02:14:49.900
Ve tahmin etmenizi isteyeceğim.

02:14:50.560 --> 02:14:50.740
Evet.

02:14:51.020 --> 02:14:51.220
Bir.

02:14:51.960 --> 02:14:52.940
Bilenler söylesin.

02:14:53.000 --> 02:14:54.300
Bilmeyenler tahmin etsin.

02:14:54.960 --> 02:14:56.940
Sınıfın default constructor'ı var mı?

02:15:00.140 --> 02:15:00.780
Cevap.

02:15:01.060 --> 02:15:01.340
Hayır.

02:15:01.640 --> 02:15:01.840
Yok.

02:15:01.940 --> 02:15:02.200
Bravo.

02:15:02.720 --> 02:15:06.440
Çünkü bir constructor yazdığım anda derleyici default constructor yazmıyor.

02:15:06.520 --> 02:15:06.780
Bakın.

02:15:06.860 --> 02:15:07.780
Delete edilmiş değil.

02:15:07.860 --> 02:15:08.040
Yok.

02:15:08.040 --> 02:15:11.580
Sınıfın destructor'ı var mı?

02:15:12.880 --> 02:15:13.720
Cevap.

02:15:14.040 --> 02:15:14.320
Var.

02:15:20.820 --> 02:15:24.820
Sınıfın copy constructor'ı zaten user declared.

02:15:24.820 --> 02:15:36.600
Copy assignment'ı cevap tahmin edin.

02:15:37.600 --> 02:15:38.580
Yine var.

02:15:38.920 --> 02:15:40.860
Yine default ediliyor.

02:15:41.940 --> 02:15:42.740
Maalesef.

02:15:42.740 --> 02:16:00.040
Moe constructor'ı var mı?

02:16:00.120 --> 02:16:00.760
Tahmin edin.

02:16:02.220 --> 02:16:02.940
Cevap.

02:16:03.060 --> 02:16:03.340
Yok.

02:16:04.200 --> 02:16:05.560
Moe assignment'ı var mı?

02:16:07.140 --> 02:16:07.860
Cevap.

02:16:08.140 --> 02:16:08.400
Yok.

02:16:08.400 --> 02:16:10.000
Dolayısıyla bakın.

02:16:10.260 --> 02:16:12.860
Sınıfa eğer bir copy constructor bildirirseniz.

02:16:12.900 --> 02:16:14.580
Bir kez daha üstünden geçelim mi?

02:16:15.580 --> 02:16:18.400
Sınıfa bir copy constructor bildirirseniz.

02:16:20.380 --> 02:16:22.500
Destructor default ediliyor.

02:16:23.740 --> 02:16:25.480
Default constructor yok.

02:16:26.560 --> 02:16:29.580
Ve copy assignment default ediliyor.

02:16:29.580 --> 02:16:33.760
Moe constructor ve move assignment yok.

02:16:38.400 --> 02:16:44.900
Şimdi copy constructor'ı yazdık.

02:16:45.580 --> 02:16:45.960
Devam.

02:16:46.380 --> 02:16:47.140
Copy assignment.

02:16:51.420 --> 02:16:53.700
Arkadaşlar ben size kuralları anlatıyorum.

02:16:53.820 --> 02:16:57.980
Bunların ne işe yarayacağı, neden böyle yapıldığını anlatmıyorum ki.

02:16:58.560 --> 02:17:01.740
Bunların doğru ya da yanlış olduğunu da söylemiyorum ki olsan.

02:17:02.280 --> 02:17:03.720
Önce kuralları öğreneceğiz.

02:17:03.720 --> 02:17:07.000
Yani sanki ben size şöyle bir şey söylemişim gibi.

02:17:07.640 --> 02:17:09.120
Böyle bir sınıf oluşturun.

02:17:09.340 --> 02:17:10.320
Keyfinize bakın.

02:17:10.720 --> 02:17:11.640
Afiyetle kullanın.

02:17:11.680 --> 02:17:12.820
Böyle bir şey demedim ki.

02:17:13.800 --> 02:17:14.620
Anlatabiliyor muyum?

02:17:15.020 --> 02:17:22.300
Önemli olan şimdi burada hangi durumda derleyicinin hangi fonksiyonları örtülü olarak

02:17:22.300 --> 02:17:24.840
implicit dedikler ettiğini öğrenmek.

02:17:25.260 --> 02:17:27.500
Yoksa benim ağzımdan şöyle bir cümle çıkmadı ki.

02:17:27.500 --> 02:17:32.460
Bir sınıfın copy constructor'ını bildirin ama diğer özel üye fonksiyonlarını bildirmeyin.

02:17:32.540 --> 02:17:33.500
Böyle bir şey söylemedim.

02:17:33.720 --> 02:17:34.440
Peki.

02:17:35.340 --> 02:17:38.480
Gelelim atama operatör fonksiyonuna.

02:17:38.580 --> 02:17:40.780
Kopyalayan atama operatör fonksiyonuna.

02:17:44.900 --> 02:17:45.680
Copy assignment.

02:17:47.580 --> 02:17:50.120
Ve yine tahminde bulunmaya çalışalım.

02:17:50.600 --> 02:17:51.200
Arkadaşlar.

02:17:51.840 --> 02:17:52.380
Soru 1.

02:17:52.900 --> 02:17:54.400
Default constructor var mı?

02:17:56.400 --> 02:17:57.680
Devam var.

02:17:57.680 --> 02:18:04.040
Soru 2.

02:18:04.680 --> 02:18:05.840
Destructor var mı?

02:18:07.440 --> 02:18:08.260
Var.

02:18:16.620 --> 02:18:17.740
Soru 3.

02:18:17.740 --> 02:18:19.620
Copy constructor var mı?

02:18:19.620 --> 02:18:24.080
Cevap var.

02:18:35.080 --> 02:18:37.840
Soru mu constructor var mı?

02:18:38.840 --> 02:18:39.580
Tahmin edin.

02:18:39.580 --> 02:18:42.200
Cevap yok.

02:18:42.200 --> 02:18:42.220
Cevap yok.

02:18:42.220 --> 02:18:44.440
Move assignment var mı?

02:18:45.440 --> 02:18:46.760
Cevap yok.

02:18:46.760 --> 02:18:49.120
O zaman bir kez daha tekrar edelim.

02:18:49.760 --> 02:18:53.500
Sınıfa kopyalayan atama operatör fonksiyonuna yazarsanız.

02:18:53.500 --> 02:19:00.220
Bu durumda arkadaşlar default constructor derleyici tarafından default edilecek.

02:19:00.380 --> 02:19:02.060
Destructor default edilecek.

02:19:02.940 --> 02:19:05.120
Copy constructor default edilecek.

02:19:05.720 --> 02:19:06.980
Tabii şunu da eklemeliyiz.

02:19:07.060 --> 02:19:09.080
Copy assignment user declared.

02:19:09.080 --> 02:19:21.760
Takip edebiliyor muyuz?

02:19:22.180 --> 02:19:22.440
Evet.

02:19:23.740 --> 02:19:24.240
Devam.

02:19:24.740 --> 02:19:25.820
Move memberlar yok.

02:19:31.140 --> 02:19:32.020
Şimdi.

02:19:33.020 --> 02:19:34.160
Aman dikkat.

02:19:34.620 --> 02:19:36.820
Sınıfa move constructor yazarsanız.

02:19:36.820 --> 02:19:39.180
My class.

02:19:39.860 --> 02:19:40.500
Arkadaşlar.

02:19:40.980 --> 02:19:43.660
Tabii bu arada bunların hep public olduğunu düşünüyoruz.

02:19:43.960 --> 02:19:45.980
Yani şuraya public sözcüğünü yazmamışım.

02:19:46.060 --> 02:19:48.000
Hep yazdığımı düşünün.

02:19:48.280 --> 02:19:51.780
Bunun gelişim kontrolüyle şimdilik bir alakası yok.

02:19:52.380 --> 02:19:52.620
Tamam.

02:19:52.620 --> 02:19:53.900
Şimdi soru.

02:19:54.740 --> 02:19:59.160
Sınıfa move constructor'ı user declared yapıyorum.

02:19:59.920 --> 02:20:01.780
Yine tahminlerinizi alacağım.

02:20:02.040 --> 02:20:02.960
Bakalım doğru tahmini.

02:20:03.000 --> 02:20:05.100
Bilenler değil tahmin edenler söylesin.

02:20:06.180 --> 02:20:06.440
Evet.

02:20:06.820 --> 02:20:12.080
Default constructor'ı var mı?

02:20:14.380 --> 02:20:15.980
Cevap yok.

02:20:16.620 --> 02:20:18.240
Çünkü bu bir constructor.

02:20:18.580 --> 02:20:19.200
Neydi kural?

02:20:19.780 --> 02:20:26.060
Bir tane constructor bildirirseniz derleyici default constructor'ı arkadaşlar bildirmez.

02:20:26.060 --> 02:20:28.740
O zaman default constructor yok.

02:20:29.400 --> 02:20:30.260
Devam ediyorum.

02:20:31.200 --> 02:20:32.260
Destructor var mı?

02:20:33.920 --> 02:20:35.040
Cevap var.

02:20:35.380 --> 02:20:36.140
Destructor.

02:20:38.020 --> 02:20:39.420
Default edilmiş.

02:20:42.100 --> 02:20:44.180
Copy constructor var mı?

02:20:44.180 --> 02:20:48.140
İşte burada cevabınız yanlış.

02:20:48.140 --> 02:20:50.020
Yani tahmininiz yanlış.

02:20:50.840 --> 02:20:53.880
Copy constructor var ama delete edilmiş.

02:20:53.880 --> 02:20:54.880
Yani sınıfa.

02:20:54.880 --> 02:21:01.960
Yani sınıfa move constructor'ı bildirirseniz derleyici copy constructor'ı delete ediyor.

02:21:01.960 --> 02:21:19.120
Yani şöyle myclass arkadaşlar const const myclass ref eşittir delete.

02:21:19.120 --> 02:21:22.380
derleyici böyle bir kod ekliyor.

02:21:22.380 --> 02:21:22.660
Böyle bir kod ekliyor.

02:21:23.380 --> 02:21:25.080
Copy assignment var mı?

02:21:25.080 --> 02:21:30.260
Cevap bravo.

02:21:30.340 --> 02:21:31.580
Bu sefer tahmini doğru.

02:21:31.580 --> 02:21:33.160
Var ama delete edilmiş.

02:21:34.240 --> 02:21:35.260
Myclass ref.

02:21:37.100 --> 02:21:38.020
Operatör.

02:21:38.020 --> 02:21:45.400
Atama const myclass ref eşittir delete.

02:21:47.260 --> 02:21:48.620
E zaten move constructor.

02:21:51.200 --> 02:21:52.460
User declared.

02:21:53.100 --> 02:21:54.920
Move assignment var mı?

02:21:56.640 --> 02:21:57.440
Cevap.

02:21:59.480 --> 02:22:01.080
Move assignment yok.

02:22:01.640 --> 02:22:02.300
Not declared.

02:22:03.520 --> 02:22:04.560
Yani böyle bravo.

02:22:05.960 --> 02:22:06.920
Anlaşıldı mı?

02:22:06.920 --> 02:22:08.500
Ve son olarak

02:22:08.500 --> 02:22:15.040
daha sonra ben size bunu bir tablo halinde kendi oluşturduğum tablo halinde vereceğim.

02:22:15.180 --> 02:22:17.200
Bir katkın bakın ezberleyene kadar.

02:22:18.280 --> 02:22:20.600
Peki move assignment yazarsam.

02:22:22.060 --> 02:22:23.060
Myclass ref.

02:22:24.860 --> 02:22:25.940
Operatör atama.

02:22:26.560 --> 02:22:27.700
Myclass ref ref.

02:22:28.020 --> 02:22:28.620
Move assignment.

02:22:36.920 --> 02:22:41.480
Yine bu sefer tahminlerinin hepsinin doğru olacağını düşünüyorum.

02:22:41.620 --> 02:22:42.180
Bekliyorum.

02:22:43.020 --> 02:22:44.080
Default constructor.

02:22:45.080 --> 02:22:46.240
Var.

02:22:52.080 --> 02:22:53.120
Destructor.

02:22:54.500 --> 02:22:55.800
Cevap var.

02:23:01.140 --> 02:23:02.260
Devam.

02:23:02.260 --> 02:23:03.740
Copy constructor.

02:23:03.740 --> 02:23:03.860
Copy constructor.

02:23:06.860 --> 02:23:07.940
Elited.

02:23:08.320 --> 02:23:08.640
Bravo.

02:23:18.640 --> 02:23:20.960
Move constructor.

02:23:22.960 --> 02:23:24.000
Yok.

02:23:25.800 --> 02:23:26.140
Evet.

02:23:27.020 --> 02:23:27.940
Move assignment.

02:23:28.900 --> 02:23:29.580
User declared.

02:23:29.580 --> 02:23:46.100
Arkadaşlar şimdi kafanız karışmış olabilir.

02:23:46.260 --> 02:23:46.880
Gayet normal.

02:23:47.460 --> 02:23:51.800
Ben size toplu sonuçları vereceğim şimdi.

02:23:52.020 --> 02:23:55.060
Yani toplu sonuçlar derken neyi kastediyorum?

02:23:55.060 --> 02:24:01.860
Bütün bu söylediklerimin hem özeti hem de buradaki kritik noktalar.

02:24:03.220 --> 02:24:08.420
Şimdi söylediklerimi anladığınızı onaylayın olur mu arkadaşlar?

02:24:09.200 --> 02:24:10.400
Anladığınızı onaylayın.

02:24:10.480 --> 02:24:11.920
Çünkü her bir cümle önemli.

02:24:12.840 --> 02:24:14.540
Bir kere izleyin.

02:24:14.540 --> 02:24:28.620
Bir sınıfa herhangi bir konstruktör bildirirsek, default konstruktör olmayan,

02:24:28.620 --> 02:24:42.300
herhangi bir konstruktör bildirirsek derleyici,

02:24:47.300 --> 02:24:51.500
default konstruktörü bildirmez.

02:24:51.500 --> 02:24:55.420
Yani not declared durumuna düşer.

02:24:56.520 --> 02:24:57.480
Bunda açık değil mi?

02:24:57.720 --> 02:25:00.920
Örneklerin hepsinde arkadaşlar gördük.

02:25:01.020 --> 02:25:01.960
Anlamayan var mı?

02:25:02.860 --> 02:25:03.140
Evet.

02:25:04.680 --> 02:25:05.080
Devam.

02:25:06.340 --> 02:25:06.740
İki.

02:25:07.260 --> 02:25:15.480
Bir sınıfın her zaman destraktörü vardır.

02:25:16.080 --> 02:25:16.720
Burası önemli.

02:25:16.720 --> 02:25:23.340
Yani destraktör, hocam son durumda copy assignment delete olması gerekmez miydi?

02:25:23.420 --> 02:25:24.460
Delete yazmadın mı?

02:25:25.900 --> 02:25:28.360
MyClass, const MyClass yazmamışım onu.

02:25:28.560 --> 02:25:29.260
Haklısınız.

02:25:29.980 --> 02:25:30.760
Niye yazmadım?

02:25:32.040 --> 02:25:34.000
MyClass, ref.

02:25:35.920 --> 02:25:36.940
Yazdım zannettim.

02:25:37.240 --> 02:25:38.560
Operatör atama.

02:25:42.400 --> 02:25:43.500
Operatör atama.

02:25:43.500 --> 02:25:44.680
Onu yazmamışım gerçekten.

02:25:44.900 --> 02:25:45.360
Haklısınız.

02:25:45.540 --> 02:25:46.520
Operatör atama.

02:25:46.720 --> 02:25:49.160
const, onu atlamışım.

02:25:49.240 --> 02:25:50.400
MyClass, ref.

02:25:50.980 --> 02:25:51.780
Eşittir delete.

02:25:53.600 --> 02:25:55.160
Emrecan, teşekkür ederim.

02:25:55.580 --> 02:25:56.880
Bunu yazmayı unutmuşum.

02:25:57.540 --> 02:25:57.780
Tamam.

02:25:57.960 --> 02:25:58.960
Şimdi buraya geri dönüyorum.

02:25:59.540 --> 02:26:02.380
Bir sınıfın her zaman destraktörü vardır.

02:26:03.380 --> 02:26:05.460
Yani destraktörün olmadığı bir senaryo.

02:26:06.380 --> 02:26:09.320
Destraktörü siz bildirirseniz user declared.

02:26:09.320 --> 02:26:17.760
Sizin bildirmediğiniz bütün durumlarda arkadaşlar implicit dedikleriz.

02:26:17.760 --> 02:26:19.060
Bunda anlaştık mı?

02:26:19.060 --> 02:26:19.660
Tamam.

02:26:19.660 --> 02:26:21.520
Şimdi buraya dikkat.

02:26:21.520 --> 02:26:22.960
bir sınıfın her zaman destraktörü.

02:26:22.960 --> 02:26:23.580
Bir sınıfa.

02:26:23.580 --> 02:26:23.620
Bir sınıfa.

02:26:23.620 --> 02:26:23.660
Bir sınıfa.

02:26:25.660 --> 02:26:28.660
Eskiden büyük üçlü denilen.

02:26:34.340 --> 02:26:35.220
Denilen.

02:26:35.640 --> 02:26:37.580
Neydi o büyük üçlü eskiden?

02:26:38.060 --> 02:26:38.880
Destraktör.

02:26:38.880 --> 02:26:40.880
Copy.

02:26:40.880 --> 02:26:41.480
Copy.

02:26:41.480 --> 02:26:41.500
Copy.

02:26:41.500 --> 02:26:41.520
Copy.

02:26:41.520 --> 02:26:41.540
Copy.

02:26:41.540 --> 02:26:41.560
Copy.

02:26:41.560 --> 02:26:44.900
Asignment ki o zaman ismi böyle değildi.

02:26:47.140 --> 02:26:47.380
Copy.

02:26:47.380 --> 02:26:48.060
Constructor.

02:26:50.120 --> 02:26:50.800
Buraya dikkat.

02:26:51.340 --> 02:26:54.600
Bunlardan hangisini bildirirseniz bildirin.

02:26:55.600 --> 02:26:58.220
Move memberlar not declared olur.

02:27:00.600 --> 02:27:09.420
Bunlardan herhangi birini bildirmezseniz arkadaşlar.

02:27:11.560 --> 02:27:15.160
Move memberlar.

02:27:15.240 --> 02:27:16.240
Move member ne demek?

02:27:16.860 --> 02:27:20.000
Move member deyince move constructor, move assignment.

02:27:20.760 --> 02:27:23.780
Copy members deyince copy constructor, copy assignment.

02:27:24.240 --> 02:27:24.720
Anlaşılıyor.

02:27:24.720 --> 02:27:30.400
Bunlardan herhangi birini bildirirseniz bildirmezseniz demişim.

02:27:31.120 --> 02:27:37.240
Bildirirseniz derleyici move memberları bildirmez.

02:27:41.560 --> 02:27:44.840
Yani bu durumda sınıfın move memberları yoktur.

02:27:50.900 --> 02:27:52.860
Bakın delete edilmiş değil.

02:27:53.140 --> 02:27:54.900
Move memberları yoktur.

02:27:54.900 --> 02:27:59.480
Takip edebiliyor muyuz?

02:27:59.480 --> 02:28:00.080
Evet.

02:28:01.080 --> 02:28:01.800
Devam.

02:28:03.340 --> 02:28:14.480
Bir sınıfa move memberlardan birini bildirirseniz.

02:28:14.480 --> 02:28:24.620
İster move constructor olsun, ister move assignment olsun, derleyici copy memberları ne yapar?

02:28:26.200 --> 02:28:26.740
Söyleyin.

02:28:27.840 --> 02:28:30.420
Derleyici copy memberları delete eder.

02:28:30.760 --> 02:28:31.060
Bravo.

02:28:32.160 --> 02:28:37.620
Derleyici copy memberları delete eder.

02:28:37.620 --> 02:28:40.200
Bu da çok önemli bir kural.

02:28:40.800 --> 02:28:44.620
Move memberları yazarsanız copy memberları delete eder.

02:28:45.040 --> 02:28:50.140
Mesela demin arkadaşlarından biri böyle böyle yaparsak ne olur falan demişti.

02:28:50.180 --> 02:28:52.900
Ben dedim ki onu incelemiyoruz daha, onu da konuşuruz.

02:28:53.440 --> 02:28:54.720
Sadece kuralları inceliyoruz.

02:28:55.000 --> 02:28:58.200
Ama mesela arkadaşımın sorusuna uygun bir durum.

02:28:58.840 --> 02:28:59.900
Çok dikkatli izleyin.

02:28:59.900 --> 02:29:04.040
Şimdi şöyle bir sınıf oluştursam.

02:29:05.240 --> 02:29:07.020
Class, my class.

02:29:08.520 --> 02:29:09.360
Public.

02:29:11.620 --> 02:29:14.420
My class, my class.

02:29:15.080 --> 02:29:15.640
Refref.

02:29:17.520 --> 02:29:18.880
My class.

02:29:19.140 --> 02:29:19.920
Ref.

02:29:21.500 --> 02:29:23.540
Operatör atama.

02:29:24.740 --> 02:29:25.720
My class.

02:29:26.160 --> 02:29:26.600
Refref.

02:29:26.980 --> 02:29:28.700
Soruyu önce anlamaya çalışın.

02:29:28.780 --> 02:29:29.780
Sadece sınıf bu kadar.

02:29:29.900 --> 02:29:37.080
Bu sınıf movable but not copyable.

02:29:37.460 --> 02:29:39.360
Yani not copyable but movable.

02:29:39.460 --> 02:29:42.620
Ya da diğer ismiyle move only class'tır diyebilir miyim?

02:29:43.200 --> 02:29:44.200
Evet ya da hayır diyeyim.

02:29:47.560 --> 02:29:50.460
Bu sınıf move only class mıdır değil midir?

02:29:50.580 --> 02:29:51.640
Cevap evet.

02:29:52.340 --> 02:29:53.080
Neden evet?

02:29:53.820 --> 02:29:59.320
Çünkü move memberları bildirdiğim için zaten copy memberlar delete olduğu için.

02:29:59.900 --> 02:30:12.180
Yani böyle yazmakla gidip de buraya bunlar için delete bildirimi yapmanın bir farkı yok.

02:30:12.820 --> 02:30:13.680
Anladınız değil mi?

02:30:13.680 --> 02:30:20.860
Zaten derleyici bunları delete ediyor.

02:30:20.860 --> 02:30:24.140
Bakın tekrar söylüyorum arkadaşlar.

02:30:24.140 --> 02:30:37.200
Düzelteyim ki hata olmasın.

02:30:37.200 --> 02:30:39.200
Tekrar söylüyorum.

02:30:39.200 --> 02:30:40.540
Tekrar söylüyorum.

02:30:42.760 --> 02:30:45.260
Sınıfı böyle oluşturmanızla.

02:30:45.760 --> 02:30:48.200
Şuradaki referans deklaratörü bitmiş.

02:30:48.460 --> 02:30:48.600
Tamam.

02:30:49.380 --> 02:30:50.580
Böyle yazmanızla.

02:30:51.340 --> 02:30:55.080
Bu delete bildirimlerini hiç yapmamanız arasında bir fark yok.

02:30:55.080 --> 02:31:02.000
Çünkü move memberlardan birini bildirirseniz dahi derleyici ne yapıyor?

02:31:02.640 --> 02:31:04.680
Copy memberları delete ediyor.

02:31:05.540 --> 02:31:06.460
Anlaşıldı mı?

02:31:06.940 --> 02:31:07.140
Evet.

02:31:08.020 --> 02:31:13.880
Diğer taraftan move memberlardan birini bildirirseniz sadece.

02:31:14.000 --> 02:31:16.280
Mesela sadece move constructor bildirdiniz.

02:31:17.420 --> 02:31:18.860
Move assignment'ın durumu ne?

02:31:18.860 --> 02:31:23.240
Sadece move constructor bildirdiniz.

02:31:23.320 --> 02:31:24.300
Bakalım hatırlıyor musunuz?

02:31:24.360 --> 02:31:25.720
Move assignment'ın durumu ne?

02:31:26.860 --> 02:31:28.020
Cevap not declared.

02:31:28.540 --> 02:31:28.820
Bravo.

02:31:29.540 --> 02:31:32.120
Ya da tam tersi move assignment bildirdiniz.

02:31:33.080 --> 02:31:33.680
Arkadaşlar.

02:31:34.540 --> 02:31:38.100
Efendim move constructor'ın durumu ne?

02:31:38.880 --> 02:31:40.500
Cevap not declared.

02:31:41.260 --> 02:31:42.860
Bakın şimdi sizinle de paylaşacağım.

02:31:42.860 --> 02:31:43.500
Kaynaşacağım.

02:31:43.980 --> 02:31:45.800
Burayı boşaltayım.

02:31:47.000 --> 02:31:50.780
Ve oluşturduğum tabloyu buraya koyayım.

02:31:50.980 --> 02:31:54.440
Hiç unutmamamız gereken bundan sonra bir tablo.

02:31:54.560 --> 02:32:00.900
Şimdi belki başlangıçta hemen kafanızda canlandıramayabilirsiniz.

02:32:01.140 --> 02:32:04.200
Ama az önce anlattıklarımın toplu sonucu bu.

02:32:05.180 --> 02:32:05.740
Ne demek?

02:32:06.060 --> 02:32:06.700
Şimdi bakalım.

02:32:06.700 --> 02:32:18.600
Eğer hiçbir constructor bildirmezsem default constructor, distracter, copy constructor, copy assignment, move constructor, move assignment hepsini derleyici bildiriyor.

02:32:19.040 --> 02:32:20.740
Anlamadığımız bir yer olduğunu da söyleyin.

02:32:21.260 --> 02:32:24.000
Ya da olur da ben yanlış bir şey yazmışımdır.

02:32:24.660 --> 02:32:27.420
Ayıp olur diye söylememezlik yapmayın.

02:32:28.220 --> 02:32:28.840
Arkadaşlar.

02:32:29.260 --> 02:32:29.700
Devam.

02:32:29.700 --> 02:32:37.620
Eğer tablonun anlamını kavradınız değil mi?

02:32:37.960 --> 02:32:40.720
Eğer herhangi bir şey bildirmezsem hepsi bildiriliyor.

02:32:41.440 --> 02:32:51.900
Eğer herhangi bir constructor bildirirsem yani special member function olmayan constructor bildirirsem default constructor not declared öbürlerinin hepsi var.

02:32:53.320 --> 02:32:54.720
Takip edebiliyor muyuz?

02:32:54.720 --> 02:33:16.840
Default constructor bildirirsem arkadaşlar buraya dikkat destracter user declared ama move memberler not declared default constructor defaulted ama copy constructor ve copy assignment defaulted.

02:33:17.060 --> 02:33:19.020
Neden bunu farklı renkte yazdım?

02:33:19.900 --> 02:33:22.460
Bende renk körlüğü var ama kırmızı olduğunu düşünün.

02:33:22.460 --> 02:33:24.980
Neden bunu farklı renkte yazdım?

02:33:25.260 --> 02:33:27.660
Çünkü bu istenmeyen bir durum.

02:33:28.200 --> 02:33:37.260
Yani böyle bir kod yazmışsanız arkadaşlar hem deprecated açık kırmızıymış bu ara ben kırmızı yanlış söylememişim.

02:33:37.380 --> 02:33:39.480
Renklerin çoğunu algılayamıyorum çünkü.

02:33:40.000 --> 02:33:40.140
Evet.

02:33:41.460 --> 02:33:45.400
Diyor ki Yusuf onların açacağı tehlikeli durumları konuşacak mıyız?

02:33:45.400 --> 02:33:52.960
Biz aslında konuştuk bile hatırlarsanız neden copy constructor'ı yazmamız gerekir?

02:33:53.060 --> 02:33:56.180
Neden copy assignment'ı yazmamız gerekir?

02:33:56.360 --> 02:34:02.080
Aslında açıklaması orada ama Yusuf isterseniz oraya tekrar döneriz bir sonraki derste.

02:34:02.860 --> 02:34:03.080
Evet.

02:34:03.080 --> 02:34:07.280
Bakınız lütfen mouse'u takip edin.

02:34:07.900 --> 02:34:13.260
Destructor, copy constructor, copy assignment hangisini bildirirseniz bildirin.

02:34:13.600 --> 02:34:15.220
Move memberler not declared.

02:34:16.560 --> 02:34:17.680
Görüyorsunuz değil mi?

02:34:18.380 --> 02:34:24.440
Copy constructor bildirirsek o da bir constructor olduğu için default constructor not declared.

02:34:25.400 --> 02:34:28.080
Copy assignment defaulted ama çok tehlikeli.

02:34:28.080 --> 02:34:32.640
Tehlikeli yine arkadaşlar neden tehlikeli?

02:34:32.680 --> 02:34:34.560
Yusuf'un sorusuna da geri dönelim.

02:34:35.140 --> 02:34:39.380
Şimdi bakın siz copy constructor yazıyorsanız demek ki onu yazmanız için bir neden var.

02:34:40.140 --> 02:34:40.720
Öyle değil mi?

02:34:40.980 --> 02:34:42.320
Muhtemelen bir handle var.

02:34:43.000 --> 02:34:48.820
Bu durumda copy assignment'ın da onunla aynı mantıkta oluşturulması gerekiyor.

02:34:48.900 --> 02:34:51.220
Ama copy assignment'ı derleyici öyle yazmıyor ki.

02:34:52.480 --> 02:34:55.860
Evet ve yine move memberler not declared.

02:34:55.860 --> 02:34:58.260
Takip edebildik mi?

02:34:58.460 --> 02:34:59.280
Copy assignment.

02:35:00.280 --> 02:35:03.220
Bu durumda da copy constructor defaulted.

02:35:03.340 --> 02:35:14.800
Kırmızı olanlar ya da açık kırmızı olanlar Yusuf'un dediği gibi hem deprecated olanlar hem de yapmanız sakıncalı olan durumlar.

02:35:15.860 --> 02:35:16.020
Evet.

02:35:17.200 --> 02:35:21.600
Move constructor ya da move assignment'ı bildirirsem buraya dikkat.

02:35:21.600 --> 02:35:24.820
Copy memberların delete edildiğini görüyorsunuz.

02:35:24.820 --> 02:35:32.700
Move constructor'ı bildirirsem move assignment'ın not declared olduğunu görüyorsunuz.

02:35:33.420 --> 02:35:39.500
Move assignment'ı bildirirsem move constructor'ın not declared olduğunu görüyorsunuz.

02:35:40.300 --> 02:35:45.720
Move constructor'ı bildirirsem default constructor'ın not declared olduğunu görüyorsunuz.

02:35:45.720 --> 02:35:52.880
Aslında bir iki kere bakınca arkadaşlar tabloyu ezberlemeniz mümkün.

02:35:53.000 --> 02:35:59.180
Zaten genel mantığı da kavradığınız için ben ciddi bir zorluk çıkacağını düşünmüyorum.

02:35:59.180 --> 02:36:06.740
Ama yine de burada itiraz ettiğiniz ya da anlamadığınız herhangi bir nokta varsa onu sorabilirsiniz.

02:36:07.460 --> 02:36:07.640
Evet.

02:36:08.340 --> 02:36:10.200
Zaten kritik noktaları gösterdim.

02:36:10.320 --> 02:36:15.260
Bakın destructor her zaman ya defaulted user declared olmadığı sürece.

02:36:15.960 --> 02:36:19.560
Yani destructor'ın olmaması diye bir senaryo söz konusu değil.

02:36:20.740 --> 02:36:28.280
Move constructor'lar sınıfa destructor, copy constructor ya da copy assignment bildirirseniz not declared.

02:36:28.280 --> 02:36:34.500
Ama sınıfa move member'ları bildirirseniz copy member'lar not declared değil.

02:36:34.740 --> 02:36:36.780
Copy member'lar deleted.

02:36:37.280 --> 02:36:48.760
Sınıfa bir constructor bildirirseniz ister special member function olan arkadaşlar constructor'lardan biri ister parametreli herhangi bir constructor olsun.

02:36:49.620 --> 02:36:53.020
Bu durumda default constructor not declared.

02:36:53.160 --> 02:36:57.460
Bakın default constructor'ın not declared olduğu durumlara bakın.

02:36:57.460 --> 02:37:06.460
Default constructor'ın not declared olduğu arkadaşlar herhangi bir constructor'ı bildirirsem, copy constructor'ı bildirirsem, move constructor'ı bildirirsem.

02:37:07.640 --> 02:37:09.360
Tablo bu kadar açık.

02:37:09.360 --> 02:37:14.800
Şimdi buraya kadar biraz yüksek tempoyla geldik.

02:37:15.020 --> 02:37:17.280
Anlamadığınız yerler olursa sorun dedim.

02:37:18.360 --> 02:37:25.360
Ben son beş dakikayı bundan sonraki konu başlıklarının neler olduğunu açıklamakla geçireceğim.

02:37:26.220 --> 02:37:29.120
Yani yeni bir konuya geçmeyeceğim arkadaşlar.

02:37:29.120 --> 02:37:34.820
Şimdi bundan sonra göreceğimiz konu başlıkları şunlar.

02:37:35.240 --> 02:37:39.420
Bunlar bir kısmı küçük alt başlıklar, bir kısmı önemli alt başlıklar.

02:37:40.700 --> 02:37:43.120
Geçen derslerden bir tanesine bir arkadaşım söylemişti.

02:37:44.220 --> 02:37:45.880
Ben onu henüz görmedik dedim.

02:37:46.000 --> 02:37:48.560
Sanıyorum Cengiz Han arkadaşımdı.

02:37:49.640 --> 02:37:55.520
Modern C++'da dile eklenen delegating constructor dediğimiz bir yapı var.

02:37:55.520 --> 02:37:58.000
Eski C++'da yoktu.

02:37:58.880 --> 02:38:00.120
Yılmaz Çağrı Yüksel.

02:38:00.640 --> 02:38:06.320
Açık kırmızıların sorunu yani deprecated senaryolar runtime sorunu yaratacak.

02:38:06.940 --> 02:38:12.360
Deleted veya not declared fonksiyonlara erişim istenirse compile time error alacağız.

02:38:13.240 --> 02:38:13.880
Doğru mudur?

02:38:14.100 --> 02:38:16.180
Şimdi soruyu tam olarak anlamamış olabilir mi?

02:38:16.240 --> 02:38:17.680
İki tane ayrı soru mu var?

02:38:18.540 --> 02:38:22.260
Deprecated senaryolar runtime sorunu yaratacak.

02:38:22.260 --> 02:38:24.860
Yani onun compile time ile alakası yok.

02:38:25.520 --> 02:38:28.780
Buraya geri dönelim arkadaşımın sorusunu anlamaya çalışayım.

02:38:29.340 --> 02:38:34.060
Mesela bir sınıfa destructor bildirirseniz arkadaşlar,

02:38:35.140 --> 02:38:37.780
destructor'ı user declared yaparsanız

02:38:37.780 --> 02:38:45.260
ama copy constructor ve copy assignment'ın derleyici tarafından default edilmesini sağlarsanız

02:38:45.260 --> 02:38:48.040
bu compile time'a yönelik bir hata değil.

02:38:48.140 --> 02:38:49.800
Bu run time'a yönelik bir hata.

02:38:50.580 --> 02:38:56.600
Yani bu sınıf nesneleri kopyalandığı zaman copy constructor ya da copy assignment yoluyla

02:38:56.600 --> 02:39:07.800
%99.99 derleyicinin yazacağı arkadaşlar copy constructor ve copy assignment sizin işinizi görmeyecek, problem yaratacak.

02:39:07.800 --> 02:39:13.200
Eğer bu anlamda söylediyseniz Yılmaz çağrı söylediğiniz şüphesiz doğru.

02:39:14.120 --> 02:39:22.060
Ama ikinci soruya ayrı bir soru olarak, bravo ben doğru anlamışım, ikinci soruya ayrı bir soru olarak soruyorsanız

02:39:22.060 --> 02:39:27.580
not declare fonksiyonla çağrı yapılması durumu bu runtime ile alakalı değil.

02:39:27.700 --> 02:39:30.140
Bu syntax hatası arkadaşlar.

02:39:30.140 --> 02:39:35.080
Mesela arkadaşımın sorusunu biraz canlı hale getirelim.

02:39:35.640 --> 02:39:37.560
İzleyin bakın canlı hale getirelim.

02:39:37.840 --> 02:39:39.520
Hatta şu anda da güzel bir örnek var.

02:39:40.180 --> 02:39:40.680
Soru.

02:39:42.640 --> 02:39:43.460
My class.

02:39:44.740 --> 02:39:45.420
Me.

02:39:46.100 --> 02:39:48.680
Sadece sorularıma cevap verin her bir soruya.

02:39:49.440 --> 02:39:50.700
Neden sentatat hastan?

02:39:55.420 --> 02:39:56.140
Cevap.

02:39:56.960 --> 02:39:59.580
Arkadaşlar default constructor yok.

02:39:59.580 --> 02:40:02.020
Default bir constructor yok demeyin.

02:40:02.520 --> 02:40:03.740
Default constructor yok.

02:40:04.060 --> 02:40:06.620
Çünkü constructor yok derseniz aha bu ne derim?

02:40:07.060 --> 02:40:07.900
Bu da bir constructor.

02:40:08.700 --> 02:40:09.080
Anladım.

02:40:09.420 --> 02:40:09.620
Tamam.

02:40:09.780 --> 02:40:11.000
Bunun peki.

02:40:11.620 --> 02:40:12.360
My class.

02:40:14.220 --> 02:40:16.200
Şimdi default constructor var.

02:40:18.300 --> 02:40:18.940
M1.

02:40:20.820 --> 02:40:21.580
M2.

02:40:24.580 --> 02:40:26.100
M1 eşit M2.

02:40:27.320 --> 02:40:28.300
Geçerlemediği mi?

02:40:29.580 --> 02:40:31.420
Error mü legal mi?

02:40:33.820 --> 02:40:34.660
Cevap.

02:40:34.800 --> 02:40:35.240
Error.

02:40:36.060 --> 02:40:36.880
Neden error?

02:40:37.520 --> 02:40:42.800
Çünkü bir move member'ı bildirdiğim için copy member'lar delete edilmiş durumda.

02:40:42.800 --> 02:40:52.180
Dolayısıyla derleyici delete edilmiş copy assignment'a çağrı yaptığım, çağrı yapmam nedeniyle sentaks hatası verecek.

02:40:52.920 --> 02:40:54.080
Devam ediyorum.

02:40:54.080 --> 02:40:56.020
M1 eşittir.

02:40:56.020 --> 02:40:57.860
Stood move.

02:40:57.860 --> 02:41:00.360
Stood move make'i.

02:41:00.360 --> 02:41:02.660
Bu legal mi?

02:41:04.400 --> 02:41:05.500
Cevap geçerli.

02:41:06.140 --> 02:41:14.680
Çünkü burada eşittir'in sağ tarafındaki ifade r value expression olduğu için move assignment fonksiyonu çağrılacak.

02:41:14.680 --> 02:41:24.060
Arkadaşlar çok tipik yapılan bir hata mülakatlarda da soruyorlar ama cevabını bir dahaki derse bırakacağım.

02:41:24.660 --> 02:41:30.460
Bakın şimdi copy member'ları delete etmek istenebilir, gerekebilir, son derece doğal.

02:41:30.460 --> 02:41:37.160
Yani sınıfın ne olduğuna bağlı olarak non-copyable bir sınıf oluşturmak isteyebilirsiniz.

02:41:37.720 --> 02:41:40.620
Ama move member'ları asla delete etmeyin.

02:41:41.240 --> 02:41:47.000
Yani hiçbir nedenle bir move member'ın delete edilmesinin size sağlayacağı ekstra bir fayda yok.

02:41:47.400 --> 02:41:48.660
Hadi bunu da not alarak alın.

02:41:48.860 --> 02:41:49.960
Ben bazen görüyorum.

02:41:50.460 --> 02:41:53.620
Mesela move constructor ya da move assignment'ı delete etmiş.

02:41:53.620 --> 02:42:01.860
Söyleyin bakalım move member'ları delete ederseniz bunun olası ilk kötü sonucu ne olur?

02:42:02.360 --> 02:42:08.120
Move member'ları delete ederseniz bunun olası kötü sonucu ne olur?

02:42:08.720 --> 02:42:15.580
Arkadaşlar cevap arkadaşlar copy'e fallback olmaz.

02:42:17.100 --> 02:42:21.180
Yani normalde move member olmasaydı copy'e fallback olacaktı değil mi?

02:42:21.180 --> 02:42:29.240
Ama move member'ı delete ederseniz move gereken yerde sentaks hatası olur.

02:42:30.160 --> 02:42:31.880
Ne demek istediğimi herkes anladı mı?

02:42:32.720 --> 02:42:34.500
Yani şöyle bir sınıf olsaydı.

02:42:35.500 --> 02:42:36.980
Bak dedi açmayalım.

02:42:37.180 --> 02:42:41.840
Şöyle bir sınıf olsaydı arkadaşlar copy constructor'ı var.

02:42:45.280 --> 02:42:47.640
Efendim copy assignment'ı var.

02:42:49.920 --> 02:42:50.700
Evet.

02:42:51.180 --> 02:42:56.040
Ama move member ya da member'lar delete edilmiş.

02:42:57.320 --> 02:42:59.520
Şimdi bunun bir mantığı var mı?

02:42:59.660 --> 02:43:00.340
Olabilir mi?

02:43:01.080 --> 02:43:01.360
Hayır.

02:43:02.420 --> 02:43:02.860
Neden?

02:43:03.920 --> 02:43:13.720
Çünkü bu durumda taşıma gereken yerde taşıma olmadığı için biz kopyalamaya fallback olmasını istiyoruz.

02:43:13.720 --> 02:43:17.440
Ama fallback olma sentaks hatası olur.

02:43:17.440 --> 02:43:19.460
İsterseniz bakın şimdi.

02:43:19.460 --> 02:43:24.320
My class default constructor arkadaşlar.

02:43:24.320 --> 02:43:27.500
Arkadaşlar sırasını düzeltelim.

02:43:30.140 --> 02:43:30.380
Evet.

02:43:32.980 --> 02:43:34.300
Const my class ref.

02:43:35.420 --> 02:43:37.740
My class ref ref.

02:43:38.740 --> 02:43:39.740
Evet.

02:43:40.480 --> 02:43:41.320
My class.

02:43:41.560 --> 02:43:43.800
Yanlış yazarsam söyleyenin hızlı gidiyorum çünkü.

02:43:44.100 --> 02:43:46.080
My class ref ref.

02:43:46.080 --> 02:43:47.620
Eşittir.

02:43:47.620 --> 02:43:48.300
Delete.

02:43:49.300 --> 02:43:51.240
Şimdi programcı ne yapmış?

02:43:51.240 --> 02:43:54.740
Sınıfın move member'larını delete etmiş.

02:43:55.240 --> 02:43:56.860
Ama copy member'ları var.

02:43:57.700 --> 02:43:59.820
Peki örneğin böyle bir senaryoda ne olacak?

02:44:01.140 --> 02:44:02.340
Copy çalışmayacak.

02:44:03.100 --> 02:44:09.500
Move delete edildiği için delete edilmiş fonksiyona yapılan çağrı sentaks hatası oluşturacak.

02:44:09.500 --> 02:44:19.500
Ama move member'ları delete etmek yerine bildirmeseydi şimdi taşıma gereken yerde taşıma nereye düşecekti?

02:44:20.280 --> 02:44:24.500
İşte orada fallback terimini kullandım ya kopyalamaya fallback olacaktı.

02:44:25.820 --> 02:44:29.000
Arkadaşlar bugünkü ve bu haftaki derslerimiz de burada sona eriyor.

02:44:29.340 --> 02:44:31.380
Derse katıldığınız için çok teşekkür ediyorum.

02:44:32.080 --> 02:44:33.500
Bir dahaki hafta görüşmek üzere.

02:44:33.800 --> 02:44:36.280
Herkese iyi çalışmalar veriyorum.

02:44:36.720 --> 02:44:38.220
Hoşçakalın sevgili arkadaşlar.

02:44:39.500 --> 02:45:09.480
Altyazı M.K.

