### ğŸ“˜ C++ Dersi NotlarÄ±: 43. GÃ¼n (STL KonteynerlarÄ± - BÃ¶lÃ¼m II)
**Tarih:** 27 KasÄ±m 2024
**Konular:** `std::list`, `std::forward_list` ve `std::set` GiriÅŸ

---

#### 1. std::list (Double Linked List / Ã‡ifte BaÄŸlÄ± Liste) [00:00 - 11:21]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
`std::vector` ve `std::deque` gibi konteynerlar bellek bloÄŸu bazlÄ±dÄ±r. Ancak verinin ortasÄ±ndan sÄ±k sÄ±k ekleme ve silme yapÄ±lmasÄ± gerekiyorsa, bu konteynerlar Ã¶ÄŸeleri kaydÄ±rdÄ±ÄŸÄ± iÃ§in maliyetlidir. `std::list`, konumunu (iterator) bildiÄŸimiz her yerden ekleme ve silme iÅŸlemini **Constant Time** (sabit zaman) karmaÅŸÄ±klÄ±ÄŸÄ±nda yapmak iÃ§in tasarlanmÄ±ÅŸtÄ±r.

**ğŸ” Arka Plan (Under the Hood)**
`std::list` bir **Double Linked List** (Ã§ifte baÄŸlÄ± liste) veri yapÄ±sÄ±dÄ±r. Her bir Ã¶ÄŸe bir "node" (dÃ¼ÄŸÃ¼m) iÃ§inde tutulur.
*   DÃ¼ÄŸÃ¼mler ayrÄ± ayrÄ± allocate (tahsis) edilir, bu yÃ¼zden **Spatial Locality** (mekansal yerellik) saÄŸlamaz.
*   **Cash Friendly** (Ã¶n bellek dostu) deÄŸildir.
*   Dinamik bellek maliyeti, her Ã¶ÄŸe iÃ§in ayrÄ± `malloc/new` Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ± iÃ§in yÃ¼ksektir.

**ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art)**
```text
      Anchor (Head)                                     Anchor (Tail)
          |                                                 |
          v                                                 v
    +-----------+       +-----------+       +-----------+       +-----------+
    | prev: NULL| <---- |   prev    | <---- |   prev    | <---- |   prev    |
    | data: 10  |       |   data    |       |   data    |       |   data    |
    | next: ----| ----> |   next    | ----> |   next    | ----> | next: NULL|
    +-----------+       +-----------+       +-----------+       +-----------+
```

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±**
*   **Vector:** Index ile eriÅŸim $O(1)$, araya ekleme $O(n)$.
*   **List:** Index ile eriÅŸim $O(n)$ (Linear Complexity - DoÄŸrusal KarmaÅŸÄ±klÄ±k), araya ekleme $O(1)$ (konum biliniyorsa).

**ğŸš© MÃ¼lakat Sorusu / Kritik Nokta**
**Soru:** Bir iÅŸlemi hem bir algoritma (global function) hem de sÄ±nÄ±fÄ±n Ã¼ye fonksiyonu (member function) yapabiliyorsa hangisi tercih edilmelidir?
**Cevap:** Kesinlikle **Ãœye Fonksiyon** tercih edilmelidir. Ã‡Ã¼nkÃ¼ Ã¼ye fonksiyon sÄ±nÄ±fÄ±n iÃ§sel implementasyonuna (private pointer'lar, dÃ¼ÄŸÃ¼m yapÄ±sÄ± vb.) eriÅŸebilir ve daha dÃ¼ÅŸÃ¼k maliyetle Ã§alÄ±ÅŸÄ±r. Algoritmalar ise sadece iterator arayÃ¼zÃ¼nÃ¼ kullanabilir. [10:13]

---

#### 2. std::list'e Ã–zgÃ¼ Ãœye Fonksiyonlar [11:21 - 29:00]

`std::list`, `std::sort` veya `std::reverse` gibi **Random Access Iterator** (rastgele eriÅŸim iteratÃ¶rÃ¼) bekleyen algoritmalarla Ã§alÄ±ÅŸamaz. Bu yÃ¼zden kendi Ã¶zelleÅŸmiÅŸ fonksiyonlarÄ±na sahiptir.

**Kod Ã–rneÄŸi: Reverse ve Erase Ä°ÅŸlemleri**
```cpp
#include <list>
#include <string>
#include <iterator>

int main() {
    std::list<std::string> myList = {"ali", "veli", "can"};

    myList.reverse(); // <-- Hoca buraya dikkat Ã§ekti: std::reverse(algoritma) deÄŸil, Ã¼ye fonksiyon! [12:20]

    // Belirli bir konumu silme
    auto it = std::next(myList.begin()); 
    myList.erase(it); // Ä°kinci Ã¶ÄŸeyi siler.

    // BaÅŸtan ve sondan silme/ekleme O(1)
    myList.push_front("nuri"); // [15:52]
    myList.pop_back();
}
```

**ğŸ” remove() ve remove_if() FarkÄ± [20:23]**
`std::vector`'de `std::remove` algoritmasÄ± "Logical Erase" (mantÄ±ksal silme) yaparken, `std::list::remove` Ã¼ye fonksiyonu dÃ¼ÄŸÃ¼mleri fiziksel olarak siler ve belleÄŸi iade eder.

**Kod Ã–rneÄŸi: remove_if ve Lambda KullanÄ±mÄ± [24:05]**
```cpp
myList.remove_if([](const std::string& s) {
    return s.front() == s.back(); // Ä°lk ve son harfi aynÄ± olanlarÄ± sil. [25:00]
});
```

---

#### 3. std::list::sort() ve Ã–zel KarÅŸÄ±laÅŸtÄ±rÄ±cÄ±lar [29:00 - 35:30]

`std::list::sort()`, listeyi dÃ¼ÄŸÃ¼m pointer'larÄ±nÄ± manipÃ¼le ederek sÄ±ralar (Ã¶ÄŸeleri kopyalamaz, baÄŸlarÄ± deÄŸiÅŸtirir).

**ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar**
Hoca, lambdalarÄ±n iÃ§inde dÄ±ÅŸarÄ±daki bir fonksiyonu veya nesneyi kullanmak iÃ§in **Capture** (yakalama) yapÄ±lmasÄ± gerektiÄŸini, aksi halde **Syntax Error** (sentaks hatasÄ±) oluÅŸacaÄŸÄ±nÄ± hatÄ±rlattÄ±. [32:30]

**Kod Ã–rneÄŸi: Custom Comparator (Ã–zel KarÅŸÄ±laÅŸtÄ±rÄ±cÄ±)**
```cpp
auto fc_sum = [](const std::string& s) {
    int sum = 0;
    for (char c : s) sum += c;
    return sum;
};

// Harf toplamlarÄ±na gÃ¶re sÄ±ralama
myList.sort([&fc_sum](const std::string& s1, const std::string& s2) { // <-- fc_sum'u capture ettik
    return fc_sum(s1) < fc_sum(s2); // [33:05]
});
```

---

#### 4. Splice Ä°ÅŸlemi (DÃ¼ÄŸÃ¼m Transferi) [45:30 - 55:30]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
Ä°ki liste arasÄ±nda veri transferi yaparken Ã¶ÄŸeleri kopyalayÄ±p eskisini silmek (Copy & Erase) Ã§ok maliyetlidir. **Splice**, bir listedeki dÃ¼ÄŸÃ¼mÃ¼ fiziksel olarak yerinden sÃ¶kÃ¼p diÄŸer listeye "baÄŸlama" iÅŸlemidir.

**ğŸ” Arka Plan (Under the Hood)**
*   **No Copy, No Move:** Nesne kopyalanmaz veya taÅŸÄ±nmaz.
*   **No Destruction:** Destructor Ã§aÄŸrÄ±lmaz.
*   Sadece pointer'lar gÃ¼ncellenir. $O(1)$ karmaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r.

**Kod Ã–rneÄŸi: Splice UygulamasÄ± [50:11]**
```cpp
std::list<std::string> males = {"erkan", "fazil"};
std::list<std::string> females = {"ayla", "bilge"};

// females listesinin tamamÄ±nÄ± males listesinin baÅŸÄ±na ekle
males.splice(males.begin(), females); 
// ArtÄ±k females boÅŸ, males ise 4 Ã¶ÄŸeli. [51:53]
```

---

#### 5. std::forward_list (Singly Linked List) [55:30 - 01:10:00]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
`std::list` her dÃ¼ÄŸÃ¼mde iki pointer (prev, next) tutar. EÄŸer bellek kÄ±sÄ±tlÄ±ysa ve geriye doÄŸru yÃ¼rÃ¼meye (bidirectional) ihtiyaÃ§ yoksa, `std::forward_list` sadece tek bir pointer tutarak bellek tasarrufu saÄŸlar. C'deki yalÄ±n baÄŸlÄ± liste performansÄ±ndadÄ±r.

**ğŸš© MÃ¼lakat Sorusu / Kritik Nokta**
**Soru:** `std::forward_list` konteynerÄ±nda neden `size()` fonksiyonu yoktur? [56:50]
**Cevap:** Ã‡Ã¼nkÃ¼ tekli baÄŸlÄ± listede `size` bilgisini tutmak her ekleme/silmede ek maliyet getirir. STL felsefesi "kullanmadÄ±ÄŸÄ±n ÅŸeyin bedelini Ã¶deme" (zero-overhead) Ã¼zerinedir. EÄŸer boyut lazÄ±msa `std::distance` ile $O(n)$ zamanda hesaplanmalÄ±dÄ±r.

**ğŸ” after FonksiyonlarÄ± (Erase/Insert After) [01:00:30]**
Tekli baÄŸlÄ± listede bir dÃ¼ÄŸÃ¼mÃ¼ silmek iÃ§in ondan **Ã¶nceki** dÃ¼ÄŸÃ¼mÃ¼n pointer'Ä±nÄ± gÃ¼ncellemek gerekir. Bu yÃ¼zden geleneksel `erase(iter)` yerine `erase_after(iter)` kullanÄ±lÄ±r.

**ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Before Begin Abstraction)**
```text
[before_begin] -> [begin (ali)] -> [veli] -> [can] -> [end]
      ^
      |-- Bu hayali bir konumdur (soyutlama).
          Ä°lk Ã¶ÄŸeyi silmek iÃ§in erase_after(before_begin()) Ã§aÄŸrÄ±lÄ±r. [01:04:50]
```

---

--- DEVAM EDÄ°YOR ---

#### 6. Associative Containers (std::set, std::multiset) [01:27:00 - 01:38:00]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
Sequence container'larda (vektÃ¶r, liste) bir Ã¶ÄŸeyi aramak genellikle $O(n)$ maliyetlidir. **Associative Containers** (Ä°liÅŸkisel Kaplar), Ã¶ÄŸeleri belirli bir anahtar (key) deÄŸerine gÃ¶re sÄ±ralÄ± tutarak arama, ekleme ve silme iÅŸlemlerini **Logarithmic Time** ($O(\log n)$) karmaÅŸÄ±klÄ±ÄŸÄ±na indirger.

**ğŸ” Arka Plan (Under the Hood)**
*   Bu konteynerlar arka planda tipik olarak bir **Red-Black Tree** (KÄ±rmÄ±zÄ±-Siyah AÄŸaÃ§) olan dengelenmiÅŸ bir **Binary Search Tree** (Ä°kili Arama AÄŸacÄ±) kullanÄ±r. [01:35:00]
*   **Equality (EÅŸitlik)** yerine **Equivalence (EÅŸdeÄŸerlik)** kavramÄ±nÄ± kullanÄ±rlar. `==` operatÃ¶rÃ¼ne bakmazlar, sÄ±ralama kriteri Ã¼zerinden Ã¶ÄŸelerin Ã§akÄ±ÅŸÄ±p Ã§akÄ±ÅŸmadÄ±ÄŸÄ±nÄ± anlarlar.

**ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Binary Search Tree)**
```text
          [ 20 ]          <-- Root (KÃ¶k)
         /      \
      [10]      [30]      <-- Sol: KÃ¼Ã§Ã¼kler, SaÄŸ: BÃ¼yÃ¼kler
      /  \      /  \
    [5]  [15] [25] [35]
```

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±**
*   **std::set:** Her anahtardan sadece bir tane olabilir. (Unique Keys) [01:33:00]
*   **std::multiset:** AynÄ± anahtardan birden fazla bulunabilir. (Duplicate Keys)
*   **std::map / std::multimap:** Anahtara karÅŸÄ±lÄ±k gelen bir deÄŸer (Value) tutar. `std::pair<const Key, Value>` tipinde Ã¶ÄŸeler barÄ±ndÄ±rÄ±r. [01:36:00]

---

#### 7. Strict Weak Ordering (Kesin ZayÄ±f SÄ±ralama) [01:45:50 - 01:51:30]

**ğŸš© Kritik Nokta / MÃ¼lakat Sorusu**
Set ve Map gibi kaplara verdiÄŸiniz karÅŸÄ±laÅŸtÄ±rma fonksiyonu (comparator) belirli kurallara uymak zorundadÄ±r. EÄŸer bu kurallar bozulursa **UB (Undefined Behavior - TanÄ±msÄ±z DavranÄ±ÅŸ)** oluÅŸur. [01:51:00]

**DÃ¶rt AltÄ±n Kural (Strict Weak Ordering):**
1.  **Antisymmetry (Antisimetri):** EÄŸer `x < y` doÄŸruysa, `y < x` yanlÄ±ÅŸ olmalÄ±dÄ±r. [01:47:00]
2.  **Transitivity (GeÃ§iÅŸkenlik):** EÄŸer `x < y` ve `y < z` ise, `x < z` olmalÄ±dÄ±r. [01:47:40]
3.  **Irreflexivity (YansÄ±masÄ±zlÄ±k):** Bir Ã¶ÄŸe kendisinden kÃ¼Ã§Ã¼k olamaz (`x < x` her zaman false olmalÄ±dÄ±r). Bu yÃ¼zden `operator<=` karÅŸÄ±laÅŸtÄ±rÄ±cÄ± olarak kullanÄ±lamaz! [01:48:40]
4.  **Transitivity of Equivalence:** EÄŸer `x` ve `y` eÅŸdeÄŸerse ve `y` ve `z` eÅŸdeÄŸerse, `x` ve `z` de eÅŸdeÄŸer olmalÄ±dÄ±r. [01:49:30]

---

#### 8. Ã–zel KarÅŸÄ±laÅŸtÄ±rÄ±cÄ±lar ve Alias Templates [01:38:00 - 01:55:00]

**ğŸ” Arka Plan (Under the Hood)**
C++20 Ã¶ncesinde lambda ifadeleri **Default Constructible** (varsayÄ±lan oluÅŸturulabilir) deÄŸildi. Bu yÃ¼zden set tanÄ±mlarken lambdayÄ± constructor'a elle geÃ§mek gerekiyordu. C++20 ile **Stateless Lambdas** artÄ±k default construct edilebilir. [01:44:40]

**Kod Ã–rneÄŸi: Custom Comparator ve Alias Template**
```cpp
#include <set>
#include <functional>

// Mutlak deÄŸere gÃ¶re sÄ±ralayan alias template [01:51:30]
template <typename T>
using AbsSet = std::set<T, decltype([](T a, T b) { // <-- C++20 Stateless Lambda
    return std::abs(a) < std::abs(b);
})>;

int main() {
    AbsSet<int> mySet;
    mySet.insert(-10);
    mySet.insert(5);
    mySet.insert(10); // <-- Bu eklenmez! Ã‡Ã¼nkÃ¼ |10| ve |-10| eÅŸdeÄŸerdir (Equivalence). [01:42:50]
}
```

---

#### 9. Arama AlgoritmalarÄ±: lower_bound, upper_bound ve equal_range [02:07:30 - 02:25:00]

SÄ±ralÄ± bir aralÄ±kta bir deÄŸeri bulmak iÃ§in Ã¼Ã§ kritik kavram vardÄ±r:

1.  **std::lower_bound:** Aranan deÄŸerden kÃ¼Ã§Ã¼k olmayan ( $\ge$ ) ilk Ã¶ÄŸenin konumu. [02:10:50]
2.  **std::upper_bound:** Aranan deÄŸerden bÃ¼yÃ¼k ( $>$ ) ilk Ã¶ÄŸenin konumu. [02:11:15]
3.  **std::equal_range:** Hem lower hem de upper bound'u bir `std::pair` olarak dÃ¶ndÃ¼rÃ¼r.

**ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Bound KavramÄ±)**
```text
Range: [ 10, 20, 20, 20, 30, 40 ]
                ^           ^
                |           |
          lower_bound(20)  upper_bound(20)
          (Ä°lk 20)         (30'un konumu)

Distance(lower, upper) = 3 (KaÃ§ tane 20 olduÄŸu) [02:12:33]
```

**ğŸš© MÃ¼lakat Sorusu: Sorted Vector [02:25:00]**
**Soru:** Her zaman sÄ±ralÄ± kalmasÄ± gereken bir vektÃ¶re nasÄ±l ekleme yaparsÄ±nÄ±z?
**Cevap:** `std::lower_bound` ile eklenecek yeri bulup, `std::vector::insert` ile o konuma ekleyerek. Bu iÅŸlem $O(\log n)$ arama + $O(n)$ kaydÄ±rma maliyetindedir.

---

#### 10. std::set::insert Geri DÃ¶nÃ¼ÅŸ DeÄŸeri [02:31:00 - 02:40:22]

Set'in `insert` fonksiyonu, bir Ã¶ÄŸe zaten mevcutsa ekleme yapmaz. Bu durumu kontrol etmek iÃ§in fonksiyon bir `std::pair` dÃ¶ndÃ¼rÃ¼r.

**Kod Ã–rneÄŸi: Structured Binding ile Insert KontrolÃ¼ [02:38:30]**
```cpp
std::set<std::string> names = {"ali", "can"};

// C++17 Structured Binding (YapÄ±sal BaÄŸlama) [02:39:00]
auto [iter, inserted] = names.insert("ali"); 

if (!inserted) {
    std::cout << *iter << " zaten sette var!\n"; // [02:38:20]
}
```

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±**
*   **std::set:** `insert` -> `std::pair<iterator, bool>` dÃ¶ner.
*   **std::multiset:** `insert` -> Sadece `iterator` dÃ¶ner (baÅŸarÄ±sÄ±z olma ihtimali yoktur). [02:39:50]

---

