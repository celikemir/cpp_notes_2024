Harika bir istek! İşte dersin ilk kısmı için sanki çok çalışkan bir öğrenci tarafından tutulmuş gibi detaylı notlar:

**DERS NOTLARI: C++ İleri Seviye Programlama - 9. Ders (Sınıflar, Üye Fonksiyonlar, `this`, `const`, `inline`, Constructor'a Giriş)**

**Genel Not:** Hoca, dersin başında bir önceki dersin devamı olduğunu ve sınıfların üye fonksiyonlarından (member functions) kaldığımız yerden devam edeceğimizi belirtti. Sık sık "eski öğrendiklerinizi unutun" veya "unlearn yapın" diyerek C'den veya temel C++'tan gelen bazı alışkanlıkların modern C++'ta farklı ele alınabileceğine dikkat çekiyor.

---

**BÖLÜM 1: GİRİŞ VE DÜZELTME (00:00.000 - 01:01.100)**

*   **Tarih ve Saat:** 29 Temmuz 2024 Pazartesi, 19:30.
*   **Ders Numarası Düzeltmesi:** Başlangıçta 6. ders günü olarak belirtilse de, bunun "Online C++ Kursu" kapsamında **9. ders** günü olduğu düzeltildi (Hoca bunu `9.67` gibi bir kodla ifade etti, muhtemelen kendi numaralandırma sistemi). Bu karışıklığın aynı zamanda bir "Sİİ kursu" (muhtemelen "C kursu" demek istedi) verilmesinden kaynaklandığı belirtildi.
*   **Konu Başlangıcı:** Sınıflar konusuna girilmiş, sınıfların İngilizce karşılığıyla "member"larından bahsedilmeye başlanmış:
    *   Data members (Veri üyeleri)
    *   Member functions (Üye fonksiyonlar)
    *   Member types (Üye türleri)
    olarak 3 kategoriye ayrıldığı hatırlatıldı.

---

**BÖLÜM 2: NON-STATİK ÜYE FONKSİYONLARA GİRİŞ VE GLOBAL FONKSİYONLARLA KARŞILAŞTIRMA (01:07.540 - 04:23.140)**

*   **Yeniden Giriş (01:07.540 - 01:18.920):** Doğru ders numarası (9. ders) ile yeniden başlandı.
*   **Sınıfların Üye Fonksiyonları (01:19.800 - 01:37.700):**
    *   İki ana kategoriye ayrılır:
        1.  **Statik Üye Fonksiyonlar:** Henüz işlenmedi, daha sonra ele alınacak.
        2.  **Non-Statik Üye Fonksiyonlar:** Bu dersin ana konusu. Aksi söylenmedikçe bahsedilen üye fonksiyonlar non-statiktir.
    *   **Non-Statik Üye Fonksiyonların Semantik Anlamı (01:38.580 - 02:08.260):**
        *   Bunlar, C++ dil seviyesinde bir "semantik gizleme" veya "maskeleme"dir. Assembly (makine kodu) düzeyinde, "sınıfın üye fonksiyonu" diye özel bir kavram yoktur.
        *   Non-statik üye fonksiyonlar, çağrıldıkları sınıf nesnesinin adresiyle (gizli bir şekilde) çağrılırlar. Ancak C++ sentaksında bu adres operatörü (`&`) açıkça görünmez.
        *   **Örnek:**
            ```cpp
            class MyClass {
            public:
                void func(int val); // Bir parametre alan public üye fonksiyonu
            };
            ```
            Bu `func` fonksiyonu, assembly düzeyinde aslında iki parametre alır:
            1.  `MyClass*` (çağrıldığı `MyClass` nesnesinin adresi - `this` pointer)
            2.  `int val` (açıkça tanımlanmış parametre)
*   **Fonksiyon Türlerinin Ayrımı (02:09.180 - 02:56.440):**
    *   Üye fonksiyonların varlığıyla birlikte, fonksiyonları iki şekilde niteleyeceğiz:
        1.  **Global Function / Free Function / Standalone Function:** Bir sınıfa ait olmayan, bağımsız fonksiyonlar.
        2.  **Member Function (Üye Fonksiyon):** Bir sınıfa ait olan fonksiyonlar (örneğimizdeki `func` gibi).
*   **Gizli Parametre (`this` pointer) ve Çağrı Mekanizması (02:56.560 - 03:46.580):**
    *   Non-statik bir üye fonksiyonun gizli bir parametresi vardır: `this` pointer. Bu pointer, fonksiyonun çağrıldığı nesnenin adresini tutar.
    *   `.` (nokta) veya `->` (ok) operatörü ile bir üye fonksiyon çağrıldığında, bu operatörlerin solundaki nesnenin adresi (veya pointer'ın değeri olan adres) otomatik olarak fonksiyona `this` pointer aracılığıyla geçirilir.
    *   **Örnek:**
        ```cpp
        MyClass m_obj;
        m_obj.func(10); // m_obj'nin adresi (&m_obj) func fonksiyonuna 'this' olarak gizlice geçer.
        ```
        Bu sayede `func` fonksiyonu, `m_obj` nesnesinin üyelerine erişebilir.
*   **C Stili Global Fonksiyonla Karşılaştırma (03:47.020 - 04:23.140):**
    *   Eğer `MyClass::func` bir C++ global fonksiyonu (veya C'deki gibi) olsaydı, nesne adresini açıkça parametre olarak alması gerekirdi:
        ```c++
        // C++ global fonksiyonu veya C fonksiyonu (yaklaşık eşdeğeri)
        void global_func_equivalent(MyClass* p_my_class_obj, int val);
        ```
    *   Hoca, bazen fonksiyonları global olarak sunmanın daha iyi olabileceğini, ancak aradaki önemli farkların anlaşılması gerektiğini vurguladı.

---

**BÖLÜM 3: ÜYE FONKSİYONLAR VE GLOBAL FONKSİYONLAR ARASINDAKİ TEMEL FARKLILIKLAR (04:23.920 - 10:08.260)**

Hoca 3-4 tane önemli farklılık sayacağını belirtti.

1.  **Farklılık 1: Nesne Adresinin Geçirilme Şekli (04:23.920 - 05:52.020)**
    *   **Üye Fonksiyon:** `m_obj.func(val)` çağrısında, `m_obj`'nin adresi derleyici tarafından otomatik ve gizli bir şekilde (`this` pointer'ına) geçirilir. Pointer ile çağrıda (`ptr->func(val)`), `ptr`'nin tuttuğu adres geçirilir. Programcı açıkça adres göndermez.
    *   **Global Fonksiyon:** `global_func_equivalent(&m_obj, val)` çağrısında, programcı nesnenin adresini (`&m_obj`) açıkça göndermek zorundadır.
        ```cpp
        MyClass m;
        MyClass* p = &m;

        m.func(10);       // Otomatik adres geçişi
        p->func(10);      // Otomatik adres geçişi

        global_func_equivalent(&m, 10); // Açık adres geçişi
        ```

2.  **Farklılık 2: Erişim Kontrolü (Access Control) (05:52.980 - 07:07.060)**
    *   **Üye Fonksiyon:** Sınıfın kendi `private` veya `protected` üyelerine (veri üyeleri, diğer üye fonksiyonlar, üye türler) erişim yasağı *yoktur*.
        ```cpp
        class MyClass {
        private:
            int mx;
        public:
            void setX_member(int val) {
                mx = val; // Geçerli: Üye fonksiyon private üyeye erişebilir.
            }
        };
        ```
    *   **Global Fonksiyon:** Sınıfın `private` veya `protected` üyelerine *erişemez*. Derleyici erişim yasağı hatası verir.
        ```cpp
        // global_func_equivalent içinde:
        // p_my_class_obj->mx = val; // DERLEME HATASI: 'mx' private.
        // Hata mesajı: "Cannot access private member declared in class MyClass"
        ```

3.  **Farklılık 3: Kapsam (Scope) ve İsim Arama (Name Lookup) (07:07.620 - 08:28.800)**
    *   **Üye Fonksiyon (`MyClass::func`):** İsmi, ait olduğu sınıfın kapsamında (`class scope`) bulunur.
    *   **Global Fonksiyon (`global_func_equivalent`):** İsmi, tanımlandığı `namespace scope`'ta (veya global namespace'de) bulunur.
    *   Bu nedenle, üye fonksiyonlarının isimlerini buldurmak (name lookup) için özel niteleyiciler gerekir:
        *   Nokta operatörü: `m_obj.func()`
        *   Ok operatörü: `ptr->func()`
        *   Kapsam Çözünürlük Operatörü (`::`): Genellikle sınıf dışında üye fonksiyonu tanımlarken (`void MyClass::func(){...}`) veya statik üyelere erişirken kullanılır.
            *   Hoca, "çözünürlük benim tabirimle, İngilizce karşılığıyla scope resolution operatörü" ifadesini kullandı.

4.  **İsim Arama Başarısı vs. Bağlam Kontrolü (Context Control) (08:28.800 - 10:08.260)**
    *   Bir fonksiyon çağrısında derleyicinin yaptığı kontroller farklı aşamalardadır. İsim bulunsa bile, çağrı yine de hatalı olabilir.
    *   **Örnek 1: Eksik Argüman**
        ```cpp
        // MyClass::func(int val) şeklinde tanımlıysa
        m_obj.func(); // İsim arama BAŞARILI (`func` bulunur).
                      // Bağlam kontrolü HATALI: `func` bir `int` argüman bekliyor, verilmemiş.
        ```
    *   **Örnek 2: Non-statik Üyenin Nesnesiz Çağrılması**
        ```cpp
        // MyClass::func(int val) non-statik bir üye fonksiyonuysa
        // MyClass::func(123); // İsim arama BAŞARILI (`MyClass` scope'unda `func` bulunur).
                             // Bağlam kontrolü HATALI: Non-statik üye fonksiyon bir nesne üzerinden
                             // (m_obj.func(123) veya ptr->func(123)) çağrılmalıdır.
                             // "Ortada obje yok" durumu.
        ```
        Hoca, "statik üye fonksiyonu olsaydı geçerli olurdu, ama henüz görmedik" diye ekledi.

---

**BÖLÜM 4: ÜYE FONKSİYONLARIN TANIMLANMASI (10:09.260 - 14:24.280)**

*   **Genel Kurallar (10:32.980 - 12:28.600):**
    *   Hoca, "bundan önce öğrendiklerimizi devre dışı bırakıyoruz, unlearn yapıyoruz" ilkesini tekrarladı.
    *   Bir üye fonksiyonun (örneğin `void MyClass::set(int x, int y);`) tanımını yapmanın iki ana yolu vardır:
        1.  **Kaynak Dosyasında (`.cpp`) Tanım:** En yaygın yöntem. Fonksiyonun bildirimi başlık dosyasında (`.h`), tanımı ise ayrı bir kaynak dosyasında (`.cpp`) yapılır.
        2.  **Başlık Dosyasında (`.h`) `inline` Tanım:** Fonksiyonun tanımı, `inline` anahtar kelimesiyle birlikte başlık dosyasında yapılabilir. Bu, ODR (One Definition Rule - Tek Tanım Kuralı) ihlalini önler. (Bu konuya daha sonra detaylı girilecek.)
            *   Şu anki odak, `.cpp` dosyasında tanım yapma üzerinedir.
*   **Kaynak Dosyasında (`.cpp`) Tanım Sentaksı (12:29.100 - 14:24.280):**
    *   Normal fonksiyon tanımına benzer, ancak fonksiyon ismi sınıf ismiyle nitelenir.
    *   Sıralama:
        1.  (Varsa) Attribute'lar (örn: `[[nodiscard]]` - henüz işlenmedi)
        2.  Geri dönüş değeri türü (örn: `void`)
        3.  Sınıf ismi ve kapsam çözünürlük operatörü (`MyClass::`)
        4.  Fonksiyon ismi (örn: `set`)
        5.  Parametre listesi (örn: `(int x, int y)`)
        6.  Fonksiyon gövdesi (`{ ... }`)
    *   **Doğru Örnek:**
        ```cpp
        // MyClass.h
        class MyClass {
        public:
            void set(int x, int y); // Bildirim
        private:
            int mx, my;
        };

        // MyClass.cpp
        #include "MyClass.h" // Genellikle gerekli
        void MyClass::set(int x, int y) { // Tanım
            // Fonksiyon gövdesi buraya gelecek
            mx = x; // Bu kısım birazdan detaylanacak
            my = y;
        }
        ```
    *   **Tipik Hata (Global Fonksiyon Tanımlamak):**
        ```cpp
        // MyClass.cpp (yanlışlıkla global tanım)
        void set(int x, int y) { /* ... */ }
        // Bu, MyClass'ın üye fonksiyonu olan 'set'i değil,
        // 'set' isminde yeni bir global fonksiyonu tanımlar.
        // MyClass::set hala tanımsız kalır.
        ```
    *   Derleyici, `.cpp` dosyasındaki tanımın, `.h` dosyasındaki bildirimle (imza: isim, parametre türleri, sayısı, `const` durumu vb.) eşleşip eşleşmediğini kontrol eder. Uyumsuzluk varsa (örn: parametre sayısı farklıysa) derleme hatası verir.

---

**BÖLÜM 5: ÜYE FONKSİYON İÇİNDE İSİM ARAMA VE ÜYELERE ERİŞİM (14:24.960 - 28:08.400)**

*   **İsim Arama Kurallarındaki Farklılık (14:24.960 - 16:22.420):**
    *   **Global Fonksiyon İçinde:** İsim önce içinde bulunduğu blokta aranır. Bulunamazsa, onu kapsayan bloklarda sırayla aranır. En son global isim alanında (`global namespace`) aranır.
    *   **Üye Fonksiyon İçinde:** İsim önce içinde bulunduğu blokta aranır. Bulunamazsa, **doğrudan sınıfın kapsamında (`class scope`)** aranır. Orada da bulunamazsa, sınıfın bulunduğu `namespace` (eğer varsa) ve en son `global namespace`'de aranır.
    *   Bu şu anlama gelir: Eğer üye fonksiyon içinde bir isim (örn: `mx`) kullanılırsa ve bu isimde bir yerel değişken yoksa, derleyici bu ismi sınıfın üyeleri arasında arar.
        ```cpp
        // MyClass.cpp
        void MyClass::set(int x, int y) {
            // Yerel 'mx' veya 'my' değişkeni yok.
            mx = x; // Derleyici 'mx'i MyClass'ın üyeleri arasında arar ve bulur.
            my = y; // Derleyici 'my'ı MyClass'ın üyeleri arasında arar ve bulur.
        }
        ```
*   **`this` Pointer'ının Örtülü Kullanımı ve Non-Static Veri Üyelerine Erişim (16:22.420 - 19:30.580):**
    *   Bir üye fonksiyon içinde `mx = x;` gibi bir ifade yazıldığında, derleyici `mx`'in o sınıfa ait bir non-statik veri üyesi olduğunu anlar.
    *   Non-statik veri üyeleri, her sınıf nesnesi için ayrı ayrı 존재 eder (her nesnenin kendi `mx`'i vardır).
    *   Derleyici bu ifadeyi aslında şöyle yorumlar: `this->mx = x;`
        *   `this`: Fonksiyonun çağrıldığı nesnenin adresini tutan gizli bir pointer'dır.
        *   Yani `mx = x;` ifadesi, "bu fonksiyon hangi nesne için çağrıldıysa, *o nesnenin* `mx` üyesine `x` değerini ata" anlamına gelir.
    *   **Örnek:**
        ```cpp
        // main.cpp
        MyClass obj1, obj2;
        obj1.set(10, 20); // obj1 için set çağrılır. 'this' &obj1 olur. obj1.mx=10, obj1.my=20.
        obj2.set(30, 40); // obj2 için set çağrılır. 'this' &obj2 olur. obj2.mx=30, obj2.my=40.
        ```
    *   Hoca, bu durumda `this->mx = x;` gibi açıkça `this` kullanmanın genellikle gereksiz ve "çirkin" bir kodlama stili olduğunu, `this` pointer konusunun ileride detaylı işleneceğini belirtti.

*   **Üye Fonksiyonların Sınıfın `private` Üyelerine Erişimi (Tekrar) (19:30.580 - 20:04.880):**
    *   Hoca, bir üye fonksiyonun, ait olduğu sınıfın `private` bölümüne erişebildiğini teyit etti.
    *   **Önemli Vurgu:** Bu erişim, sadece fonksiyonun çağrıldığı nesnenin (`this` nesnesinin) `private` üyeleriyle sınırlı değildir. Bir üye fonksiyon, *aynı sınıftan olan başka nesnelerin* de `private` üyelerine erişebilir.

*   **Üye Fonksiyonların *Diğer* Nesnelerin `private` Üyelerine Erişimi (20:05.360 - 24:21.340):**
    *   Bir `MyClass` üye fonksiyonu, parametre olarak aldığı başka bir `MyClass` nesnesinin, global bir `MyClass` nesnesinin veya fonksiyon içinde yerel olarak tanımladığı bir `MyClass` nesnesinin `private` üyelerine erişebilir. Erişim yasağı yoktur.
    *   **Kapsamlı Örnek:**
        ```cpp
        // MyClass.h
        class MyClass {
        private:
            int secret_val;
            void private_helper_func() { /* ... */ }
        public:
            MyClass(int val = 0) : secret_val(val) {}
            void access_own_private() {
                secret_val = 10; // Kendi private üyesine erişim (this->secret_val)
                private_helper_func(); // Kendi private fonksiyonuna erişim
            }
            void access_other_private(MyClass& other_obj, MyClass* p_other_obj, const MyClass& c_other_obj) {
                other_obj.secret_val = 20; // Parametre (referans) nesnenin private üyesine erişim
                other_obj.private_helper_func(); // Parametre nesnenin private fonksiyonuna erişim

                p_other_obj->secret_val = 30; // Parametre (pointer) nesnenin private üyesine erişim

                int val = c_other_obj.secret_val; // const parametre nesnenin private üyesini okuma
                // c_other_obj.secret_val = 40; // HATA: const nesnenin üyesi değiştirilemez.
            }
        };

        MyClass global_my_obj(100); // Global MyClass nesnesi

        // MyClass::access_other_private içinde devam:
        // global_my_obj.secret_val = 50; // Global nesnenin private'ına erişim
        // MyClass local_my_obj(200);
        // local_my_obj.secret_val = 60; // Yerel nesnenin private'ına erişim
        ```
    *   Bu erişim hakkı, `private` veri üyeleri, `private` üye fonksiyonlar ve `private` üye türler (typedef, using, iç içe sınıf vb.) için geçerlidir.

*   **İsim Gizleme (Name Hiding/Masking/Shadowing) ve Çözüm Yolları (24:21.340 - 28:08.400):**
    *   Bir üye fonksiyon içindeki bir yerel değişken veya parametre, sınıfın bir üyesiyle (veri üyesi veya üye fonksiyon) aynı isme sahipse, bu yerel isim sınıf üyesinin ismini *gizler* (maskeler).
    *   **Örnek:**
        ```cpp
        // MyClass.h
        class MyClass {
            int mx; // Sınıfın veri üyesi
        public:
            void setMX(int mx); // Parametre ismi de 'mx'
        };

        // MyClass.cpp
        void MyClass::setMX(int mx) { // Parametre 'mx', sınıf üyesi 'this->mx'i gizler
            // mx = mx; // YANLIŞ: Parametre 'mx'e yine parametre 'mx' atanır.
                      // Sınıf üyesi olan 'this->mx' değişmez. Bu bir self-assignment.
        }
        ```
    *   Gizlenen sınıf üyesine erişmek için:
        1.  **`this->` Kullanımı:** `this->mx = mx;` (En net ve yaygın çözüm)
        2.  **Kapsam Çözünürlük Operatörü (`SınıfAdı::`):** `MyClass::mx = mx;`
            *   Hoca bu kullanımı gösterdi, ancak non-statik veri üyeleri için `this->` daha standarttır. `SınıfAdı::üye` genellikle statik üyeler için veya nadir bazı özel durumlarda kullanılır.
    *   **Global Kapsamdaki İsme Erişim:** Eğer bir global değişken de aynı isme sahipse (`::mx`), ona da `::` (unary scope resolution operator) ile erişilebilir.
        ```cpp
        // Global değişken
        int mx = 100;

        class MyClass {
            int mx; // Sınıf üyesi
        public:
            void exampleFunc(int mx) { // Parametre
                this->mx = mx + ::mx; // Sınıf üyesine, (parametre + global değişken) atanır.
            }
        };
        ```
    *   Hoca, bu tür karmaşık isim çakışmalarının iyi bir pratik olmadığını, sadece dilin kurallarını anlamak için gösterildiğini vurguladı. İsimlendirme konvansiyonları (örn: üye değişkenler için `m_` ön eki veya `_` son eki) bu tür sorunları en baştan engeller.

---

Tamamdır, Bölüm 6'dan itibaren detaylı notlara devam ediyorum:

---

**BÖLÜM 6: ÜYE FONKSİYONLARIN BİRBİRİNİ ÇAĞIRMASI, REKÜRSİF ÇAĞRILAR VE OVERLOADING DETAYLARI (28:08.400 - 44:54.800)**

*   **Global Fonksiyonların Birbirini Çağırması (Hatırlatma) (28:08.400 - 29:37.720):**
    *   Eğer bir global fonksiyon (`bar`), başka bir global fonksiyonu (`foo`) çağıracaksa ve `foo` bir nesne adresi (`MyClass* p`) bekliyorsa, `bar` bu adresi `foo`'ya açıkça geçirmelidir.
        ```cpp
        void foo(MyClass* p_obj) { /* ... */ }
        void bar(MyClass* p_main_obj) {
            // ...
            foo(p_main_obj); // 'bar'a gelen adresi 'foo'ya açıkça geçir.
            // ...
        }

        // Referans semantiği ile:
        void foo_ref(MyClass& r_obj) { /* ... */ }
        void bar_ref(MyClass& r_main_obj) {
            // ...
            foo_ref(r_main_obj); // 'bar_ref'e gelen referansı 'foo_ref'e açıkça geçir.
            // ...
        }
        ```
*   **Non-Statik Üye Fonksiyonların Birbirini Çağırması (29:38.480 - 32:15.160):**
    *   Bir non-statik üye fonksiyon (`foo_member`), aynı sınıfa ait başka bir non-statik üye fonksiyonu (`bar_member`) çağırdığında, `this` pointer'ı otomatik olarak (`foo_member`'ın aldığı `this` pointer'ı) `bar_member`'a geçirilir.
    *   İsim arama kuralları nedeniyle, `foo_member` içinde `bar_member()` çağrısı yapıldığında, derleyici önce blokta, sonra `class scope`'ta `bar_member`'ı arar. `MyClass::bar_member` bulunur.
    *   **Örnek:**
        ```cpp
        // MyClass.h
        class MyClass {
        public:
            void foo_member(int x);
            void bar_member(int y);
        };

        // MyClass.cpp
        void MyClass::foo_member(int x) {
            // ...
            bar_member(x * 2); // 'this' pointer (&nesne) otomatik olarak bar_member'a geçer.
                               // Yani, foo_member hangi nesne için çağrıldıysa,
                               // bar_member da AYNI nesne için çağrılır.
            // ...
        }
        void MyClass::bar_member(int y) { /* ... */ }

        // main.cpp
        MyClass obj;
        obj.foo_member(10); // obj.foo_member çağrılır (this = &obj).
                           // İçeride obj.bar_member(20) çağrılır (this = &obj).
        ```
    *   Yani, çağıran üye fonksiyon kendi aldığı (`this` ile gelen) nesne adresini, çağırdığı diğer üye fonksiyona gizlice aktarır. Her iki fonksiyon da aynı nesne üzerinde çalışır.

*   **İsim Gizleme (Name Hiding) ve Global Fonksiyon Çağrısı (32:16.440 - 33:16.220):**
    *   Eğer `bar_member` ile aynı isimde (`bar_member`) bir global fonksiyon da varsa, üye fonksiyon içindeki nitelenmemiş `bar_member()` çağrısı, `class scope`'taki üye fonksiyonu çağırır (global olan gizlenir).
    *   Global olan `bar_member` fonksiyonunu çağırmak için `::bar_member()` (unary scope resolution operator) kullanılmalıdır.
        ```cpp
        // global_bar.cpp
        void bar_member(int val) { /* Global bar_member */ }

        // MyClass.cpp
        void MyClass::foo_member(int x) {
            bar_member(x);      // MyClass::bar_member'ı çağırır.
            ::bar_member(x);    // Global bar_member'ı çağırır.
        }
        ```

*   **Üye Fonksiyonun Sınıf Adıyla Nitelenerek Çağrılması (33:16.220 - 35:12.680):**
    *   Bir üye fonksiyon içinden başka bir üye fonksiyonu çağırırken, genellikle ismi nitelemek gerekmez (`bar_member()`).
    *   Ancak, `this->bar_member()` veya nadiren `MyClass::bar_member()` (eğer özel bir durum varsa, genellikle statiklerle ilgili) şeklinde de çağrılabilir.
    *   Bir nesne üzerinden çağrı yaparken (`obj.foo_member()`), `obj.MyClass::foo_member()` şeklinde niteleme yapmak da sentaks hatası değildir, ancak gereksizdir.
    *   Pointer ile çağrı (`p->foo_member()`), `p->MyClass::foo_member()` şeklinde de yazılabilir.
    *   Bu durum, `::` (scope resolution) operatörünün `.` ve `->` (member selection) operatörlerinden daha yüksek önceliğe sahip olduğunu gösterir.

*   **Rekürsif (Recursive) Üye Fonksiyon Çağrıları (35:12.680 - 36:31.740):**
    *   Bir üye fonksiyon, tıpkı global fonksiyonlar gibi, kendini doğrudan veya dolaylı olarak çağırabilir (rekürsif çağrı).
    *   İsim arama kuralları nedeniyle, nitelenmemiş bir çağrı (eğer isim çakışması yoksa) yine kendini çağıracaktır.
        ```cpp
        // MyClass.cpp
        void MyClass::recursive_func(int count) {
            if (count <= 0) return;
            // ... işlem ...
            recursive_func(count - 1); // Kendini çağırır (this ile aynı nesne için).
        }
        ```
    *   Hoca, bu tür çağrıların stack overflow'a yol açmaması için bir sonlanma koşulu olması gerektiğini hatırlattı.

*   **İsim Arama ve Overloading Karışık Örnekler (36:31.740 - 41:39.300):**
    *   **Senaryo 1: Global Fonksiyon ve Üye Fonksiyon Aynı İsimde, Üye Fonksiyon İçinden Çağrı**
        ```cpp
        // Global
        int global_bar(int x) { return x * 10; }

        class MyClass {
        public:
            void foo(int val) {
                // ...
                bar(global_bar(val)); // 1. global_bar(val) çağrılır, geri dönüş değeri alınır.
                                      // 2. Bu değerle MyClass::bar(int) çağrılır.
                // ...
            }
            void bar(int x) { /* MyClass'ın bar'ı */ }
        };
        ```
    *   **Senaryo 2: Üye Fonksiyonların Overload Edilmesi**
        *   Üye fonksiyonlar, parametre sayıları veya türleri farklıysa birbirlerini overload edebilirler.
            ```cpp
            class MyClass {
            public:
                void process(int data);
                void process(double data);
                void process(const char* str);
            };
            // Bunların hepsi MyClass::process fonksiyonunun overload'larıdır.
            ```
    *   **Senaryo 3: Üye Fonksiyonların Yeniden Bildirimi (Redeclaration)**
        *   Global fonksiyonların aksine, bir üye fonksiyonun aynı kapsamda (class scope içinde) *sadece geri dönüş değeri farklı olacak şekilde* veya *aynı imzayla* yeniden bildirilmesi **sentaks hatasıdır**.
            ```cpp
            class MyClass {
            public:
                void func();
                // int func(); // HATA: Sadece geri dönüş değeri farklı, redeclaration.
                // void func(); // HATA: Aynı imzayla redeclaration.
            };
            ```
    *   **Senaryo 4: `public` ve `private` Üyelerin Overload Edilmesi**
        *   `public` bölümdeki bir üye fonksiyon ile `private` (veya `protected`) bölümdeki aynı isimli bir üye fonksiyon, parametreleri farklıysa birbirini overload edebilir. Hepsi aynı `class scope` içindedir.
            ```cpp
            class MyClass {
            private:
                void helper(int x);
            public:
                void helper(double y); // Geçerli: private helper(int) ile overload olur.
            };
            ```
    *   **Senaryo 5: İsim Arama ve Overload Resolution Birlikte**
        *   Eğer bir üye fonksiyon içinde `bar(2.3)` çağrısı yapılırsa:
            1.  `bar` ismi `class scope`'ta aranır.
            2.  Diyelim ki `MyClass::bar(int)` bulundu, ama `MyClass::bar(double)` bulunamadı.
            3.  Aynı isimde bir `global_bar(double)` olsa bile, `class scope`'taki `bar` ismi onu gizlediği için global olan dikkate alınmaz (eğer `::` ile çağrılmazsa).
            4.  Derleyici, `MyClass::bar(int)` fonksiyonunu `2.3` (double) argümanıyla çağırmaya çalışır.
            5.  `double`'dan `int`'e örtülü dönüşüm (implicit conversion) mümkünse (veri kaybı uyarısıyla birlikte), `MyClass::bar(int)` çağrılır.
            *   **Özet:** İsim arama, overload resolution'dan *önce* gelir. Bir isim bir kapsamda bulunduğunda, daha dış kapsamlardaki aynı isimler (eğer daha iyi bir eşleşme sunsalar bile) dikkate alınmaz, meğerki açıkça nitelenmesinler.

*   **Overload Resolution ve Erişim Kontrolü Sırası (41:39.300 - 44:54.800):**
    *   Bu çok önemli bir nokta ve sıkça yanlış anlaşılır.
    *   Derleyicinin bir fonksiyon çağrısını çözme adımları şöyledir (basitleştirilmiş):
        1.  **Name Lookup (İsim Arama):** Çağrılan fonksiyonun ismi bulunur.
        2.  **Function Overload Resolution (Fonksiyon Aşırı Yükleme Çözümlemesi):** Bulunan isimle eşleşen tüm overload adayları arasından en uygun olanı seçilir (argüman türlerine göre).
        3.  **Context Control (Bağlam Kontrolü):** Seçilen fonksiyonun çağrılma şekli (örn: `static`/`non-static`, argüman sayısı vs.) doğru mu diye bakılır.
        4.  **Access Control (Erişim Kontrolü):** *En son olarak*, seçilen fonksiyona erişim izni olup olmadığı (`public`, `private`, `protected`) kontrol edilir.
    *   **Yanlış Anlama:** "Private bir fonksiyon overload resolution'a dahil edilmez." BU YANLIŞTIR.
    *   **Doğru Yaklaşım:** Overload resolution yapılırken fonksiyonun `private` olup olmadığına bakılmaz. *Tüm adaylar* (erişim seviyesine bakılmaksızın) değerlendirilir. En iyi eşleşen fonksiyon seçildikten *sonra*, eğer bu seçilen fonksiyon `private` ise ve çağrı `private` erişime izin verilmeyen bir yerden yapılıyorsa, o zaman erişim hatası alınır.
    *   **Örnek:**
        ```cpp
        class MyClass {
        private:
            void func(int x) { /* Private versiyon */ }
        public:
            void func(double y) { /* Public versiyon */ }
        };

        // ...
        MyClass obj;
        obj.func(10); // '10' bir int.
                      // 1. Name lookup: MyClass::func bulunur.
                      // 2. Overload resolution:
                      //    - MyClass::func(int) -> int'e tam eşleşme.
                      //    - MyClass::func(double) -> int'ten double'a dönüşüm gerekir.
                      //    En iyi eşleşme MyClass::func(int)'dir.
                      // 3. Access control: MyClass::func(int) private. Çağrı sınıf dışından.
                      //    SONUÇ: DERLEME HATASI (erişim kontrolü nedeniyle).
                      //    Public olan MyClass::func(double) ÇAĞRILMAZ.
        ```
        Eğer `obj.func(10.0);` (double ile) çağrılsaydı, `MyClass::func(double)` seçilir ve public olduğu için sorunsuz çalışırdı.

---

**BÖLÜM 7: `const` DOĞRULUĞU (CONST CORRECTNESS) VE `const` ÜYE FONKSİYONLAR (44:54.800 - 01:01:15.360)**

Bu bölüm C++'ın temel taşlarından biridir ve çok önemlidir.

*   **Global Fonksiyonlarda `const` Parametreler (Hatırlatma) (46:41.540 - 50:08.220):**
    *   Bir fonksiyona pointer veya referans yoluyla bir nesne geçirildiğinde, fonksiyonun bu nesneyi değiştirip değiştirmeyeceği `const` anahtar kelimesiyle belirtilir.
    *   **Mutator (Değiştirici) Fonksiyon:** Nesneyi değiştirmesi beklenen fonksiyon. Parametresi `const` olmaz.
        ```cpp
        struct Data { int val; };
        void set_data_ptr(Data* p_data, int new_val) { // Mutator (pointer ile)
            p_data->val = new_val;
        }
        void set_data_ref(Data& r_data, int new_val) { // Mutator (referans ile)
            r_data.val = new_val;
        }
        ```
    *   **Accessor (Erişimci) Fonksiyon:** Nesneyi sadece okuması, değiştirmemesi beklenen fonksiyon. Parametresi `const` (low-level const) olur.
        ```cpp
        int get_data_ptr(const Data* p_data) { // Accessor (pointer ile)
            // p_data->val = 100; // HATA: const nesne değiştirilemez.
            return p_data->val;
        }
        int get_data_ref(const Data& r_data) { // Accessor (referans ile)
            // r_data.val = 100; // HATA: const nesne değiştirilemez.
            return r_data.val;
        }
        ```
    *   Hoca, `const` kullanmamanın "olabilecek en kaba semantik hata" olduğunu vurguladı eğer fonksiyon nesneyi değiştirmiyorsa.
    *   **`const` Overloading (Global Fonksiyonlarda):** Aynı isimli global fonksiyonlar, parametrelerinin `const` olup olmamasına göre overload edilebilirler. Bu, `const` nesneler ve `const` olmayan nesneler için farklı davranışlar tanımlamayı sağlar.
        ```cpp
        void process(Data* p_data);       // const olmayan için
        void process(const Data* p_data); // const olan için

        Data my_data;
        const Data c_my_data;
        process(&my_data);   // const olmayan 'process' çağrılır.
        process(&c_my_data); // const olan 'process' çağrılır.
        ```

*   **Üye Fonksiyonlarda `const` Belirteci (52:30.040 - 54:40.520):**
    *   Üye fonksiyonların nesneyi (yani `this` nesnesini) değiştirip değiştirmeyeceğini belirtmek için farklı bir sentaks kullanılır.
    *   `const` anahtar kelimesi, fonksiyonun parametre listesinden *sonra*, fonksiyon gövdesinden (eğer tanım yapılıyorsa) veya noktalı virgülden (eğer bildirim yapılıyorsa) *önce* gelir.
    *   **Non-`const` Member Function (Değiştirici):** Sınıf nesnesini değiştirebilir. `this` pointer'ı `MyClass* this` gibidir.
        ```cpp
        class MyClass {
        public:
            void mutator_func(); // Non-const (değiştirebilir)
        };
        ```
    *   **`const` Member Function (Erişimci):** Sınıf nesnesini *değiştirmemelidir*. `this` pointer'ı `const MyClass* this` gibidir. Bu, fonksiyon içinde `this` nesnesinin üyelerine yapılan atamaları veya non-`const` üye fonksiyon çağrılarını engeller.
        ```cpp
        class MyClass {
        public:
            void accessor_func() const; // const (değiştiremez)
        };
        ```
*   **`const` Üye Fonksiyonu Ne Zaman Kullanılmalı? (Yanlış ve Doğru Anlama) (54:40.680 - 01:01:15.360)**
    *   **Yaygın Yanlış Anlama:** "Bir üye fonksiyon, sınıfın *herhangi bir veri üyesini* değiştiriyorsa non-`const` olmalı, hiçbirini değiştirmiyorsa `const` olmalı."
        *   Hoca bunun **KESİNLİKLE YANLIŞ** olduğunu ve en çok yanlış anlaşılan noktalardan biri olduğunu belirtti.
    *   **Doğru Anlama:** Bir üye fonksiyonun `const` olup olmaması, sınıfın *veri üyelerinin* bit-bit değişip değişmediğiyle değil, **sınıf nesnesinin problem domenindeki gözlemlenebilir durumunun (observable state) değişip değişmediğiyle** ilgilidir.
        *   Yani, fonksiyon çağrıldıktan sonra, dışarıdan bakıldığında nesnenin anlamı, davranışı veya temel özellikleri değişmiş mi?
        *   **Hocanın Örneği: `Fighter` Sınıfı ve `cryName()` Fonksiyonu**
            *   Bir `Fighter` sınıfı var, `string cryName() const;` şeklinde bir fonksiyonu olsun. Bu fonksiyon savaşçının ismini bağırmasını sağlar ve ismini string olarak döndürür.
            *   **Senaryo A:** Eğer isim bağırmak savaşçının gücünü, enerjisini vs. (yani gözlemlenebilir durumunu) etkilemiyorsa, `cryName()` **`const`** olmalıdır. Veri üyelerinin (örn: bir sayaç) değişip değişmemesi bu kararı doğrudan etkilemez.
            *   **Senaryo B (Uçuk Örnek):** Eğer her isim bağırdığında savaşçının "güç puanı" (sınıfın bir veri üyesi) azalıyorsa, bu durumda `cryName()` fonksiyonu nesnenin gözlemlenebilir durumunu değiştirdiği için **non-`const`** olmalıdır. `const` yapılamaz.
        *   **Temel Fikir:** `const` üyeler, nesnenin "mantıksal `const`"luğunu (logical constness) korumalıdır, "fiziksel `const`"luğunu (bitwise constness - her bir bitin aynı kalması) değil.
    *   **Pointer Üyeler ve `const`:**
        *   Bir sınıfın `char* p_name;` gibi bir pointer veri üyesi olabilir.
        *   Bir `const` üye fonksiyon `p_name` pointer'ının *kendisini* (yani gösterdiği adresi) değiştiremez (`p_name = new_address;` // HATA).
        *   Ancak, `const` üye fonksiyon (normalde) `p_name`'in *gösterdiği veriyi* (`*p_name = 'A';`) değiştiremez, çünkü `this` `const MyClass*` olduğu için `this->p_name` de `char * const` gibi değil (pointer'ın kendisi const değil), `const char*` gibi (gösterdiği şey const) davranır.
            *   *Düzeltme/Not:* Hoca burada biraz hızlı geçti. Eğer `p_name` üyesi `char*` ise, `const` üye fonksiyonda `this` `const MyClass*` olur. `this->p_name` ifadesinin türü `char*` kalır. Ancak, `*(this->p_name) = 'X';` gibi bir atama, `this` nesnesini dolaylı yoldan değiştirdiği için (eğer `p_name` nesnenin bir parçası olarak kabul ediliyorsa) mantıksal `const`'luğu ihlal edebilir. Derleyici bunu doğrudan yakalamayabilir. Bu yüzden `mutable` veya dikkatli tasarım gerekir. Eğer `p_name` `const char*` olarak tanımlansaydı, o zaman `*(this->p_name)` zaten değiştirilemezdi.
    *   **Sonuç:** Bir fonksiyonun `const` olup olmayacağına karar verirken, sınıfın soyut arayüzüne ve nesnenin dışarıdan nasıl algılandığına odaklanılmalıdır, iç veri üyelerinin birebir değişimine değil.

---

Anlaşıldı, Bölüm 8 ile devam ediyorum. `mutable` anahtar kelimesi `const` doğruluğunun önemli bir parçası.

---

**BÖLÜM 8: `const` ÜYE FONKSİYONLAR İÇİNDE DERLEYİCİ KONTROLLERİ VE `mutable` ANAHTAR KELİMESİ (01:01:15.360 - 01:18:04.560)**

*   **Derleyicinin `const` Üye Fonksiyonlara Uyguladığı Sentaks Kontrolleri (01:01:15.360 - 01:08:39.320):**
    *   Hoca, semantik (mantıksal `const`'luk) ve sentaks (derleyicinin yaptığı kontrol) ayrımının önemli olduğunu vurguladı.
    *   Bir üye fonksiyon `const` olarak işaretlendiğinde, derleyici o fonksiyonun içindeki `this` pointer'ını `const MyClass* this` (veya eşdeğeri) olarak kabul eder. Bu, "low-level const pointer" anlamına gelir, yani `this` pointer'ı aracılığıyla erişilen nesnenin kendisi `const`'tur.
    *   Bu durumun getirdiği temel kısıtlamalar:
        1.  **Non-`static` Veri Üyelerinin Değiştirilememesi:** `const` bir üye fonksiyon içinde, sınıfın non-`static` veri üyelerine doğrudan atama yapılamaz.
            ```cpp
            class MyClass {
                int mx;
            public:
                void func_const() const {
                    mx = 5; // DERLEME HATASI: 'this->mx' (yani 'mx') const kabul edilir.
                }
                void func_non_const() {
                    mx = 5; // GEÇERLİ: Non-const fonksiyonda 'mx' değiştirilebilir.
                }
            };
            ```
            Bu, C'deki `const T* ptr; ptr->member = value;` hatasıyla aynı mantıktadır.
        2.  **Non-`const` Üye Fonksiyonların Çağrılamaması:** `const` bir üye fonksiyon içinden, aynı nesne için (`this` üzerinden) non-`const` bir üye fonksiyon çağrılamaz.
            ```cpp
            class MyClass {
            public:
                void non_const_helper() { /* ... */ }
                void const_caller() const {
                    non_const_helper(); // DERLEME HATASI: const fonksiyondan non-const fonksiyon çağrılamaz.
                                        // Çünkü non_const_helper, this nesnesini değiştirebilir.
                                        // Bu, const T* this'ten T* this'e dönüşüm gerektirir ki bu yasaktır.
                }
                void const_helper() const { /* ... */ }
                void another_const_caller() const {
                    const_helper(); // GEÇERLİ: const fonksiyondan başka bir const fonksiyon çağrılabilir.
                }
            };
            ```
            Bu kural, `const` fonksiyonun "nesneyi değiştirmeyeceğim" sözünü tutmasını sağlar. Eğer non-`const` bir yardımcı fonksiyon çağırabilseydi, bu sözü dolaylı yoldan çiğnemiş olurdu.
    *   **İstisna:** `const` bir üye fonksiyon, `static` veri üyelerini değiştirebilir (çünkü `static` üyeler `this` nesnesine ait değildir, sınıfa aittir). `const` bir üye fonksiyon, `static` üye fonksiyonları da çağırabilir.

*   **Sentaks vs. Semantik: Pointer Üyeler ve Yanıltıcı Durumlar (01:08:39.320 - 01:12:11.400):**
    *   Hoca, derleyicinin yaptığı sentaks kontrolünün her zaman semantik doğruluğu garanti etmediğini bir örnekle açıkladı.
    *   **Senaryo:** Sınıfın `int* mp;` gibi bir pointer üyesi var.
        ```cpp
        class MyClass {
            int* mp; // Pointer veri üyesi
            int g_var;
        public:
            MyClass() { mp = new int(0); g_var = 0; }
            ~MyClass() { delete mp; }

            void problematic_const_func() const {
                // mp = &g_var; // DERLEME HATASI: 'this->mp' (yani 'mp' pointer'ının kendisi) değiştirilemez.
                *mp = 5;      // DERLEYİCİ İÇİN GEÇERLİ (SENTAKS HATASI YOK)!
                              // 'mp'nin gösterdiği yerdeki değer değişiyor, 'mp' pointer'ı değil.
            }
        };
        ```
    *   `problematic_const_func` `const` olmasına rağmen, `*mp = 5;` satırı derleme hatası vermez. Çünkü `this` `const MyClass*` olduğunda, `this->mp` ifadesinin türü `int*` olarak kalır (aslında `int * const` gibi değil, `int *`ın gösterdiği değerin `const` olduğu gibi düşünülür: `const int*` değil, `int*`ün kendisi `const MyClass`ın bir parçası). Daha doğrusu, `mp`'nin kendisi `this` üzerinden değiştirilemez ama `mp`'nin gösterdiği *bellek alanı* `const` değildir.
    *   **Semantik Sorun:** Eğer `*mp`'nin değeri, `MyClass` nesnesinin *gözlemlenebilir durumunun* bir parçasıysa (örn: bir string sınıfında tutulan karakter dizisi), bu durumda `*mp = 5;` ifadesi nesnenin mantıksal `const`'luğunu ihlal eder, fonksiyon aslında nesneyi değiştirmiş olur. Ama derleyici bunu yakalayamaz.
    *   Bu durum, `const` doğruluğunun sadece derleyiciye bırakılamayacağını, programcının da mantıksal `const`'luğu düşünmesi gerektiğini gösterir.

*   **`mutable` Anahtar Kelimesi: Mantıksal `const`'luğu Korumak (01:12:11.400 - 01:18:04.560):**
    *   Bazen bir `const` üye fonksiyonun, sınıf nesnesinin *gözlemlenebilir durumunu değiştirmeden* bazı içsel veri üyelerini değiştirmesi gerekebilir.
    *   **Örnek Senaryolar:**
        1.  **Debugging Sayaçları:** Bir `const` fonksiyonun kaç kere çağrıldığını saymak için bir sayaç. Bu sayaç değişir ama nesnenin dışarıdan görünen anlamı değişmez.
        2.  **Caching (Önbellekleme):** Bir `const` fonksiyon pahalı bir hesaplama yapıyorsa, sonucu bir veri üyesinde saklayıp sonraki çağrılarda bu önbellekten okuyabilir. Önbellek değeri ilk hesaplamada değişir ama nesnenin mantıksal durumu değişmez.
        3.  **Mutex/Lock Nesneleri (Concurrency):** Bir `const` fonksiyon, thread-safe olmak için bir mutex'i kilitleyip açabilir. Mutex'in içsel durumu değişir ama asıl nesnenin mantıksal `const`'luğu korunur.
    *   Bu tür durumlarda, eğer bu içsel veri üyeleri normal şekilde tanımlanırsa, `const` üye fonksiyon içinde değiştirilmeleri derleme hatasına yol açar.
    *   **Çözüm: `mutable`**
        *   Bir non-`static` veri üyesi `mutable` anahtar kelimesiyle bildirilirse, bu üye **`const` bir üye fonksiyon içinde dahi değiştirilebilir.**
        *   `mutable` demek, derleyiciye "Bu üyenin değeri değişebilir, ama bu değişim nesnenin dışarıdan gözlemlenebilir (mantıksal) `const`'luğunu etkilemez. Lütfen `const` fonksiyon içinde buna atama yapmama izin ver." demektir.
    *   **Örnek (Debugging Sayacı):**
        ```cpp
        #include <string> // std::string için
        #include <iostream> // std::cout için

        class Person {
            std::string m_name;
            int m_age;
            mutable int m_get_name_call_count; // Bu üye mutable

        public:
            Person(const std::string& name, int age) : m_name(name), m_age(age), m_get_name_call_count(0) {}

            std::string getName() const {
                m_get_name_call_count++; // GEÇERLİ! Çünkü m_get_name_call_count mutable.
                                         // Bu, Person nesnesinin mantıksal durumunu (ismi, yaşı) değiştirmez.
                return m_name;
            }

            int getAge() const {
                // m_get_name_call_count++; // Bunu da mutable yaparsak burası da geçerli olurdu.
                return m_age;
            }

            void printCallCount() const {
                std::cout << "getName() çağrılma sayısı: " << m_get_name_call_count << std::endl;
            }
        };

        int main() {
            const Person p("Necati", 40);
            std::cout << "İsim: " << p.getName() << std::endl;
            std::cout << "İsim: " << p.getName() << std::endl;
            p.printCallCount(); // Çıktı: getName() çağrılma sayısı: 2
            // p.m_age = 41; // HATA: p const ve m_age mutable değil.
            return 0;
        }
        ```
    *   `mutable` kullanımı, "bit-wise constness" (tüm bitlerin aynı kalması) yerine "logical constness" (mantıksal durumun aynı kalması) kavramını destekler.
    *   **`mutable`'ın Başka Kullanımı (Kısa Değini):** Hoca, `mutable`'ın lambda ifadeleriyle ilgili bambaşka bir anlamı daha olduğunu, bunun bu dersin konusu olmadığını belirtti (01:18:09.260 civarı). Sınıf üyeleri için kullanılan `mutable` ile lambda'daki `mutable` karıştırılmamalıdır.
    *   Oğuzhan Anayesin'in sorusu üzerine: `mutable` keyword'ü Modern C++ (C++11 sonrası) ile gelmemiştir, C++98 standardında da mevcuttu.

---

**BÖLÜM 9: `this` POINTER / KEYWORD (01:31:51.420 - 01:58:26.600)**

*   **`this` Nedir? (01:32:15.340 - 01:36:36.000)**
    *   `this`, bir sınıfın **non-`static`** üye fonksiyonu içinde kullanılabilen özel bir anahtar kelimedir (keyword).
    *   Fonksiyonun çağrıldığı **nesnenin adresini** tutan bir pointer'dır. Bu yüzden sıkça "this pointer" olarak anılır.
    *   **Kullanılamayacağı Yerler:**
        1.  Global fonksiyonlar içinde.
        2.  `static` üye fonksiyonlar içinde (çünkü `static` üyeler belirli bir nesneye değil, sınıfa aittir).
    *   **Değerinin Gösterimi:**
        ```cpp
        #include <iostream>
        class MyClass {
        public:
            void printAddress() {
                std::cout << "this pointer değeri (içeride): " << this << std::endl;
            }
        };

        int main() {
            MyClass obj;
            std::cout << "obj'nin adresi (dışarıda):    " << &obj << std::endl;
            obj.printAddress(); // Çıktılar aynı olmalı
            return 0;
        }
        ```
*   **`this` vs. `*this` (01:36:36.000 - 01:38:17.700):**
    *   `this`: Fonksiyonun çağrıldığı nesnenin **adresi** (bir pointer).
    *   `*this`: `this` pointer'ının gösterdiği nesnenin **kendisi** (bir referans/Lvalue).
        *   Java, C# gibi dillerde `this` (veya `self`) genellikle nesnenin kendisini temsil eder. C++'ta `this` adrestir, `*this` nesnenin kendisidir. Bu önemli bir ayrımdır.
*   **`this` İfadesinin Değer Kategorisi (Value Category) (01:38:17.700 - 01:39:57.940):**
    *   `this` anahtar kelimesinin oluşturduğu ifadenin kendisi bir **PRvalue**'dur (Pure Rvalue). Lvalue değildir.
    *   Bu şu anlama gelir:
        *   `this = some_other_address;` // DERLEME HATASI: `this`'e atama yapılamaz.
        *   `&this;` // DERLEME HATASI: `this` pointer'ının kendi adresi alınamaz (PRvalue'nun adresi alınamaz).
*   **`this`'in Örtülü ve Açık Kullanımı (01:39:58.540 - 01:46:26.180):**
    *   Non-`static` üye fonksiyon içinde, sınıfın diğer non-`static` üyelerine (veri üyeleri veya fonksiyonlar) erişirken `this->` öneki genellikle örtülüdür (implicit).
        ```cpp
        class MyClass {
            int mx;
            void helper_func() {}
        public:
            void func() {
                mx = 10;          // Aslında: this->mx = 10;
                helper_func();    // Aslında: this->helper_func();
            }
        };
        ```
    *   **Gereksiz `this` Kullanımı:** Hoca, yukarıdaki gibi durumlarda `this->mx` veya `this->helper_func()` şeklinde açıkça `this` kullanmanın gereksiz, kodu kalabalıklaştıran ve "çirkin" bir pratik olduğunu, bunun genellikle başka dillerden gelen alışkanlıklar veya yanlış öğretiler sonucu yapıldığını belirtti.
    *   **İsim Çakışması Durumu:**
        *   Eğer bir üye fonksiyonun parametresi veya yerel değişkeni, sınıfın bir veri üyesiyle aynı isme sahipse, `this->` (veya `SınıfAdı::`) kullanarak sınıf üyesine erişmek gerekir.
            ```cpp
            class MyClass {
                int x;
            public:
                void setX(int x) { // Parametre x, üye x'i gizler
                    this->x = x;   // Üye x'e parametre x atanır.
                    // MyClass::x = x; // Alternatif, ama this-> daha yaygın.
                }
            };
            ```
        *   Hoca, bu durumun bile `this` kullanımını haklı çıkarmadığını, asıl sorunun kötü isimlendirme konvansiyonu olduğunu savundu. Üye değişkenlere `m_x` veya `x_` gibi ayırt edici isimler verilirse bu çakışma ve `this` ihtiyacı ortadan kalkar.
*   **`this`'in Gerçekten Gerekli Olduğu Senaryolar (01:46:26.180 - 01:53:37.800):**
    1.  **Sınıf Nesnesinin Adresini/Kendisini Global Fonksiyonlara Geçmek:**
        ```cpp
        // Global fonksiyonlar
        void global_process_ptr(MyClass* p_obj);
        void global_process_ref(MyClass& r_obj);

        class MyClass {
        public:
            void call_globals() {
                global_process_ptr(this);    // 'this' (adresi) global fonksiyona geçer.
                global_process_ref(*this);   // '*this' (nesnenin kendisi) global fonksiyona geçer.
            }
        };
        ```
        `this` olmasaydı bu yapılamazdı.
    2.  **Üye Fonksiyonun Kendi Nesnesinin Adresini Döndürmesi:**
        ```cpp
        class MyClass {
        public:
            MyClass* get_own_address() {
                return this;
            }
        };
        ```
    3.  **Üye Fonksiyonun Kendi Nesnesinin Kendisini (Referans Olarak) Döndürmesi (Chaining / Fluent API için):**
        *   Bu, bir nesne üzerinde art arda birden fazla işlem yapmayı sağlayan "zincirleme çağrı" (method chaining) veya "akıcı arayüz" (fluent API) tasarım desenlerinde çok yaygındır.
        ```cpp
        class MyClass {
        public:
            MyClass& operation1() {
                // ... işlem 1 ...
                return *this; // Kendi referansını döndür
            }
            MyClass& operation2() {
                // ... işlem 2 ...
                return *this; // Kendi referansını döndür
            }
        };

        // main.cpp
        MyClass obj;
        obj.operation1().operation2(); // Zincirleme çağrı
        // Bu şuna denktir:
        // obj.operation1();
        // obj.operation2();
        // ama tek bir ifadede yapılır.
        ```
        Hoca, `std::cout << a << b << c;` örneğinin de aslında bu mekanizmaya (operatör overloading ile birlikte) dayandığını belirtti. Her `<<` işlemi `cout` nesnesinin kendisini (`*this`) döndürür.

*   **`this` Pointer'ının Türü ve `const` Üye Fonksiyonlar (01:58:27.380 - 02:03:02.620):**
    *   **Non-`const` Üye Fonksiyonda:** `this` pointer'ının türü `MyClass*` (veya `SınıfAdı*`) gibidir.
    *   **`const` Üye Fonksiyonda:** `this` pointer'ının türü `const MyClass*` (veya `const SınıfAdı*`) gibidir.
    *   Bu durum, `const` üye fonksiyonların `this`'i veya `*this`'i döndürmesi durumunda geri dönüş değeri türünün uyumlu olmasını gerektirir:
        ```cpp
        class MyClass {
        public:
            // Non-const versiyonlar
            MyClass* get_addr_non_const() { return this; }
            MyClass& get_ref_non_const() { return *this; }

            // Const versiyonlar
            const MyClass* get_addr_const() const { return this; }
            const MyClass& get_ref_const() const { return *this; }

            // HATALI const versiyonlar
            // MyClass* wrong_get_addr_const() const { return this; } // HATA: const MyClass* -> MyClass* dönüşümü yok.
            // MyClass& wrong_get_ref_const() const { return *this; } // HATA: const MyClass& -> MyClass& dönüşümü yok.
        };
        ```
        `const` bir üye fonksiyon, `this`'i döndürüyorsa, geri dönüş türü de `const SınıfAdı*` veya `const SınıfAdı&` olmalıdır ki `const`'luk korunabilsin.

---

Elbette, Bölüm 10 ile devam ediyoruz: `const` üye fonksiyonların overload edilmesi.

---

**BÖLÜM 10: `const` ÜYE FONKSİYONLARIN OVERLOAD EDİLMESİ (CONST OVERLOADING) (02:03:03.200 - 02:13:12.320)**

*   **Global Fonksiyonlarda `const` Overloading (Hatırlatma) (02:03:03.200 - 02:05:00.160):**
    *   Daha önce de değinildiği gibi, global fonksiyonlar parametrelerinin `const` olup olmamasına göre overload edilebilir.
        ```cpp
        class MyClass { /* ... */ };
        void process(MyClass* ptr);       // MyClass* parametreli
        void process(const MyClass* ptr); // const MyClass* parametreli (overload)

        void process_ref(MyClass& ref);       // MyClass& parametreli
        void process_ref(const MyClass& ref); // const MyClass& parametreli (overload)

        MyClass obj;
        const MyClass const_obj;

        process(&obj);          // process(MyClass*) çağrılır
        process(&const_obj);    // process(const MyClass*) çağrılır

        process_ref(obj);       // process_ref(MyClass&) çağrılır
        process_ref(const_obj); // process_ref(const MyClass&) çağrılır
        ```
    *   Bu, `const` nesneler ve `const` olmayan nesneler için farklı davranışlar tanımlanmasını sağlar. `const` nesne için, `const` parametre alan overload daha iyi bir eşleşmedir veya tek uygun eşleşmedir.

*   **Üye Fonksiyonlarda `const` Overloading (02:05:00.160 - 02:07:25.080):**
    *   Aynı prensip, üye fonksiyonlar için de geçerlidir. Bir üye fonksiyon, `const` olup olmamasına göre (yani, fonksiyon imzasının sonuna `const` eklenip eklenmemesine göre) overload edilebilir.
    *   İmzanın bir parçası olduğu için `const` niteleyicisi, fonksiyonu farklı bir fonksiyon yapar.
        ```cpp
        class MyClass {
        public:
            void foo() {
                // Non-const versiyon: Nesneyi değiştirebilir
                std::cout << "Non-const foo() çağrıldı." << std::endl;
            }

            void foo() const {
                // Const versiyon: Nesneyi değiştirmemeli
                std::cout << "Const foo() çağrıldı." << std::endl;
            }
        };
        ```
    *   **Çağrı Mekanizması:**
        *   Eğer `MyClass` türünden **non-`const` bir nesne** üzerinden `foo()` çağrılırsa, **non-`const` `foo()`** versiyonu seçilir. (Her iki versiyon da uygundur (viable), ancak non-`const` versiyon `this` için daha iyi bir eşleşmedir: `MyClass*` vs `const MyClass*`.)
        *   Eğer `MyClass` türünden **`const` bir nesne** üzerinden `foo()` çağrılırsa, **`const` `foo()`** versiyonu seçilir. (Bu durumda non-`const` versiyon uygun değildir (not viable), çünkü `const MyClass*` olan `this`'i `MyClass*`'a dönüştüremez.)
        ```cpp
        // main.cpp
        MyClass obj;
        const MyClass const_obj;

        obj.foo();       // Çıktı: Non-const foo() çağrıldı.
        const_obj.foo(); // Çıktı: Const foo() çağrıldı.
        ```
    *   Bu, `const` nesneler için salt okunur bir arayüz, `const` olmayan nesneler için ise hem okuma hem de yazma yeteneği olan bir arayüz sunmanın yaygın bir yoludur.

*   **Pratik Örnek: `std::vector::at()` Fonksiyonu (02:07:25.080 - 02:13:12.320):**
    *   Hoca, `std::vector` sınıfının (C++ standart kütüphanesindeki dinamik dizi) `at()` üye fonksiyonunun bu `const` overloading mekanizmasını kullandığını belirtti. `std::vector`, elemanlarına indis (index) ile erişim sağlar.
    *   `std::vector<T>::at(size_type n)` fonksiyonunun iki temel overload'u vardır (basitleştirilmiş):
        1.  `T& at(size_type n);` (Non-`const` versiyon)
        2.  `const T& at(size_type n) const;` (`const` versiyon)
    *   **Non-`const` Vektör ile Kullanım:**
        ```cpp
        #include <vector>
        #include <iostream>

        int main() {
            std::vector<int> vec = {10, 20, 30};

            // vec non-const bir nesne.
            // Dolayısıyla T& at(size_type n) overload'u çağrılır.
            vec.at(1) = 99; // GEÇERLİ. vec.at(1) bir int& döndürür, bu Lvalue'ya atama yapılabilir.
                            // vec şimdi {10, 99, 30}

            int val = vec.at(0); // GEÇERLİ. int&'den int'e okuma.
            std::cout << "vec.at(0): " << val << std::endl; // Çıktı: 10
            std::cout << "vec.at(1): " << vec.at(1) << std::endl; // Çıktı: 99

            return 0;
        }
        ```
        Non-`const` vektör için `at()`, elemana bir *referans* (`T&`) döndürdüğü için, bu referans üzerinden elemanın değeri hem okunabilir hem de *değiştirilebilir*.
    *   **`const` Vektör ile Kullanım:**
        ```cpp
        #include <vector>
        #include <iostream>

        int main() {
            const std::vector<int> const_vec = {100, 200, 300};

            // const_vec const bir nesne.
            // Dolayısıyla const T& at(size_type n) const overload'u çağrılır.

            // const_vec.at(1) = 999; // DERLEME HATASI!
                                     // const_vec.at(1) bir const int& döndürür.
                                     // const referans üzerinden atama yapılamaz.

            int val = const_vec.at(0); // GEÇERLİ. const int&'den int'e okuma.
            std::cout << "const_vec.at(0): " << val << std::endl; // Çıktı: 100
            std::cout << "const_vec.at(1): " << const_vec.at(1) << std::endl; // Çıktı: 200

            return 0;
        }
        ```
        `const` vektör için `at()` fonksiyonunun `const` overload'u çağrılır. Bu fonksiyon, elemana bir *`const` referans* (`const T&`) döndürür. Bu, elemanın değerinin okunabileceği, ancak `at()` çağrısı üzerinden *değiştirilemeyeceği* anlamına gelir. Bu, `const` nesnenin durumunun korunmasını sağlar.
    *   **Hocanın Basitleştirilmiş `Vector` Sınıfı Üzerinden Gösterimi:**
        Hoca, konuyu daha netleştirmek için kendi basitleştirilmiş `Vector` sınıf tanımını yazarak gösterdi:
        ```cpp
        // Hocanın tahtadaki basitleştirilmiş örneği (kavramsal)
        class Vector { // Gerçek std::vector template'dir ve T alır. Bu basitleştirilmiştir.
            // ... internal data ...
            int* m_data; // Örneğin
            size_t m_size;
        public:
            // Non-const versiyon
            int& at(size_t idx) {
                // ... sınır kontrolü ...
                std::cout << "Non-const Vector::at(" << idx << ") çağrıldı." << std::endl;
                return m_data[idx]; // int& döndürür
            }

            // Const versiyon
            const int& at(size_t idx) const {
                // ... sınır kontrolü ...
                std::cout << "Const Vector::at(" << idx << ") çağrıldı." << std::endl;
                return m_data[idx]; // const int& döndürür
            }
            // Constructor, destructor, diğer üyeler...
            Vector(size_t s) : m_size(s), m_data(new int[s]()) {}
            ~Vector() { delete[] m_data; }
        };

        // Kullanım
        Vector my_vec(3); // Non-const nesne
        my_vec.at(0) = 5; // Non-const at() çağrılır, atama başarılı.

        const Vector c_my_vec(3); // Const nesne
        // c_my_vec.at(0) = 10; // Const at() çağrılır, geri dönüş const int&, atama HATALI.
        int x = c_my_vec.at(1); // Const at() çağrılır, okuma başarılı.
        ```
    *   Bu `const` overloading mekanizması, C++'ta `const` doğruluğunu sağlamak ve API'ları hem `const` hem de non-`const` nesnelerle güvenli ve esnek bir şekilde kullanılabilir kılmak için kritik bir tekniktir.

---

**BÖLÜM 11: `inline` ÜYE FONKSİYONLAR (02:13:12.460 - 02:28:42.680)**

*   **Yanlış Algı: Tanım Yeri Fark Etmez (02:13:32.620 - 02:16:16.280):**
    *   Hoca, yeni başlayanların sıkça yaptığı bir hataya değindi: Bir üye fonksiyonun tanımının sınıf tanımı *içinde* yapılmasıyla (`.h` dosyasında, class body içinde) veya ayrı bir `.cpp` dosyasında yapılmasının *aynı şey* zannedilmesi.
    *   **Bu kesinlikle yanlıştır.** İki yöntem arasında önemli farklar vardır, özellikle `inline` olma ve ODR (One Definition Rule) açısından.

*   **ODR (One Definition Rule - Tek Tanım Kuralı) ve `inline` (02:16:16.280 - 02:16:36.440):**
    *   ODR, bir programdaki her non-`inline` fonksiyonun (ve değişkenin vb.) yalnızca bir tanımının olabileceğini belirtir. Eğer bir fonksiyonun tanımı bir başlık dosyasına konulursa ve bu başlık dosyası birden fazla `.cpp` dosyası tarafından `#include` edilirse, linker birden fazla tanım bulacağı için hata verir (multiple definition error).
    *   `inline` fonksiyonlar bu kuralın bir istisnasıdır. `inline` bir fonksiyonun tanımı başlık dosyasına konulabilir ve birden fazla çeviri birimi (translation unit, yani `.cpp` dosyası) tarafından görülebilir. Linker bu durumda hata vermez.

*   **Üye Fonksiyonları `inline` Yapma Yolları (02:16:37.540 - 02:19:23.920):**
    1.  **Sınıf Tanımı Dışında, Başlık Dosyasında `inline` Keyword ile (Explicit Inline):**
        *   Fonksiyonun bildirimi (veya sadece tanımı) başlık dosyasında (`.h`) yapılır ve `inline` anahtar kelimesi kullanılır.
            ```cpp
            // MyClass.h
            class MyClass {
            public:
                void set(int x); // Bildirim
            private:
                int mx;
            };

            // Tanım da başlık dosyasında, sınıf tanımı dışında:
            inline void MyClass::set(int x) {
                mx = x;
            }
            // VEYA bildirimde inline:
            // class MyClass { public: inline void set(int x); };
            // void MyClass::set(int x) { mx = x; } // Tanım da inline olur
            // VEYA her ikisinde:
            // class MyClass { public: inline void set(int x); };
            // inline void MyClass::set(int x) { mx = x; }
            ```
            Bu yöntem, global `inline` fonksiyonlarla aynı mantıkta çalışır. `inline` anahtar kelimesi, derleyiciye fonksiyonun tanımının birden fazla yerde görünebileceği bilgisini verir ve ODR ihlalini önler. Aynı zamanda derleyiciye "inline expansion" (fonksiyon çağrısını fonksiyonun koduyla değiştirme) için bir *ipucu* verir (garanti değil).
    2.  **Sınıf Tanımı İçinde Tanım (Implicit Inline):**
        *   Bir üye fonksiyonun tanımı doğrudan sınıf tanımının *içinde* yapılırsa, bu fonksiyon **otomatik olarak (örtülü bir şekilde) `inline` kabul edilir.** `inline` anahtar kelimesini yazmaya gerek yoktur.
            ```cpp
            // MyClass.h
            class MyClass {
            public:
                void set(int x) { // Tanım sınıf içinde
                    mx = x;
                } // Bu fonksiyon otomatik olarak inline'dır.
            private:
                int mx;
            };
            ```
            Bu, en sık kullanılan `inline` üye fonksiyon tanımlama şeklidir, özellikle kısa ve basit "setter/getter" tarzı fonksiyonlar için.

*   **`inline` Yapma Kararı: Ne Zaman ve Neden? (02:19:23.920 - 02:27:12.000):**
    *   Hoca, "bu fonksiyonu `inline` yapalım mı?" sorusunun cevabının "ne bileyim ben?" olduğunu, çünkü bunun duruma göre değişen bir karar olduğunu belirtti. Kesin bir kuralı yoktur.
    *   **`inline` Yapma Nedenleri/Senaryoları:**
        1.  **Header-Only Library Oluşturma:** Eğer `.cpp` dosyası olmayan, sadece başlık dosyalarından oluşan bir kütüphane yazılıyorsa, tüm fonksiyon tanımlarının başlık dosyasında olması ve dolayısıyla `inline` olması gerekir (ODR'ı ihlal etmemek için).
        2.  **Inline Expansion Optimizasyonu İçin Fırsat Verme:** Eğer bir fonksiyonun çağrı yükünü (call overhead) azaltmak ve potansiyel olarak daha fazla optimizasyona olanak tanımak için derleyicinin "inline expansion" yapması isteniyorsa, fonksiyonun tanımının derleyici tarafından *çağrı noktasında* görülmesi gerekir. Bu da genellikle tanımın başlık dosyasında (yani `inline` olarak) olması anlamına gelir.
            *   **Önemli:** `inline` anahtar kelimesi derleyiciye sadece bir *tavsiyedir*. Derleyici bu tavsiyeye uymayabilir (örn: fonksiyon çok büyükse, rekürsifse vb.). Tersine, derleyici `inline` olmayan bazı küçük fonksiyonları da (eğer tanımlarını görebiliyorsa, örn: aynı `.cpp` dosyasında) kendi kararıyla "inline" edebilir (link-time optimization ile farklı dosyalardakini bile yapabilir).
    *   **`inline` Yapmamanın Potansiyel Faydaları / `inline` Yapmanın Dezavantajları:**
        1.  **Derleme Süreleri ve Bağımlılıklar (Compilation Dependencies):**
            *   Eğer bir fonksiyonun tanımı başlık dosyasına (yani `inline` olarak) konulursa ve bu fonksiyon başka sınıfları veya başlık dosyalarını kullanıyorsa (complete type olarak), o zaman bu başlık dosyasını `#include` eden her `.cpp` dosyası, dolaylı olarak o diğer başlıklara da bağımlı hale gelir.
            *   Bu, "Pimpl Idiom" gibi tekniklerle azaltılmaya çalışılan bir sorundur.
            *   Eğer fonksiyon tanımı `.cpp` dosyasında olsaydı (`out-of-line`), bu bağımlılıklar sadece o `.cpp` dosyasıyla sınırlı kalır, başlık dosyasını kullanan diğer istemcileri etkilemezdi. Bu da derleme sürelerini iyileştirebilir (özellikle büyük projelerde).
            *   **Örnek:**
                ```cpp
                // MyClass.h
                // #include "Person.h" // Eğer setPerson inline ise bu BAŞLIKTA GEREKLİ OLUR.

                class Person; // Forward declaration (eğer sadece pointer/referans kullanılıyorsa yeterli olabilir)

                class MyClass {
                    Person* m_person_ptr;
                public:
                    // Eğer tanım sınıf içindeyse (inline):
                    // void setPerson(const Person& p) { /* Person::copy() gibi bir şey kullanırsa Person.h lazım */ }

                    // Eğer tanım .cpp'de ise (out-of-line):
                    void setPerson(const Person& p); // Bildirim burada
                };

                // MyClass.cpp
                #include "MyClass.h"
                #include "Person.h" // Bağımlılık sadece .cpp dosyasına gelir.
                void MyClass::setPerson(const Person& p) {
                    // ... p'nin üyelerini kullan ...
                }
                ```
        2.  **Kod Boyutu (Code Bloat):** Eğer büyük bir fonksiyon `inline` yapılır ve birçok yerde çağrılırsa, her çağrı noktasına fonksiyonun kodu kopyalanacağı için toplam çalıştırılabilir dosya boyutu artabilir. Bu da instruction cache performansını olumsuz etkileyebilir. Küçük fonksiyonlar için bu genellikle sorun değildir.
    *   **Genel Tavsiye:**
        *   Çok küçük, sık çağrılan ve performansa etkisi olabilecek fonksiyonlar (tipik "getter" ve "setter"lar gibi) sınıf tanımı içinde (implicit inline) tanımlanabilir.
        *   Daha büyük veya karmaşık bağımlılıkları olan fonksiyonlar `.cpp` dosyasında tanımlanmalıdır.
        *   Header-only kütüphane yazılıyorsa zaten hepsi `inline` olmak zorundadır.

*   **Prototipte `inline` Kullanıp Tanımı `.cpp`'de Yapmak (02:27:12.000 - 02:28:42.680):**
    *   Soru: `inline void MyClass::func();` (başlıkta) ve `void MyClass::func() { /*... */ }` (`.cpp`'de) şeklinde yapılabilir mi?
    *   Hoca, bunun bir etkisi veya faydası olmayacağını belirtti. Derleyicinin `inline expansion` yapabilmesi için fonksiyonun *tanımını* görmesi gerekir. Tanım `.cpp` dosyasındaysa ve başka bir `.cpp` dosyasından çağrılıyorsa, o çağrı noktasında derleyici tanımı göremez. (Modern derleyiciler Link-Time Optimization (LTO) ile farklı çeviri birimlerindeki fonksiyonları bile `inline` edebilirler, ancak bu `inline` keyword'ünden bağımsız bir optimizasyon tekniğidir.)

---

**BÖLÜM 12: SINIF NESNELERİNİN HAYATA BAŞLAMASI VE SONLANMASI: CONSTRUCTOR VE DESTRUCTOR'A GİRİŞ (02:28:42.680 - 02:33:37.120)**

Bu bölüm, C++'ın en karmaşık ve önemli konularından birine giriş niteliğindedir.

*   **Zorlu Konulara Geçiş (02:28:42.680 - 02:29:18.380):**
    *   Hoca, sınıf nesnelerinin hayata gelmesi (creation), hayatlarının başlaması (initialization), hayatlarının bitmesi (destruction), kopyalanması (copying), taşınması (moving) gibi konuların C++ sentaksının en karmaşık ve öğrenmesi en zor alanları olduğunu belirtti. Dikkat katsayısının artırılması gerektiğini vurguladı.

*   **Constructor (Kurucu / Yapıcı Fonksiyon) (02:29:18.380 - 02:31:31.060):**
    *   **Tanım ve Amaç:** Bir sınıf nesnesinin hayata başlamasını sağlayan, onu kullanılabilir bir varlık haline getiren (initialize eden) özel bir üye fonksiyondur. Bir sınıf nesnesi nerede yaratılıyorsa, orada mutlaka bir constructor çağrısı vardır.
    *   **Türkçe Karşılıklar:** Hoca, "kurucu", "kurucu işlev", "başlangıç fonksiyonu" gibi farklı Türkçe terimler olduğunu, ancak kendisinin İngilizce "constructor" terimini kullanmayı tercih ettiğini belirtti (terminoloji karmaşasını önlemek için).
    *   Constructor, "construct" (inşa etmek, kurmak) fiilinden gelir.

*   **Destructor (Yıkıcı / Yok Edici Fonksiyon) (02:31:31.060 - 02:33:37.120):**
    *   **Tanım ve Amaç:** Bir sınıf nesnesinin hayatı bittiğinde (nesne kapsam dışına çıktığında, `delete` edildiğinde vb.) otomatik olarak çağrılan, nesnenin kullandığı kaynakları (bellek, dosya tanıtıcıları vb.) serbest bırakmak (cleanup) için kullanılan özel bir üye fonksiyondur.
    *   **İsimlendirme Kökeni:** Hoca, "destructor" kelimesinin "destroy" (yok etmek) fiiliyle ilişkili olduğunu, ancak "distract" diye bir fiil olmamasına rağmen "destructor" teriminin kullanıldığını, normalde "destroyer" gibi bir kelimenin daha mantıklı olabileceğini ancak C++ jargonunda "destructor"un yerleştiğini belirtti.
    *   "Sınıf nesnesini distract eder" gibi ifadeler kullanılır.

*   **Temel Kural (02:33:37.120 - 02:34:34.800):**
    *   Nesne ömrü başladığında: Constructor çağrılır.
    *   Nesne ömrü bittiğinde: Destructor çağrılır.
    *   Hem constructor hem de destructor, sınıfın **non-`static` üye fonksiyonlarıdır.** Global fonksiyon veya `static` üye fonksiyon olamazlar.

---

Tamamdır, Bölüm 13: Constructor'ların Detaylı Özellikleri ile devam ediyoruz.

---

**BÖLÜM 13: CONSTRUCTOR'LARIN DETAYLI ÖZELLİKLERİ (02:34:34.800 - 02:42:15.400)**

*   **Constructor'ların Temel Kuralları ve Sentaksı (02:34:34.800 - 02:36:26.720):**
    1.  **İsim (Name):** Bir constructor'ın ismi, ait olduğu **sınıfın ismiyle birebir aynı olmak zorundadır.** Bu, derleyicinin ve programcının bir fonksiyonun constructor olduğunu anlamasının temel yoludur.
        ```cpp
        class MyClass {
        public:
            MyClass(); // Bu bir constructor'dır çünkü ismi sınıf ismiyle aynı.
            // My_Class(); // HATA: Bu bir constructor değildir, normal bir fonksiyondur.
        };

        class String {
        public:
            String(const char* s); // String sınıfının constructor'ı.
        };
        ```
    2.  **Geri Dönüş Değeri (Return Value):** Constructor'ların **geri dönüş değeri kavramı yoktur.** Bu, `void` bile yazılamayacağı anlamına gelir. Eğer bir geri dönüş türü (hatta `void`) belirtilirse, derleyici bunu normal bir üye fonksiyon olarak algılar (eğer isim sınıf ismiyle aynıysa bu bir hata olur) veya sentaks hatası verir.
        ```cpp
        class MyClass {
        public:
            MyClass();      // DOĞRU: Geri dönüş değeri yok.
            // void MyClass(); // HATALI: Constructor'a geri dönüş türü (void) belirtilemez.
            // int MyClass();  // HATALI: Constructor'a geri dönüş türü (int) belirtilemez.
        };
        ```
        Constructor'lar "bir şey döndürmezler"; onların işi nesneyi "inşa etmek" ve kullanıma hazır hale getirmektir.
    3.  **`const` Olmama Durumu:** Constructor'lar **`const` üye fonksiyon olamazlar.** Bir constructor'ı `const` olarak nitelemeye çalışmak sentaks hatasıdır.
        ```cpp
        class MyClass {
        public:
            // MyClass() const; // HATALI: Constructor 'const' olamaz.
            MyClass();
        };
        ```
        Bu mantıklıdır, çünkü constructor'ın temel amacı nesnenin ilk durumunu (veri üyelerini) ayarlamaktır, yani nesneyi "değiştirmektir". `const` bir fonksiyon ise nesneyi değiştirmemeyi taahhüt eder.

*   **Constructor'ların Overload Edilmesi (02:36:28.120 - 02:37:54.940):**
    *   Constructor'lar, normal fonksiyonlar gibi, **parametre sayıları veya türleri farklı olmak kaydıyla overload edilebilirler.**
    *   Bu, bir sınıf nesnesini farklı başlangıç argümanlarıyla veya farklı şekillerde hayata getirme esnekliği sağlar.
        ```cpp
        class Nec { // Hoca bu ismi kullandı
        public:
            Nec();                     // 1. Parametresiz (Default constructor olabilir)
            Nec(int x);                // 2. int parametreli
            Nec(int x, int y);         // 3. iki int parametreli
            Nec(double d);             // 4. double parametreli
            Nec(const char* s);        // 5. C-string parametreli
            // ... ve diğer olası overload'lar
        };
        ```
    *   Hangi constructor'ın çağrılacağı, nesne yaratılırken kullanılan ifadedeki argümanlara göre **function overload resolution** kurallarıyla belirlenir. Bu konu bir sonraki derste (Çarşamba) detaylandırılacak.
    *   Örnek (hangi constructor'ın çağrılacağına dair sezgisel bir bakış):
        ```cpp
        // Nec n1;        // Nec() çağrılır (eğer public ise)
        // Nec n2(10);    // Nec(int) çağrılır
        // Nec n3(3.14);  // Nec(double) çağrılır
        // Nec n4("text"); // Nec(const char*) çağrılır
        ```

*   **Constructor'ların Erişim Belirleyicileri (`public`, `private`, `protected`) (02:37:54.940 - 02:39:36.260):**
    *   Constructor'lar da diğer üye fonksiyonlar gibi `public`, `private` veya `protected` erişim belirleyicilerine sahip olabilirler.
    *   **`public` Constructor:** En yaygın durumdur. Sınıfın herhangi bir yerinden (sınıf dışından, türetilmiş sınıflardan vb.) nesne yaratılmasına izin verir.
    *   **`private` veya `protected` Constructor:**
        *   Bunları bildirmek sentaks hatası değildir.
        *   Ancak, `private` bir constructor'a sınıf dışından (veya `friend` olmayan bir yerden) veya `protected` bir constructor'a sınıf veya türetilmiş sınıfları dışından doğrudan çağrı yaparak nesne yaratmaya çalışmak **erişim kontrolü nedeniyle derleme hatasına** yol açar.
        *   **Kullanım Alanları:**
            *   **Singleton Tasarım Deseni:** Bir sınıftan sadece bir tek nesne yaratılmasını garantilemek için constructor `private` yapılır ve nesneye erişim `static` bir üye fonksiyon aracılığıyla sağlanır.
            *   **Factory Method Tasarım Deseni:** Nesne yaratma işlemini bir `static` "fabrika" fonksiyonuna devretmek için constructor'lar `private` veya `protected` yapılabilir.
            *   **Soyut Sınıflar (Abstract Classes) / Sadece Miras Alınabilen Sınıflar:** Bir sınıfın doğrudan nesnesinin yaratılmasını engellemek, sadece türetilmiş sınıflar tarafından kullanılmasını sağlamak için constructor `protected` yapılabilir.
        *   Hoca, bu tür desenlerin ve `private`/`protected` constructor kullanımlarının ilerleyen derslerde karşımıza çıkacağını belirtti.

*   **Constructor'ların Tanımlanma Yerleri (02:39:37.140 - 02:40:29.380):**
    *   Diğer üye fonksiyonlarda olduğu gibi, constructor'ların tanımları da iki temel yerde yapılabilir:
        1.  **Sınıf Tanımı İçinde (Implicit Inline):**
            ```cpp
            class Nec {
            public:
                Nec(int val) { // Tanım sınıf içinde
                    m_value = val;
                    std::cout << "Nec(int) constructor çağrıldı, m_value = " << m_value << std::endl;
                }
            private:
                int m_value;
            };
            // Bu constructor otomatik olarak inline'dır.
            ```
        2.  **Kaynak Dosyasında (`.cpp`) (Out-of-line):**
            *   Bildirimi başlık dosyasında (`.h`), tanımı ise ayrı bir kaynak dosyasında (`.cpp`) yapılır.
            *   Tanım yapılırken, constructor ismi sınıf ismiyle nitelenmelidir (`SınıfAdı::SınıfAdı`).
            ```cpp
            // Nec.h
            class Nec {
            public:
                Nec(int val); // Bildirim
            private:
                int m_value;
            };

            // Nec.cpp
            #include "Nec.h" // Genellikle gerekli
            #include <iostream> // std::cout için

            Nec::Nec(int val) { // Tanım .cpp dosyasında
                m_value = val;
                std::cout << "Nec(int) out-of-line constructor çağrıldı, m_value = " << m_value << std::endl;
            }
            ```
            Bu durumda constructor, (eğer `inline` anahtar kelimesiyle ayrıca belirtilmemişse) `inline` değildir.

*   **Notlar ve Paylaşım Konusu (02:40:31.360 - 02:41:58.820):**
    *   Emre Can adlı öğrencinin ders notlarının paylaşılıp paylaşılamayacağı sorusu üzerine hoca:
        *   Kendi anlık aldığı notların çok düzenli olmadığını ve paylaşımın çok faydalı olmayabileceğini belirtti.
        *   Daha önceki derslerden öğrenciler tarafından tutulmuş, hatta kitap/github formatında yayınlanmış kapsamlı notların olduğunu (örn: Umut Kota Ankara'nın notları) ve bunları paylaşabileceğini söyledi.
        *   Ders sırasında mükemmel not tutmaya çalışmanın ders temposunu çok düşüreceğini, bu yüzden mevcut yöntemi (zengin içerik, daha az formal not) tercih ettiğini açıkladı.

*   **Dersin Sonu ve Gelecek Ders (02:41:58.820 - 02:42:15.400):**
    *   Dersin bu bölümü burada sona erdi.
    *   Konulara Çarşamba günü devam edileceği belirtildi.
    *   Canlı katılımın önemi vurgulandı.

---

**ÖZET VE ÖNEMLİ ÇIKARIMLAR (CONSTRUCTOR'LAR İÇİN BU BÖLÜMDEN):**

1.  **Kimlik:** Constructor ismi, sınıf ismiyle aynıdır. Geri dönüş değeri yoktur (void bile değil). `const` olamaz.
2.  **Esneklik:** Birden fazla constructor (overload) tanımlanabilir, bu da nesnelerin farklı şekillerde initialize edilmesini sağlar.
3.  **Kontrol:** Erişim belirleyicileri (`public`, `private`, `protected`) ile kimlerin nesne yaratabileceği kontrol edilebilir, bu da çeşitli tasarım desenlerine olanak tanır.
4.  **Uygulama:** Tanımları, diğer üye fonksiyonlar gibi, ya sınıf içinde (implicit inline) ya da `.cpp` dosyasında (out-of-line) yapılabilir. Inline yapılıp yapılmaması, ODR ve optimizasyon/bağımlılık yönetimi gibi faktörlere bağlıdır.

Constructor'lar, C++'ta nesne yönelimli programlamanın temelini oluşturur ve doğru anlaşılıp kullanılmaları, sağlam ve yönetilebilir kod yazmak için hayati önem taşır.

---
Bir sonraki bölüm muhtemelen destructor'ların detayları ve/veya constructor'ların çağrılma mekanizmaları (initialization) üzerine olacaktır.