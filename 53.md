### ğŸ“š C++ Teknik Ä°nceleme NotlarÄ±: AkÄ±llÄ± Pointerlar (Smart Pointers) - BÃ¶lÃ¼m II
**EÄŸitmen:** Necati Ergin  
**Tarih:** 6 Ocak 2025  
**Konu:** `std::shared_ptr` Derinlemesine BakÄ±ÅŸ, `shared_ptr<void>`, Array Specialization ve `reset()` SemantiÄŸi

---

#### 1. PaylaÅŸÄ±mlÄ± Sahiplik Stratejisi: `std::shared_ptr` GiriÅŸ [00:00 - 04:00]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
`std::unique_ptr`, "Exclusive Ownership" (Tekil Sahiplik) stratejisini uygular; yani bir kaynaÄŸÄ±n sadece tek bir sahibi olabilir. Ancak gerÃ§ek hayat senaryolarÄ±nda (Ã¶rneÄŸin bir Graph veri yapÄ±sÄ±ndaki dÃ¼ÄŸÃ¼mler veya ortak kullanÄ±lan bir config nesnesi), bir nesnenin birden fazla kod birimi tarafÄ±ndan ortaklaÅŸa kullanÄ±lmasÄ± ve nesnenin ancak "son kullanÄ±cÄ±" iÅŸini bitirdiÄŸinde yok edilmesi gerekir. `shared_ptr` bu "Shared Ownership" (PaylaÅŸÄ±mlÄ± Sahiplik) ihtiyacÄ±nÄ± karÅŸÄ±lar.

âš™ï¸ **Teknik Detay ve Sentaks:**
`shared_ptr` nesneleri kopyalanabilir. Her kopyalama iÅŸleminde arka plandaki **Reference Count** (Referans SayÄ±cÄ±) artÄ±rÄ±lÄ±r.
```cpp
#include <memory>

std::shared_ptr<int> sp1(new int(10)); // DoÄŸrudan kaynakla baÅŸlatma
auto sp2 = sp1; // Copy Constructor: Ref count artÄ±k 2.
// <-- Hoca belirtti: Son shared_ptr Ã¶lene kadar kaynak delete edilmez.
```

ğŸ” **Arka Plan (Under the Hood):**
`shared_ptr` nesnesi bellek alanÄ±nda genellikle iki adet pointer (ham gÃ¶sterici) bÃ¼yÃ¼klÃ¼ÄŸÃ¼ndedir (genellikle 16 byte - 64 bit sistemlerde).
1.  **Stored Pointer:** Kontrol edilen (yÃ¶netilen) nesnenin adresi.
2.  **Control Block Pointer:** Referans sayÄ±cÄ±larÄ±nÄ± ve diÄŸer yÃ¶netim bilgilerini tutan dinamik alanÄ±n adresi.

ğŸ”— **KÃ¼mÃ¼latif BaÄŸlantÄ±lar:**
`unique_ptr`'da olduÄŸu gibi `shared_ptr` da `<memory>` baÅŸlÄ±k dosyasÄ±ndadÄ±r. Ancak `unique_ptr`'dan farklÄ± olarak Copy Constructor ve Copy Assignment fonksiyonlarÄ± silinmemiÅŸtir (not deleted).

---

#### 2. Kontrol BloÄŸu (Control Block) ve Bellek YerleÅŸimi [04:02 - 08:14]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Birden fazla `shared_ptr` nesnesinin aynÄ± sayacÄ± senkronize bir ÅŸekilde artÄ±rÄ±p azaltabilmesi iÃ§in bu sayacÄ±n ortak bir alanda (Heap) tutulmasÄ± zorunludur.

âš™ï¸ **Bellek Optimizasyonu: `std::make_shared`:**
Hoca, `std::make_shared` kullanmanÄ±n sadece yazÄ±m kolaylÄ±ÄŸÄ± olmadÄ±ÄŸÄ±nÄ±, performans aÃ§Ä±sÄ±ndan kritik olduÄŸunu vurguladÄ±.
*   **AyrÄ± Tahsisat:** `shared_ptr<T> p(new T)` yazÄ±ldÄ±ÄŸÄ±nda; Ã¶nce `T` nesnesi iÃ§in `new` Ã§aÄŸrÄ±lÄ±r, sonra Kontrol BloÄŸu iÃ§in ikinci bir dinamik tahsisat yapÄ±lÄ±r.
*   **Tek Tahsisat:** `make_shared<T>` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, derleyici `T` nesnesi ve Kontrol BloÄŸu iÃ§in tek bir bÃ¼yÃ¼k bellek bloÄŸu allocate eder.

ğŸ–¼ï¸ **GÃ¶rselleÅŸtirme (Memory Layout):**
```text
   shared_ptr nesnesi (Stack)          Control Block (Heap)
   +-----------------------+          +-----------------------+
   |  T* ptr (Data)        |--------->| Managed Object (T)    |
   +-----------------------+          +-----------------------+
   |  ControlBlock* cb_ptr |--------->| Reference Count (2)   |
   +-----------------------+          | Weak Count      (0)   |
                                      | Custom Deleter?       |
                                      +-----------------------+
```

ğŸš© **Kritik Nokta (Aliasing Constructor):**
Hoca, nesnenin iÃ§indeki pointer ile Kontrol BloÄŸundaki pointer'Ä±n her zaman aynÄ± adresi gÃ¶stermek zorunda olmadÄ±ÄŸÄ±nÄ± belirtti. "Aliasing Constructor" sayesinde, bir sÄ±nÄ±fÄ±n tamamÄ±nÄ± kontrol eden bir bloÄŸa sahipken, sadece o sÄ±nÄ±fÄ±n bir veri elemanÄ±nÄ± (member) gÃ¶steren bir `shared_ptr` oluÅŸturulabilir. Bu durumda Control Block asÄ±l nesneyi hayatta tutmaya devam ederken, `shared_ptr` bir member'Ä± point eder.

---

#### 3. TÃ¼r Silme (Type Erasure) ve Deleter MekanizmasÄ± [08:15 - 15:16]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
`unique_ptr`'da deleter (silici), sÄ±nÄ±fÄ±n bir template parametresidir. Bu durum, farklÄ± deleter'lara sahip `unique_ptr`'larÄ±n farklÄ± tÃ¼rler olmasÄ±na yol aÃ§ar. `shared_ptr` ise "Type Erasure" (TÃ¼r Silme) tekniÄŸi ile deleter'Ä± Ã§alÄ±ÅŸma zamanÄ±nda (runtime) Kontrol BloÄŸu iÃ§inde saklar.

ğŸ“Š **Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±:**
| Ã–zellik | `std::unique_ptr<T, D>` | `std::shared_ptr<T>` |
| :--- | :--- | :--- |
| **Deleter TÃ¼rÃ¼** | Template Parametresi (Compile-time) | TÃ¼r Silme / Type Erasure (Runtime) |
| **Bellek Maliyeti** | Overhead yok (Light wrapper) | Control Block nedeniyle daha yÃ¼ksek |
| **`void` DesteÄŸi** | `unique_ptr<void>` GEÃ‡ERSÄ°Z | `shared_ptr<void>` GEÃ‡ERLÄ° |

âš™ï¸ **Teknik Detay (shared_ptr<void>):**
`shared_ptr<void>` kullanÄ±mÄ± legaldir. Nesne silinirken doÄŸru destruktÃ¶rÃ¼n Ã§aÄŸrÄ±lacaÄŸÄ±ndan emin olur Ã§Ã¼nkÃ¼ `shared_ptr` nesne oluÅŸturulduÄŸu andaki tÃ¼r bilgisini Kontrol BloÄŸu iÃ§inde "erase" ederek saklar.
```cpp
std::shared_ptr<void> sp1(new MyClass); // Legal
// sp1.operator*(); <-- HATA: void pointer dereference edilemez!
```

---

#### 4. Dizi UzmanlaÅŸmasÄ± (Array Specialization) [15:17 - 19:30]

âš™ï¸ **Teknik Detay:**
C++17 ile birlikte `shared_ptr<T[]>` kÄ±smi uzmanlaÅŸmasÄ± (partial specialization) gelmiÅŸtir. Bu durumda `delete` yerine `delete[]` otomatik olarak kullanÄ±lÄ±r.

```cpp
#include <iostream>
#include <memory>

struct Point {
    Point() { std::cout << "Point construct\n"; }
    ~Point() { std::cout << "Point destruct\n"; }
};

int main() {
    // <-- Hoca uyardÄ±: T[] aÃ§Ä±lÄ±mÄ± kullanÄ±lmalÄ±!
    std::shared_ptr<Point[]> sp(new Point[10]); 
    // Scope sonunda 10 kez destructor Ã§aÄŸrÄ±lÄ±r.
}
```
ğŸ” **Derleyici GÃ¶zÃ¼ (Undefined Behavior):**
EÄŸer `shared_ptr<Point>` (dizi olmayan aÃ§Ä±lÄ±m) iÃ§ine `new Point[10]` adresi verilirse, derleyici `delete` (tekil silme) Ã§aÄŸÄ±rÄ±r. Bu durum **UB (Undefined Behavior)** oluÅŸturur.

---

#### 5. `reset()` Fonksiyonu ve Referans SayÄ±cÄ± YÃ¶netimi [19:31 - 25:00]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Bir `shared_ptr`'Ä±n elindeki sahipliÄŸi bÄ±rakmasÄ± veya yeni bir kaynaÄŸÄ± yÃ¶netmeye baÅŸlamasÄ± iÃ§in kullanÄ±lÄ±r.

âš™ï¸ **Teknik Detay:**
*   `sp.reset()`: `sp` artÄ±k hiÃ§bir yeri gÃ¶stermez. Eski gÃ¶sterdiÄŸi yerin referans sayÄ±cÄ± 1 azalÄ±r. EÄŸer sayÄ±cÄ± 0 olursa kaynak delete edilir.
*   `sp.reset(new T)`: `sp` eski baÄŸÄ±nÄ± koparÄ±r (sayacÄ± azaltÄ±r) ve yeni `T` nesnesini yÃ¶netmeye baÅŸlar.

```cpp
auto sp1 = std::make_shared<Point>(1, 3, 5);
auto sp2 = sp1; // Count: 2

sp1.reset(new Point(3, 5, 8)); 
// sp1 artÄ±k yeni Point'i gÃ¶steriyor (Count: 1).
// Ä°lk Point nesnesini hala sp2 gÃ¶steriyor (Count: 1).
```

ğŸš© **MÃ¼lakat Sorusu:**
**Soru:** Bir `shared_ptr`'a `nullptr` atamak ile `reset()` Ã§aÄŸÄ±rmak arasÄ±nda fark var mÄ±dÄ±r?
**Cevap:** Fonksiyonel olarak ikisi de aynÄ±dÄ±r. Her iki durumda da referans sayÄ±cÄ± 1 azaltÄ±lÄ±r ve `shared_ptr` "Empty State"e (boÅŸ durum) geÃ§er. Ancak `reset(ptr)` yeni bir adres alabilirken, `nullptr` atamasÄ± sadece boÅŸaltma yapar.

---

Bu bÃ¶lÃ¼mde Hoca ÅŸu **3 kritik hataya** dikkat Ã§ekti:
1.  **Dizi KarmaÅŸasÄ±:** `new[]` ile oluÅŸturulan alanÄ± `T[]` olmayan bir `shared_ptr`'a vermek (UB).
2.  **Void Dereference:** `shared_ptr<void>` nesnesini `*` veya `->` operatÃ¶rleriyle kullanmaya Ã§alÄ±ÅŸmak (Syntax hatasÄ±).
3.  **Ref Count YanÄ±lgÄ±sÄ±:** `reset()` yapÄ±ldÄ±ÄŸÄ±nda nesnenin hemen silineceÄŸini sanmak (EÄŸer baÅŸka bir `shared_ptr` daha varsa silinmez).

### ğŸ“š C++ Teknik Ä°nceleme NotlarÄ±: AkÄ±llÄ± Pointerlar - BÃ¶lÃ¼m III
**EÄŸitmen:** Necati Ergin  
**Konu:** Konteynerlarda `shared_ptr` KullanÄ±mÄ±, Custom Deleters ve Aliasing Constructor

---

#### 6. Konteynerlar Ä°Ã§inde `std::shared_ptr` ve Algoritmalar [25:00 - 47:15]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
AynÄ± nesneye birden fazla veri yapÄ±sÄ± (Ã¶rneÄŸin bir `std::list` ve bir `std::vector`) Ã¼zerinden eriÅŸilmesi gereken durumlarda, nesnenin kopyalanmasÄ± yerine adresinin paylaÅŸÄ±lmasÄ± hem bellekten tasarruf saÄŸlar hem de nesnenin gÃ¼ncel durumunun tÃ¼m yapÄ±larca gÃ¶rÃ¼lmesini saÄŸlar.

âš™ï¸ **Teknik Detay ve Sentaks:**
Hoca, bir `Person` sÄ±nÄ±fÄ± Ã¼zerinden `std::list` iÃ§indeki `shared_ptr`'larÄ±n bir `std::vector`'e kopyalanmasÄ±nÄ± gÃ¶sterdi. Burada nesneler kopyalanmaz, sadece sahiplik paylaÅŸÄ±lÄ±r.

```cpp
using PersonPtr = std::shared_ptr<Person>;
std::list<PersonPtr> myList;
myList.emplace_back(new Person("Alihan", "BozkÄ±r"));
myList.emplace_back(new Person("YiÄŸit", "Ä°nce"));

// Range Constructor ile kopyalama (Sadece pointerlar kopyalanÄ±r)
std::vector<PersonPtr> myVec(myList.begin(), myList.end()); 
// <-- Hoca belirtti: Ref count artÄ±k her nesne iÃ§in 2.

// Algoritma KullanÄ±mÄ±: HATA RÄ°SKÄ°!
std::sort(myVec.begin(), myVec.end()); 
// <-- HATA BURADA: Default sort, adresleri (pointer deÄŸerlerini) karÅŸÄ±laÅŸtÄ±rÄ±r. 
// Nesne deÄŸerlerini (Person) karÅŸÄ±laÅŸtÄ±rmak iÃ§in custom comparator ÅŸart!

std::sort(myVec.begin(), myVec.end(), [](const PersonPtr& p1, const PersonPtr& p2) {
    return *p1 < *p2; // <-- DoÄŸru yaklaÅŸÄ±m: Dereference ederek karÅŸÄ±laÅŸtÄ±r.
});
```

ğŸ” **Arka Plan (Under the Hood):**
`std::vector` iÃ§indeki `shared_ptr`'lar yok edildiÄŸinde (scope sonunda), Kontrol BloÄŸu iÃ§indeki referans sayÄ±cÄ±larÄ± 1 azalÄ±r. Ancak `std::list` hala hayatta olduÄŸu iÃ§in asÄ±l `Person` nesneleri `delete` edilmez.

ğŸš© **Kritik Nokta:**
Hoca, `shared_ptr`'Ä±n "aynÄ± nesneyi gÃ¶steren farklÄ± akÄ±llÄ± pointer nesneleri" olduÄŸunu, dolayÄ±sÄ±yla bir konteyner Ã¼zerinden nesneyi deÄŸiÅŸtirdiÄŸinizde (Ã¶rneÄŸin ismin sonuna "can" eklemek), diÄŸer konteyner Ã¼zerinden eriÅŸtiÄŸinizde de bu deÄŸiÅŸikliÄŸi gÃ¶receÄŸinizi ("matruÅŸka bebek gibi" iÃ§ iÃ§e geÃ§miÅŸ bir yapÄ± olmadÄ±ÄŸÄ±nÄ±, gerÃ§ek bir paylaÅŸÄ±m olduÄŸunu) vurguladÄ±.

---

#### 7. Custom Deleters (Ã–zel Siliciler) ve Type Erasure [47:16 - 58:40]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Bazen bir nesnenin silinmesi sadece `delete` operatÃ¶rÃ¼yle deÄŸil, Ã¶zel bir temizlik fonksiyonuyla (Ã¶rneÄŸin bir dosyayÄ± kapatmak, bir mutex'i serbest bÄ±rakmak veya bir log yazmak) yapÄ±lmalÄ±dÄ±r.

âš™ï¸ **Teknik Detay ve Sentaks:**
`shared_ptr`'da deleter, constructor'a bir **argÃ¼man** olarak geÃ§ilir. Bu durum `unique_ptr`'dan en bÃ¼yÃ¼k mimari farkÄ±dÄ±r.

```cpp
auto myDeleter = [](Point* p) {
    std::cout << "Custom deleting point at: " << p << "\n";
    delete p;
};

std::shared_ptr<Point> sp(new Point(1, 2, 3), myDeleter);
// <-- KRÄ°TÄ°K: Deleter, shared_ptr'Ä±n TÃœRÃœNÃœN (Type) bir parÃ§asÄ± deÄŸildir!
```

ğŸ” **Arka Plan (Type Erasure):**
Hoca, `shared_ptr`'Ä±n iÃ§indeki sihrin **Type Erasure (TÃ¼r Silme)** olduÄŸunu belirtti.
*   `unique_ptr<int, MyDeleter>` ve `unique_ptr<int, OtherDeleter>` farklÄ± tÃ¼rlerdir, birbirlerine atanamazlar.
*   `shared_ptr<int>` ise her zaman aynÄ± tÃ¼rdÃ¼r. Deleter bilgisi sÄ±nÄ±fÄ±n iÃ§inde deÄŸil, Ã§alÄ±ÅŸma zamanÄ±nda oluÅŸturulan **Control Block** iÃ§inde saklanÄ±r. Bu sayede farklÄ± deleter'lara sahip `shared_ptr`'lar birbirine atanabilir.

ğŸš© **MÃ¼lakat Sorusu:**
**Soru:** FarklÄ± deleter'lara sahip iki `shared_ptr` birbirine atanabilir mi?
**Cevap:** Evet. Ã‡Ã¼nkÃ¼ `shared_ptr`'da deleter tÃ¼rÃ¼ template parametresi deÄŸildir, Kontrol BloÄŸu iÃ§inde "erase" edilmiÅŸtir. Atama yapÄ±ldÄ±ÄŸÄ±nda, sol taraftaki nesne saÄŸ taraftaki nesnenin Kontrol BloÄŸunu (ve dolayÄ±sÄ±yla onun deleter'Ä±nÄ±) paylaÅŸmaya baÅŸlar.

---

#### 8. Aliasing Constructor (Takma Ä°sim YapÄ±landÄ±rÄ±cÄ±sÄ±) [58:41 - 01:15:40]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
En karmaÅŸÄ±k senaryolardan biridir. Bir `shared_ptr` dÃ¼ÅŸÃ¼nÃ¼n; bir `Owner` nesnesini yÃ¶netiyor. Biz bu nesnenin iÃ§indeki bir veri elemanÄ±na (`Member`) iÅŸaret eden bir `shared_ptr` istiyoruz. Ancak `Member`'Ä± kullanan kodlar varken, `Owner` nesnesinin tamamÄ± bellekten silinmemelidir.

âš™ï¸ **Teknik Detay ve Sentaks:**
Aliasing constructor iki parametre alÄ±r:
1.  Kontrol bloÄŸunu paylaÅŸacaÄŸÄ± mevcut `shared_ptr` (sahiplik buradadÄ±r).
2.  GerÃ§ekten iÅŸaret edeceÄŸi (point edeceÄŸi) adres.

```cpp
struct Member { /* ... */ };
struct Owner { Member m; };

std::shared_ptr<Owner> sp_owner = std::make_shared<Owner>();
// sp_member, Owner nesnesinin iÃ§indeki 'm' elemanÄ±nÄ± gÃ¶steriyor:
std::shared_ptr<Member> sp_member(sp_owner, &sp_owner->m); 

// <-- Hoca vurguladÄ±: sp_owner yok edilse bile sp_member 
// sayesinde Owner nesnesinin tamamÄ± hayatta kalÄ±r!
```

ğŸ” **Arka Plan (Memory Layout):**
*   `sp_member` iÃ§indeki "Stored Pointer", `m`'nin adresini tutar.
*   `sp_member` iÃ§indeki "Control Block Pointer", `Owner`'Ä±n kontrol bloÄŸunu tutar.
*   SonuÃ§: Referans sayÄ±cÄ± artar, `Owner` nesnesi bÃ¼tÃ¼nsel olarak korunur.

ğŸ–¼ï¸ **GÃ¶rselleÅŸtirme:**
```text
[shared_ptr<Member> sp_member]
    |-- Stored Pointer ------> [Owner.m (Member Adresi)]
    |-- Control Block Pointer -> [Owner'Ä±n Kontrol BloÄŸu (Ref Count)]
```

---

#### 9. `shared_from_this` ve CRTP Ã–rÃ¼ntÃ¼sÃ¼ [01:15:41 - 01:43:00]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Bir sÄ±nÄ±fÄ±n Ã¼ye fonksiyonu iÃ§inde, nesnenin kendisini (`this`) bir `shared_ptr` olarak baÅŸka bir yere (fonksiyona veya konteynera) kaydetmemiz gerekebilir. EÄŸer doÄŸrudan `shared_ptr<T>(this)` yazarsak, aynÄ± nesne iÃ§in **yepyeni bir Kontrol BloÄŸu** oluÅŸur. Bu da scope sonunda nesnenin iki kez `delete` edilmesine (**Double Free**) ve UB'ye yol aÃ§ar.

âš™ï¸ **Teknik Detay (CRTP & enable_shared_from_this):**
SÄ±nÄ±fÄ±n `std::enable_shared_from_this<T>` sÄ±nÄ±fÄ±ndan CRTP (Curiously Recurring Template Pattern) ile kalÄ±tÄ±m almasÄ± gerekir.

```cpp
class MyClass : public std::enable_shared_from_this<MyClass> { // <-- CRTP
public:
    void func() {
        // auto bad_sp = std::shared_ptr<MyClass>(this); <-- HATA: Double delete!
        auto good_sp = shared_from_this(); // <-- DOÄRU: Mevcut kontrol bloÄŸunu kullanÄ±r.
    }
};
```

ğŸ” **Arka Plan (Under the Hood):**
`enable_shared_from_this` sÄ±nÄ±fÄ±, arka planda nesneye ait olan Kontrol BloÄŸuna bir zayÄ±f referans (`weak_ptr`) tutar. `shared_from_this()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda bu zayÄ±f referanstan yeni bir `shared_ptr` Ã¼retir.

ğŸš© **Kritik Nokta:**
`shared_from_this()` fonksiyonunun Ã§alÄ±ÅŸabilmesi iÃ§in nesnenin **mutlaka** daha Ã¶nceden bir `shared_ptr` tarafÄ±ndan sahiplenilmiÅŸ olmasÄ± gerekir. EÄŸer nesne Stack'te ise veya Ã§Ä±plak bir pointer ise bu fonksiyon `std::bad_weak_ptr` exception'Ä± (istisnasÄ±) fÄ±rlatÄ±r.

---

Bu bÃ¶lÃ¼mde Hoca ÅŸu **3 kritik hataya** dikkat Ã§ekti:
1.  **Implicit Address Sort:** Konteynerdaki `shared_ptr`'larÄ± `sort` ederken comparator kullanmamak (Adresler sÄ±ralanÄ±r, iÃ§erik deÄŸil).
2.  **Double Control Block:** `shared_ptr<T>(this)` kullanÄ±mÄ± (Nesnenin iki farklÄ± ref-count mekanizmasÄ±na sahip olmasÄ±na neden olur).
3.  **Dangling Aliasing:** Aliasing constructor kullanÄ±rken, Kontrol BloÄŸu ile gÃ¶sterilen nesnenin Ã¶mÃ¼rlerini yanlÄ±ÅŸ hesaplamak.


### ğŸ“š C++ Teknik Ä°nceleme NotlarÄ±: AkÄ±llÄ± Pointerlar - BÃ¶lÃ¼m IV
**EÄŸitmen:** Necati Ergin  
**Konu:** `std::weak_ptr` MekanizmasÄ±, GÃ¶zlemci Stratejisi ve DÃ¶ngÃ¼sel Referans (Cyclic Reference) Ã‡Ã¶zÃ¼mÃ¼

---

#### 10. ZayÄ±f GÃ¶stericiler: `std::weak_ptr` GiriÅŸ [01:43:00 - 01:48:40]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
`std::shared_ptr` harika bir paylaÅŸÄ±mlÄ± sahiplik sunsa da, "sahiplik" (ownership) ile "gÃ¶zlemleme" (observation) arasÄ±ndaki farkÄ± ayÄ±ramaz. Bazen bir nesneye eriÅŸmemiz gerekir ama onun hayatÄ±nÄ± (lifetime) biz kontrol etmek istemeyiz. EÄŸer gÃ¶zlemci de `shared_ptr` kullanÄ±rsa, nesne sistemde gereksiz yere hayatta tutulur. `weak_ptr`, referans sayÄ±cÄ±nÄ± artÄ±rmadan nesneyi takip etmemizi saÄŸlar.

âš™ï¸ **Teknik Detay ve Sentaks:**
`weak_ptr`, bir `shared_ptr` nesnesinden oluÅŸturulur ancak **Reference Count**'u (Referans SayÄ±cÄ±) artÄ±rmaz. Sadece **Weak Count**'u artÄ±rÄ±r.

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(100);
std::weak_ptr<int> wp = sp; // <-- Hoca belirtti: Ref count hala 1!
```

ğŸ” **Arka Plan (Under the Hood):**
Kontrol BloÄŸu (Control Block) iÃ§inde iki farklÄ± sayÄ±cÄ± vardÄ±r:
1.  **Shared Count:** Nesneyi gerÃ§ekten sahiplenenlerin sayÄ±sÄ±. 0 olduÄŸunda nesne `delete` edilir.
2.  **Weak Count:** Nesneyi izleyen `weak_ptr` sayÄ±sÄ±. 0 olduÄŸunda Kontrol BloÄŸunun kendisi `delete` edilir.

ğŸš© **Kritik Nokta:**
Hoca, `weak_ptr`'Ä±n bir "akÄ±llÄ± pointer" gibi davranmadÄ±ÄŸÄ±nÄ±, Ã§Ã¼nkÃ¼ `operator*` (dereference) ve `operator->` (member access) operatÃ¶rlerine sahip olmadÄ±ÄŸÄ±nÄ± vurguladÄ±. Nesneye eriÅŸmek iÃ§in "kilitleme" (lock) mekanizmasÄ± ÅŸarttÄ±r.

---

#### 11. Hayat SÄ±namasÄ±: `expired()` ve `lock()` FonksiyonlarÄ± [01:48:41 - 02:07:30]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
`weak_ptr` sahiplik tutmadÄ±ÄŸÄ± iÃ§in, o bakarken nesne her an baÅŸka bir kod tarafÄ±ndan silinebilir. Bu yÃ¼zden nesneye eriÅŸmeden Ã¶nce "Hala orada mÄ±sÄ±n?" diye sormasÄ± gerekir.

âš™ï¸ **Teknik Detay ve Sentaks:**
*   `wp.expired()`: Nesne silinmiÅŸse `true`, hayattaysa `false` dÃ¶ner.
*   `wp.lock()`: EÄŸer nesne hayattaysa, bir `shared_ptr` dÃ¶ndÃ¼rerek referans sayÄ±cÄ±nÄ± geÃ§ici olarak artÄ±rÄ±r. Nesne silinmiÅŸse "Empty State" (boÅŸ) bir `shared_ptr` dÃ¶ndÃ¼rÃ¼r.

```cpp
// <-- Hoca'nÄ±n "GÃ¶rmeniz iÃ§in yazÄ±yorum" dediÄŸi idiomatik yapÄ±:
if (auto spx = wp.lock()) { // <-- "Locking" mekanizmasÄ±
    std::cout << "Nesne hayatta: " << *spx << "\n";
    // spx burada hayatta olduÄŸu sÃ¼rece nesne silinemez!
} else {
    std::cout << "Nesne Ã§oktan silinmiÅŸ (Expired).\n";
}
```

ğŸ” **Arka Plan (Dangling Pointer Ã–nleme):**
`lock()` fonksiyonu atomik (thread-safe) bir ÅŸekilde Ã§alÄ±ÅŸÄ±r. Biz `lock()` ile bir `shared_ptr` elde ettiÄŸimiz anda, biz o scope'tan Ã§Ä±kana kadar nesnenin silinmeyeceÄŸi garanti altÄ±na alÄ±nmÄ±ÅŸ olur.

ğŸš© **Kritik Nokta (Bad Weak Ptr):**
EÄŸer bir `shared_ptr`'Ä±, sÃ¼resi dolmuÅŸ (expired) bir `weak_ptr` argÃ¼manÄ±yla construct etmeye Ã§alÄ±ÅŸÄ±rsanÄ±z, `std::bad_weak_ptr` exception'Ä± fÄ±rlatÄ±lÄ±r.
```cpp
sp.reset(); // Kaynak silindi
try {
    std::shared_ptr<Point> sp2(wp); // wp expired!
} catch (const std::bad_weak_ptr& e) {
    // <-- Hoca bu hatayÄ± runtime'da gÃ¶sterdi.
}
```

---

#### 12. DÃ¶ngÃ¼sel Referans (Cyclic Reference) Problemi ve Ã‡Ã¶zÃ¼mÃ¼ [02:08:00 - 02:24:00]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Ä°ki nesnenin birbirini `shared_ptr` ile tutmasÄ± durumunda bir "kilitlenme" oluÅŸur. A nesnesi B'yi, B nesnesi de A'yÄ± hayatta tutar. Her ikisinin de referans sayÄ±cÄ±larÄ± asla 0'a dÃ¼ÅŸmez ve **Memory Leak** (Bellek SÄ±zÄ±ntÄ±sÄ±) oluÅŸur.

âš™ï¸ **Problemin Ä°nÅŸasÄ± (HatalÄ± Senaryo):**
```cpp
struct B; // Forward declaration
struct A { std::shared_ptr<B> bptr; ~A() { cout << "A destruct\n"; } };
struct B { std::shared_ptr<A> aptr; ~B() { cout << "B destruct\n"; } };

auto spa = std::make_shared<A>();
auto spb = std::make_shared<B>();

spa->bptr = spb;
spb->aptr = spa; // <-- CYCLE OLUÅTU! Destructorlar asla Ã§aÄŸrÄ±lmaz.
```

âš™ï¸ **Ã‡Ã¶zÃ¼m (weak_ptr KullanÄ±mÄ±):**
Hoca, bu dÃ¶ngÃ¼yÃ¼ kÄ±rmanÄ±n yolunun taraflardan birini `weak_ptr` yapmak olduÄŸunu belirtti.

```cpp
struct B { 
    std::weak_ptr<A> aptr; // <-- Ã‡Ã–ZÃœM: shared_ptr yerine weak_ptr
    ~B() { cout << "B destruct\n"; } 
};
```

ğŸ” **Arka Plan (Memory Layout):**
`weak_ptr` referans sayÄ±cÄ±nÄ± artÄ±rmadÄ±ÄŸÄ± iÃ§in, `spa` yok edildiÄŸinde referans sayÄ±cÄ± 1'den 0'a dÃ¼ÅŸebilir. `A` yok edilince iÃ§indeki `bptr` de (`shared_ptr<B>`) yok olur ve bÃ¶ylece `B`'nin de sayÄ±cÄ± 0'a dÃ¼ÅŸerek zincirleme temizlik gerÃ§ekleÅŸir.

---

#### 13. KapsamlÄ± Ã–rnek: Oyun ProgramÄ± "KÃ¶peklerin ArkadaÅŸlÄ±ÄŸÄ±" [02:24:01 - 02:37:00]

Hoca, konuyu somutlaÅŸtÄ±rmak iÃ§in bir "Oyun Senaryosu" (Game Scenario) kurguladÄ±.

**Senaryo:**
*   `Dog` sÄ±nÄ±fÄ± her kÃ¶peÄŸin bir ismini tutar.
*   Her kÃ¶peÄŸin bir "oyun arkadaÅŸÄ±" (`m_friend`) olabilir.
*   EÄŸer arkadaÅŸlÄ±k `shared_ptr` ile kurulursa; Kont, KarabaÅŸ'Ä±; KarabaÅŸ da Kont'u "oyun dÄ±ÅŸÄ±" (destruction) kalmaktan sonsuza dek korur (Leak).

```cpp
class Dog {
    std::string m_name;
    std::weak_ptr<Dog> mp_friend; // <-- Hoca vurguladÄ±: BurasÄ± shared_ptr olsaydÄ± leak olurdu!
public:
    void make_friend(std::shared_ptr<Dog> sp) { mp_friend = sp; }
    void display_friend() {
        if (auto sp = mp_friend.lock()) { // <-- GÃ¼venli eriÅŸim
             std::cout << m_name << "'in arkadaÅŸÄ±: " << sp->m_name << "\n";
        }
    }
};
```

ğŸš© **Kritik Nokta (Aliasing vs Weak):**
Bir arkadaÅŸÄ±m mÃ¼lakat tadÄ±nda sordu: "SÄ±nÄ±f iÃ§indeki tÃ¼m pointerlar her zaman `weak_ptr` mÄ± olmalÄ±?"
Hoca: "HayÄ±r. Sadece sahiplik hiyerarÅŸisinde bir dÃ¶ngÃ¼ oluÅŸuyorsa veya nesnenin hayatÄ±nÄ± kontrol etmememiz gereken 'Observer' durumlarÄ±nda `weak_ptr` kullanÄ±lÄ±r."

---

#### 14. Ders KapanÄ±ÅŸÄ± ve Gelecek Konular [02:37:01 - Son]

ğŸ“Š **Ã–zet Tablo (Smart Pointers):**
| TÃ¼r | Sahiplik (Ownership) | Ref Count Etkisi | KullanÄ±m AmacÄ± |
| :--- | :--- | :--- | :--- |
| `unique_ptr` | Exclusive (Tekil) | Yok | Tek sahip, sÄ±fÄ±r maliyet. |
| `shared_ptr` | Shared (PaylaÅŸÄ±mlÄ±) | ArtÄ±rÄ±r | Ortak kullanÄ±m, otomatik yÃ¶netim. |
| `weak_ptr` | None (GÃ¶zlemci) | Yok (Sadece Weak) | Cycle kÄ±rma, hayat sÄ±nama. |

ğŸ”— **KÃ¼mÃ¼latif BaÄŸlantÄ±lar:**
Hoca, bir sonraki derste **Literal Operators**, **IOStream** kÃ¼tÃ¼phanesi derinlikleri, **Concurrency** (EÅŸzamanlÄ±lÄ±k) ve **Regex** gibi konulara geÃ§ileceÄŸini belirterek 2025'in ilk dersini sonlandÄ±rdÄ±.

---

Bu bÃ¶lÃ¼mde Hoca ÅŸu **3 kritik hataya** dikkat Ã§ekti:
1.  **Direct Dereference on Weak:** `weak_ptr` Ã¼zerinden `*` veya `->` operatÃ¶rlerini kullanmaya Ã§alÄ±ÅŸmak (Syntax HatasÄ±).
2.  **Forgotten Lock:** Nesne hayatta mÄ± diye bakmadan (lock yapmadan) `weak_ptr` kullanmaya Ã§alÄ±ÅŸmak.
3.  **Ref-Count Deadlock:** KarÅŸÄ±lÄ±klÄ± `shared_ptr` kullanÄ±mÄ±nÄ±n (Cyclic Reference) yarattÄ±ÄŸÄ± sessiz bellek sÄ±zÄ±ntÄ±larÄ± (Leak).

