Merhaba, ben Necati Hoca'nÄ±n dersini en Ã¶n sÄ±radan takip eden, notlarÄ±nÄ± titizlikle tutan Ã¶ÄŸrencisiyim. 23 AralÄ±k 2024 tarihli 50. dersin teknik analizini ve derinlemesine notlarÄ±nÄ± aÅŸaÄŸÄ±da bulabilirsin.

---

# C++ Dersi NotlarÄ± - 50. GÃ¼n: Structured Binding Derinlemesine BakÄ±ÅŸ ve Dinamik Ã–mÃ¼rlÃ¼ Nesneler

Bu dersin odak noktasÄ±, C++17 ile gelen en radikal sentaks araÃ§larÄ±ndan biri olan **Structured Binding** (YapÄ±sal BaÄŸlama) mekanizmasÄ±nÄ±n iÃ§ yÃ¼zÃ¼, C++20 ile gelen gÃ¼ncellemeler ve **Dinamik Ã–mÃ¼rlÃ¼ Nesneler** (Dynamic Objects) konusuna yapÄ±lan kapsamlÄ± giriÅŸtir.

---

## 1. Structured Binding (YapÄ±sal BaÄŸlama) - Temel Mekanizma [00:00 - 05:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++17 Ã¶ncesinde, birden fazla Ã¶ÄŸeye sahip yapÄ±larÄ± (struct, pair, tuple) bileÅŸenlerine ayÄ±rmak iÃ§in `std::tie` kullanÄ±lÄ±yor veya elemanlara tek tek isim verilmesi gerekiyordu. Bu hem kod kalabalÄ±ÄŸÄ±na yol aÃ§Ä±yor hem de deÄŸiÅŸkenlerin Ã¶nceden tanÄ±mlanmasÄ± zorunluluÄŸunu getiriyordu.

### âš™ï¸ Teknik Detay ve Sentaks
```cpp
struct Data {
    int x;
    std::string str;
};

Data get_data();

// Sentaks: auto [declarators] = expression;
auto [no, name] = get_data(); // <-- Hoca buraya dikkat Ã§ekti: Burada aslÄ±nda 'no' ve 'name' birer deÄŸiÅŸken deÄŸil!
```

### ğŸ” Arka Plan (Under the Hood)
Hoca'nÄ±n en Ã§ok vurguladÄ±ÄŸÄ± nokta: **"Biz xyz isimli deÄŸiÅŸkenler tanÄ±mlamÄ±yoruz."**
Derleyici, eÅŸitliÄŸin saÄŸ tarafÄ±ndaki ifade (`expression`) iÃ§in gizli bir anonim nesne oluÅŸturur. KÃ¶ÅŸeli parantez iÃ§indeki isimler, bu anonim nesnenin elemanlarÄ±na verilen **Alias** (eÅŸ isim) niteliÄŸindedir.

```cpp
// Derleyicinin Ã¼rettiÄŸi sembolik kod:
auto __compiler_generated_object = get_data(); 
using no = __compiler_generated_object.x;      // <-- Teknik terim: Alias (EÅŸ isim)
using name = __compiler_generated_object.str;
```

**Kritik Kural:** TÃ¼r Ã§Ä±karÄ±mÄ± (Type Deduction) isimler iÃ§in deÄŸil, saÄŸ taraftaki ifade iÃ§in yapÄ±lÄ±r.

---

## 2. Tuple Interface ve Custom Type DesteÄŸi [05:00 - 10:10]

### ğŸ§  Rationale
Structured Binding sadece `struct` ve `C dizileri` iÃ§in dilin doÄŸal desteÄŸine sahiptir. Ancak `std::pair`, `std::tuple` ve `std::array` gibi kÃ¼tÃ¼phane tÃ¼rleri iÃ§in bu destek **Tuple Interface** implementasyonu ile saÄŸlanÄ±r.

### âš™ï¸ Teknik Detay
Kendi sÄ±nÄ±fÄ±mÄ±zÄ± Structured Binding'e uygun hale getirmek iÃ§in ÅŸu 3 bileÅŸeni implemente etmeliyiz:
1.  `std::tuple_size` (Metafunction)
2.  `std::tuple_element` (Metafunction)
3.  `get<N>` (Function template)

```cpp
using MyPair = std::pair<int, double>;

// 1. Tuple Size kontrolÃ¼
static_assert(std::tuple_size_v<MyPair> == 2); // <-- Kritik: Ã–ÄŸeyi sayÄ±sÄ±nÄ± verir.

// 2. Tuple Element kontrolÃ¼
using FirstType = std::tuple_element_t<0, MyPair>; // int

// 3. Get Interface
MyPair p{1, 2.5};
auto val = std::get<0>(p); // 1
```

---

## 3. C++20 GÃ¼ncellemeleri ve Private Ãœye EriÅŸimi [10:10 - 12:00]

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±

| Ã–zellik | C++17 | C++20 |
| :--- | :--- | :--- |
| **Private Ãœye EriÅŸimi** | Yasak (Sadece public Ã¼yeler) | **Serbest** (Ãœye/Friend fonksiyonlar iÃ§inde) |
| **Lambda Capture** | SB isimleri capture edilemez | **Capture edilebilir** |

### âš™ï¸ Teknik Ã–rnek (Private Ãœye EriÅŸimi)
```cpp
class A {
    int x, y; // Private
    friend void f2();
public:
    void mem_func() {
        auto [m, n] = *this; // C++20'de legal: Ãœye fonksiyon private eriÅŸebilir.
    }
};

void f1(A ax) {
    // auto [x, y] = ax; // <-- HATA: f1 dÄ±ÅŸarÄ±dan private Ã¼yeye eriÅŸemez.
}

void f2() {
    A ax;
    auto [x, y] = ax; // C++20'de legal: Friend fonksiyon eriÅŸebilir.
}
```

---

## 4. TaÅŸÄ±ma SemantiÄŸi (Move Semantics) ve SB [12:00 - 15:00]

### ğŸ” Arka Plan (Memory Layout)
Structured Binding'de `std::move` kullanÄ±ldÄ±ÄŸÄ±nda, taÅŸÄ±nan ÅŸey SB iÃ§indeki isimler deÄŸil, derleyicinin oluÅŸturduÄŸu **anonim nesnedir.**

```cpp
Person p{"Necati", "Ergin"};
auto [name, surname] = std::move(p); // <-- Kritik: p'nin kaynaklarÄ± Ã§alÄ±ndÄ±.

// Under the hood:
auto __comp_obj = std::move(p); // Move Constructor Ã§aÄŸrÄ±lÄ±r
// name ve surname __comp_obj'nin elemanlarÄ±na alias'tÄ±r.
```

**ğŸš© MÃ¼lakat Sorusu:** AÅŸaÄŸÄ±daki kodda `p.name.length()` ne dÃ¶ner?
```cpp
auto [n, s] = std::move(p);
std::cout << p.name.length(); 
```
**Cevap:** 0 dÃ¶ner (veya move-from state'e geÃ§er). Ã‡Ã¼nkÃ¼ anonim nesne `p`'den kaynaklarÄ± Ã§almÄ±ÅŸtÄ±r.

---

## 5. STL Ä°Ã§inde Structured Binding KullanÄ±m SenaryolarÄ± [15:00 - 30:00]

Hoca bu bÃ¶lÃ¼mde SB'nin "Map'e Ã¶zgÃ¼ bir Ã¶zellik" sanÄ±lmasÄ±nÄ±n bÃ¼yÃ¼k bir hata olduÄŸunu belirtti.

### âš™ï¸ Senaryo A: Map DolaÅŸÄ±mÄ±
```cpp
std::map<string, int> age_map;
for (const auto& [name, age] : age_map) { // pair.first ve pair.second yerine anlamlÄ± isimler.
    // ...
}
```

### âš™ï¸ Senaryo B: `std::set::insert` DÃ¶nÃ¼ÅŸÃ¼
```cpp
// Eskiden:
auto ret = my_set.insert(val);
if (ret.second) { /* use ret.first */ }

// Modern (SB + If with Initializer):
if (auto [iter, success] = my_set.insert(val); success) {
    // iter ve success burada kullanÄ±labilir.
}
```

### âš™ï¸ Senaryo C: Algoritma SonuÃ§larÄ± (`std::minmax_element`)
```cpp
auto [min_it, max_it] = std::minmax_element(vec.begin(), vec.end());
```

---

## 6. Kritik SÄ±nÄ±rlar ve Lambda Capture HatasÄ± [30:00 - 35:00]

### ğŸš© Kritik Nokta: constexpr KÄ±sÄ±tÄ±
**"Structure Binding isimleri constexpr O-LA-MAZ!"**
Nesneniz `constexpr` olsa bile, baÄŸlama isimleri bu niteleyiciyi alamaz.

```cpp
constexpr std::pair p{1, 2};
// constexpr auto [x, y] = p; // <-- SYNTAX HATASI: SB constexpr olamaz.
```

### âš™ï¸ Lambda Capture (C++20 Ã–ncesi vs SonrasÄ±)
```cpp
auto [x, y] = my_pair;
auto f = [x]() { return x; }; 
// C++17: HATA (SB isimleri capture edilemezdi)
// C++20: GEÃ‡ERLÄ°
```

---

## 7. Universal Reference YanÄ±lgÄ±sÄ± [35:00 - 39:30]

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
Hoca, `auto &&[x, y]` yazÄ±ldÄ±ÄŸÄ±nda nesnenin otomatik olarak taÅŸÄ±ndÄ±ÄŸÄ±na (move) dair yaygÄ±n bir yanlÄ±ÅŸ inanÄ±ÅŸ olduÄŸunu sÃ¶yledi.

```cpp
void func(std::string&& re) {
    auto s = re; // <-- HATA: re bir isimdir, L-value'dur. Kaynak Ã§alÄ±nmaz, kopyalanÄ±r!
    auto s2 = std::move(re); // <-- DOÄRUSU: KaynaÄŸÄ± Ã§almak iÃ§in move ÅŸart.
}
```
Structured Binding'de de `auto &&` sadece **Universal Reference** (Forwarding Reference) baÄŸlamÄ± oluÅŸturur, doÄŸrudan bir taÅŸÄ±ma iÅŸlemi tetiklemez.

---

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: Structured Binding Bellek YapÄ±sÄ±

```text
EÅŸitliÄŸin SaÄŸ TarafÄ±: get_data() -> R-value Object
                                      |
                                      v
[ Derleyici Anonim Nesnesi (E) ] <--- Bellekte yer kaplayan gerÃ§ek nesne bu!
      |               |
      |-- (no)  <-----|-- x elemanÄ±na referans/alias
      |-- (name)<-----|-- str elemanÄ±na referans/alias
```

---

### Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:
1.  Structured Binding isimlerinin (`[x, y]`) gerÃ§ek birer baÄŸÄ±msÄ±z deÄŸiÅŸken sanÄ±lmasÄ± (Onlar sadece alias'tÄ±r).
2.  SB'nin sadece `std::map` ile kullanÄ±labileceÄŸi yanÄ±lgÄ±sÄ±.
3.  `auto &&` kullanÄ±ldÄ±ÄŸÄ±nda nesnenin kendiliÄŸinden `move` edileceÄŸi sanÄ±lmasÄ±.

---

Dersin teknik derinliÄŸi artÄ±yor; Ã¶zellikle kendi tÃ¼rÃ¼mÃ¼zÃ¼ Structured Binding'e adapte etmek ve bellek yÃ¶netiminin "low-level" detaylarÄ± mÃ¼lakatlarÄ±n vazgeÃ§ilmezidir. Notlara devam ediyoruz.

---

## 8. Custom TÃ¼rleri Structured Binding'e HazÄ±rlamak (Employee Ã–rneÄŸi) [39:30 - 57:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
SÄ±nÄ±f elemanlarÄ±mÄ±z `private` ise ve biz bu tÃ¼rÃ¼ bir kÃ¼tÃ¼phane bileÅŸeni olarak sunuyorsak, kullanÄ±cÄ±larÄ±n verileri `tuple` gibi ayrÄ±ÅŸtÄ±rmasÄ±nÄ± saÄŸlamak iÃ§in kÃ¼tÃ¼phane tarafÄ±nda "Tuple Interface" desteÄŸi vermeliyiz.

### âš™ï¸ Teknik Detay ve Sentaks (Tam Uygulama)
Kendi tÃ¼rÃ¼mÃ¼zÃ¼ (`Employee`) baÄŸlamaya uygun hale getirmek iÃ§in 3 adÄ±m:

```cpp
#include <iostream>
#include <string>
#include <tuple>

class Employee {
    int m_id;
    std::string m_name;
    std::string m_surname;
public:
    Employee(int id, std::string name, std::string surname) 
        : m_id(id), m_name(std::move(name)), m_surname(std::move(surname)) {}

    // Getter'lar zorunlu
    int get_id() const { return m_id; }
    const std::string& get_name() const { return m_name; }
    const std::string& get_surname() const { return m_surname; }
};

// --- ADIM 1: tuple_size Specialization ---
template<>
struct std::tuple_size<Employee> : std::integral_constant<std::size_t, 3> {}; // <-- Kritik: Eleman sayÄ±sÄ± 3

// --- ADIM 2: tuple_element Specialization ---
template<std::size_t Idx>
struct std::tuple_element<Idx, Employee> {
    using type = std::conditional_t<Idx == 0, int, std::string>; // 0 ise int, deÄŸilse string
};

// --- ADIM 3: get<N> Fonksiyonu (if constexpr kullanÄ±mÄ±) ---
template<std::size_t Idx>
auto get(const Employee& e) {
    if constexpr (Idx == 0) return e.get_id();
    else if constexpr (Idx == 1) return e.get_name();
    else if constexpr (Idx == 2) return e.get_surname();
    else static_assert(Idx < 3, "Gecersiz indeks!"); // <-- Hoca buraya dikkat Ã§ekti: Compile-time kontrolÃ¼
}

// KullanÄ±m:
int main() {
    Employee emp{12, "Oguz", "Aykut"};
    auto [id, name, sur] = emp; // ARTIK LEGAL!
    std::cout << id << " " << name << std::endl;
}
```

---

## 9. Dinamik Ã–mÃ¼rlÃ¼ Nesneler (Dynamic Objects) [57:00 - 01:15:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Stack Ã¶mÃ¼rlÃ¼ nesnelerin kapsamÄ± (scope) bittiÄŸinde hayatlarÄ± biter. Ancak Ã§alÄ±ÅŸma zamanÄ±nda bÃ¼yÃ¼klÃ¼ÄŸÃ¼ belli olan veya fonksiyon kapsamÄ± dÄ±ÅŸÄ±nda da yaÅŸamasÄ± gereken nesneler iÃ§in **Heap (Free Store)** yÃ¶netimi ÅŸarttÄ±r. 

### âš™ï¸ Teknik Detay ve Sentaks
Hoca Ã§ok Ã¶nemli bir ayrÄ±m yaptÄ±: **New Expression** vs **Operator New Function**.

1.  **New Expression:** Bizim kodda yazdÄ±ÄŸÄ±mÄ±z `new MyClass()`.
2.  **Operator New Function:** Derleyicinin arka planda bellek tahsis etmek iÃ§in Ã§aÄŸÄ±rdÄ±ÄŸÄ± `void* operator new(size_t)`.

```cpp
MyClass* p = new MyClass(); 
```
### ğŸ” Arka Plan (Under the Hood)
Derleyici yukarÄ±daki satÄ±rÄ± ÅŸu adÄ±mlara dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r:
1.  **Allocation:** `void* raw = operator new(sizeof(MyClass));` fonksiyonunu Ã§aÄŸÄ±rÄ±r. (Malloc benzeri ama `bad_alloc` throw eder).
2.  **Construction:** `raw` adresinde nesnenin `constructor`Ä±nÄ± Ã§aÄŸÄ±rÄ±r.
3.  **Assignment:** Elde edilen adresi `p` gÃ¶stericisine atar.

**ğŸš© Kritik Kural:** `operator new` baÅŸarÄ±sÄ±z olursa `std::bad_alloc` throw eder. `malloc` gibi `NULL` dÃ¶nmez (istisnalar hariÃ§).

---

## 10. Constructor Exception Durumu (Bellek SÄ±zÄ±ntÄ±sÄ± mÄ±?) [01:15:00 - 01:35:00]

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `new MyClass()` ifadesinde, bellek tahsis edildikten sonra `constructor` bir exception (istisna) fÄ±rlatÄ±rsa ne olur? Bellek sÄ±zÄ±ntÄ±sÄ± (memory leak) oluÅŸur mu?

**Cevap:** **HAYIR.** 
Derleyici buraya otomatik bir "try-catch" bloÄŸu ekler. EÄŸer constructor baÅŸarÄ±sÄ±z olursa, derleyici ayrÄ±lan belleÄŸi geri vermek iÃ§in otomatik olarak `operator delete` fonksiyonunu Ã§aÄŸÄ±rÄ±r ve istisnayÄ± dÄ±ÅŸarÄ±ya (re-throw) fÄ±rlatÄ±r.

```cpp
// Derleyicinin Ã¼rettiÄŸi sembolik kod:
void* temp = operator new(sizeof(MyClass));
try {
    new (temp) MyClass(); // Constructor Ã§aÄŸrÄ±sÄ±
} catch (...) {
    operator delete(temp); // <-- Bellek sÄ±zÄ±ntÄ±sÄ±nÄ± engelleyen sihirli dokunuÅŸ!
    throw; // HatayÄ± ilet
}
```

---

## 11. Customizing Failure: New Handler [01:35:00 - 01:54:00]

### ğŸ§  Rationale
Bellek yetmediÄŸinde doÄŸrudan programÄ±n Ã§Ã¶kmesini istemiyorsak, "son bir gayretle" bellekte yer aÃ§maya Ã§alÄ±ÅŸan bir mekanizma kurabiliriz.

### ğŸ” Arka Plan (Under the Hood)
`operator new` fonksiyonu aslÄ±nda bir sonsuz dÃ¶ngÃ¼ iÃ§indedir:
1.  Bellek ayÄ±rmaya Ã§alÄ±ÅŸ. BaÅŸarÄ±lÄ±ysa `return`.
2.  BaÅŸarÄ±sÄ±zsa `new_handler` tanÄ±mlÄ± mÄ± bak.
3.  TanÄ±mlÄ±ysa o fonksiyonu Ã§aÄŸÄ±r (belki orada bir ÅŸeyleri `free` ederiz).
4.  TanÄ±mlÄ± deÄŸilse `bad_alloc` fÄ±rlat.

```cpp
void my_new_handler() {
    std::cout << "Bellek bitti! Yer aciliyor..." << std::endl;
    // Kritik bellek bloklarÄ±nÄ± serbest bÄ±rakma mantÄ±ÄŸÄ± burada olur.
    // EÄŸer yer aÃ§amazsak ya terminate etmeliyiz ya da handler'Ä± null yapmalÄ±yÄ±z.
}

std::set_new_handler(my_new_handler); // Handler'Ä± kaydet
```

---

## 12. Placement New ve Explicit Destructor Call [02:10:00 - 02:27:00]

### ğŸ§  Rationale
Bazen bellek zaten elimizdedir (Ã¶rneÄŸin bir `buffer` veya `vektÃ¶rÃ¼n kapasite alanÄ±`) ve biz sadece o adreste nesneyi "inÅŸa etmek" (construct) isteriz.

### âš™ï¸ Teknik Detay ve Sentaks
```cpp
unsigned char buff[1024]; // Bellek hazÄ±r
MyClass* p = new (buff) MyClass(); // <-- Placement New: buff adresinde nesneyi oluÅŸtur.
```

### ğŸš© Kritik Kural (MÃ¼lakatlarda Ã‡ok Sorulur)
Placement new ile oluÅŸturulan nesneler iÃ§in asla `delete p;` **YAZILMAZ!** 
Ã‡Ã¼nkÃ¼ bellek `operator new` ile heap'ten alÄ±nmadÄ±. Sadece nesnenin hayatÄ±nÄ± bitirmek iÃ§in `destructor` **Ä°SMÄ°YLE** Ã§aÄŸrÄ±lmalÄ±dÄ±r:

```cpp
p->~MyClass(); // <-- EXPLICIT DESTRUCTOR CALL: MÃ¼lakatlarÄ±n vazgeÃ§ilmez sorusu!
```

---

## 13. Array New / Array Delete TuzaÄŸÄ± [02:27:00 - 02:46:00]

Hoca bu kÄ±smÄ± "Kesinlikle TanÄ±msÄ±z DavranÄ±ÅŸ (UB)" etiketiyle anlattÄ±:

```cpp
MyClass* ptr = new MyClass[10]; // Array new
// delete ptr;   // <-- HATA: TanÄ±msÄ±z DavranÄ±ÅŸ (Undefined Behavior)
delete[] ptr; // <-- DOÄRU
```

**ğŸ” Neden FarklÄ±?**
`delete[]` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, derleyici dizinin kaÃ§ elemanlÄ± olduÄŸunu bellekteki gizli bir alandan (genelde adresin hemen baÅŸÄ±ndan) okur ve o kadar kez `destructor` Ã§aÄŸÄ±rÄ±r. `delete` ise tek bir nesne sanÄ±p sadece bir kez destructor Ã§aÄŸÄ±rÄ±r ve bu da bellek felaketine yol aÃ§ar.

---

### Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:
1.  Placement new kullanÄ±lan nesneye `delete` operatÃ¶rÃ¼ uygulamak (DoÄŸrusu destructor'Ä± manuel Ã§aÄŸÄ±rmaktÄ±r).
2.  `new[]` ile oluÅŸturulan diziyi `delete` ile silmeye Ã§alÄ±ÅŸmak (UB - TanÄ±msÄ±z DavranÄ±ÅŸ).
3.  Constructor hata fÄ±rlattÄ±ÄŸÄ±nda bellek sÄ±zÄ±ntÄ±sÄ± olacaÄŸÄ±nÄ± sanmak (Derleyici bunu otomatik yÃ¶netir).

---
