# C++ Programlama Dersi Notları: 39. Ders (Bölüm 1)
**Konu:** Lambda İfadeleri (Derinlemesine), C++17/20 Standartları, STL ve İteratör Adaptörleri
**Tarih:** 13 Kasım 2024

---

## 1. Lambda İfadelerinde `constexpr` Belirleyicisi (C++17 Standartı) [00:01:45 - 00:05:45]

C++17 standartıyla birlikte lambda ifadelerinin `constexpr` olma durumuna ilişkin kurallar köklü bir değişikliğe uğramıştır. Bu değişiklik, derleyicinin lambdayı daha esnek bir şekilde optimize etmesine olanak tanır.

*   **Varsayılan `constexpr` Durumu:** Bir lambda ifadesi, eğer `constexpr` fonksiyon olma koşullarını (gövdesinde statik değişken bulundurmamak, sadece sabit ifadelerle çalışmak vb.) sağlıyorsa, siz açıkça belirtmeseniz bile derleyici tarafından **örtülü (implicitly) olarak `constexpr`** kabul edilir. Bu, lambdanın sabit ifadesi gereken yerlerde (dizi boyutu, template argümanı vb.) doğrudan kullanılabilmesini sağlar.
*   **Koşulların İhlali:** Eğer lambda gövdesinde `constexpr` kurallarını ihlal eden bir öğe (örneğin `static` ömürlü bir yerel değişken) varsa, lambda artık `constexpr` değildir. Bu durumda lambda hala geçerlidir ancak sadece run-time'da (çalışma zamanında) çağrılabilir; compile-time bağlamlarında kullanılamaz.
*   **Açıkça `constexpr` Belirtmek:** Programcı lambda bildiriminde parametre parantezinden sonra açıkça `constexpr` anahtar sözcüğünü kullanabilir. Bu durumda, eğer lambda gövdesi `constexpr` olma koşullarını sağlamıyorsa, derleyici "bu fonksiyon constexpr olamaz" diyerek bir **syntax hatası** üretir. Bu yöntem, kodun derleme zamanında çalışmasını garanti altına almak için bir güvenlik mekanizmasıdır.

```cpp
// C++17 Örneği
auto f = [](int x) { return x * x; }; // Örtülü constexpr

constexpr int val = f(10); // Geçerli, sabit ifadesi olarak kullanıldı.

auto f_hata = [](int x) {
    static int call_count = 0; // constexpr kuralını bozar
    return x * x;
};
// constexpr int val2 = f_hata(5); // ERROR: Sabit ifadesi değil!

auto f_zorunlu = [](int x) constexpr {
    // static int y = 0; // Eğer burayı açarsanız SYNTAX ERROR olur.
    return x * 2;
};
```

---

## 2. Trailing Return Type (Sondan Geri Dönüş Türü) Gerekliliği [00:05:45 - 01:09:00]

Lambda ifadelerinde geri dönüş türü genellikle çıkarım (deduction) yoluyla belirlenir. Ancak bazı durumlarda `-> Type` sentaksını kullanmak zorunluluk arz eder.

*   **Farklı Türden Return İfadeleri:** Lambda gövdesinde birden fazla `return` ifadesi varsa ve bu ifadelerin döndürdüğü değerlerin türleri aynı değilse (örneğin biri `int` diğeri `double`), derleyici çıkarım yapamaz ve hata verir. Bu durumda trailing return type ile derleyiciye hangi türe dönüşüm yapılması gerektiği (örneğin `-> double`) dikte edilmelidir.
*   **Çıkarımı İptal Etmek (Dikte Etmek):** Bazen derleyici bir çıkarım yapabilir (örneğin bir tamsayı döndüğü için `int` diyebilir), ancak programcı bu türün özellikle `double` veya başka bir tür olmasını isteyebilir. Bu tür "tür dikte etme" senaryolarında trailing return type kullanılır.
*   **Referans Döndürme Durumu:** Standart `auto` çıkarımı, referansları ve `const` eklerini düşürür (decay). Eğer bir lambda parametre olarak aldığı bir L-value referansı tekrar referans olarak döndürmek istiyorsa, çıkarım mekanizması bunu sadece türün kendisi (int& yerine int) olarak algılayacaktır. Bu durumda `-> int&` veya C++14 ile gelen `-> decltype(auto)` kullanılarak referans semantiği korunur.

```cpp
// Farklı return türleri örneği
auto f = [](int x) -> double {
    if (x > 10) return 1;    // int
    else return 3.4;         // double (hata almamak için dikte ettik)
};

// Referans döndürme örneği
int a = 10;
auto f_ref = [](int& r) -> int& {
    return r; // Trailing return type olmazsa int& değil int döner (kopyalama yapılır).
};
```

---

## 3. Generic Lambdalar ve Template Parametreleri [01:09:00 - 01:11:00]

C++14 ile hayatımıza giren generic lambdalar, aslında arka planda derleyicinin bir "function template" oluşturmasını sağlar.

*   **`auto` Parametreleri:** Lambda parametrelerinde `auto` kullanıldığında, derleyicinin oluşturduğu closure type içindeki `operator()` fonksiyonu bir template fonksiyon haline gelir. Bu sayede lambda farklı türden argümanlarla çağrılabilir.
*   **Universal Reference ve Perfect Forwarding:** Lambdalarda `auto&& args` yapısı kullanılarak mükemmel gönderim (perfect forwarding) yapılabilir. Bu, özellikle başka fonksiyonları sarmalayan (wrapper) lambdalar için hayati önem taşır.
*   **C++20 Abbreviated Template Syntax:** C++20 ile lambdalarda template parametre paketi (`auto&&... args`) kullanımı daha da kolaylaşmış ve normal fonksiyon şablonlarındaki kısaltılmış sentaks lambdalara da tam uyumlu hale getirilmiştir.

```cpp
// Generic Lambda (C++14)
auto f = [](auto x, auto y) {
    return x + y;
};

// Variadic Lambda (C++20/C++14)
auto wrapper = [](auto&&... args) {
    return some_function(std::forward<decltype(args)>(args)...);
};
```

---

## 4. Üye Fonksiyonlarda Lambda ve `this` Yakalama (C++17/20) [01:11:00 - 01:24:30]

Bir sınıfın üye fonksiyonu (member function) içinde lambda kullanıldığında, sınıfın veri elemanlarına (member variables) erişim özel bir durumdur.

*   **`this` Yakalamak:** Sınıfın veri elemanları aslında `this` pointer'ı üzerinden erişilen isimlerdir. Lambdanın `mx` veya `my` gibi elemanlara erişebilmesi için `[this]` şeklinde bir capture clause'a sahip olması gerekir. Bu durumda lambda, orijinal nesnenin adresini saklar ve doğrudan o nesnenin elemanlarını değiştirir.
*   **`[*this]` ile Kopyalama (C++17):** Bazı durumlarda nesnenin hayatı bittikten sonra lambdanın (closure object) hala hayatta olması gerekebilir. Eğer lambda sadece `this` pointer'ını saklıyorsa, orijinal nesne yok edildiğinde "dangling pointer" (sahipsiz pointer) sorunu oluşur. C++17 ile gelen `[*this]` sentaksı, nesnenin o anki durumunun bir kopyasını lambdanın içine alır. Böylece orijinal nesne ölse bile lambda kendi içindeki kopyayla güvenle çalışır.
*   **C++20 Deprecated Durumu:** C++20 standartından önce `[=]` (her şeyi kopyalayarak yakala) sentaksı, `this` pointer'ını da örtülü olarak kopyalıyordu. Ancak bu durum, programcının "nesneyi kopyalıyorum" zannederken aslında sadece "pointer'ı kopyalaması" nedeniyle hatalara yol açıyordu. Artık `[=]` ile `this`'in örtülü yakalanması **deprecated** (kullanımdan kaldırılmak üzere işaretlenmiş) kabul ediliyor. Bunun yerine açıkça `[=, this]` veya `[=, *this]` yazılmalıdır.

```cpp
class Point {
    int mx = 0, my = 0;
public:
    void func() {
        // [this] -> Orijinal nesne üzerinde işlem yapar (by reference gibi)
        // [*this] -> Nesnenin kopyasını alır (C++17)
        
        auto l1 = [this]() {
            mx++; // Orijinal nesnedeki mx artar
        };

        auto l2 = [*this]() mutable {
            mx++; // Kopyadaki mx artar, orijinal değişmez
        };
    }
};
```

---

## 5. Lambda İdiomları: IIFE ve Tek Seferlik Kod Çalıştırma [01:24:30 - 01:43:00]

Lambda ifadeleri sadece bir fonksiyon nesnesi oluşturmak için değil, kod mimarisini düzenlemek için de kullanılır.

*   **IIFE (Immediately Invoked Function Expression):** Bir lambdanın tanımlandığı satırda hemen parantez açılarak çağrılmasıdır. Bu teknik, özellikle `const` bir değişkene karmaşık bir hesaplama sonucunda (if-else veya döngü gerektiren) ilk değer vermek için kullanılır. Bu sayede "initialization-assignment split" (tanımlama ve atamanın ayrılması) hatasından kaçınılmış olur.
*   **Thread-Safe Tek Seferlik Çalıştırma:** Bir fonksiyonun her çağrıldığında değil, sadece ilk çağrıldığında çalışmasını istediğimiz kodlar olabilir. Normalde statik yerel değişkenler ve bayraklarla yapılan bu işlem, C++'ta statik yerel değişkenlerin "thread-safe initialization" özelliğinden faydalanılarak bir lambda ile çok daha şık bir şekilde çözülebilir.

```cpp
void some_func() {
    // Statik değişkenin lambda ile ilklendirilmesi (Thread-safe)
    static int _ = []() {
        std::cout << "Bu kod sadece bir kez calisir!" << std::endl;
        return 0; 
    }();

    // IIFE ile const değişken ilklendirme
    const int complex_val = [/* captures */]() {
        if (/* condition */) return 42;
        return 100;
    }();
}
```

---

## 6. Stateless Lambdalarda Default Constructor ve Atama (C++20) [01:43:00 - 01:58:00]

C++20 standartı, "stateless" (hiçbir şeyi yakalamayan/capture etmeyen) lambdalara yönelik önemli kısıtlamaları kaldırmıştır.

*   **C++20 Öncesi Kısıtlamalar:** C++20'den önce, closure type'ların default constructor'ı ve copy assignment operatörü "delete" edilmişti. Yani bir lambdanın türünden boş bir nesne oluşturamaz veya o türden iki nesneyi birbirine atayamazdınız.
*   **C++20 Serbestliği:** Eğer bir lambda hiçbir şeyi capture etmiyorsa (stateless), artık default construct edilebilir ve atanabilir (assignable). Bu, özellikle STL container'larında (örneğin `std::set` veya `std::map`) karşılaştırma kriteri olarak lambda kullanırken büyük kolaylık sağlar. Artık bu container'lara karşılaştırma nesnesini (comparator) constructor'da göndermek zorunda kalmadan sadece tür bilgisiyle (`decltype`) tanımlama yapabilirsiniz.

```cpp
// C++20 Stateless Lambda
auto cmp = [](int a, int b) { return std::abs(a) < std::abs(b); };

// C++20'de geçerli, C++17'de hata:
std::set<int, decltype(cmp)> my_set; 
```

---

## 7. Master Kod Örneği: Lambda Gücü ve Esnekliği

Aşağıdaki kod, derste işlenen constexpr, trailing return, capture mechanisms ve IIFE konularının tamamını kapsayan bir örnek teşkil eder.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class DataProcessor {
    int factor = 5;
public:
    void process() {
        std::vector<int> nums = {1, 2, 3, 4, 5};

        // 1. IIFE ile karmaşık const ilklendirme
        const size_t threshold = [this]() {
            return (factor > 0) ? 2 : 10;
        }();

        // 2. C++17 [*this] capture ve C++14 Generic Lambda
        // Nesne kopyalanır, 'factor' kopyadan okunur.
        auto multiply = [*this](auto val) mutable -> auto {
            return val * factor; 
        };

        // 3. Lambda ve constexpr (Örtülü)
        auto square = [](int n) { return n * n; };
        constexpr int sq_ten = square(10);

        // Algoritma üzerinde uygulama
        std::for_each(nums.begin(), nums.end(), [&](int& n) {
            n = multiply(n);
            std::cout << n << " ";
        });
    }
};

int main() {
    DataProcessor dp;
    dp.process();
    return 0;
}
```

---

# C++ Programlama Dersi Notları: 39. Ders (Bölüm 2)
**Konu:** Multi-Lambda Idiom, Variadic Templates, STL İteratör Adaptörleri ve Yardımcı Fonksiyonlar
**Zaman Aralığı:** [01:58:00 - 02:42:13]

---
Haklısın, bir anlık "kodlama hatası" ile zaman algım STL iteratörleri gibi bozulmuş. Transkriptin sonuna yaklaştığımızı fark etmeden video süresini aşan yanlış damgalar eklemişim. Hemen gerçek transkript akışına (01:58:00 - 02:42:13 arası) sadık kalarak, o bölümün teknik derinliğini ve doğru zaman damgalarını içeren notları düzeltiyorum.

Hoca bu bölümde aslında **Multi-Lambda**'dan başlayıp, **İteratör Adaptörlerinin iç yapısına** (back_inserter nasıl çalışır?) giriyor ve dersi **İteratör yardımcı fonksiyonlarıyla** bitiriyor.

---

# C++ Programlama Dersi Notları: 39. Ders (Bölüm 2 - Düzeltilmiş)
**Konu:** Multi-Lambda Idiom, İteratör Adaptörlerinin İç Yapısı ve Yardımcı Fonksiyonlar
**Zaman Aralığı:** [01:58:00 - 02:42:13]

---

## 8. Multi-Lambda Idiom ve Variadic Inheritance [01:58:00 - 02:13:00]

Bu bölümde Hoca, C++'ın modern sentaks öğelerini (Variadic Templates, `using` declaration, Pack Expansion) birleştirerek birden fazla lambdayı tek bir yapıda nasıl toplayacağımızı gösteriyor.

*   **Variadic Kalıtım:** `template<typename... Ts> struct Overloader : Ts...` yapısı ile bir sınıfın, kendisine geçilen tüm lambda türlerinden (closure type) aynı anda türetilmesi sağlanır.
*   **İsim Çatışması ve `using` Çözümü:** Her lambdanın kendi `operator()` fonksiyonu vardır. Bunlar farklı sınıflardan (taban sınıflar) geldiği için derleyici hangisini çağıracağını bilemez (ambiguity). `using Ts::operator()...;` ifadesi ile tüm bu fonksiyonlar türemiş sınıfın kapsamına (scope) çekilir ve "Function Overloading" kuralları işletilir.
*   **Kullanım Amacı:** Özellikle `std::variant` gibi türlerde, gelen verinin türüne göre farklı bir lambda çalıştırmak (pattern matching benzeri bir yapı kurmak) için kullanılır.

```cpp
// Hoca'nın adım adım kurduğu o yapı:
template<typename... Ts>
struct MultiLambda : Ts... {
    using Ts::operator()...; // Pack expansion ile tüm operator()'leri yükle
};

// C++17 CTAD sayesinde MultiLambda{[](){}, [](){}} diyebiliyoruz.
```

---

## 9. İteratör Adaptörleri ve `back_inserter`'ın İç Yapısı [02:13:00 - 02:27:00]

Hoca bu bölümde `std::back_inserter` gibi fonksiyonların sadece "sihir" olmadığını, arkasında basit ama dahiyane bir operatör overloading mantığı olduğunu kanıtlıyor.

*   **Atama Operatörünün (`operator=`) Gücü:** `back_insert_iterator` sınıfı aslında bir iteratör değildir; bir iteratör gibi davranan bir nesnedir. Bu sınıfın atama operatörü, kendisine verilen değeri doğrudan bağlı olduğu konteynerin `push_back()` fonksiyonuna gönderir.
*   **Neden `*it++` Çalışır?** `std::copy` gibi algoritmalar `*dest++ = *src++` şeklinde kodlanmıştır. Adaptörün düzgün çalışması için `operator*` ve `operator++` fonksiyonlarının overload edilmesi ama **hiçbir iş yapmadan** nesnenin kendisini döndürmesi gerekir. Hoca bunu "etkisiz eleman kılmak" olarak tanımlıyor.
*   **Fabrika Fonksiyonu:** `std::back_inserter` bir fonksiyon şablonudur ve aslında `back_insert_iterator<Container>` nesnesini bizim yerimize oluşturur (Generic factory function).

```cpp
// Hoca'nın tahtada simüle ettiği iç yapı:
template <typename Container>
class MyBackInsertIterator {
    Container& con; // Konteynere referans tutar
public:
    MyBackInsertIterator(Container& c) : con(c) {}
    
    // Asıl işi yapan yer:
    MyBackInsertIterator& operator=(const typename Container::value_type& val) {
        con.push_back(val); // Atamayı push_back'e çevirdi!
        return *this;
    }
    // Algoritmayı kandıran "boş" operatörler:
    MyBackInsertIterator& operator*() { return *this; }
    MyBackInsertIterator& operator++() { return *this; }
};
```

---

## 10. `std::ostream_iterator` ve Stream Adaptörleri [02:27:00 - 02:37:00]

Yazma algoritmalarının sadece konteynerlere değil, doğrudan çıktı akışlarına (console veya dosya) nasıl yönlendirileceği işleniyor.

*   **Mantık:** `ostream_iterator`, atama operatörü çağrıldığında bu değeri `<<` operatörü ile bir akışa (örneğin `std::cout`) yazar.
*   **Delim (Ayraç) Parametresi:** Constructor'a geçilen ikinci argüman (örneğin `" "`), her öğeden sonra otomatik olarak akışa basılır.
*   **Dosya Çıktısı:** Hoca, `std::ofstream` nesnesini `ostream_iterator`'a bağlayarak `std::copy` ile tek satırda dosyaya veri yazılacağını gösteriyor.

```cpp
// Hoca'nın ostream örneği:
std::vector<std::string> names = {"Edis", "Birhan", "Cezmi"};
std::copy(names.begin(), names.end(), 
          std::ostream_iterator<std::string>(std::cout, "\n")); // Her ismi yeni satıra basar
```

---

## 11. İteratör Yardımcı Fonksiyonları [02:37:00 - 02:42:13]

Dersin son dakikalarında, tüm iteratör türleriyle (List, Vector vb.) çalışabilen jenerik yardımcı fonksiyonlar özetleniyor.

*   **`std::advance(it, n)`:** İteratörü `n` konum değiştirir. Liste (`std::list`) için döngü kurar, Vektör (`std::vector`) için `+=` operatörünü kullanır. Hoca burada "compile-time kod seçimi" (iterator category tags) yapıldığını vurguluyor.
*   **`std::distance(it1, it2)`:** İki iteratör arasındaki farkı bulur. Listelerde elemanları tek tek sayarken, vektörlerde çıkarma işlemi yapar.
*   **`std::next` ve `std::prev`:** `advance`'den farkı, orijinal iteratörü değiştirmeyip, hedef konumu **yeni bir iteratör** olarak döndürmeleridir. Bu fonksiyonların ikinci parametresi default olarak `1`'dir.
*   **`std::iter_swap`:** İki iteratörün işaret ettiği değerleri takas eder.

---

## Master Kod Örneği (Ders Sonu Özeti)

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::list<int> l;

    // 1. back_inserter ile boş listeye kopyalama
    std::copy(v.begin(), v.end(), std::back_inserter(l));

    // 2. ostream_iterator ile ekrana basma
    std::cout << "Liste: ";
    std::copy(l.begin(), l.end(), std::ostream_iterator<int>(std::cout, " "));

    // 3. Yardımcı fonksiyonlar
    auto it = l.begin();
    std::advance(it, 3); // it artık 40'ı gösteriyor
    std::cout << "\n3. Adimdaki eleman: " << *it;

    auto previous = std::prev(it); // it değişmez, previous 30'u gösterir
    std::cout << "\nBir onceki: " << *previous;

    return 0;
}
```

---

