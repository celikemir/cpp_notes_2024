### C++ Ders NotlarÄ±: 45. Ders (4 AralÄ±k 2024)
**EÄŸitmen:** Necati Ergin  
**Konular:** Map C++17 GÃ¼ncellemeleri, Unordered Associative Containers, Hashing MekanizmasÄ±

---

### 1. `std::map` C++17 GÃ¼ncellemeleri: `insert_or_assign` ve `try_emplace` [01:18 - 15:11]

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++17 Ã¶ncesinde `std::map` Ã¼zerinde Ã¶ÄŸe ekleme veya gÃ¼ncelleme iÅŸlemleri (Upsert) iÃ§in `operator[]` veya `insert/emplace` kullanÄ±lÄ±yordu. Ancak bu araÃ§larÄ±n iki temel zayÄ±flÄ±ÄŸÄ± vardÄ±:
1.  **`operator[]` ZayÄ±flÄ±ÄŸÄ±:** DeÄŸer tÃ¼rÃ¼nÃ¼n (mapped_type) *Default Constructible* (varsayÄ±lan yapÄ±landÄ±rÄ±cÄ±ya sahip) olmasÄ±nÄ± zorunlu kÄ±lÄ±yordu. AyrÄ±ca iÅŸlemin bir "ekleme" mi yoksa "gÃ¼ncelleme" mi olduÄŸunu raporlamÄ±yordu.
2.  **`insert/emplace` ZayÄ±flÄ±ÄŸÄ±:** Anahtar zaten map iÃ§inde olsa bile, `emplace` fonksiyonu argÃ¼manlardan bir geÃ§ici nesne/pair oluÅŸturabiliyor; bu da gereksiz kaynak Ã§alÄ±nmasÄ±na (Move semantics) yol aÃ§abiliyordu.

#### ğŸ” Arka Plan (Under the Hood)
*   **`insert_or_assign`:** EÄŸer anahtar varsa sadece atama (assignment) yapar, yoksa ekleme yapar. Geriye `std::pair<iterator, bool>` dÃ¶ndÃ¼rerek iÅŸlemin sonucunu bildirir.
*   **`try_emplace`:** Ã–nce anahtarÄ± kontrol eder. Anahtar varsa hiÃ§bir nesne oluÅŸturmaz, hiÃ§bir `move` iÅŸlemi yapmaz. Sadece anahtar yoksa mÃ¼kemmel gÃ¶nderim (perfect forwarding) ile nesneyi map iÃ§inde yerinde (in-place) oluÅŸturur.

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `const std::map` nesnelerinde neden `operator[]` kullanamayÄ±z?  
**Cevap:** Ã‡Ã¼nkÃ¼ `operator[]`, anahtar map'te yoksa yeni bir Ã¶ÄŸe ekleme (mutation) potansiyeline sahiptir ve bu yÃ¼zden *non-const* bir Ã¼ye fonksiyondur. `const` map nesneleriyle sadece `at()` (exception throw eder) veya `find()` kullanÄ±labilir.

```cpp
std::map<int, std::string> my_map;
auto [iter, inserted] = my_map.insert_or_assign(12, "Mustafa"); // <-- Hoca: C++17 Structured Binding ile kullanÄ±mÄ± Ã§ok pratik.

if (inserted) 
    std::cout << "Yeni Ã¶ÄŸe eklendi\n";
else 
    std::cout << "Var olan Ã¶ÄŸe gÃ¼ncellendi\n";
```

---

### 2. Unordered Associative Containers GiriÅŸ [21:07 - 37:48]

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
`std::set` ve `std::map` gibi konteynerlar arka planda **Balanced Binary Search Tree** (tipik olarak Red-Black Tree) kullanÄ±r ve `O(log n)` karmaÅŸÄ±klÄ±ÄŸÄ±nda Ã§alÄ±ÅŸÄ±r. Verinin sÄ±ralÄ± olmasÄ± gerekmediÄŸi durumlarda, daha hÄ±zlÄ± eriÅŸim (`O(1)` average case) iÃ§in **Hash Table** tabanlÄ± konteynerlara ihtiyaÃ§ duyulmuÅŸtur.

#### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Hash Table YapÄ±sÄ±)
Necati Hoca'nÄ±n anlatÄ±mÄ±yla bellek yapÄ±sÄ±:
```text
[Bucket 0] -> [Node (Key1)] -> [Node (Key2)] (Collision/Chain)
[Bucket 1] -> [Empty]
[Bucket 2] -> [Node (Key3)]
[Bucket 3] -> [Node (Key4)] -> [Node (Key5)]
```

#### ğŸ” Arka Plan (Under the Hood)
Bu konteynerlar Ã¶ÄŸeleri bir "torbaya" (Unordered) atÄ±lmÄ±ÅŸ gibi tutarlar. EriÅŸim ÅŸu adÄ±mlarla gerÃ§ekleÅŸir:
1.  **Hashing:** Anahtar, bir `Hasher` (fonksiyon nesnesi) aracÄ±lÄ±ÄŸÄ±yla `size_t` tÃ¼rÃ¼nde bir tamsayÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.
2.  **Indexing:** Bu sayÄ±, bucket sayÄ±sÄ±na gÃ¶re mod iÅŸlemine tabi tutularak ilgili bucket (kova) indeksi bulunur.
3.  **Collision Handling:** AynÄ± indekse dÃ¼ÅŸen farklÄ± anahtarlar (Collision/Ã‡akÄ±ÅŸma), C++ standartlarÄ±nda tipik olarak **Singly Linked List** (baÄŸlÄ± liste) yapÄ±sÄ± ile "Chaining" (zincirleme) yÃ¶ntemiyle Ã§Ã¶zÃ¼lÃ¼r.

#### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
| Ã–zellik | `std::set/map` (Associative) | `std::unordered_set/map` |
| :--- | :--- | :--- |
| **Veri YapÄ±sÄ±** | Red-Black Tree | Hash Table |
| **KarmaÅŸÄ±klÄ±k** | O(log n) | O(1) Ortalama / O(n) Worst Case |
| **SÄ±ralama** | Strict Weak Ordering | SÄ±rasÄ±z |
| **Gereksinim** | `operator<` (Less) | `std::hash` ve `operator==` (Equal To) |

---

### 3. `std::hash` MekanizmasÄ± ve Custom Types [37:51 - 58:40]

#### ğŸ” Arka Plan (Under the Hood)
Standart kÃ¼tÃ¼phane; tamsayÄ±lar, floating point tÃ¼rleri, `std::string` ve pointer tÃ¼rleri iÃ§in `std::hash` sÄ±nÄ±f ÅŸablonunun *explicit specialization* (aÃ§Ä±k Ã¶zelleÅŸtirme) hallerini sunar. Ancak kendi sÄ±nÄ±flarÄ±mÄ±zÄ± (Ã–rn: `Date`) bu konteynerlarda kullanmak iÃ§in iki ÅŸart vardÄ±r:
1.  Bir **Hasher** saÄŸlamak.
2.  **`operator==`** aÅŸÄ±rÄ± yÃ¼klemesini (overload) saÄŸlamak.

#### ğŸš© Kritik Nokta: Hasher OluÅŸturma YÃ¶ntemleri
Hoca Ã¼Ã§ yÃ¶ntem gÃ¶sterdi:
1.  `std::hash` ÅŸablonunu kendi tÃ¼rÃ¼mÃ¼z iÃ§in Ã¶zelleÅŸtirmek (Specialization).
2.  Kendi Hasher sÄ±nÄ±fÄ±mÄ±zÄ± (Functor) yazÄ±p template argÃ¼manÄ± olarak geÃ§mek.
3.  Lambda ifadesi kullanÄ±p `decltype` ile tÃ¼rÃ¼nÃ¼ belirtmek.

```cpp
// Hasher Specialization Ã¶rneÄŸi:
namespace std {
    template<>
    struct hash<Date> {
        size_t operator()(const Date& d) const noexcept {
            // Hoca: "Muziplik olsun diye toplama yapabiliriz ama gerÃ§ek hayatta daha iyi daÄŸÄ±lÄ±m gerekir."
            return hash<int>{}(d.day()) ^ hash<int>{}(d.month()) ^ hash<int>{}(d.year()); // <-- Kritik: KarÄ±ÅŸtÄ±rma (Mixing)
        }
    };
}
```

---

### 4. Bucket Interface ve Load Factor [01:20:06 - 01:31:30]

#### ğŸ” Arka Plan (Under the Hood)
*   **Bucket Count:** Konteynerdaki toplam kova sayÄ±sÄ±. Genellikle 2'nin kuvvetleri ÅŸeklinde artar.
*   **Load Factor (YÃ¼kleme FaktÃ¶rÃ¼):** `Size / Bucket Count`. Yani bir kovaya ortalama kaÃ§ eleman dÃ¼ÅŸtÃ¼ÄŸÃ¼.
*   **Max Load Factor:** KonteynerÄ±n ne zaman **Rehash** (yeniden hashleme) yapacaÄŸÄ±nÄ± belirleyen eÅŸik deÄŸer. VarsayÄ±lanÄ± `1.0`'dÄ±r.

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** Rehash iÅŸleminin maliyeti nedir?  
**AÃ§Ä±klama:** Bucket sayÄ±sÄ± arttÄ±ÄŸÄ±nda (genellikle 2 katÄ±na Ã§Ä±kar), mevcut tÃ¼m Ã¶ÄŸelerin hash deÄŸerleri yeni bucket sayÄ±sÄ±na gÃ¶re tekrar hesaplanÄ±r ve Ã¶ÄŸeler yeni yerlerine taÅŸÄ±nÄ±r. Bu `O(n)` maliyetli bir iÅŸlemdir. Performans kritikse `reserve()` veya `rehash()` ile baÅŸtan yer ayrÄ±lmalÄ±dÄ±r.

```cpp
std::unordered_set<std::string> my_set;
std::cout << my_set.load_factor(); // Mevcut doluluk oranÄ±
my_set.max_load_factor(0.75f);     // Hoca: "Ä°deal deÄŸer genelde 0.7 ile 0.8 arasÄ±ndadÄ±r."
```

Memnuniyetle devam ediyorum. Necati Hoca'nÄ±n `std::array` Ã¼zerine yaptÄ±ÄŸÄ± o efsanevi vurgularÄ± ve C dizileriyle olan farklarÄ±nÄ± titizlikle notlarÄ±ma ekliyorum.

---

### 5. `std::array`: C Dizilerinin Modern SarmalayÄ±cÄ±sÄ± [01:54:02 - 02:08:00]

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C tarzÄ± diziler (raw arrays), C++'Ä±n nesne yÃ¶nelimli ve jenerik yapÄ±sÄ±na tam uyum saÄŸlamaz. Dizinin isminin bir pointer'a dÃ¶nÃ¼ÅŸmesi (decay), boyut bilgisinin kaybolmasÄ± ve fonksiyonlara kopyalanarak geÃ§ilememesi ciddi tasarÄ±m kusurlarÄ±dÄ±r. `std::array`, C dizilerinin performansÄ±nÄ± korurken, onlara bir "sÄ±nÄ±f arayÃ¼zÃ¼" kazandÄ±rmak iÃ§in gelmiÅŸtir.

#### ğŸ” Arka Plan (Under the Hood)
`std::array` aslÄ±nda bir **Plain Old Data (POD)** ve daha spesifik olarak bir **Aggregate Type**'dÄ±r. Ä°Ã§inde sadece bir C dizisi tutan bir struct ÅŸablonudur.
```cpp
template <typename T, size_t N>
struct array {
    T _elems[N]; // <-- Hoca: "AslÄ±nda arka planda sadece bu var, Ã¼zerine ince bir interface eklenmiÅŸ."
    T& operator[](size_t i) { return _elems[i]; }
    // ... iteratÃ¶rler ve diÄŸer Ã¼ye fonksiyonlar ...
};
```

#### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±: C Dizisi vs. `std::array`
| Ã–zellik | C TarzÄ± Dizi (`int a[5]`) | `std::array<int, 5>` |
| :--- | :--- | :--- |
| **Array Decay** | Pointer'a dÃ¶nÃ¼ÅŸÃ¼r (KaÃ§Ä±nÄ±lmaz) | Nesne kimliÄŸini korur, decay olmaz |
| **Boyut Bilgisi** | Manuel takip gerekir | `size()` ile her zaman eriÅŸilebilir |
| **Atama/Kopyalama** | YasaktÄ±r (`a = b` hata) | MÃ¼mkÃ¼ndÃ¼r (`a = b` tÃ¼m elemanlarÄ± kopyalar) |
| **Parametre GeÃ§iÅŸi** | Pointer olarak geÃ§er (SÄ±ÄŸ kopyalama) | Call-by-value ile tam kopya geÃ§ilebilir |

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::array<int, 10>` ve `std::array<int, 20>` aynÄ± tÃ¼rden midir?  
**Cevap:** HayÄ±r! `N` (boyut) bir **Non-type Template Parameter** olduÄŸu iÃ§in, farklÄ± boyutlar farklÄ± sÄ±nÄ±flar (type) Ã¼retir. Bu yÃ¼zden birbirlerine atanamazlar.

---

### 6. Ä°lklendirme (Initialization) ve Aggregate YapÄ±sÄ± [02:08:00 - 02:16:00]

#### ğŸ” Arka Plan (Under the Hood)
`std::array` bir aggregate type olduÄŸu iÃ§in yapÄ±cÄ± fonksiyonu (constructor) yoktur. Ä°lklendirme doÄŸrudan kÃ¼me parantezleri ile yapÄ±lÄ±r.

#### ğŸš© Kritik UyarÄ±: Ã‡Ã¶p DeÄŸer Riski (Garbage Values)
Necati Hoca buraya Ã§ok sert bir vurgu yaptÄ±:
```cpp
std::array<int, 10> a; // <-- AMAN DÄ°KKAT: Elemanlar sÄ±fÄ±rlanmaz, Ã§Ã¶p deÄŸer (garbage) ile baÅŸlar!
std::array<int, 10> b{}; // <-- DoÄŸru kullanÄ±m: TÃ¼m elemanlar value-initialize (sÄ±fÄ±r) edilir.
```

#### ğŸ“Š C++17 CTAD (Class Template Argument Deduction)
C++17 ile birlikte artÄ±k tÃ¼r ve boyut yazmak zorunda deÄŸiliz; derleyici bunu elemanlardan Ã§Ä±karabilir.
```cpp
std::array x = {1, 2, 3, 4, 5}; // <-- Derleyici: std::array<int, 5> olduÄŸunu anlar (Deduction).
// Ancak tÃ¼rler farklÄ±ysa (Ã¶rn: 1, 2.5) Ã§Ä±karÄ±m hatasÄ± oluÅŸur.
```

---

### 7. GÃ¼venli EriÅŸim: `at()` vs `operator[]` [02:16:00 - 02:26:00]

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C dizilerinde sÄ±nÄ±r kontrolÃ¼ (bounds check) yoktur. YanlÄ±ÅŸ indekse eriÅŸim **Undefined Behavior (UB)** ile sonuÃ§lanÄ±r. `std::array` her iki dÃ¼nyayÄ± da sunar.

#### ğŸ” Arka Plan (Under the Hood)
*   **`operator[]`:** Maksimum hÄ±z iÃ§in sÄ±nÄ±r kontrolÃ¼ yapmaz.
*   **`at()`:** Ä°ndeksi kontrol eder, geÃ§ersizse `std::out_of_range` exception throw eder.

```cpp
std::array<int, 5> my_arr = {1, 2, 3, 4, 5};
try {
    int val = my_arr.at(10); // <-- Hoca: "GÃ¼venlik istiyorsanÄ±z at() kullanÄ±n."
} catch (const std::out_of_range& e) {
    std::cerr << e.what(); 
}
```

---

### 8. `std::array` ve C API Entegrasyonu [02:35:00 - 02:41:50]

#### ğŸ” Arka Plan (Under the Hood)
Hala C kÃ¼tÃ¼phanelerini (Ã¶rn: `printf`, `memcpy`) kullanmak zorunda olduÄŸumuz yerlerde `std::array` nesnesini ham pointer'a dÃ¶nÃ¼ÅŸtÃ¼rmemiz gerekir. Bunun iÃ§in `data()` Ã¼ye fonksiyonu kullanÄ±lÄ±r.

```cpp
void old_c_function(const int* p, size_t size);

std::array<int, 10> my_arr;
old_c_function(my_arr.data(), my_arr.size()); // <-- Kritik: C API'leri ile mÃ¼kemmel uyum.
```

#### ğŸ”— Jenerik YazÄ±m: `operator<<` Overload [02:33:40 - 02:37:00]
Hoca dersin sonunda her boyutta `std::array` nesnesini yazdÄ±rabilen jenerik bir fonksiyon ÅŸablonu yazdÄ±:
```cpp
template <typename T, std::size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<T, N>& arr) {
    if constexpr (N == 0) return os << "[]"; // <-- C++17 Compile-time check.
    
    os << "[";
    for (std::size_t i = 0; i < N - 1; ++i) os << arr[i] << ", ";
    return os << arr.back() << "]";
}
```

#### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Memory Layout)
`std::array` bellek yapÄ±sÄ± ham dizi ile tÄ±patÄ±p aynÄ±dÄ±r; ek bir pointer veya metadata maliyeti yoktur:
```text
Raw Array: [ Int1 ][ Int2 ][ Int3 ]  (Stack Ã¼zerinde ardÄ±ÅŸÄ±k)
std::array: [ Int1 ][ Int2 ][ Int3 ]  (Stack Ã¼zerinde ardÄ±ÅŸÄ±k - SIFIR MALÄ°YET)
```

---

ğŸ“Œ