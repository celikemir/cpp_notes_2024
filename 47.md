Merhaba, Necati Hoca'nÄ±n 47. dersinin ilk bÃ¶lÃ¼mÃ¼nÃ¼ en Ã¶n sÄ±radan aldÄ±ÄŸÄ±m notlarla, teknik derinliÄŸi koruyarak senin iÃ§in hazÄ±rladÄ±m.

---

# C++ Dersi Teknik NotlarÄ±: Lesson 47 (11 AralÄ±k 2024)

## 1. `std::tuple` ArayÃ¼zÃ¼ ve Custom Type Entegrasyonu [00:00 - 05:30]

`std::tuple`, variadic template (deÄŸiÅŸken sayÄ±da ÅŸablon parametresi) kullanan, farklÄ± tÃ¼rlerden deÄŸerleri bir arada tutan bir sÄ±nÄ±f ÅŸablonudur. Dersin baÅŸÄ±nda, bir kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rÃ¼n (Custom Type) nasÄ±l `std::tuple` arayÃ¼zÃ¼ne uyumlu hale getirileceÄŸi ve bu sayede **Structured Binding** (yapÄ±sal baÄŸlama) Ã¶zelliÄŸinden faydalanabileceÄŸi hatÄ±rlatÄ±ldÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++'ta sÄ±nÄ±flarÄ±mÄ±zÄ±/yapÄ±larÄ±mÄ±zÄ± standart kÃ¼tÃ¼phane fonksiyonlarÄ±yla (Ã¶rneÄŸin `std::get`) ve modern dil Ã¶zellikleriyle (Ã¶rneÄŸin Structured Binding) uyumlu hale getirmek iÃ§in bu meta-fonksiyonlarÄ±n Ã¶zelleÅŸtirilmesi (specialization) gerekir.

### ğŸ” Arka Plan (Under the Hood)
Bir tÃ¼rÃ¼n tuple arayÃ¼zÃ¼nÃ¼ desteklemesi iÃ§in ÅŸu Ã¼Ã§ Ã¶ÄŸenin implemente edilmesi zorunludur:
1.  `std::tuple_size`: TÃ¼rÃ¼n kaÃ§ eleman iÃ§erdiÄŸini bildiren meta-function.
2.  `std::tuple_element`: Belirli bir indeksteki elemanÄ±n tÃ¼rÃ¼nÃ¼ hesaplayan meta-function.
3.  `get<I>()`: Belirli bir indeksteki elemana eriÅŸimi saÄŸlayan fonksiyon ÅŸablonu.

```cpp
// <-- Necati Hoca: "Bu yapÄ±larÄ± implemente edersek custom type'Ä±mÄ±z structured binding destekler"
template<>
struct std::tuple_size<MyDate> : std::integral_constant<std::size_t, 3> {}; // <-- ÃœÃ§ elemanlÄ± bir tarih yapÄ±sÄ±

template<std::size_t I>
struct std::tuple_element<I, MyDate> {
    using type = int; // <-- Kritik kural: TÃ¼m elemanlarÄ±n int olduÄŸunu varsaydÄ±k
};

template<std::size_t I>
auto get(const MyDate& d) {
    if constexpr (I == 0) return d.day; // <-- static if (C++17) kullanÄ±mÄ±
    else if constexpr (I == 1) return d.mon;
    else if constexpr (I == 2) return d.year;
}
```

---

## 2. Tuple KarÅŸÄ±laÅŸtÄ±rma Ä°diomu: "Poor Man's Spaceship Operator" [05:30 - 11:00]

C++20 Ã¶ncesinde, birden fazla veri elemanÄ±na sahip sÄ±nÄ±flarda karÅŸÄ±laÅŸtÄ±rma operatÃ¶rlerini (`<`, `>`, `==` vb.) yazmak oldukÃ§a zahmetliydi.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
SÄ±rasÄ±yla gÃ¼n, saat, dakika ve saniyeye gÃ¶re karÅŸÄ±laÅŸtÄ±rma yapmak iÃ§in iÃ§ iÃ§e geÃ§miÅŸ `if` bloklarÄ± veya karmaÅŸÄ±k ternary operatÃ¶rler yazmak yerine, `std::tuple`'Ä±n varsayÄ±lan **Lexicographical Comparison** (sÃ¶zlÃ¼kbilimsel karÅŸÄ±laÅŸtÄ±rma) Ã¶zelliÄŸinden faydalanÄ±lÄ±r.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art)
```text
Tuple KarÅŸÄ±laÅŸtÄ±rma MantÄ±ÄŸÄ±:
(A, B, C) < (D, E, F)
  |  |  |      |  |  |
  |  |  +------>  |  |  (EÅŸitse bir sonrakine bak)
  |  +---------->  |    (EÅŸitse bir sonrakine bak)
  +-------------->      (Ä°lk kÃ¼Ã§Ã¼k olan kazanÄ±r)
```

```cpp
bool operator<(const Duration& lhs, const Duration& rhs) {
    // <-- Necati Hoca: "Fakir adamÄ±n spaceship operatÃ¶rÃ¼"
    return std::tie(lhs.day, lhs.hour, lhs.min, lhs.sec) < 
           std::tie(rhs.day, rhs.hour, rhs.min, rhs.sec);
}
```

---

## 3. std::tie ve Referans SemantiÄŸi [11:00 - 27:00]

`std::tie`, argÃ¼man olarak aldÄ±ÄŸÄ± L-value (sol taraf deÄŸeri) nesnelere referans tutan bir `std::tuple` nesnesi oluÅŸturur.

### ğŸ” Arka Plan (Under the Hood)
`std::pair` veya `std::tuple` varsayÄ±lan olarak elemanlarÄ± kopyalayarak tutar. Ancak ÅŸablon parametresi olarak referans tÃ¼rleri (`T&`) verilirse, nesnelerin kendisini sarmalar.

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::make_tuple` ile `std::tie` arasÄ±ndaki temel fark nedir?
**Cevap:** `std::make_tuple` argÃ¼manlarÄ±n kopyasÄ±nÄ± tutan bir tuple dÃ¶ndÃ¼rÃ¼rken (decay uygulanÄ±r), `std::tie` argÃ¼manlarÄ±n kendisine baÄŸlanan (bind olan) referanslarÄ± tutan bir tuple dÃ¶ndÃ¼rÃ¼r.

```cpp
int x = 10;
std::string name = "Necati";
auto t = std::tie(x, name); // tuple<int&, string&> oluÅŸturur.

std::get<0>(t) = 99; // <-- Kritik kural: x deÄŸiÅŸkeni artÄ±k 99 oldu!
```

---

## 4. Ãœye Fonksiyon ve Veri ElemanÄ± PointerlarÄ± (MFP & DMP) [30:00 - 01:09:00]

Dersin en teknik bÃ¶lÃ¼mlerinden biri, sÄ±nÄ±fÄ±n `static` olmayan (non-static) Ã¼ye fonksiyonlarÄ±nÄ±n ve veri elemanlarÄ±nÄ±n adreslerini tutan pointer mekanizmasÄ±ydÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir Ã¼ye fonksiyonu Ã§aÄŸÄ±rmak iÃ§in gizli `this` pointer'Ä±na (nesne adresine) ihtiyaÃ§ vardÄ±r. Bu yÃ¼zden normal fonksiyon pointer'larÄ± Ã¼ye fonksiyonlarÄ± gÃ¶steremez.

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ± (Syntax)
| Pointer TÃ¼rÃ¼ | TanÄ±mlama (Syntax) | Ã‡aÄŸÄ±rma (Syntax) |
| :--- | :--- | :--- |
| **Free Function Ptr** | `int (*fp)(int)` | `fp(5)` |
| **Member Function Ptr** | `int (Class::*mfp)(int)` | `(obj.*mfp)(5)` veya `(ptr->*mfp)(5)` |
| **Data Member Ptr** | `int Class::*dmp` | `obj.*dmp` |

```cpp
class MyClass {
public:
    int foo(int x) { return x * x; }
};

int main() {
    auto fp = &MyClass::foo; // <-- Necati Hoca: "Adres operatÃ¶rÃ¼ & zorunludur!"
    MyClass m;
    MyClass* p = &m;

    (m.*fp)(10);  // Nesne ile Ã§aÄŸrÄ±
    (p->*fp)(20); // Pointer Ã¼zerinden Ã§aÄŸrÄ± // <-- Kritik kural: Parantez Ã¶nceliÄŸi ÅŸart!
}
```

### ğŸ” Under the Hood: Data Member Pointer
Veri elemanÄ± pointer'larÄ± (`Data Member Pointers`), nesnenin baÅŸlangÄ±cÄ±ndan ilgili elemana kadar olan **offset** (kayÄ±klÄ±k) deÄŸerini tutar. Bu yÃ¼zden bir nesneye baÄŸlanmadan (bind) anlam ifade etmezler.

---

## 5. std::not_fn ve Fonksiyon AdaptÃ¶rlerine GiriÅŸ [01:09:00 - 01:38:00]

`std::not_fn` (C++17), bir Callable (Ã§aÄŸrÄ±labilir varlÄ±k) alÄ±p, onun lojik deÄŸilini (`!`) dÃ¶ndÃ¼ren yeni bir Callable Ã¼reten bir **Function Adapter** (fonksiyon adaptÃ¶rÃ¼dÃ¼r).

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ã–rneÄŸin `is_prime` (asal mÄ±) fonksiyonumuz var ama biz bir algoritmada "asal olmayanlar" Ã¼zerinde iÅŸlem yapmak istiyoruz. Lambda yazmak yerine mevcut fonksiyonu "adapte" ederiz.

```cpp
// <-- Necati Hoca: "is_prime'Ä± asal olmayanlarÄ± saymak iÃ§in adapte ediyoruz"
auto n_non_primes = std::count_if(ivec.begin(), ivec.end(), std::not_fn(is_prime));
```

### ğŸ” Arka Plan (Under the Hood)
`std::not_fn` arka planda bir sÄ±nÄ±f (proxy object) oluÅŸturur. Bu sÄ±nÄ±fÄ±n `operator()` fonksiyonu, sarmaladÄ±ÄŸÄ± fonksiyonu Ã§aÄŸÄ±rÄ±p sonucuna `!` operatÃ¶rÃ¼nÃ¼ uygular.

---

Dersin ikinci yarÄ±sÄ±nda Necati Hoca, C++'Ä±n en kritik yardÄ±mcÄ± sÄ±nÄ±flarÄ±ndan biri olan `std::reference_wrapper` ve fonksiyon programlamanÄ±n temel taÅŸlarÄ±ndan olan `std::bind` mekanizmalarÄ±nÄ± derinlemesine inceledi.

---

## 6. std::reference_wrapper: Yeniden BaÄŸlanabilir Referanslar [01:38:00 - 01:56:00]

`std::reference_wrapper`, bir nesneye referansÄ± bir "nesne" (object) gibi sarmalayan bir sÄ±nÄ±f ÅŸablonudur.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++'ta gerÃ§ek referanslar (`T&`) nesne deÄŸildir; bellekte yer kaplamazlar ve adresleri alÄ±namaz. Bu yÃ¼zden:
1.  Dizilerin elemanÄ± referans olamaz: `int& arr[10];` // <-- Sentaks hatasÄ±!
2.  Konteynerlerin elemanÄ± referans olamaz: `std::vector<int&> v;` // <-- Sentaks hatasÄ±!
3.  Referanslar bir kez baÄŸlandÄ±ÄŸÄ±nda baÅŸka bir nesneyi gÃ¶steremezler (Non-reboundable).

`std::reference_wrapper` bu kÄ±sÄ±tlamalarÄ± aÅŸmak iÃ§in geliÅŸtirilmiÅŸtir.

### ğŸ” Arka Plan (Under the Hood)
Arka planda sadece bir pointer (`T*`) tutar. Ancak `operator T&()` (Conversion Operator) ve `get()` fonksiyonlarÄ± sayesinde kodun geri kalanÄ±na bir referansmÄ±ÅŸ gibi davranÄ±r.

```cpp
#include <functional>

int main() {
    int x = 10, y = 20;
    std::reference_wrapper<int> r = x; // r artÄ±k x'e baÄŸlÄ±

    r.get() = 15; // x artÄ±k 15 // <-- Hoca buraya dikkat Ã§ekti: get() L-value dÃ¶ner.
    
    r = y; // Rebind (Yeniden baÄŸlanma): r artÄ±k y'yi gÃ¶steriyor. 
    // <-- Kritik kural: GerÃ§ek referanslarda bu atama x'in deÄŸerini deÄŸiÅŸtirirdi, burada nesne yer deÄŸiÅŸtirdi.
    
    r.get() = 30; // y artÄ±k 30, x hala 15.
}
```

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ± (CTAD)
*   **C++11/14:** `std::reference_wrapper<int> r(x);` ÅŸeklinde tÃ¼r belirtmek zorunluydu.
*   **C++17:** **CTAD** (Class Template Argument Deduction) sayesinde `std::reference_wrapper r(x);` yazÄ±labilir.
*   **YardÄ±mcÄ± Fonksiyonlar:** `std::ref(x)` (T& dÃ¶ner) ve `std::cref(x)` (const T& dÃ¶ner) fabrikalarÄ± her zaman kullanÄ±labilir.

---

## 7. Konteynerlerde Referans Tutma Ä°diomu [01:43:00 - 01:56:00]

Hoca, bir nesneyi birden fazla konteynerde kopyalamadan ama "nesne gibi" tutmanÄ±n yolunu gÃ¶sterdi.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art)
```text
  [Bellek Adresi 0x100] -> GerÃ§ek Nesne (std::string "Hasan")
           ^                     ^
           |                     |
   [Vector ElemanÄ± 0]    [List ElemanÄ± 0]
   (reference_wrapper)   (reference_wrapper)
```

```cpp
std::list<std::string> names = {"Hasan", "Nur", "Berk"};
// <-- Necati Hoca: "AynÄ± nesneleri kopyalamadan vektÃ¶re de koymak istiyoruz"
std::vector<std::reference_wrapper<std::string>> v(names.begin(), names.end());

for(auto& s : names) s.get() += " Can"; // Listeyi deÄŸiÅŸtirince vektÃ¶r de deÄŸiÅŸmiÅŸ olur!
```

---

## 8. std::bind: Fonksiyon AdaptÃ¶rÃ¼ ve ArgÃ¼man BaÄŸlama [01:56:00 - 02:38:11]

`std::bind`, bir Callable'Ä± alÄ±p parametrelerini Ã¶nceden belirlenmiÅŸ deÄŸerlere veya **Placeholders** (yer tutucular) adÄ± verilen jokerlere baÄŸlayan bir fonksiyondur.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bazen bir algoritma (Ã¶rneÄŸin `std::count_if`) tek parametreli bir fonksiyon beklerken, bizim elimizde iki parametreli bir fonksiyon (`std::less`) olabilir. `std::bind` ile bu iki parametreli fonksiyonu, bir parametresi sabitlenmiÅŸ tek parametreli bir fonksiyona "adapte" ederiz.

### ğŸ” Arka Plan (Under the Hood)
`std::bind` bir **Proxy Object** (vekil nesne) dÃ¶ndÃ¼rÃ¼r. Bu nesne, Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda orijinal fonksiyonu bizim belirttiÄŸimiz argÃ¼man dizilimiyle Ã§aÄŸÄ±rÄ±r.

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::bind` argÃ¼manlarÄ± nasÄ±l tutar?
**Cevap:** `std::bind` argÃ¼manlarÄ±nÄ± **Copy** (kopyalama) semantiÄŸi ile tutar. EÄŸer bir nesnenin kopyalanmasÄ±nÄ± deÄŸil, referans olarak baÄŸlanmasÄ±nÄ± istiyorsanÄ±z `std::ref()` kullanmak zorundasÄ±nÄ±z!

```cpp
#include <functional>
using namespace std;
using namespace std::placeholders; // _1, _2 yer tutucularÄ± iÃ§in

void func(int x, int y, int z) { /*...*/ }

int main() {
    // 1. Parametreyi 10'a sabitle, 2. ve 3. parametreler dÄ±ÅŸarÄ±dan gelsin
    auto f1 = bind(func, 10, _1, _2); 
    f1(20, 30); // Arka planda func(10, 20, 30) Ã§aÄŸrÄ±lÄ±r.

    // Parametrelerin yerini deÄŸiÅŸtir
    auto f2 = bind(func, _2, _1, 100);
    f2(10, 20); // Arka planda func(20, 10, 100) Ã§aÄŸrÄ±lÄ±r. // <-- Hoca buraya dikkat Ã§ekti!
}
```

### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar: std::ref ve std::bind BirlikteliÄŸi
Necati Hoca, `std::bind` kullanÄ±rken `std::ref` kullanÄ±lmazsa oluÅŸacak hatayÄ± `std::cout` Ã¶rneÄŸiyle gÃ¶sterdi:
*   `std::cout` kopyalanamaz (non-copyable).
*   `std::bind(print, std::cout, _1)` // <-- Sentaks hatasÄ±! Bind kopyalamaya Ã§alÄ±ÅŸÄ±r.
*   `std::bind(print, std::ref(std::cout), _1)` // <-- DoÄŸru kullanÄ±m.

---


Ä°ÅŸte transkriptin kalanÄ±ndaki "gÃ¶zden kaÃ§mamasÄ± gereken" o detaylar:

---

## 9. std::apply: Tuple ElemanlarÄ±nÄ± Fonksiyona AÃ§mak [27:00 - 30:00]

Hoca, C++17 ile gelen `std::apply` fonksiyonunun, bir tuple iÃ§indeki deÄŸerleri tek tek Ã§Ã¶zÃ¼p bir fonksiyona argÃ¼man olarak nasÄ±l gÃ¶nderdiÄŸini anlattÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Elimizde `std::tuple<int, double, string>` var ve bir fonksiyon `void func(int, double, string)` bekliyor. Tuple elemanlarÄ±nÄ± tek tek `std::get<0>`, `std::get<1>` yaparak Ã§aÄŸÄ±rmak yerine bu iÅŸlemi otomatize eder.

```cpp
void func(int a, double b, string c) { /*...*/ }
auto myTuple = make_tuple(10, 4.5, "Murat");

// <-- Necati Hoca: "Unpacking (paketi aÃ§ma) iÅŸlemini mÃ¼kemmel yapar"
std::apply(func, myTuple); 
```

---

## 10. std::tie ile DeÄŸer Rotasyonu (Multi-Assignment) [20:20 - 27:00]

`std::tie` sadece karÅŸÄ±laÅŸtÄ±rma iÃ§in deÄŸil, mevcut deÄŸiÅŸkenlere toplu atama yapmak iÃ§in de kullanÄ±lÄ±r.

### ğŸ” Arka Plan (Under the Hood)
Hoca, `x, y, z, t` deÄŸiÅŸkenlerinin deÄŸerlerini birbirine kaydÄ±ran (rotation) verbos (uzun) kod ile `std::tie` arasÄ±ndaki farkÄ± gÃ¶sterdi.

```cpp
// Geleneksel yÃ¶ntem: Temporary (geÃ§ici) deÄŸiÅŸkenler gerekir.
// Modern yÃ¶ntem std::tie:
// <-- Necati Hoca: "AynÄ± anda atama (simultaneous assignment) illÃ¼zyonu yaratÄ±r"
std::tie(x, y, z, t) = std::make_tuple(y, z, t, x); 
```

---

## 11. MFP: Ãœye Fonksiyon Pointer Dizileri ve Callback [46:00 - 56:00]

Hoca, Ã¼ye fonksiyon pointer'larÄ±nÄ±n sadece bir adresi tutmakla kalmayÄ±p, birer **Callback** mekanizmasÄ± olarak nasÄ±l dizilerde saklanabileceÄŸini gÃ¶sterdi.

```cpp
using MFPTR = int (MyClass::*)(int, int); // Type Alias (tÃ¼r eÅŸ ismi)

MFPTR tasks[] = { &MyClass::foo, &MyClass::bar, &MyClass::baz }; 

MyClass m;
for (auto fp : tasks) {
    (m.*fp)(10, 20); // <-- Kritik kural: DÃ¶ngÃ¼ iÃ§inde farklÄ± fonksiyonlar Ã§aÄŸrÄ±lÄ±yor.
}
```

---

## 12. DMP: Finansal Veri (OHLC) Ã–rneÄŸi [56:00 - 01:09:20]

Data Member Pointer'Ä±n (Veri ElemanÄ± PointerÄ±) gerÃ§ek hayattaki karÅŸÄ±lÄ±ÄŸÄ±nÄ± **OHLC (Open-High-Low-Close)** Ã¶rneÄŸiyle somutlaÅŸtÄ±rdÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir algoritma yazÄ±yorsunuz (Ã¶rneÄŸin hareketli ortalama hesaplayan bir indikatÃ¶r). Bu algoritmanÄ±n mum grafiÄŸindeki hangi fiyat tÃ¼rÃ¼ne (AÃ§Ä±lÄ±ÅŸ mÄ±? KapanÄ±ÅŸ mÄ±?) gÃ¶re Ã§alÄ±ÅŸacaÄŸÄ±nÄ± dÄ±ÅŸarÄ±dan parametre olarak geÃ§mek istiyorsunuz.

```cpp
struct Bar { double open, high, low, close; };

// Algoritma, hangi veriyi kullanacaÄŸÄ±nÄ± DMP Ã¼zerinden seÃ§iyor.
double calculate(const Bar& b, double Bar::*pricePtr) {
    return b.*pricePtr * 1.05; // SeÃ§ilen fiyat elemanÄ±na eriÅŸim
}

// KullanÄ±m:
calculate(myBar, &Bar::close); // KapanÄ±ÅŸ fiyatÄ±na gÃ¶re hesapla
calculate(myBar, &Bar::open);  // AÃ§Ä±lÄ±ÅŸ fiyatÄ±na gÃ¶re hesapla
```

---

## 13. AÄŸÄ±r Functor'larÄ±n Maliyeti ve std::ref Ã‡Ã¶zÃ¼mÃ¼ [01:26:00 - 01:38:00]

Hoca, `std::generate` gibi algoritmalarÄ±n, eÄŸer Functor nesnesi Ã§ok bÃ¼yÃ¼kse (Ã¶rneÄŸin iÃ§inde koca bir array tutuyorsa) kopyalama maliyetinin performansÄ± nasÄ±l Ã¶ldÃ¼receÄŸini gÃ¶sterdi.

### ğŸ” Arka Plan (Under the Hood)
`std::generate` ÅŸablonu parametresini **Value** (deÄŸer) olarak alÄ±r.

```cpp
class HeavyGenerator {
    int data[1000]; // 4000 byte!
    int operator()() { return 1; }
};

HeavyGenerator gen;
// <-- Necati Hoca: "Burada 4000 byte her Ã§aÄŸrÄ±da kopyalanÄ±r, petrol boru hattÄ± sÄ±zdÄ±rÄ±yor!"
std::generate(v.begin(), v.end(), gen); 

// Ã‡Ã¶zÃ¼m:
std::generate(v.begin(), v.end(), std::ref(gen)); // <-- Kopyalama yok, referans aktarÄ±mÄ± var.
```

---

ğŸ“Œ **Åimdi transkriptteki tÃ¼m teknik detaylar (00:00 - 02:38:11) eksiksiz ÅŸekilde notlandÄ±rÄ±ldÄ±.** 

