**C++ Dersi Notları - 10. Ders (31 Temmuz 2024)**

**Genel Konu:** Sınıfların Kurucu (Constructor) ve Yıkıcı (Destructor) Fonksiyonları, Özel Üye Fonksiyonlar (Special Member Functions), Çağrılma Mekanizmaları ve İlgili C++ Kavramları.

---

**1. Giriş ve Önceki Dersin Özeti (00:00.000 - 00:34.060)**
*   Dersin 10. günü.
*   Önceki derste sınıfların kurucu (constructor) ve yıkıcı (destructor) fonksiyonlarına giriş yapılmıştı.
*   **Constructor:** Bir sınıf nesnesi hayata geldiğinde, onu hayata getiren, kullanılabilir hale getiren özel bir üye fonksiyondur. Nesneye "Ben olmasam sen bir çöp yığınıydın, seni var eden benim" diyebilir.
*   **Destructor:** Bir sınıf nesnesinin hayatı bittiğinde çağrılan, sonlandırma işlemlerini yapan özel bir üye fonksiyondur.
*   Hayata gelme -> Constructor, hayata veda -> Destructor.

---

**2. Constructor (Kurucu) Fonksiyonların Özellikleri (00:34.840 - 02:42.980)**
*   **İsimlendirme:** Sınıf ismiyle aynı olmak zorundadır. Bu sayede derleyici ve kodu okuyan kişi onun constructor olduğunu anlar.
    *   `class MyClass { public: MyClass(); };`
*   **Geri Dönüş Değeri:** Geri dönüş değeri kavramına sahip değildir. `void` bile değildir.
*   **Parametreler:** Parametre değişken(ler)i alabilir.
*   **Overload Edilebilme:** Aynı isimde (yani sınıf ismiyle) farklı parametre listelerine sahip birden fazla constructor tanımlanabilir (function overloading).
*   **`const` Üye Fonksiyon Olamaz:** Constructor'lar nesneyi oluşturma ve başlatma amacı taşıdığı için `const` olamazlar.
*   **`static` Üye Fonksiyon Olamaz:** Constructor'lar bir nesne oluşturmak için çağrıldığından, nesneye bağlı olmayan `static` üye fonksiyon olamazlar. (Bazı dillerde `static constructor` kavramı olsa da C++'da doğrudan bu şekilde yoktur.)
*   **Erişim Belirleyiciler (`public`, `private`, `protected`):**
    *   Constructor'lar `private` ya da `protected` olabilir. Bu yasak değildir.
    *   Ancak `private` veya `protected` bir constructor'ın client kodlar tarafından doğrudan çağrılması (nesne oluşturma girişimi) bir syntax hatasıdır. Bu durum genellikle Singleton gibi tasarım desenlerinde veya nesne oluşturmanın özel fabrika metodlarıyla kontrol edildiği durumlarda kullanılır.

---

**3. Destructor (Yıkıcı/Sonlandırıcı) Fonksiyonların Özellikleri (03:04.680 - 04:25.800)**
*   **İsimlendirme:** Sınıf ismiyle aynıdır, ancak önünde tilde (~) karakteri bulunur.
    *   `class MyClass { public: ~MyClass(); };`
*   **Parametreler:** Parametre alamaz. Parametresiz olmak zorundadır.
*   **Overload Edilebilme:** Overload edilemez. Bir sınıfın yalnızca bir tane destructor'ı olabilir.
*   **Geri Dönüş Değeri:** Tıpkı constructor gibi, geri dönüş değeri kavramına sahip değildir (`void` bile değil).
*   **Erişim Belirleyiciler:** `private` ya da `protected` olabilir. Ancak, özellikle polimorfik silme durumlarında (base class pointer üzerinden derived class nesnesini silme) base class destructor'ının `public` ve `virtual` olması genellikle önemlidir, aksi takdirde tanımsız davranışlar oluşabilir. Eğer `private` ise, `delete ptr;` gibi bir ifade o kapsamdan erişilemiyorsa syntax hatası verir.

---

**4. Default Constructor (Varsayılan Kurucu İşlev) (04:58.740 - 05:41.180)**
*   **Tanım:** Parametresi olmayan veya tüm parametreleri varsayılan argüman (default argument) almış olan constructor'dır.
*   Bu sayede argüman gönderilmeden çağrılabilir.
*   Örnekler:
    ```cpp
    class MyClass {
    public:
        MyClass(); // Parametresiz default constructor
        // VEYA
        MyClass(int a = 0, double b = 0.0); // Tüm parametreleri varsayılan argümanlı default constructor
    };
    ```
*   Bu, "Special Member Functions" (Özel Üye Fonksiyonlar) kategorisine giren önemli bir constructor türüdür.

---

**5. Special Member Functions (Özel Üye Fonksiyonlar - SMF) (05:41.180 - 15:40.980)**
*   C++ standardı tarafından belirlenmiş, sınıflar için özel davranışlara ve kurallara sahip üye fonksiyonlardır.
*   **Özellikleri:**
    1.  **Derleyici Tarafından Yazılabilme:** Belirli koşullar sağlandığında, bu fonksiyonların kodu programcı tarafından yazılmasa bile derleyici tarafından otomatik olarak yazılabilir (synthesize/generate edilebilir). Bu işleme modern C++'da fonksiyonun derleyici tarafından "default edilmesi" denir.
*   **Modern C++ Öncesi (C++98/03):** 4 tane SMF vardı.
*   **Modern C++ (C++11 ve sonrası):** 6 tane SMF vardır.
*   **6 Adet Special Member Function (Ezberlenecek!):**
    1.  **Default Constructor** (Varsayılan Kurucu İşlev)
    2.  **Destructor** (Sonlandırıcı İşlev)
    3.  **Copy Constructor** (Kopyalayan Kurucu İşlev)
    4.  **Move Constructor** (Taşıyan Kurucu İşlev) - C++11 ile eklendi.
    5.  **Copy Assignment Operator** (Kopyalayan Atama Operatörü)
    6.  **Move Assignment Operator** (Taşıyan Atama Operatörü) - C++11 ile eklendi.
*   **Önemli Not:** Her constructor bir SMF değildir. Sadece "Default Constructor" SMF kategorisindedir. Örneğin, `MyClass(int x);` bir SMF değildir.
*   **Karmaşıklık:** SMF'lerle ilgili kurallar oldukça detaylı ve bazen karmaşık olabilir.
*   **"Default Etmek" (To default a function):** Derleyicinin bir SMF'nin kodunu yazması anlamına gelir. Bu, programcının `MyClass() = default;` şeklinde açıkça istemesiyle (explicitly defaulted function) veya programcının hiçbir şey yazmaması durumunda derleyicinin belirli kurallara göre örtük olarak (implicitly declared and defined) yapmasıyla olabilir.

---

**6. Constructor ve Destructor'ların Çağrılma Zamanları ve Mekanizmaları (15:42.320 - 42:52.280)**
*   **Genel İlke:**
    *   Constructor: Nesne hayata gelirken onu kullanılabilir hale getirmek için çağrılır. Veri üyelerini başlatır, kaynakları (resources) ele geçirir (acquire).
    *   Destructor: Nesnenin ömrü biterken çağrılır. Kaynakları geri verir (release), temizlik yapar.
*   **Fonksiyon Tanımlama Yeri:**
    *   SMF'ler ve diğer üye fonksiyonlar `.cpp` dosyasında tanımlanabilir.
    *   Veya `inline` olarak başlık (`.h`) dosyasında, sınıf tanımı içinde tanımlanabilirler. Hoca, örneklerde zaman kazanmak için inline tanım kullanacağını belirtti.
*   **`this` Pointer'ı:** Constructor ve destructor'lar (non-static oldukları için) `this` pointer'ına sahiptirler. `this`, o an işlem gören nesnenin adresini tutar. Örneklerde `this` pointer'ının değeri yazdırılarak hangi nesne için çağrıldıkları takip edildi.
    ```cpp
    // MyClass.h
    #include <iostream>
    class MyClass {
    public:
        MyClass() {
            std::cout << "MyClass Default Constructor. this = " << this << std::endl;
        }
        ~MyClass() {
            std::cout << "MyClass Destructor. this = " << this << std::endl;
        }
        // ... diğer üyeler
    };
    ```

*   **Statik Ömürlü Nesneler:**
    *   **Global Nesneler:**
        *   Constructor: `main` fonksiyonu çalışmaya başlamadan önce çağrılır.
        *   Destructor: `main` fonksiyonu bittikten sonra çağrılır.
        *   **Aynı Kaynak Dosyasındaki Global Nesnelerin Sırası:** Tanımlanma sıralarıyla constructor'ları çağrılır. Destructor'ları ise ters sırada çağrılır (son giren ilk çıkar - LIFO).
            ```cpp
            // Global_A_B_C.cpp
            MyClass g1; // g1.ctor()
            MyClass g2; // g2.ctor()
            MyClass g3; // g3.ctor()
            // main() ...
            // g3.dtor(), g2.dtor(), g1.dtor()
            ```
        *   **Farklı Kaynak Dosyalarındaki Global Nesnelerin Sırası:** Tanımlanma sırası **belirli değildir (unspecified)**. Bu durum "Static Initialization Order Fiasco" olarak bilinen probleme yol açabilir.
            *   *Problem*: Bir global nesnenin constructor'ı, henüz hayata gelmemiş başka bir kaynak dosyasındaki global bir nesneyi kullanmaya çalışırsa tanımsız davranış oluşur.
    *   **Statik Yerel Nesneler (Fonksiyon İçinde `static` ile Tanımlananlar):**
        *   Constructor: Fonksiyon ilk kez çağrıldığında ve programın akışı o nesnenin tanımına ilk kez geldiğinde çağrılır. Fonksiyonun sonraki çağrılarında constructor tekrar çağrılmaz.
        *   Destructor: `main` fonksiyonu bittikten sonra (program sonlanırken) çağrılır.
        *   **Thread Safety (C++11 ve sonrası):** Statik yerel değişkenlerin başlatılması (initialization) thread-safe'dir. Yani birden fazla thread aynı anda bu fonksiyonu çağırsa bile constructor yalnızca bir kez çalışır.
            ```cpp
            // StaticLocal.cpp
            void foo() {
                static MyClass s_local; // ctor sadece foo ilk çağrıldığında ve bu satıra gelindiğinde çalışır
                std::cout << "foo() called." << std::endl;
            }
            // main() içinde foo() birkaç kez çağrılsa da s_local.ctor() bir kez, s_local.dtor() main bitince çağrılır.
            ```

*   **Otomatik Ömürlü Nesneler (Stack'te yaşayan, non-static yerel nesneler):**
    *   Constructor: Programın akışı nesnenin tanımına her geldiğinde çağrılır.
    *   Destructor: Nesnenin tanımlandığı skop (scope, `{}`) bittiğinde çağrılır.
    *   **Sıra:** Aynı blok içindeki otomatik nesneler için constructor'lar tanımlanma sırasıyla, destructor'lar ise ters sırada çağrılır.
        ```cpp
        // AutomaticLocal.cpp
        void bar() {
            std::cout << "bar() starts." << std::endl;
            MyClass a1; // a1.ctor()
            MyClass a2; // a2.ctor()
            // ...
            std::cout << "bar() ends." << std::endl;
            // a2.dtor(), a1.dtor()
        }
        // bar() her çağrıldığında a1 ve a2 için bu sıra tekrarlanır.
        ```
    *   Döngü içinde tanımlanan otomatik nesneler, döngünün her iterasyonunda yeniden oluşturulur ve yok edilir.

---

**7. Constructor Çağrılmasıyla İlgili Özel Durumlar ve Hatalar (43:24.360 - 57:52.340)**
*   **Referanslar:** Bir referans tanımlamak (L-value veya R-value referans) yeni bir nesne oluşturmaz ve dolayısıyla bir constructor çağırmaz. Referans, var olan bir nesneye bağlanır.
    ```cpp
    MyClass obj;       // obj.ctor() çağrılır.
    MyClass& ref = obj; // Constructor çağrılmaz.
    ```
*   **Nesne Dizileri (Arrays of Objects):**
    *   `MyClass arr[N];` ifadesi, `N` adet `MyClass` nesnesi oluşturur.
    *   Her bir dizi elemanı için (indeks sırasıyla `arr[0]`, `arr[1]`, ..., `arr[N-1]`) **default constructor** çağrılır.
    *   Bu nedenle, bu şekilde bir dizi tanımlamak için `MyClass`'ın erişilebilir bir default constructor'ı olmalıdır. Yoksa syntax hatası oluşur.
    *   Destructor'lar ters sırada (`arr[N-1]` için önce, sonra `arr[N-2]`, ...) çağrılır.
    *   *Örnek Mülakat Sorusu:* Bir döngü kullanmadan 0'dan 99'a kadar sayıları ekrana yazdırma. Çözüm: 100 elemanlı bir sınıf dizisi oluşturulur, sınıfın constructor'ı içinde static bir sayaç artırılıp yazdırılır.
*   **Default Constructor'ın Çağrıldığı Durumlar:**
    1.  **Default Initialization:** `MyClass m;`
    2.  **Value Initialization:** `MyClass m{};` (veya `MyClass m = {};`)
*   **Most Vexing Parse (En Can Sıkıcı Çözümleme):**
    *   `MyClass m();` // BU BİR NESNE TANIMI DEĞİLDİR!
    *   Bu ifade, `m` adında, parametre almayan ve `MyClass` türünden bir değer döndüren bir fonksiyonun bildirimidir (function declaration).
    *   Bu durumda `m` için bir constructor çağrılmaz, çünkü `m` bir nesne değildir.
*   **Default Constructor Olmadığında Ne Olur?**
    *   Eğer bir sınıf için programcı herhangi bir constructor (örneğin `MyClass(int);`) tanımlamışsa, derleyici o sınıf için otomatik olarak bir default constructor **oluşturmaz**.
    *   Bu durumda `MyClass m;` veya `MyClass m{};` gibi default constructor gerektiren bir nesne oluşturma girişimi syntax hatası verir: "no appropriate default constructor available".

---

**8. `= delete` ve `= default` ile Fonksiyonların Kontrolü (Modern C++) (57:56.380 - 01:18:12.780)**

*   **`= delete` (Fonksiyonu Silme/Yasarlama):**
    *   **Syntax:** `DonusTipi FonksiyonAdi(Parametreler) = delete;`
    *   **Anlamı:** Bu fonksiyonun var olduğunu (bildirildiğini, overload resolution'a katıldığını) ancak çağrılmasının yasak olduğunu belirtir. Çağrılmaya çalışılırsa syntax hatası ("attempting to reference a deleted function") alınır.
    *   **Kullanım Alanları:**
        *   Belirli overload'ları engellemek.
        *   Bir sınıfın kopyalanamaz (copy constructor ve copy assignment `= delete` edilerek) veya taşınamaz yapılmasını sağlamak.
        *   Herhangi bir fonksiyon (global, üye, constructor, destructor) için kullanılabilir.
    *   **Farkı:** Fonksiyonun hiç deklare edilmemesinden farklıdır. Deklare edilmemişse overload resolution'a katılmaz. `= delete` edilmişse katılır, seçilirse hata verir.
        ```cpp
        class NoCopy {
        public:
            NoCopy() = default;
            NoCopy(const NoCopy&) = delete; // Kopyalayan kurucu yasak
            NoCopy& operator=(const NoCopy&) = delete; // Kopyalayan atama yasak
        };
        // NoCopy nc1;
        // NoCopy nc2 = nc1; // HATA: deleted function
        ```

*   **`= default` (Fonksiyonu Varsayılan Olarak Tanımlama):**
    *   **Syntax:** `OzelUyeFonksiyon() = default;`
    *   **Anlamı:** Derleyiciye, bu özel üye fonksiyon için varsayılan (standart) implementasyonu oluşturmasını açıkça söyler.
    *   **Kullanım Alanları:**
        *   Yalnızca **6 Özel Üye Fonksiyon** (ve C++20 ile gelen spaceship operator `operator<=>`) için geçerlidir. Normal üye fonksiyonlar veya global fonksiyonlar için kullanılamaz.
        *   Derleyicinin örtük olarak (implicitly) üreteceği davranışı geri getirmek için (örneğin, bir constructor tanımladıktan sonra default constructor'ın da derleyici tarafından üretilmesini istiyorsak).
        ```cpp
        class MyData {
            int x;
        public:
            MyData(int val) : x(val) {} // Kullanıcı tanımlı ctor
            MyData() = default; // Derleyiciye default ctor üretmesini söyle
        };
        ```

*   **Özel Üye Fonksiyonların Durumları (Declaration Status):**
    Bir SMF şu durumlardan birinde olabilir:
    1.  **User-declared (Kullanıcı Tarafından Bildirilmiş):**
        *   Programcı açıkça bildirmiş: `MyClass();` (tanımı başka yerde olabilir)
        *   Programcı inline tanımlamış: `MyClass() { /* gövde */ }`
        *   Programcı `= default` ile bildirmiş: `MyClass() = default;`
        *   Programcı `= delete` ile bildirmiş: `MyClass() = delete;`
        Bu dört durum da "user-declared" sayılır.
    2.  **Implicitly-declared (Örtük Olarak Bildirilmiş):**
        *   Programcı hiçbir bildirim yapmamış, ancak dil kuralları gereği derleyici bu SMF'yi kendisi bildirir.
        *   Derleyici bu örtük bildirimi yaptıktan sonra iki şey olabilir:
            *   **Implicitly-defined (and defaulted):** Derleyici fonksiyonu bildirir ve varsayılan gövdesini de oluşturur. (Örn: Boş bir sınıf için default constructor).
            *   **Implicitly-declared as deleted:** Derleyici fonksiyonu bildirir ama `= delete` edilmiş olarak bildirir. Bu durum, varsayılan implementasyonun oluşturulması bir kural ihlaline (örn: const üyenin başlatılmaması) yol açacaksa gerçekleşir.
    3.  **Not declared (Bildirilmemiş):**
        *   Ne kullanıcı ne de derleyici tarafından bildirilmemiştir. Fonksiyon o sınıf için mevcut değildir.

*   **Örtük Olarak Silinme Kuralı (Implicitly-deleted SMF):**
    *   Eğer derleyici, örtük olarak bildirmesi gereken bir SMF'yi (örneğin default constructor) tanımlamaya çalıştığında, bu tanım dilin bir kuralını ihlal edecekse (örn: bir `const` üye veri elemanının başlatılamaması, bir referans üyenin bağlanamaması, bir üye sınıfın erişilemeyen/silinmiş bir constructor'ının çağrılması gerekmesi), derleyici o SMF'yi hata vermek yerine **`= delete` edilmiş olarak bildirir.**
    *   Bu durumda, o SMF'yi kullanmaya çalışan kod "attempting to reference a deleted function" hatası alır.
    *   **Örnek:**
        ```cpp
        class Member {
        public:
            Member(int) {} // Default constructor yok
        };
        class Owner {
            Member m; // m'nin default initialize edilmesi gerekir, ama Member::Member() yok.
        public:
            // Owner() {} // Eğer bunu yazsaydık, m initialize edilemediği için hata alırdık.
                        // Yazmadığımız için derleyici Owner::Owner()'ı implicit-declared as deleted yapar.
        };
        // Owner o; // HATA: Owner::Owner() deleted.
        ```
    *   **Derleyicinin Örtük Olarak Bildirdiği SMF'lerin Erişimi:** Her zaman `public` ve `inline` olur.

---
Cevap verme sınırına yaklaşıyorum. Buradan sonraki konular şunlar olacak:
*   **Constructor Initializer List (Member Initializer List - MIL)**
*   **Default Member Initializer (In-Class Initializer)**
*   **Explicit Constructor/Destructor Calls**
*   **Complete vs. Incomplete Types**


Harika! "Constructor Initializer List (Member Initializer List - MIL) (01:23:03.240 - 01:56:02.240) konusundan devam et."

---

**9. Constructor Initializer List (Member Initializer List - MIL) (01:23:03.240 - 01:56:02.240)**

*   **Tanım ve Amaç:**
    *   Constructor'ın, sınıfın **non-static veri üyelerini** ve **base class alt nesnelerini** (kalıtım durumunda) **initialize etmesini** (ilk değer atamasını) sağlayan özel bir C++ sentaksıdır.
    *   Bu işlem, constructor gövdesine girilmeden *önce* gerçekleşir. Dolayısıyla bu, bir "atama (assignment)" değil, bir "başlatma (initialization)" işlemidir.
*   **Sentaks:**
    *   Constructor'ın parametre listesinden sonra, gövdesinden (`{}`) önce iki nokta üst üste (`:`) ile başlar.
    *   Her bir üye, `uyeAdi(ilk_deger)` veya modern C++ ile `uyeAdi{ilk_deger}` şeklinde listelenir. Birden fazla üye virgülle ayrılır.
    ```cpp
    // MyClass.h
    class MyClass {
        int mx;
        double my;
        std::string m_name;
    public:
        MyClass(); // CPP'de tanımlanacak
        MyClass(int x_val, double y_val, const std::string& name_val); // CPP'de tanımlanacak
    };

    // MyClass.cpp
    #include "MyClass.h" // ve <string>

    MyClass::MyClass()
    : mx(0),       // mx'i 0 ile initialize et
      my(0.0),     // my'yi 0.0 ile initialize et
      m_name("Default") // m_name'i "Default" ile initialize et
    {
        // Constructor gövdesi, tüm üyeler initialize edildikten sonra çalışır.
        // Burada üyeler zaten hayatta ve ilk değerlerini almış durumdalar.
    }

    MyClass::MyClass(int x_val, double y_val, const std::string& name_val)
    : mx(x_val),   // mx'i constructor parametresi x_val ile initialize et
      my(y_val),   // my'yi constructor parametresi y_val ile initialize et
      m_name(name_val) // m_name'i constructor parametresi name_val ile initialize et
    {
        // Gövde
    }
    ```
*   **Neden Kullanılmalı?**
    1.  **Zorunluluk Durumları:**
        *   **`const` Üyeler:** `const` veri üyeleri tanımlandıklarında initialize edilmek zorundadır. Constructor gövdesinde atama yapılamaz, çünkü `const` oldukları için değerleri değiştirilemez. MIL ile initialize edilmelidirler.
        *   **Referans Üyeler:** Referanslar da tanımlandıklarında bir nesneye bağlanmak zorundadır. MIL ile initialize edilmelidirler.
        *   **Default Constructor'ı Olmayan Üye Sınıflar:** Eğer bir üye nesnenin sınıfının (örneğin `Member m;` `Member` sınıfının) erişilebilir bir default constructor'ı yoksa ve programcı MIL'de bu üyeyi açıkça initialize etmezse, derleyici `m`'yi default initialize etmeye çalışır ve hata alır. Bu durumda `m`'nin uygun bir constructor'ı MIL'de çağrılmalıdır.
        *   **Base Class Alt Nesnelerinin Başlatılması (Kalıtım):** Türemiş sınıfın constructor'ı, base class'ın belirli bir constructor'ını çağırmak için MIL kullanmak zorundadır (base class'ın default constructor'ı yoksa veya farklı bir constructor çağrılmak isteniyorsa).
    2.  **Verimlilik:**
        *   Özellikle sınıf türünden üyeler için, constructor gövdesinde atama yapmak yerine MIL'de initialize etmek genellikle daha verimlidir.
        *   **Atama Yolu:** Önce üyenin default constructor'ı (veya MIL'de belirtilmeyen bir constructor) çağrılır, sonra gövdede atama operatörü (`operator=`) çağrılır. Bu iki ayrı işlemdir.
        *   **MIL Yolu:** Doğrudan istenen constructor (genellikle copy veya move constructor ya da uygun parametreli bir constructor) bir kez çağrılır.
            ```cpp
            // Verimsiz Örnek (String için)
            class BadExample {
                std::string _text;
            public:
                BadExample(const char* s) { // _text ÖNCE default initialize edilir (boş string)
                    _text = s;              // SONRA atama operatörü çağrılır
                }
            };

            // Verimli Örnek (String için)
            class GoodExample {
                std::string _text;
            public:
                GoodExample(const char* s) : _text(s) { // _text DOĞRUDAN s ile initialize edilir (uygun ctor çağrılır)
                }
            };
            ```
    3.  **İyi Pratik ve Okunabilirlik:** Sınıf üyelerinin nasıl başlatıldığını constructor tanımının başında net bir şekilde gösterir. Genellikle tercih edilen yöntemdir.
*   **MIL'de Olmayan Üyeler:**
    *   Eğer bir non-static veri üyesi MIL'de listelenmemişse, derleyici onu **default initialize etmeye** çalışır.
    *   Temel türler (int, double vs.) için default initialization, değerlerinin tanımsız (garbage value) kalması anlamına gelir (static ömürlü değillerse).
    *   Sınıf türleri için default initialization, o sınıfın default constructor'ının çağrılması anlamına gelir. Eğer default constructor yoksa veya erişilemiyorsa, syntax hatası oluşur.
*   **Initialize Edilme Sırası:**
    *   **ÇOK ÖNEMLİ:** Üyeler, MIL'de yazıldıkları sırayla **DEĞİL**, sınıf tanımı içinde **deklare edildikleri sırayla** initialize edilirler.
    *   Bu durum, bir üyenin başlatılmasının başka bir üyeye bağlı olduğu durumlarda ciddi hatalara ve tanımsız davranışlara yol açabilir.
        ```cpp
        class OrderMatters {
            int mx; // Önce mx declare edildi
            int my; // Sonra my declare edildi
        public:
            OrderMatters(int val)
            : my(val),      // my, val ile initialize edilecek GİBİ GÖRÜNÜR
              mx(my + 10)   // mx, my+10 ile initialize edilecek GİBİ GÖRÜNÜR.
                            // ASLINDA:
                            // 1. mx initialize edilirken my henüz initialize OLMAMIŞTIR (garbage değer).
                            //    mx = (garbage_my_değeri) + 10; -> Tanımsız davranış!
                            // 2. Sonra my, val ile initialize edilir.
            { }
        };
        // DOĞRU YAKLAŞIM: MIL'deki sırayı daima class declaration sırasıyla aynı tutmak.
        // VEYA birbirine bağımlı initializasyonlardan kaçınmak / dikkatli olmak.
        ```
    *   **Tavsiye:** Kodu okuyanlar için kafa karışıklığını önlemek ve hataları engellemek adına, MIL'deki üyelerin sırası her zaman sınıf tanımındaki bildirim sırasıyla aynı olmalıdır.
*   **Modern C++ (`{}` Kullanımı):**
    *   C++11 ile birlikte MIL'de üyeleri initialize ederken parantez `()` yerine küme parantezi `{}` (uniform initialization / brace initialization) kullanılabilir: `uyeAdi{ilk_deger}`.
    *   **Faydası:** `narrowing conversion` (daraltıcı dönüşüm, örn: `double`'dan `int`'e veri kaybıyla) durumunda syntax hatası verir, bu da potansiyel hataları erken yakalamayı sağlar. Parantezli sürümde bu dönüşümler (eğer mümkünse) sessizce yapılabilir.
    *   Çoğu durumda anlamsal olarak `()` ile `{}` aynıdır. Ancak `std::initializer_list` alan constructor'lar söz konusu olduğunda `{}` farklı davranabilir (bu ileri bir konu).

---

**10. Default Member Initializer (In-Class Initializer) (Modern C++) (01:51:09.000 - 02:07:45.600)**

*   **Tanım ve Amaç:**
    *   C++11 ile gelen bir özelliktir. Sınıf tanımı içinde, non-static veri üyelerine doğrudan bir başlangıç değeri atanmasını sağlar.
    *   Bu, üyenin **varsayılan başlangıç değerini** belirtir.
*   **Sentaks:**
    ```cpp
    class Point {
        int x = 0;  // x için default member initializer (0)
        int y = 0;  // y için default member initializer (0)
    public:
        Point() {} // Default ctor - x ve y, 0 ile initialize edilir.
        Point(int x_val, int y_val) : x(x_val), y(y_val) {} // MIL önceliklidir.
    };
    ```
    *   Ayrıca küme parantezi de kullanılabilir: `int x{0};`
    *   **Dikkat:** Parantezli doğrudan başlatma `int x(0);` sınıf tanımı içinde bu şekilde **geçerli değildir**. Ya `=` ya da `{}` kullanılmalıdır.
*   **Nasıl Çalışır?**
    *   Bu bir "initialization" değil, constructor'a "eğer bu üyeyi MIL'de sen başlatmazsan, ben onu bu değerle başlatacağım" demektir.
    *   Eğer bir constructor, **Constructor Initializer List (MIL)** kullanarak bir üyeyi açıkça initialize ederse, o üye için belirtilen default member initializer **dikkate alınmaz**, MIL'deki değer kullanılır.
    *   Eğer bir constructor MIL'de bir üyeyi initialize etmezse, o zaman o üye için sınıf tanımında belirtilmiş olan default member initializer kullanılır.
    *   Eğer hem MIL'de hem de default member initializer'da bir üye için başlatma yoksa, o üye default initialize edilir (temel türler için garbage, sınıf türleri için default ctor).
*   **Örnek Senaryo:**
    ```cpp
    class Config {
        std::string m_path = "/default/path"; // Varsayılan yol
        int m_timeout = 1000;                 // Varsayılan zaman aşımı
    public:
        Config() {
            // m_path, "/default/path" ile; m_timeout, 1000 ile initialize edilir.
        }

        Config(const std::string& custom_path) : m_path(custom_path) {
            // m_path, custom_path ile initialize edilir (MIL öncelikli).
            // m_timeout MIL'de yok, bu yüzden default member initializer (1000) kullanılır.
        }
    };
    ```
*   **Derleyicinin Yazdığı Default Constructor ve Default Member Initializer:**
    *   Eğer programcı hiçbir constructor yazmazsa, derleyici bir default constructor üretir (eğer üretebiliyorsa).
    *   Derleyicinin ürettiği bu default constructor, default member initializer'ları olan üyeleri bu değerlerle, olmayanları ise normal default initialization kurallarına göre initialize eder.
    *   **Kritik Kuralın Tekrarı:** Eğer derleyicinin bir SMF'yi (örneğin default constructor) oluşturma süreci (üyeleri default member initializer'larla veya default-initialization ile başlatırken) bir kural ihlaline yol açarsa (örn: const üyenin başlatılamaması), derleyici o SMF'yi **`= delete` edilmiş olarak** bildirir.

---

**11. Constructor ve Destructor'ların Açık (Explicit) Çağrılması (02:11:20.820 - 02:15:05.500)**

*   **Constructor'ların Açık Çağrılması:**
    *   Normal üye fonksiyonlar gibi, bir nesne üzerinden `obj.MyConstructor()` veya `ptr->MyConstructor()` şeklinde **doğrudan çağrılamazlar.** Bu bir syntax hatasıdır.
    *   Constructor'lar nesne oluşturma ifadeleriyle ( `MyClass obj;`, `new MyClass();` vb.) dolaylı olarak çağrılırlar.
*   **Destructor'ların Açık Çağrılması:**
    *   Bir nesne üzerinden `obj.~MyClass()` veya `ptr->~MyClass()` şeklinde **doğrudan çağrılabilirler.** Bu sentaktik olarak geçerlidir.
    *   **ANCAK, bu genellikle KÖTÜ BİR FİKİRDİR ve ÇOK TEHLİKELİDİR!**
        *   Eğer otomatik (stack) veya statik ömürlü bir nesnenin destructor'ını açıkça çağırırsanız, nesnenin skopu bittiğinde destructor bir kez daha (otomatik olarak) çağrılacaktır. Aynı nesne için destructor'ın birden fazla kez çağrılması genellikle tanımsız davranışa (undefined behavior) yol açar (örn: aynı belleği iki kez free etmeye çalışmak).
    *   **Ne Zaman Gerekli Olabilir?**
        *   **Placement New:** Bu, çok özel bir `new` operatörü kullanımıdır. Önceden ayrılmış bir bellek alanına bir nesne "yerleştirir". Placement new ile oluşturulan nesnelerin ömrü bittiğinde, destructor'ları **açıkça çağrılmalıdır**, çünkü `delete` operatörü bu durumda kullanılmaz (belleği serbest bırakmamalıdır, çünkü bellek `new` ile alınmamıştır). Bu, dersin çok ilerleyen konularından biridir.
        *   Bu özel durum dışında, destructor'ları açıkça çağırmaktan kesinlikle kaçınılmalıdır.

---
Cevap sınırına tekrar yaklaşıyorum. Sonraki bölüm "Complete vs. Incomplete Types" olacak.


Tamamdır, "Complete vs. Incomplete Types (02:15:05.580 - 02:42:17.140) konusundan devam et."

---

**12. Complete vs. Incomplete Types (Tamamlanmış ve Tamamlanmamış Türler) (02:15:05.580 - 02:42:17.140)**

*   **Temel Kavram:**
    *   Derleyicinin bir kod noktasında bir veri türüne (data type) bakış açısıyla ilgilidir. Bir tür, o an ya "complete" (tamamlanmış) ya da "incomplete" (tamamlanmamış/eksik) olabilir.
*   **Sınıflar İçin Anlamı:**
    *   **Incomplete Type (Tamamlanmamış Tür):** Derleyici bir sınıf isminin varlığından haberdardır (örneğin bir **forward declaration** ile), ancak sınıfın tanımını (yani üyelerini, boyutunu vb.) henüz görmemiştir.
        *   **Forward Declaration:** `class MyClass;` veya `struct MyStruct;`
        *   Bu bildirim derleyiciye "MyClass bir sınıf adıdır" der, ama içeriği hakkında bilgi vermez.
    *   **Complete Type (Tamamlanmış Tür):** Derleyici sınıfın tam tanımını (`class MyClass { /* üyeler... */ };`) görmüştür. Artık sınıfın boyutunu, üyelerini ve nasıl oluşturulacağını bilir.
*   **Incomplete Type Oluşturma Yolları (Sınıflar için):**
    1.  Açık Forward Declaration: `class MyClass;`
    2.  `class` (veya `struct`) anahtar sözcüğü ile birlikte kullanım: Bazı bağlamlarda, `class MyClass* ptr;` gibi bir ifade, `MyClass`'ın daha önce forward declare edilmemiş olsa bile, o an için incomplete bir tür olarak ele alınmasını sağlayabilir (özellikle pointer veya referans bildirimlerinde). Ancak genellikle explicit forward declaration tercih edilir.
*   **Neden Önemli?**
    *   Dilin sentaks kuralları, bir türün incomplete olduğu durumlarda yapılabilecek işlemleri kısıtlar. Bazı işlemler için türün complete olması zorunludur.
*   **Incomplete Type ile Neler Yapılabilir? (Syntax Hatası Olmayan Durumlar)**
    1.  **Fonksiyon Bildirimlerinde (Prototiplerde):**
        *   Fonksiyonların geri dönüş değeri türü olarak: `MyClass foo();`
        *   Fonksiyonların parametre türü olarak: `void bar(MyClass x);`
        *   Fonksiyonların pointer veya referans parametre/dönüş türü olarak: `MyClass* create();`, `void process(MyClass& ref);`
            ```cpp
            class MyClass; // Forward declaration (MyClass is incomplete here)

            MyClass func1();
            void func2(MyClass param);
            MyClass* func3();
            void func4(MyClass& param_ref);
            // MyClass obj; // HATA: Cannot define an object of incomplete type
            ```
    2.  **Tür Eş İsimleri (Type Aliases):**
        *   `typedef MyClass* MyClassPtr;` (C-stili)
        *   `using MyClassPtr = MyClass*;` (Modern C++)
        *   `using MyClassRef = MyClass&;`
        *   `using AnotherNameForMyClass = MyClass;`
    3.  **Pointer Değişken Tanımlama:**
        *   `MyClass* ptr;` // Geçerli. Derleyici bir pointer'ın boyutunu bilir (hedef türün boyutundan bağımsız olarak).
        *   `MyClass* ptr = nullptr;` // Geçerli.
        *   Pointer'ları fonksiyonlara argüman olarak geçmek veya fonksiyonlardan döndürmek.
            ```cpp
            class Node; // Forward declaration
            Node* head = nullptr; // OK
            Node* createNode();   // OK
            void deleteNode(Node* p); // OK
            ```
    4.  **`extern` Bildirimleri:**
        *   `extern MyClass global_obj;` // Geçerli. Bu, `global_obj`'nin başka bir çeviri biriminde (translation unit) tanımlandığını söyler. Burada bellek ayrılmaz.
*   **Incomplete Type ile Neler Yapılamaz? (Syntax Hatası Olan Durumlar)**
    1.  **Nesne Tanımlama (Obje Oluşturma):**
        *   `MyClass obj;` // **HATA.** Derleyici `obj` için ne kadar bellek ayıracağını bilemez.
        *   `new MyClass;` // **HATA.** Heap'te nesne oluşturulamaz.
    2.  **`sizeof` Operatörü:**
        *   `sizeof(MyClass);` // **HATA.** Boyutu bilinmeyen bir türün boyutu alınamaz.
    3.  **Pointer'ı Dereference Etmek:**
        *   `MyClass* ptr; *ptr` // `*ptr` ifadesi **HATA** verir (eğer `MyClass` hala incomplete ise).
        *   `ptr->member` // **HATA.** Hangi üyelere sahip olduğu bilinmiyor.
    4.  **Sınıfın Kendi Türünden Üye (Non-static Data Member):**
        *   `class Node { Node next_node_object; };` // **HATA.** Rekürsif tanım olur ve sonsuz boyut gerektirir.
        *   Ancak, `class Node { Node* next_node_ptr; Node& prev_node_ref; };` // **GEÇERLİDİR**, çünkü pointer ve referansların boyutu sabittir.
    5.  **Statik Veri Üyesi Bildirimi (Definition Değil, Declaration):**
        *   `class MyClass { static MyClass static_obj_declaration; };` // Bu **bildirim** geçerlidir. Bu, nesnenin içinde yer kaplamaz. Tanımı (definition) ayrı bir yerde yapılır ve o noktada `MyClass` complete olmalıdır. (Bu konu statik üyelere gelince detaylandırılacak.)
    6.  **Kalıtım (Inheritance):**
        *   `class Derived : public Base;` // Burada `Base`'in **complete type** olması gerekir.
    7.  **Template Argümanı Olarak (Bazı Durumlarda):**
        *   Bazı template'ler (örn: `std::vector<MyClass>`) argüman türünün complete olmasını gerektirir. `std::unique_ptr<MyClass>` gibi bazıları ise incomplete type ile çalışabilir (özel destructor sağlanırsa).
*   **`void` Türü:**
    *   `void` "doğuştan" incomplete bir türdür.
    *   `void x;` // **HATA.** `void` türünden nesne tanımlanamaz.
    *   Ancak `void*` (void pointer) geçerlidir ve herhangi bir veri türünün adresini tutabilen genel bir pointer olarak kullanılır.
    *   Bir ifadenin türü `void` olabilir (örneğin, `void` fonksiyon çağrısı veya `(void)expression` cast'i).
*   **Incomplete Type Kullanımının Avantajları (Forward Declaration ile):**
    1.  **Derleme Sürelerini Kısaltmak (Reduced Compilation Times):**
        *   Bir başlık dosyasında (`.h`), sadece bir sınıfın pointer'ına veya referansına ihtiyaç duyuluyorsa, o sınıfın tam tanımını içeren başlık dosyasını `#include` etmek yerine, sadece forward declaration (`class OtherClass;`) yapmak yeterlidir.
        *   Bu, gereksiz `#include` zincirlerini kırar. Bir başlık dosyası değiştiğinde, sadece o başlığı gerçekten "kullanan" (nesnesini oluşturan, boyutunu isteyen vb.) `.cpp` dosyalarının yeniden derlenmesi gerekir. Sadece pointer/referansını kullanan ve forward declaration yapanlar etkilenmez.
    2.  **Gereksiz Bağımlılıkları (Dependencies) Azaltmak:**
        *   İki sınıf birbirlerinin pointer/referanslarını kullanıyorsa (dairesel bağımlılık potansiyeli), her ikisinin de diğerinin başlık dosyasını `#include` etmesi sorunlara yol açabilir. Forward declaration bu durumu çözebilir.
        ```cpp
        // header_A.h
        class B; // Forward declaration of B
        class A {
            B* b_ptr;
        public:
            void foo(B* b);
        };

        // header_B.h
        class A; // Forward declaration of A
        class B {
            A* a_ptr;
        public:
            void bar(A* a);
        };
        // Bu şekilde A, B'nin tam tanımına; B de A'nın tam tanımına ihtiyaç duymaz.
        // .cpp dosyalarında ilgili include'lar yapılır.
        ```
    *   **Tavsiye:** Bir başlık dosyasında, bir sınıfın tam tanımına (nesne oluşturma, `sizeof`, üyelere erişim vb. için) ihtiyaç yoksa, sadece pointer veya referansı kullanılacaksa, o sınıf için **forward declaration** kullanın, `#include` etmekten kaçının. `#include` direktifini `.cpp` dosyasına taşıyın.
*   **Fonksiyonun Geri Dönüş Değerini Bilerek Kullanmamak (Void Cast):**
    *   Bir fonksiyon bir değer döndürüyorsa (örn: `int func()`), ancak çağrıldığı yerde bu değer kullanılmıyorsa, bazı derleyiciler veya lint araçları uyarı verebilir ("unused return value").
    *   Bu uyarıyı bastırmak ve "bu değeri bilerek kullanmıyorum" niyetini belirtmek için fonksiyon çağrı ifadesi `void` türüne cast edilebilir: `(void)func();`
    *   Özellikle `[[nodiscard]]` attribute'u ile işaretlenmiş fonksiyonların dönüş değerleri kullanılmadığında derleyici uyarı/hata verebilir. `(void)` cast'i bu uyarıyı genellikle susturur.

---

**13. Dersi Bitirirken Genel Tekrar ve Önemli Vurgular (02:07:46.320 - Sonuna Kadar)**

*   **Default Member Initializer / In-Class Initializer:** Modern C++ özelliği, sınıf içinde üyelere varsayılan değer atama. MIL'de açıkça initialize edilmezse bu değerler kullanılır.
*   **Constructor Initializer List (MIL):** Üyeleri ve base class'ları initialize etmenin doğru ve genellikle en verimli yolu. Bildirim sırasına dikkat!
*   **Derleyicinin Yazdığı SMF'ler:**
    *   Implicitly-declared (örtük bildirilmiş) SMF'ler her zaman `public` ve `inline` olur.
    *   Derleyici, bir SMF'yi (örn: default ctor, copy ctor vb.) yazarken dilin kurallarına uyar. Eğer bu süreçte bir kural ihlali (örn: private üye constructor'ına erişim, const üyenin başlatılamaması) oluşursa, derleyici o SMF'yi hata vermek yerine **`= delete` edilmiş olarak** bildirir. Bu, modern C++'ın önemli bir kuralıdır.
*   **Complete vs. Incomplete Types:** Pointer/referans bildirimleri, fonksiyon prototipleri için incomplete type yeterli olabilir. Nesne oluşturma, `sizeof`, üye erişimi için complete type gerekir. Gereksiz `#include`'lardan kaçınmak için forward declaration kullanmanın önemi vurgulandı.

---

**Tüm Anlatılanları Kapsayan Örnek Kod Bloğu (İleri Düzey Konular Hariç):**

```cpp
#include <iostream>
#include <string>
#include <vector> // Default ctor'un önemini göstermek için

// Forward declaration for Logger (eğer başka bir dosyada tanımlıysa ve sadece pointer/ref kullanılıyorsa)
class Logger;

class Config {
    int m_id = -1; // Default member initializer
    std::string m_name = "DefaultConfig"; // Default member initializer
    const bool m_isReadOnly; // const üye, MIL'de initialize edilmeli
    Logger& m_loggerRef;     // Referans üye, MIL'de initialize edilmeli

public:
    // 1. Default constructor (explicitly defaulted)
    // Eğer Logger'ın uygun bir default constructor'ı yoksa ve m_loggerRef MIL'de bağlanmazsa
    // bu constructor derleyici tarafından implicitly-deleted olabilirdi.
    // Burada basitlik için Logger'ın var olduğu ve global bir logger_instance'a bağlanabildiği varsayılıyor.
    // Gerçek senaryoda Logger& bir parametre ile alınmalı veya farklı bir mekanizma kullanılmalı.
    // Şimdilik bu örneği basitleştirmek için, Logger'ın global bir instance'ına referans atayalım.
    // Bu iyi bir tasarım değildir ama konuyu göstermek içindir.
    // static Logger global_log_instance; // Bu da static init order fiasco'ya yol açabilir.
    // En iyisi constructor'a Logger& parametresi eklemek olurdu.

    // Basit bir örnek için Logger'ı dışarıdan alalım:
    Config(Logger& logger, bool is_ro) : m_isReadOnly(is_ro), m_loggerRef(logger) {
        std::cout << "Config Ctor (Logger&, bool): ID=" << m_id << ", Name=" << m_name
                  << ", ReadOnly=" << m_isReadOnly << ", this=" << this << std::endl;
        // m_id ve m_name default member initializer'larını kullanır çünkü MIL'de yoklar.
    }

    // 2. Parametreli constructor
    Config(int id, const std::string& name, bool is_ro, Logger& logger)
        : m_id(id),              // MIL ile initialize
          m_name(name),            // MIL ile initialize
          m_isReadOnly(is_ro),     // MIL ile initialize (const olduğu için zorunlu)
          m_loggerRef(logger)      // MIL ile initialize (referans olduğu için zorunlu)
    {
        std::cout << "Config Ctor (int, string, bool, Logger&): ID=" << m_id << ", Name=" << m_name
                  << ", ReadOnly=" << m_isReadOnly << ", this=" << this << std::endl;
    }

    // 3. Destructor
    ~Config() {
        std::cout << "Config Dtor: ID=" << m_id << ", Name=" << m_name
                  << ", this=" << this << std::endl;
    }

    // 4. Copy constructor (explicitly deleted to make class non-copyable)
    Config(const Config&) = delete;

    // 5. Copy assignment operator (explicitly deleted)
    Config& operator=(const Config&) = delete;

    // (Move constructor ve move assignment şimdilik eklenmedi, onlar da SMF'dir)

    void print() const {
        std::cout << "Config Data: ID=" << m_id << ", Name='" << m_name
                  << "', ReadOnly=" << std::boolalpha << m_isReadOnly << std::endl;
    }
};

// Logger sınıfı (basit bir örnek)
class Logger {
public:
    Logger() { std::cout << "Logger Default Ctor. this=" << this << std::endl; }
    ~Logger() { std::cout << "Logger Dtor. this=" << this << std::endl; }
    void log(const std::string& msg) { std::cout << "[LOG]: " << msg << std::endl; }
};

// --- Global Nesneler ve Statik Yerel ---
Logger g_main_logger; // Global logger instance

Config g_global_config(g_main_logger, true); // Global Config, main'den önce ctor

void testFunction() {
    static Config s_local_config(g_main_logger, false); // Static local, ilk çağrıda ctor
    std::cout << "testFunction() called." << std::endl;
    s_local_config.print();
}

int main() {
    std::cout << "--- main() started ---" << std::endl;

    // Otomatik ömürlü nesne
    {
        Config auto_config1(101, "AutoConf1", false, g_main_logger);
        auto_config1.print();
        // auto_config1 dtor burada çağrılır
    }

    std::cout << "--- Calling testFunction first time ---" << std::endl;
    testFunction();
    std::cout << "--- Calling testFunction second time ---" << std::endl;
    testFunction(); // s_local_config ctor'u tekrar çağrılmaz

    // Dizi örneği (Config'in uygun bir default ctor'u olmadığı için bu doğrudan yapılamaz)
    // Eğer Config'in Logger& almayan bir default ctor'u olsaydı:
    // Config config_array[2]; // Her eleman için default ctor çağrılırdı.

    // std::vector örneği (genellikle default ctor gerektirir)
    // std::vector<Config> vec_configs(3); // Config'in default ctor'u yoksa veya
                                         // gerekli argümanları sağlayamıyorsa hata verir.
                                         // (Bu örnekte Config'in default ctor'u yok)

    std::cout << "--- main() finishing ---" << std::endl;
    // Önce otomatik ömürlüler (eğer varsa),
    // sonra statik yereller (s_local_config dtor),
    // sonra globaller (g_global_config dtor, sonra g_main_logger dtor) yok edilir.
    return 0;
}

```
