# C++ Programlama Dili - 33. Ders NotlarÄ±

**Tarih:** 21 Ekim 2024  
**EÄŸitmen:** Necati Ergin  
**Konu Ã–zeti:** Åablon UzmanlaÅŸmasÄ± (Specialization), BaÄŸÄ±mlÄ± Ä°simler (Dependent Names), DeÄŸiÅŸken ÅablonlarÄ± (Variable Templates), TÃ¼r EÅŸisim ÅablonlarÄ± (Alias Templates) ve MÃ¼kemmel GÃ¶nderim (Perfect Forwarding) GiriÅŸ.

---

## 1. Åablonlarda UzmanlaÅŸma (Specialization) ve Non-Type Parametreler [00:00:00 - 00:18:33]

Hoca, ÅŸablonlarÄ±n sadece tÃ¼rlerle deÄŸil, sabit deÄŸerlerle de (non-type template parameters) Ã§alÄ±ÅŸabildiÄŸini vurgulayarak baÅŸladÄ±. Bu mekanizma, derleme zamanÄ±nda (compile-time) Ã¶zyinelemeli hesaplamalar yapmak iÃ§in temel araÃ§tÄ±r.

### Teknik Detaylar:
*   **Explicit (Full) Specialization:** Åablonun belirli bir durum (Ã¶rneÄŸin `0` deÄŸeri veya belirli bir tÃ¼r) iÃ§in tamamen Ã¶zelleÅŸtirilmesidir. Hem sÄ±nÄ±f hem fonksiyon ÅŸablonlarÄ± iÃ§in geÃ§erlidir.
*   **Partial Specialization:** Åablon parametrelerinin sadece bir kÄ±smÄ±nÄ±n veya bir tÃ¼r grubunun (Ã¶rneÄŸin tÃ¼m pointerlar) Ã¶zelleÅŸtirilmesidir. **Dikkat:** Fonksiyon ÅŸablonlarÄ± iÃ§in kÄ±smi uzmanlaÅŸma (partial specialization) yoktur; bu sadece sÄ±nÄ±f ve deÄŸiÅŸken ÅŸablonlarÄ± iÃ§in geÃ§erlidir.
*   **Compile-Time RekÃ¼rsiyon:** `constexpr` fonksiyonlar veya ÅŸablonlar aracÄ±lÄ±ÄŸÄ±yla derleme zamanÄ±nda dÃ¶ngÃ¼ mantÄ±ÄŸÄ± kurulabilir. UzmanlaÅŸma, bu rekÃ¼rsiyonu durduran "base case" gÃ¶revini gÃ¶rÃ¼r.

### Kod Ã–rneÄŸi: Derleme ZamanÄ± FaktÃ¶riyel (Fonksiyon Åablonu ile)
```cpp
template <long long n>
constexpr long long factorial() {
    return n * factorial<n - 1>(); // Derleme zamanÄ± Ã¶zyineleme
}

// RekÃ¼rsiyonu durduran Explicit Specialization
template <>
constexpr long long factorial<0>() {
    return 1;
}

int main() {
    constexpr auto val = factorial<5>(); // Derleme zamanÄ±nda 120 hesaplanÄ±r.
}
```

---

## 2. SÄ±nÄ±f ÅablonlarÄ±nda KÄ±smi UzmanlaÅŸma (Partial Specialization) [00:18:33 - 00:27:32]

SÄ±nÄ±f ÅŸablonlarÄ±, belirli bir tÃ¼r kÃ¼mesi iÃ§in alternatif kod bloklarÄ± sunabilir. Bu, kÃ¼tÃ¼phane tasarÄ±mÄ±nda (Ã¶zellikle STL'de) Ã§ok yaygÄ±ndÄ±r.

### Kritik ArgÃ¼manlar:
*   **ArayÃ¼z FarklÄ±lÄ±ÄŸÄ±:** UzmanlaÅŸmÄ±ÅŸ (specialized) bir sÄ±nÄ±fÄ±n arayÃ¼zÃ¼ (member fonksiyonlarÄ±, veri elemanlarÄ±) ana (primary) ÅŸablondan tamamen farklÄ± olabilir. Hoca, `std::vector<bool>` Ã¶rneÄŸinin aslÄ±nda bir partial specialization olduÄŸunu ve bu yÃ¼zden diÄŸer vektÃ¶rlerden farklÄ± davrandÄ±ÄŸÄ±nÄ± hatÄ±rlattÄ±.
*   **EÅŸleÅŸme KurallarÄ±:** Derleyici her zaman "en spesifik" olan ÅŸablonu seÃ§er. EÄŸer `T*` ve `T` ÅŸablonlarÄ± varsa ve argÃ¼man `int*` ise, derleyici `T*` olan uzmanlaÅŸmÄ±ÅŸ ÅŸablonu tercih eder.

### Kod Ã–rneÄŸi: Pointer ve Ã‡ift TÃ¼r UzmanlaÅŸmasÄ±
```cpp
template <typename T, typename U>
struct Match { /* Primary Template */ };

// Ä°kinci parametresi 3 olan durumlar iÃ§in kÄ±smi uzmanlaÅŸma
template <typename T>
struct Match<T, 3> { /* ... */ };

// Her iki parametrenin aynÄ± olduÄŸu durumlar iÃ§in kÄ±smi uzmanlaÅŸma
template <typename T>
struct Match<T, T> { /* ... */ };
```

---

## 3. Meta-Fonksiyonlar ve `value` Konvansiyonu [00:27:32 - 00:34:02]

C++'ta `constexpr` fonksiyonlardan Ã¶nce, derleme zamanÄ±nda deÄŸer hesaplamak iÃ§in kullanÄ±lan klasik "ÅŸablon meta-programlama" tekniÄŸi incelendi.

### Temel Kurallar:
1.  SonuÃ§, sÄ±nÄ±fÄ±n iÃ§indeki `static constexpr` bir `value` elemanÄ±nda tutulur.
2.  Hesaplama, ÅŸablon aÃ§Ä±lÄ±mÄ± sÄ±rasÄ±nda (instantiation) gerÃ§ekleÅŸir.
3.  STL'deki `type_traits` kÃ¼tÃ¼phanesi bu mantÄ±k Ã¼zerine kuruludur.

### Kod Ã–rneÄŸi: Ãœs Alma (Power) Meta-Fonksiyonu
```cpp
template <std::size_t Base, std::size_t Exp>
struct Power {
    static constexpr std::size_t value = Base * Power<Base, Exp - 1>::value;
};

// Durdurma noktasÄ±: Exponent 0 ise sonuÃ§ 1'dir.
template <std::size_t Base>
struct Power<Base, 0> {
    static constexpr std::size_t value = 1;
};
```

---

## 4. BaÄŸÄ±mlÄ± Ä°simler ve `typename` ZorunluluÄŸu [00:34:02 - 00:53:16]

Hoca, ÅŸablon yazarken karÅŸÄ±laÅŸÄ±lan en bÃ¼yÃ¼k "syntax" engellerinden biri olan **Dependent Names** (BaÄŸÄ±mlÄ± Ä°simler) konusunu aÃ§Ä±kladÄ±.

### Problem: Parsing BelirsizliÄŸi
Bir ÅŸablon parametresine baÄŸlÄ± olan isimlere "dependent name" denir. Ã–rneÄŸin `T::size_type * ptr;` ifadesinde:
*   EÄŸer `size_type` bir **tÃ¼r** ise, bu bir pointer bildirimidir.
*   EÄŸer `size_type` bir **statik deÄŸiÅŸken** ise, bu bir Ã§arpma iÅŸlemidir.

### Ã‡Ã¶zÃ¼m:
*   **C++ Standart KuralÄ±:** Derleyici, aksi belirtilmedikÃ§e baÄŸÄ±mlÄ± bir ismin bir **deÄŸer** (expression) olduÄŸunu varsayar.
*   EÄŸer bu ismin bir **tÃ¼r** olduÄŸunu biliyorsak, Ã¶nÃ¼ne `typename` anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼ getirmeliyiz.
*   **C++20 GevÅŸetmesi:** C++20 ile birlikte, bir ismin "zaten tÃ¼r olmaktan baÅŸka ÅŸansÄ± olmadÄ±ÄŸÄ±" yerlerde (Ã¶rneÄŸin fonksiyon geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ kÄ±smÄ± veya `using` bildiriminin saÄŸ tarafÄ±) `typename` yazma zorunluluÄŸu kaldÄ±rÄ±lmÄ±ÅŸtÄ±r. Ancak eski standartlarda bu hala zorunludur.

ğŸ’¡ **Ã–ÄŸrenci Notu:** `typename` sadece ÅŸablon parametrelerine baÄŸlÄ± isimlerde kullanÄ±lÄ±r. `std::vector<int>::iterator` iÃ§in `typename` gerekmez Ã§Ã¼nkÃ¼ `int` belli bir tÃ¼rdÃ¼r, baÄŸÄ±mlÄ± deÄŸildir.

---

## 5. DeÄŸiÅŸken ÅablonlarÄ± (Variable Templates - C++14) [00:53:16 - 01:16:47]

C++14 ile gelen bu Ã¶zellik, deÄŸiÅŸkenlerin de ÅŸablon olabilmesini saÄŸlar. Ã–zellikle matematiksel sabitler ve `type_traits` yardÄ±mcÄ±larÄ± iÃ§in devrim niteliÄŸindedir.

### Teknik Detaylar:
*   **Bellek KullanÄ±mÄ±:** `constexpr` olarak tanÄ±mlanan deÄŸiÅŸken ÅŸablonlarÄ±, adresleri alÄ±nmadÄ±ÄŸÄ± sÃ¼rece derleme zamanÄ± sabiti olarak deÄŸerlendirilir ve bellekte yer kaplamazlar.
*   **Konvansiyon:** Standart kÃ¼tÃ¼phanedeki `_v` (value) son ekli tÃ¼m araÃ§lar (Ã¶rneÄŸin `std::is_pointer_v<T>`) birer deÄŸiÅŸken ÅŸablonudur.

### Kod Ã–rneÄŸi: Set Bit Count (Bit Sayma)
```cpp
template <std::size_t N>
constexpr std::size_t sbc = (N % 2) + sbc<N / 2>;

template <>
constexpr std::size_t sbc<0> = 0;

int main() {
    constexpr auto bits = sbc<15>; // 15 (1111) iÃ§in sonuÃ§ 4'tÃ¼r.
}
```

---

## 6. TÃ¼r EÅŸisim ÅablonlarÄ± (Alias Templates - C++11) [01:20:38 - 01:45:10]

Hoca, `typedef`'in yetersiz kaldÄ±ÄŸÄ± noktada C++11 ile gelen `using` (Alias Templates) mekanizmasÄ±nÄ± anlattÄ±.

### Avantajlar:
*   `typedef` ÅŸablonlaÅŸtÄ±rÄ±lamazken, `using` ile ÅŸablon tÃ¼r eÅŸisimleri oluÅŸturulabilir.
*   Okunabilirlik: `using` atama operatÃ¶rÃ¼ sentaksÄ±nÄ± kullandÄ±ÄŸÄ± iÃ§in daha anlaÅŸÄ±lÄ±rdÄ±r.
*   `_t` son eki konvansiyonu: `std::remove_reference_t<T>` gibi araÃ§lar aslÄ±nda `typename std::remove_reference<T>::type` yazÄ±mÄ±nÄ±n kÄ±sa yoludur.

### Kod Ã–rneÄŸi: KarmaÅŸÄ±k STL TÃ¼rlerini SadeleÅŸtirme
```cpp
// Her zaman greater (bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe) sÄ±ralayan bir Set tÃ¼rÃ¼ oluÅŸturmak
template <typename T>
using GreaterSet = std::set<T, std::greater<T>>;

int main() {
    GreaterSet<int> mySet; // std::set<int, std::greater<int>> ile aynÄ±.
}
```

---

## 7. VarsayÄ±lan Åablon ArgÃ¼manlarÄ± (Default Template Arguments) [01:45:10 - 02:25:28]

Åablon parametrelerine varsayÄ±lan deÄŸerler atanmasÄ± kural ve istisnalarÄ± iÅŸlendi.

### Kurallar:
*   **SÄ±nÄ±f ÅablonlarÄ±:** TÄ±pkÄ± fonksiyon parametrelerinde olduÄŸu gibi, varsayÄ±lan argÃ¼manlar saÄŸdan sola doÄŸru verilmelidir.
*   **Fonksiyon ÅablonlarÄ±:** Ä°lginÃ§ bir ÅŸekilde, fonksiyon ÅŸablonlarÄ±nda varsayÄ±lan argÃ¼manlar herhangi bir sÄ±rada olabilir (Ã‡Ã¼nkÃ¼ Ã§Ä±karÄ±m -deduction- mekanizmasÄ± devreye girer).
*   **Redeclaration (Tekrar Bildirim):** Bir ÅŸablonu birden fazla kez bildirebiliriz ve her bildirimde yeni varsayÄ±lan argÃ¼manlar "ekleyerek" (merge) gidebiliriz.

âš ï¸ **UyarÄ±:** Fonksiyon ÅŸablonlarÄ±nda varsayÄ±lan parametre kullanÄ±mÄ±, "Template Argument Deduction"Ä±n baÅŸarÄ±sÄ±z olduÄŸu durumlarda can kurtarÄ±cÄ±dÄ±r.

---

## 8. MÃ¼kemmel GÃ¶nderim (Perfect Forwarding) GiriÅŸ [02:25:28 - 02:43:00]

Dersin sonunda, modern C++'Ä±n en gÃ¼Ã§lÃ¼ (ve en zor) konularÄ±ndan biri olan Perfect Forwarding'in temelleri atÄ±ldÄ±.

### Problem TanÄ±mÄ±:
Bir fonksiyonun (Ã¶rneÄŸin `call_func`) kendisine gelen argÃ¼manlarÄ±, baÅŸka bir fonksiyona (`func`) "hiÃ§bir Ã¶zelliÄŸini bozmadan" (const'luk ve l-value/r-value kategorisi korunarak) iletmesi problemidir.
*   EÄŸer bu manuel yapÄ±lmaya Ã§alÄ±ÅŸÄ±lÄ±rsa, parametre sayÄ±sÄ± arttÄ±kÃ§a (2^n) kadar overload yazmak gerekir (Exponential explosion).

### Ã‡Ã¶zÃ¼m: Forwarding References + `std::forward`
*   **Forwarding (Universal) Reference:** `T&&` sentaksÄ±, eÄŸer `T` bir ÅŸablon parametresiyse ve Ã§Ä±karÄ±ma tabiyse "her ÅŸeyi baÄŸlayabilen" bir referansa dÃ¶nÃ¼ÅŸÃ¼r.
*   **`std::forward<T>(arg)`:** ArgÃ¼manÄ±n orijinal tÃ¼r kategorisini (l-value mu r-value mu) koruyarak iletmeyi saÄŸlar.

### Kod Ã–rneÄŸi: Perfect Forwarding TaslaÄŸÄ±
```cpp
template <typename T>
void call_func(T&& arg) { // Forwarding reference
    func(std::forward<T>(arg)); // MÃ¼kemmel gÃ¶nderim!
}
```

---

## Master Kod Ã–rneÄŸi (Ders Ã–zeti)

Bu kod, derste iÅŸlenen BaÄŸÄ±mlÄ± Ä°simler, Variable Templates, Alias Templates ve Default Arguments konularÄ±nÄ± birleÅŸtirir:

```cpp
#include <iostream>
#include <vector>
#include <type_traits>

// 1. Alias Template: KarmaÅŸÄ±k bir vektÃ¶r tÃ¼rÃ¼nÃ¼ basitleÅŸtirdik
template <typename T>
using Vec = std::vector<T>;

// 2. Variable Template: TÃ¼rÃ¼n pointer olup olmadÄ±ÄŸÄ±nÄ± tutan compile-time sabiti
template <typename T>
constexpr bool IsPtr = std::is_pointer_v<T>;

// 3. Default Argument & Dependent Name
template <typename T = int> // VarsayÄ±lan parametre: int
struct Processor {
    // T::value_type baÄŸÄ±mlÄ± bir isimdir, typename ÅŸart!
    using InternalType = typename Vec<T>::value_type; 

    void info() {
        if constexpr (IsPtr<T>) 
            std::cout << "Pointer tipi ile calisiliyor.\n";
        else
            std::cout << "Normal tip ile calisiliyor.\n";
    }
};

int main() {
    Processor<> p1; // T = int (Default)
    p1.info();

    Processor<int*> p2; // T = int*
    p2.info(); // "Pointer tipi ile calisiliyor." Ã§Ä±ktÄ±sÄ±nÄ± verir.

    return 0;
}
```

---
