--- START OF FILE NOTLANDIRMA ---

# C++ Programlama Dili: VektÃ¶r KonteynÄ±rÄ± ve Algoritmalar - I

Bu ders notu, 20 KasÄ±m 2024 tarihli, 41. ders gÃ¼nÃ¼ne ait transkript verileri doÄŸrultusunda hazÄ±rlanmÄ±ÅŸtÄ±r. Odak noktasÄ± `std::vector` Ã¼ye fonksiyonlarÄ±, kapasite yÃ¶netimi, ekleme/silme operasyonlarÄ± ve temel sÄ±ralama algoritmalarÄ±dÄ±r.

---

## 1. std::vector: Genel BakÄ±ÅŸ ve "Almost Always Vector" Prensibi (00:00 - 03:43)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Modern C++ dÃ¼nyasÄ±nda "Almost Always Auto" prensibine benzer ÅŸekilde **"Almost Always Vector"** esprisi yapÄ±lÄ±r. Ã–zel bir neden (Ã–rn: SÄ±kÃ§a baÅŸtan ekleme veya yoÄŸun dÃ¼ÄŸÃ¼m temelli iÅŸlem ihtiyacÄ±) olmadÄ±kÃ§a, **Contiguous Memory** (BitiÅŸik bellek alanÄ±) avantajÄ± nedeniyle birinci tercih vektÃ¶r olmalÄ±dÄ±r.

### ğŸ” Arka Plan (Under the Hood)
VektÃ¶r, arka planda dinamik bir dizi (dynamic array) yÃ¶netir. 
- **Indexle EriÅŸim:** O(1) - Constant Time (Sabit zaman).
- **Sondan Ekleme/Silme:** Amortized O(1) - Amorti edilmiÅŸ sabit zaman.
- **Data() Fonksiyonu:** VektÃ¶rÃ¼n `int` aÃ§Ä±lÄ±mÄ± iÃ§in `pointer to int` dÃ¶ndÃ¼rÃ¼r. Bu, C API'leri ile doÄŸrudan uyum saÄŸlar.

### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar
- **Forward List:** Ä°lginÃ§ bir ÅŸekilde `size()` fonksiyonuna sahip deÄŸildir (Tekli baÄŸlÄ± liste implementasyonu nedeniyle maliyetlidir).
- **Deque:** VektÃ¶r ve String'in aksine, `deque` (dek) konteynÄ±rÄ± belleÄŸin tamamen bitiÅŸik (contiguous) olacaÄŸÄ± garantisini vermez.

---

## 2. Kapasite YÃ¶netimi ve Reallocation Ä°liÅŸkisi (03:43 - 12:20)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
`Size` (Ã–ÄŸe sayÄ±sÄ±) `Capacity` (Kapasite) deÄŸerine ulaÅŸtÄ±ÄŸÄ±nda, bir sonraki ekleme iÅŸlemi iÃ§in yeni bir bellek bloÄŸu gerekir. Buna **Reallocation** (Yeniden yer ayÄ±rma) denir.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art)
VektÃ¶rÃ¼n bÃ¼yÃ¼me mekanizmasÄ± (Tipik MSVC implementasyonu - 1.5x):
```text
Size: 4, Capacity: 4  [X][X][X][X] 
PushBack -> Reallocation!
Size: 5, Capacity: 6  [X][X][X][X][X][ ] 
PushBack -> 
Size: 6, Capacity: 6  [X][X][X][X][X][X]
PushBack -> Reallocation!
Size: 7, Capacity: 9  [X][X][X][X][X][X][X][ ][ ]
```

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** BoÅŸ bir vektÃ¶r oluÅŸturup 1 milyon Ã¶ÄŸe eklemekle, baÅŸtan `reserve(1.000.000)` Ã§aÄŸÄ±rmak arasÄ±ndaki fark nedir?
**Cevap:** `reserve` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda tek bir allocation yapÄ±lÄ±r. Aksi takdirde, kapasite her dolduÄŸunda Ã¶ÄŸeler yeni bloÄŸa taÅŸÄ±nÄ±r/kopyalanÄ±r. Bu taÅŸÄ±ma iÅŸleminin maliyeti, tÃ¼rÃ¼n `move constructor`'Ä±nÄ±n `noexcept` olup olmamasÄ±na baÄŸlÄ±dÄ±r.

**Soru:** `vector<int> v(400000)` ile `v.reserve(400000)` farkÄ± nedir?
**Cevap:** 
- `reserve`: Sadece bellek alanÄ±nÄ± ayÄ±rÄ±r, `size` hala 0'dÄ±r. Nesneler henÃ¼z inÅŸa (construct) edilmemiÅŸtir.
- `Fill Constructor`: 400.000 adet nesneyi **Value Initialization** (DeÄŸer ile baÅŸlatma) yaparak inÅŸa eder (Ã–rn: int ise 0 yazar, class ise Default Constructor Ã§aÄŸÄ±rÄ±r).

---

## 3. Elemanlara EriÅŸim ve Const Overloading (12:20 - 16:35)

VektÃ¶rde elemanlara eriÅŸim iÃ§in kullanÄ±lan fonksiyonlar ve davranÄ±ÅŸlarÄ±:

| Fonksiyon | Hata Durumu DavranÄ±ÅŸÄ± | Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± |
| :--- | :--- | :--- |
| `front()` / `back()` | BoÅŸ konteynÄ±rda Ã§aÄŸrÄ±lmasÄ± **UB** (Undefined Behavior - TanÄ±msÄ±z DavranÄ±ÅŸ). | O(1) |
| `operator[]` | GeÃ§ersiz indekste **UB**. | O(1) |
| `at()` | GeÃ§ersiz indekste **std::out_of_range** exception (istisna) fÄ±rlatÄ±r. | O(1) |

### ğŸ” Arka Plan (Under the Hood)
Bu fonksiyonlar **Const Overload** (Sabit yÃ¼klemesi) edilmiÅŸtir.
```cpp
T& operator[](size_t index);             // Non-const: Nesneyi deÄŸiÅŸtirebiliriz.
const T& operator[](size_t index) const; // Const: Sadece okuma yapabiliriz.

// <-- Hoca buraya dikkat Ã§ekti:
const vector<int> cvec{1, 2, 3};
cvec[0] = 5; // SENTAKS HATASI! Geri dÃ¶nÃ¼ÅŸ deÄŸeri const T&'dir.
```

---

## 4. Modifiye Eden Operasyonlar (16:35 - 31:00)

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±: Assignment (Atama)
VektÃ¶re sadece kendi tÃ¼rÃ¼nden bir vektÃ¶r `operator=` ile atanabilir. Ancak `assign` Ã¼ye fonksiyonu ile farklÄ± konteynÄ±rlardan veri alÄ±nabilir.

```cpp
vector<int> ivek;
list<int> ilist{1, 2, 3};

ivek = ilist; // SENTAKS HATASI! (FarklÄ± konteynÄ±rlar arasÄ± atama yapÄ±lamaz)
ivek.assign(ilist.begin(), ilist.end()); // DOÄRU: Range assign (AralÄ±k atamasÄ±)
```

### ğŸ§  Resize Fonksiyonu
`resize(n)` fonksiyonu hem kÃ¼Ã§Ã¼ltme hem bÃ¼yÃ¼tme yapabilir:
- **BÃ¼yÃ¼tme:** Yeni Ã¶ÄŸeler iÃ§in Default Constructor (veya belirtilen deÄŸer) kullanÄ±lÄ±r.
- **KÃ¼Ã§Ã¼ltme:** Sondaki Ã¶ÄŸeler silinir (Destructor'larÄ± Ã§aÄŸrÄ±lÄ±r). `resize(0)` yapmak `clear()` ile eÅŸdeÄŸerdir.

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** 1 milyon Ã¶ÄŸeli bir vektÃ¶rÃ¼n `sizeof` deÄŸeri nedir?
**Cevap:** VektÃ¶rdeki Ã¶ÄŸe sayÄ±sÄ±ndan baÄŸÄ±msÄ±zdÄ±r! `sizeof(vector<T>)` derleme zamanÄ± (compile-time) sabitidir. VektÃ¶r nesnesi genellikle sadece 3 adet pointer (begin, end, end_of_storage) veya bir pointer ve iki tam sayÄ± tutar (Implementasyona baÄŸlÄ±dÄ±r, Ã¶rn: 24 veya 32 byte).

---

## 5. Ekleme OperasyonlarÄ±: PushBack ve Emplace (31:00 - 01:12:44)

### ğŸ” Arka Plan (Under the Hood): Emplace vs Push
`push_back` fonksiyonu nesneyi dÄ±ÅŸarÄ±da oluÅŸturup iÃ§eriye kopyalar/taÅŸÄ±r. `emplace_back` ise nesneyi doÄŸrudan vektÃ¶rÃ¼n ayÄ±rdÄ±ÄŸÄ± bellek alanÄ±nda inÅŸa eder.

```cpp
struct MyClass {
    MyClass(int, int, int); // Parametreli Constructor
};

vector<MyClass> vec;
vec.push_back(MyClass(1, 2, 3)); // 1. GeÃ§ici nesne oluÅŸur, 2. Move edilir.
vec.emplace_back(1, 2, 3);        // 1. DoÄŸrudan vektÃ¶rÃ¼n iÃ§inde inÅŸa edilir. 
                                  // <-- Daha verimlidir!
```

### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar: Perfect Forwarding
`emplace_back` arka planda **Variadic Templates** ve **Placement New** kullanÄ±r:
```cpp
template<typename... Args>
void emplace_back(Args&&... args) {
    // ... Reallocation kontrolÃ¼ ...
    new (address) T(std::forward<Args>(args)...); // <-- Perfect Forwarding (MÃ¼kemmel GÃ¶nderim)
}
```

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: Insert Konumu
`insert` fonksiyonunda ilk parametre her zaman iteratÃ¶rdÃ¼r (konum).
```cpp
vec.insert(vec.begin(), val); // BaÅŸa ekle (Linear complexity!)
vec.insert(vec.end(), val);   // Sona ekle (Push_back gibi)
vec.insert(vec.begin() + 2, val); // 2nd indexe ekle.
```
**Kritik Kural:** `insert` fonksiyonu, yeni eklenen (birden fazla ise ilk eklenen) Ã¶ÄŸenin konumunu (iterator) dÃ¶ndÃ¼rÃ¼r.


## 6. Silme (Erasure) Ä°ÅŸlemleri ve Modern C++ Ã‡Ã¶zÃ¼mleri (01:12:44 - 01:28:21)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
VektÃ¶rden Ã¶ÄŸe silmek, silinen Ã¶ÄŸeden sonraki tÃ¼m Ã¶ÄŸelerin sola kaydÄ±rÄ±lmasÄ±nÄ± gerektirir (**Linear Complexity - O(N)**). Bu iÅŸlemi gÃ¼venli ve verimli bir ÅŸekilde yapmak iÃ§in farklÄ± fonksiyonlar tasarlanmÄ±ÅŸtÄ±r.

### ğŸ” Arka Plan (Under the Hood)
- **`pop_back()`**: Sadece son Ã¶ÄŸeyi siler. Geri dÃ¶nÃ¼ÅŸ deÄŸeri `void`'dir (Verimlilik iÃ§in nesneyi dÃ¶ndÃ¼rmez).
- **`erase(iterator)`**: Belirli bir konumdaki Ã¶ÄŸeyi siler.
- **`erase(first, last)`**: Bir aralÄ±ÄŸÄ± (range) siler.
- **Geri DÃ¶nÃ¼ÅŸ DeÄŸeri:** `erase` fonksiyonlarÄ±, silinen son Ã¶ÄŸeden bir sonraki konumu (yeni geÃ§erli konumu) dÃ¶ndÃ¼rÃ¼r. Bu, dÃ¶ngÃ¼ iÃ§inde gÃ¼venli silme iÃ§in kritiktir.

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±: C++20 Global Erase
Eskiden belirli bir deÄŸere sahip tÃ¼m Ã¶ÄŸeleri silmek iÃ§in "Erase-Remove Idiom" (Silme-Ã‡Ä±karma KalÄ±bÄ±) kullanÄ±lÄ±rdÄ±. C++20 ile bu iÅŸlem basitleÅŸti:

```cpp
// C++20 Ã¶ncesi (Erase-Remove Idiom)
svec.erase(std::remove(svec.begin(), svec.end(), "ahmet"), svec.end());

// C++20 sonrasÄ± (Global erase)
std::erase(svec, "ahmet"); // <-- Hoca: "Daha gÃ¼zel ve okunabilir."
std::erase_if(svec, [](const auto& s){ return s.length() > 5; }); // KoÅŸullu silme
```

---

## 7. Ä°teratÃ¶r GeÃ§ersizleÅŸmesi (Iterator Invalidation) - Kritik Ã–dev (01:28:21 - 01:34:00)

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
Necati Hoca, mÃ¼lakatlarda adaylarÄ±n %80'inin yanlÄ±ÅŸ cevapladÄ±ÄŸÄ± meÅŸhur bir senaryoyu Ã¶dev olarak sunuyor:

**Senaryo:** Bir vektÃ¶rÃ¼ iteratÃ¶r ile dolaÅŸÄ±rken:
1. UzunluÄŸu 5 olan isimleri **silin**.
2. UzunluÄŸu 6 olan isimlerden bir tane daha **ekleyin** (duplicate).
3. DiÄŸerlerine dokunmayÄ±n.

**Neden Zor?**
VektÃ¶re bir Ã¶ÄŸe eklediÄŸinizde veya sildiÄŸinizde, mevcut iteratÃ¶rler **Invalid** (geÃ§ersiz) hale gelebilir. Ekleme yapÄ±ldÄ±ÄŸÄ±nda `reallocation` olursa tÃ¼m iteratÃ¶rler, silme yapÄ±ldÄ±ÄŸÄ±nda ise silinen noktadan sonrakiler bozulur.

---

## 8. Kapasite BÃ¼zme (Shrink to Fit) ve Swap Trick (01:34:00 - 01:44:56)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
VektÃ¶rden Ã¶ÄŸe sildiÄŸinizde `size` dÃ¼ÅŸer ama `capacity` aynÄ± kalÄ±r. EÄŸer bellek kÄ±sÄ±tlÄ±ysa ve vektÃ¶r artÄ±k Ã§ok daha kÃ¼Ã§Ã¼k bir alan kaplayacaksa, bu fazla belleÄŸi iÅŸletim sistemine geri vermek gerekir.

### ğŸ” Arka Plan (Under the Hood): Swap Trick
C++11 Ã¶ncesinde `shrink_to_fit()` fonksiyonu yoktu. ProgramcÄ±lar kapasiteyi sÄ±fÄ±rlamak iÃ§in ÅŸu hileyi kullanÄ±rdÄ±:

```cpp
vector<int> ivek(100000); // 100 bin Ã¶ÄŸe
ivek.erase(ivek.begin() + 10, ivek.end()); // 10 Ã¶ÄŸe kaldÄ± ama kapasite hala 100 bin.

// Swap Trick (Hoca burayÄ± mÃ¼lakat sorusu olarak vurguladÄ±)
vector<int>(ivek).swap(ivek); 
/* 
   1. ivek'in kopyasÄ± olan geÃ§ici bir nesne oluÅŸur (Kapasitesi sadece size kadar olur).
   2. GeÃ§ici nesne ile asÄ±l nesne bellek alanlarÄ±nÄ± takas eder (swap).
   3. GeÃ§ici nesne (eski 100 binlik alanla) scope sonunda yok olur.
*/

// Modern C++ Ã‡Ã¶zÃ¼mÃ¼:
ivek.shrink_to_fit(); // <-- Non-binding (BaÄŸlayÄ±cÄ± olmayan) bir talep.
```

---

## 9. `<functional>` BaÅŸlÄ±k DosyasÄ± ve Functorlar (01:44:56 - 02:01:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Algoritmalara (sort, transform vb.) karÅŸÄ±laÅŸtÄ±rma veya iÅŸlem kriteri gÃ¶ndermek iÃ§in her seferinde lambda yazmak yerine, standart operatÃ¶rlerin sÄ±nÄ±f hallerine ihtiyaÃ§ duyulmuÅŸtur.

### ğŸ” Arka Plan (Under the Hood)
Bu sÄ±nÄ±flar aslÄ±nda `operator()` fonksiyonu overload edilmiÅŸ birer **Functor** (Fonksiyon nesnesi) yapÄ±sÄ±dÄ±r.

```cpp
template <typename T>
struct plus {
    T operator()(const T& lhs, const T& rhs) const {
        return lhs + rhs;
    }
};

// KullanÄ±m:
std::transform(v.begin(), v.end(), v.begin(), std::negate<int>()); // TÃ¼m sayÄ±larÄ± negatife Ã§evirir.
```

### ğŸ“Š YaygÄ±n KullanÄ±lan Standart Fonksiyon Nesneleri
- **Aritmetik:** `plus`, `minus`, `multiplies`, `negate`.
- **KarÅŸÄ±laÅŸtÄ±rma:** `equal_to`, `less` (varsayÄ±lan), `greater`.
- **MantÄ±ksal:** `logical_and`, `logical_or`, `logical_not`.

---

## 10. SÄ±ralama AlgoritmalarÄ±: Sort ve Stable Sort (02:01:00 - 02:39:12)

### ğŸ” Arka Plan (Under the Hood)
- **`std::sort`**: Genelde **IntroSort** (QuickSort + HeapSort + InsertionSort hibriti) kullanÄ±r. Ortalama karmaÅŸÄ±klÄ±ÄŸÄ± **O(N log N)**'dir. Ancak **Stable deÄŸildir**.
- **`std::stable_sort`**: AynÄ± deÄŸerdeki Ã¶ÄŸelerin birbirlerine gÃ¶re olan sÄ±rasÄ±nÄ± korur. Ekstra bellek gerekebilir.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: Stability (KararlÄ±lÄ±k)
Diyelim ki kiÅŸileri Ã¶nce isme, sonra yaÅŸa gÃ¶re sÄ±ralÄ±yoruz:
```text
SÄ±ralama Ã–ncesi (Ä°sme gÃ¶re sÄ±ralÄ±):
(34, Metin), (47, Metin), (16, Selim)

std::sort (YaÅŸa gÃ¶re - Unstable):
(16, Selim), (47, Metin), (34, Metin) <-- Metinlerin isme gÃ¶re sÄ±rasÄ± BOZULABÄ°LÄ°R.

std::stable_sort (YaÅŸa gÃ¶re - Stable):
(16, Selim), (34, Metin), (47, Metin) <-- Metinler kendi iÃ§inde isme gÃ¶re sÄ±ralÄ± KALIR.
```

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::sort` hangi durumda sentaks hatasÄ± verir?
**Cevap:** EÄŸer Ã¶ÄŸeler iÃ§in `operator<` (less than) tanÄ±mlÄ± deÄŸilse ve dÄ±ÅŸarÄ±dan bir `predicate` (koÅŸul fonksiyonu) geÃ§ilmemiÅŸse, derleme zamanÄ±nda hata oluÅŸur. STL algoritmalarÄ± bu operatÃ¶rleri "Compile-time"da kontrol eder.

### ğŸ“Š DiÄŸer SÄ±ralama YardÄ±mcÄ±larÄ±
- **`std::is_sorted(beg, end)`**: AralÄ±k sÄ±ralÄ± mÄ±? (bool dÃ¶ner).
- **`std::is_sorted_until(beg, end)`**: SÄ±ralamanÄ±n bozulduÄŸu ilk noktayÄ± (iterator) dÃ¶ner.
- **`std::partial_sort`**: Sadece ilk `n` Ã¶ÄŸeyi sÄ±ralar (Ã–rn: En genÃ§ 10 kiÅŸiyi bulmak iÃ§in tÃ¼m vektÃ¶rÃ¼ sÄ±ralamaktan daha hÄ±zlÄ±dÄ±r).

