# C++ Standart KÃ¼tÃ¼phanesi ve Modern C++ NotlarÄ± - 59. Ders

**Tarih:** 29 Ocak 2025  
**EÄŸitmen:** Necati Ergin  
**Konular:** `std::chrono` KÃ¼tÃ¼phanesi Derinleme BakÄ±ÅŸ, `steady_clock` ile Performans Ã–lÃ§Ã¼mÃ¼, Rastgele SayÄ± Ãœretimi (`random` kÃ¼tÃ¼phanesi) GiriÅŸ.

---

## 1. `std::chrono` Mimarisi ve Saat TÃ¼rleri (00:00 - 04:07)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C'den gelen geleneksel zaman fonksiyonlarÄ± (time.h), tÃ¼r gÃ¼venliÄŸi (type safety) sunmuyor ve farklÄ± zaman birimleri (saniye, milisaniye) arasÄ±nda kaza yapmaya Ã§ok mÃ¼saitti. `chrono` kÃ¼tÃ¼phanesi, **Strong Types** (GÃ¼Ã§lÃ¼ TÃ¼rler) felsefesiyle, derleme zamanÄ±nda birim kontrolÃ¼ yaparak bu riskleri ortadan kaldÄ±rmak iÃ§in tasarlandÄ±.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, `chrono` bileÅŸenlerini Ã¼Ã§ ana sÃ¼tunda Ã¶zetledi:
1.  **Clocks (Saatler):** ZamanÄ±n akÄ±ÅŸÄ±nÄ± temsil eder.
    *   `system_clock`: Ayarlanabilir (adjustable), duvar saati (wall clock). GerÃ§ek dÃ¼nya tarih/zaman iÅŸlemleri iÃ§in.
    *   `steady_clock`: Ayarlanamaz, **monotonic** (tekdÃ¼ze artan). SÃ¼re Ã¶lÃ§Ã¼mÃ¼ (benchmarking) iÃ§in kritiktir.
    *   `high_resolution_clock`: Sistemdeki en kÃ¼Ã§Ã¼k "tick" aralÄ±ÄŸÄ±na sahip saatin `type alias`Ä± (eÅŸ ismi).
2.  **Time Point (Zaman NoktasÄ±):** Bir **Epoch**'tan (baÅŸlangÄ±Ã§ noktasÄ±, Ã¶rn: 1-1-1970) geÃ§en sÃ¼re.
3.  **Duration (SÃ¼re):** Ä°ki zaman noktasÄ± arasÄ±ndaki mesafe. 
    *   `template <class Rep, class Period = ratio<1>> class duration;`
    *   `Rep`: Temsil tÃ¼rÃ¼ (int, double, long).
    *   `Period`: Saniyenin kaÃ§ta kaÃ§Ä± olduÄŸu (`std::ratio`).

### ğŸ” Arka Plan (Under the Hood)
`std::chrono::duration` tÃ¼rleri aslÄ±nda basit birer sarmalayÄ±cÄ± (wrapper) sÄ±nÄ±ftÄ±r. Hoca bunu **Zero-Cost Abstraction** (sÄ±fÄ±r maliyetli soyutlama) olarak tanÄ±mladÄ±; Ã§alÄ±ÅŸma zamanÄ±nda (runtime) ham bir sayÄ±dan (int/double) daha fazla yÃ¼k getirmezler.

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** SÃ¼re Ã¶lÃ§Ã¼mÃ¼ yaparken neden `system_clock` yerine `steady_clock` kullanmalÄ±yÄ±z?  
**Cevap:** `system_clock` sistem saatindeki deÄŸiÅŸimlerden (gÃ¼ncelleme, manuel ayar) etkilenir. EÄŸer Ã¶lÃ§Ã¼m sÄ±rasÄ±nda saat geri alÄ±nÄ±rsa negatif sÃ¼reler oluÅŸabilir. `steady_clock` ise sadece ileri akar ve hÄ±zÄ± sabittir.

---

## 2. `steady_clock` ile Kod PerformansÄ± Ã–lÃ§Ã¼mÃ¼ (04:07 - 10:37)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Kodun Ã§alÄ±ÅŸma sÃ¼resini Ã¶lÃ§mek, optimizasyon kararlarÄ± iÃ§in esastÄ±r. Hoca, `std::sort` algoritmasÄ±nÄ±n hÄ±zÄ±nÄ± Ã¶lÃ§mek iÃ§in bir senaryo kurdu.

### âš™ï¸ Teknik Detay ve Sentaks
AÅŸaÄŸÄ±daki kod, 1 milyon (sonra 5 milyona Ã§Ä±karÄ±ldÄ±) Ã¶ÄŸelik bir vektÃ¶rÃ¼ rastgele doldurup sÄ±ralama sÃ¼resini Ã¶lÃ§er:

```cpp
#include <iostream>
#include <chrono>
#include <vector>
#include <algorithm>
#include <random>

using namespace std;
using namespace std::chrono; // <-- Hoca: Ãœretimde (production) tavsiye etmem ama burada kolaylÄ±k olsun.

int main() {
    constexpr size_t size = 5'000'000;
    vector<int> vec(size);

    // Seeding (Tohumlama) Ä°ÅŸlemi
    // Hoca: System clock'un epoch'tan beri geÃ§en "count" deÄŸerini tohum olarak kullanÄ±yoruz.
    auto seed = static_cast<unsigned int>(system_clock::now().time_since_epoch().count());
    mt19937 eng(seed); 
    uniform_int_distribution dist(0, 1'000'000);

    // VektÃ¶rÃ¼ rastgele doldurma
    generate(vec.begin(), vec.end(), [&eng, &dist]() {
        return dist(eng); // <-- Hoca: mt19937 kopyalama maliyeti yÃ¼ksek, referansla capture (yakalama) yapÄ±n.
    });

    // --- Ã–LÃ‡ÃœM BAÅLIYOR ---
    auto tp_start = steady_clock::now(); // pr-value (zaman noktasÄ± nesnesi)

    sort(vec.begin(), vec.end());

    auto tp_end = steady_clock::now();
    // --- Ã–LÃ‡ÃœM BÄ°TTÄ° ---

    auto dur = tp_end - tp_start; // SonuÃ§ bir 'duration' tÃ¼rÃ¼dÃ¼r.
}
```

### ğŸ” Arka Plan (Under the Hood)
`generate` algoritmasÄ± iÃ§inde kullanÄ±lan lambda ifadesi, `mt19937` (Mersenne Twister) motorunu referansla yakalar. Hoca burada motorun **State** (durum) bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne dikkat Ã§ekti; kopyalama iÅŸlemi maliyetlidir Ã§Ã¼nkÃ¼ motorun iÃ§ durumu (state) yaklaÅŸÄ±k 5000 byte civarÄ±ndadÄ±r.

---

## 3. Duration DÃ¶nÃ¼ÅŸÃ¼mleri ve Hassasiyet (10:37 - 19:20)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Saatlerin kendi varsayÄ±lan birimi (genellikle nanosaniye) okunabilirlik aÃ§Ä±sÄ±ndan zordur. Bu deÄŸerleri saniyeye veya milisaniyeye dÃ¶nÃ¼ÅŸtÃ¼rmek gerekir.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca iki farklÄ± yaklaÅŸÄ±mÄ± gÃ¶sterdi: C++20 formatlama ve manuel `duration_cast`.

```cpp
// 1. YaklaÅŸÄ±m: C++20 ostream inserter (VarsayÄ±lan birimle yazdÄ±rÄ±r)
cout << "Sure: " << dur << endl; // Ã–rn: 73306600ns

// 2. YaklaÅŸÄ±m: Manuel Saniye DÃ¶nÃ¼ÅŸÃ¼mÃ¼ (Double representation)
// Hoca: EÄŸer representation 'double' ise Ã¶rtÃ¼lÃ¼ dÃ¶nÃ¼ÅŸÃ¼m (implicit conversion) her zaman var.
duration<double> dur_sec = dur; 
cout << "Saniye: " << dur_sec.count() << " sn" << endl;

// 3. YaklaÅŸÄ±m: duration_cast (Hassasiyet kaybÄ± olan durumlarda ZORUNLU)
// 'Finer' (ince) tÃ¼rden 'Coarse' (kaba) tÃ¼re dÃ¶nÃ¼ÅŸÃ¼m Ã¶rtÃ¼lÃ¼ yapÄ±lamaz.
auto dur_ms = duration_cast<milliseconds>(dur);
cout << "Milisaniye: " << dur_ms.count() << " ms" << endl;
```

### ğŸ” Arka Plan (Under the Hood)
*   **Implicit Conversion (Ã–rtÃ¼lÃ¼ DÃ¶nÃ¼ÅŸÃ¼m):** EÄŸer dÃ¶nÃ¼ÅŸÃ¼m sÄ±rasÄ±nda veri kaybÄ± (truncation) ihtimali yoksa (Ã¶rn: saniyeden nanosaniyeye), derleyici buna izin verir.
*   **duration_cast:** EÄŸer nanosaniyeden milisaniyeye geÃ§iyorsanÄ±z, kÃ¼surat atÄ±lacaÄŸÄ± iÃ§in derleyici sizi `duration_cast` kullanmaya zorlar.
*   **Optimizations:** Hoca uyardÄ±; eÄŸer kodun "Observable Behavior" (gÃ¶zlemlenebilir davranÄ±ÅŸ) Ã¼zerinde etkisi yoksa, derleyici Ã¶lÃ§tÃ¼ÄŸÃ¼nÃ¼z iÅŸlemi tamamen silebilir (Dead Code Elimination).

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**MÃ¼lakat Sorusu:** `duration_cast` ne zaman zorunludur?  
**Cevap:** Daha kÃ¼Ã§Ã¼k bir zaman biriminden (Ã¶rn: nanosaniye) daha bÃ¼yÃ¼k/kaba bir zaman birimine (Ã¶rn: saniye) tam sayÄ± (integer representation) ile dÃ¶nÃ¼ÅŸÃ¼m yaparken hassasiyet kaybÄ± olacaÄŸÄ± iÃ§in zorunludur. Ancak hedef representation `double` gibi bir gerÃ§ek sayÄ± tÃ¼rÃ¼ ise Ã¶rtÃ¼lÃ¼ dÃ¶nÃ¼ÅŸÃ¼m mÃ¼mkÃ¼ndÃ¼r.

### ğŸ”— Ã–nceki Derslerle BaÄŸlantÄ±
*   **Static Local Variables:** Hoca, rastgele sayÄ± motorlarÄ±nÄ±n fonksiyon iÃ§inde `static` tanÄ±mlanmasÄ± gerektiÄŸini, aksi halde fonksiyon her Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda motorun yeniden `construct` edilip aynÄ± sayÄ± sekansÄ±nÄ± Ã¼reteceÄŸini hatÄ±rlattÄ± (45. ders atÄ±fÄ±).
*   **L-value/R-value:** `steady_clock::now()` bir **pr-value** dÃ¶ndÃ¼rÃ¼r, bu yÃ¼zden `auto` ile yakalanmasÄ± **copy elision** mekanizmasÄ±nÄ± tetikler.

---

Hoca'nÄ±n dersine kaldÄ±ÄŸÄ±mÄ±z yerden, en Ã¶n sÄ±radaki titizliÄŸimizle devam ediyoruz. Åimdi `std::chrono` kÃ¼tÃ¼phanesinin C API'si ile entegrasyonunu ve dersin en aÄŸÄ±r konularÄ±ndan biri olan **Random** (Rastgele SayÄ± Ãœretimi) kÃ¼tÃ¼phanesine giriÅŸ yapÄ±yoruz.

---

## 4. `std::chrono` ve Legacy (C API) Uyumu (20:00 - 25:10)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Modern `chrono` kÃ¼tÃ¼phanesi Ã§ok gÃ¼Ã§lÃ¼dÃ¼r ancak bazen zamanÄ± insani bir formatta (gÃ¼n/ay/yÄ±l) yazdÄ±rmak veya eski C fonksiyonlarÄ±nÄ± (`ctime`, `localtime`) kullanan kÃ¼tÃ¼phanelerle Ã§alÄ±ÅŸmak gerekir. `system_clock::to_time_t` bu iki dÃ¼nya arasÄ±ndaki kÃ¶prÃ¼dÃ¼r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, zamanÄ± formatlÄ± yazdÄ±rmak iÃ§in bir `print_time` fonksiyonu Ã¼zerinden **Look-up Table** optimizasyonunu hatÄ±rlattÄ±:

```cpp
#include <chrono>
#include <ctime>
#include <iostream>
#include <iomanip>

using namespace std;

void print_time(const time_t& timer) {
    // Hoca: Bu diziler her Ã§aÄŸrÄ±da yeniden oluÅŸturulmasÄ±n diye 'static' yapÄ±yoruz (C Kursu atÄ±fÄ±).
    static const char* const months[] = {
        "Ocak", "Subat", "Mart", "Nisan", "Mayis", "Haziran",
        "Temmuz", "Agustos", "Eylul", "Ekim", "Kasim", "Aralik"
    };
    static const char* const days[] = {
        "Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi"
    };

    // Hoca: local_time fonksiyonu bize bir 'struct tm' nesnesinin adresini dÃ¶ndÃ¼rÃ¼r.
    tm* ptr = localtime(&timer); 

    cout << ptr->tm_mday << " " 
         << months[ptr->tm_mon] << " " 
         << ptr->tm_year + 1900 << " " // <-- Hoca: tm_year 1900'den beri geÃ§en sÃ¼redir.
         << days[ptr->tm_wday] << " "
         << setfill('0') << setw(2) << ptr->tm_hour << ":" 
         << setw(2) << ptr->tm_min << ":" 
         << setw(2) << ptr->tm_sec << endl;
}
```

### ğŸ” Arka Plan (Under the Hood)
`std::chrono::system_clock::to_time_t` fonksiyonu, bir `time_point` nesnesini alÄ±r ve onu C'nin `time_t` (genellikle 64 bit integer) tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Bu iÅŸlem sÄ±rasÄ±nda hassasiyet kaybÄ± olabilir Ã§Ã¼nkÃ¼ `time_t` genellikle saniye dÃ¼zeyindedir.

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** `localtime` fonksiyonunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ `tm*` iÅŸaretÃ§isinin (pointer) Ã¶mrÃ¼ nedir?  
**Cevap:** `localtime` genellikle statik bir alan kullanÄ±r. Yani fonksiyonu tekrar Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±zda eski veri Ã¼zerine yazÄ±lÄ±r. Thread-safe deÄŸildir (Multi-thread ortamlarda `localtime_s` veya `localtime_r` tercih edilmelidir).

---

## 5. Zaman AritmetiÄŸi: Dakika Ekleme/Ã‡Ä±karma (25:10 - 28:10)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Zaman noktalarÄ± (`time_point`) Ã¼zerinde toplama ve Ã§Ä±karma yaparak geÃ§miÅŸ veya gelecek tarihleri hesaplamak en sÄ±k yapÄ±lan iÅŸlemlerden biridir.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, bir zaman noktasÄ±na `std::chrono::minutes` ekleyip Ã§Ä±kararak sonuÃ§larÄ± yazdÄ±rdÄ±:

```cpp
int main() {
    auto tp_now = std::chrono::system_clock::now();
    
    int mins;
    cout << "Kac dakika oncesi ve sonrasi? ";
    cin >> mins;

    // tp_now - minutes(mins) bir time_point dÃ¶ndÃ¼rÃ¼r.
    auto tp_past = tp_now - std::chrono::minutes(mins);
    auto tp_future = tp_now + std::chrono::minutes(mins);

    cout << "Su anki zaman: ";
    print_time(std::chrono::system_clock::to_time_t(tp_now));

    cout << mins << " dakika oncesi: ";
    print_time(std::chrono::system_clock::to_time_t(tp_past));

    cout << mins << " dakika sonrasi: ";
    print_time(std::chrono::system_clock::to_time_t(tp_future));
}
```

---

## 6. Concurrency Preview: `sleep_for` ve `sleep_until` (28:10 - 30:17)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Hoca, `chrono` kÃ¼tÃ¼phanesinin Concurrency (EÅŸzamanlÄ±lÄ±k) kÃ¼tÃ¼phanesinde nasÄ±l bir parametre olarak kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶sterdi.

### âš™ï¸ Teknik Detay ve Sentaks
*   `std::this_thread::sleep_for(duration)`: Belirli bir **sÃ¼re** (Ã¶rn: 500ms) uyumak iÃ§in.
*   `std::this_thread::sleep_until(time_point)`: Belirli bir **zaman noktasÄ±na kadar** (Ã¶rn: program baÅŸladÄ±ktan tam 5 dakika sonra) uyumak iÃ§in kullanÄ±lÄ±r.

---

## 7. Rastgele SayÄ± Ãœretimi: Pseudo vs. True Random (30:17 - 34:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Modern C++ Ã¶ncesi C'den gelen `rand()` ve `srand()` fonksiyonlarÄ±, hem istatistiksel aÃ§Ä±dan zayÄ±ftÄ± hem de belirli bir aralÄ±ÄŸa daÄŸÄ±tmak (distribution) Ã§ok zordu. Modern `random` kÃ¼tÃ¼phanesi, matematiksel kesinlik ve esneklik iÃ§in tasarlandÄ±.

### âš™ï¸ Teknik Detay ve Kavramlar
1.  **PRNG (Pseudo Random Number Generation - SÃ¶zde Rastgelelik):** Matematiksel algoritmalarla Ã¼retilir. **Deterministik**'tir. 
    *   AynÄ± **Seed** (tohum) deÄŸeri verilirse her zaman aynÄ± sayÄ± zinciri (sequence) oluÅŸur.
2.  **TRNG (True Random Number Generation - GerÃ§ek Rastgelelik):** DoÄŸadan gelen fiziksel sÃ¼reÃ§lerle (radyoaktif bozulma, atmosferik gÃ¼rÃ¼ltÃ¼ vb.) Ã¼retilir. Tahmin edilemezdir.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Sequence MantÄ±ÄŸÄ±)
```text
Seed Value (Tohum) --> [ Algoritma / Engine ] --> Random Number Sequence
    (7)             --> [ Linear Congruential ] --> 6, 13, 0, 3, 11...
    (7)             --> [ Linear Congruential ] --> 6, 13, 0, 3, 11... (Tekrar Edilebilir!)
```

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** "SÃ¶zde rastgele sayÄ± Ã¼retimi (PRNG) neden deterministiktir?"  
**Cevap:** Ã‡Ã¼nkÃ¼ bir PRNG aslÄ±nda bir fonksiyondur. GiriÅŸ parametresi (seed) ve o anki durumu (state) aynÄ±ysa, bir sonraki sayÄ±yÄ± hesaplayan matematiksel formÃ¼l her zaman aynÄ± Ã§Ä±ktÄ±yÄ± Ã¼retir. Bu durum "test edilebilirlik" (debugging) iÃ§in Ã§ok faydalÄ±dÄ±r.

---

ğŸ“Œ **Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **`tm_year` HatasÄ±:** `tm_year` deÄŸeri ham haliyle yÄ±lÄ± vermez, 1900'den beri geÃ§en yÄ±lÄ± verir. Mutlaka `+ 1900` eklenmelidir.
2.  **`rand()` KullanÄ±mÄ±:** C'den gelen `rand()` fonksiyonu modern projelerde asla kullanÄ±lmamalÄ±dÄ±r; `random` kÃ¼tÃ¼phanesi Ã§ok daha Ã¼stÃ¼ndÃ¼r.
3.  **Seed Ã–nemli:** AynÄ± seed ile programÄ± her baÅŸlattÄ±ÄŸÄ±nÄ±zda "rastgele" denilen ama aslÄ±nda aynÄ± olan sayÄ±larÄ± alÄ±rsÄ±nÄ±z.

Hoca'nÄ±n dersine kaldÄ±ÄŸÄ±mÄ±z yerden, aynÄ± titizlikle devam ediyoruz. Bu bÃ¶lÃ¼mde rastgele sayÄ± Ã¼retiminin kullanÄ±m alanlarÄ±, gerÃ§ek (true) ve sÃ¶zde (pseudo) rastgelelik arasÄ±ndaki derin farklar ve C++ `<random>` kÃ¼tÃ¼phanesinin mimari yapÄ±sÄ±nÄ± inceliyoruz.

---

## 8. Rastgele SayÄ± Ãœretiminin Uygulama AlanlarÄ± (34:00 - 41:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Rastgelelik sadece "zar atmak" deÄŸildir. YazÄ±lÄ±m dÃ¼nyasÄ±nda verinin simÃ¼lasyonu, gÃ¼venliÄŸi ve test edilmesi iÃ§in vazgeÃ§ilmez bir araÃ§tÄ±r.

### âš™ï¸ Teknik Detay ve KullanÄ±m Yerleri
Hoca rastgeleliÄŸin kritik olduÄŸu alanlarÄ± ÅŸu ÅŸekilde kategorize etti:
*   **Bilgisayar OyunlarÄ±:** Minecraft gibi harita (map) oluÅŸturma, dÃ¼ÅŸman yapay zekasÄ± hareketleri.
*   **Kriptografi & Siber GÃ¼venlik:** Åifreleme anahtarlarÄ±, WhatsApp mesaj ÅŸifreleme, OTP (tek kullanÄ±mlÄ±k ÅŸifre) Ã¼retimi.
*   **Bilimsel SimÃ¼lasyonlar:** Ä°klim modelleri, hastalÄ±k yayÄ±lÄ±m modelleri.
*   **Finans (Algoritmik Trading):** Hoca burada kendi profesyonel tecrÃ¼besine atÄ±f yaptÄ±; **Genetik Algoritmalar** iÃ§in rastgele sayÄ± kalitesinin hayati Ã¶nemde olduÄŸunu belirtti.
*   **Yapay Zeka (AI):** Derin Ã¶ÄŸrenme modellerinin rastgele baÅŸlangÄ±Ã§ aÄŸÄ±rlÄ±klarÄ± (weights) ile eÄŸitilmesi.
*   **YazÄ±lÄ±m Testleri (Mocking):** Milyonlarca kiÅŸilik bir veritabanÄ± testi iÃ§in sentetik veri Ã¼retimi.

---

## 9. GerÃ§ek Rastgelelik (TRNG) ve KaynaklarÄ± (41:00 - 46:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bilgisayarlar deterministik makinelerdir; kod ile Ã¼retilen hiÃ§bir ÅŸey "gerÃ§ekten" rastgele deÄŸildir. Ancak bazÄ± fiziksel sÃ¼reÃ§ler bu determinizmi kÄ±rabilir.

### ğŸ” Arka Plan (Under the Hood)
Hoca TRNG (True Random Number Generation) kaynaklarÄ±nÄ± ÅŸÃ¶yle sÄ±raladÄ±:
1.  **Elektriksel GÃ¼rÃ¼ltÃ¼:** ElektronlarÄ±n hareketi tahmin edilemezdir. Modern Intel/AMD iÅŸlemcilerde bu amaÃ§la Ã¶zel Ã§ipler bulunur.
2.  **Radyoaktif Bozulma:** Bir atomun ne zaman bozulacaÄŸÄ± asla bilinemez. Geiger sayacÄ± ile bu veri toplanabilir.
3.  **Atmosferik GÃ¼rÃ¼ltÃ¼:** `random.org` gibi sistemlerin kullandÄ±ÄŸÄ±, doÄŸadaki radyo dalgalarÄ±.
4.  **KullanÄ±cÄ± DavranÄ±ÅŸlarÄ±:** Hoca buna **"Semi-Random"** (yarÄ± rastgele) dedi. Linux'taki `/dev/random` dosyasÄ±, farenin (mouse) hareket sÃ¼resi ve klavye basÄ±ÅŸ aralÄ±klarÄ±nÄ± (entropy pool) kullanÄ±r.

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** TRNG neden her zaman tercih edilmez?  
**Cevap:** TRNG sistemleri **yavaÅŸtÄ±r** Ã§Ã¼nkÃ¼ fiziksel bir sÃ¼reci beklemek zorundadÄ±r. AyrÄ±ca **tekrarlanamaz (non-deterministic)** olduÄŸu iÃ§in bir hatayÄ± (bug) debug etmek imkansÄ±zdÄ±r.

---

## 10. C++ `<random>` KÃ¼tÃ¼phanesi Mimarisi (46:00 - 54:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Eski C usulÃ¼ `rand() % 10` gibi yÃ¶ntemler hem istatistiksel olarak hatalÄ±dÄ±r (modulo bias) hem de esnek deÄŸildir. Modern C++ kÃ¼tÃ¼phanesi iki sorumluluÄŸu birbirinden ayÄ±rmÄ±ÅŸtÄ±r.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Architecture Layout)
```text
[ Bit KaynaÄŸÄ± ]             [ DÃ¶nÃ¼ÅŸtÃ¼rÃ¼cÃ¼ ]             [ SonuÃ§ ]
   ENGINE        ----->     DISTRIBUTION     ----->   Ä°stenen AralÄ±k
(URBG - Raw bits)         (Gaussian/Uniform)         (Zar: 1..6)
```

### âš™ï¸ Teknik Detay ve Sentaks
KÃ¼tÃ¼phanedeki URBG (Uniform Random Bit Generator) kategorileri:
1.  **Linear Congruential Engine:** HÄ±zlÄ±, az yer kaplar ama kalitesi ortadÄ±r.
2.  **Mersenne Twister Engine (`mt19937`):** En yaygÄ±n kullanÄ±lan. Devasa bir periyoda ve yÃ¼ksek kaliteye sahiptir.
3.  **Subtract with Carry Engine (Lagged Fibonacci):** FarklÄ± matematiksel model.

---

## 11. Engine Ä°Ã§ YapÄ±sÄ± ve Linear Congruential (54:00 - 1:02:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
En basit algoritmanÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak, rastgeleliÄŸin aslÄ±nda ne kadar "matematiksel" olduÄŸunu gÃ¶sterir.

### ğŸ” Arka Plan (Under the Hood)
**Linear Congruential Formula:** $x_{n+1} = (a \cdot x_n + c) \pmod m$
*   `a`: Multiplier (Ã‡arpan)
*   `c`: Increment (ArtÄ±ÅŸ)
*   `m`: Modulus (Mod faktÃ¶rÃ¼)

Hoca bir Ã¶rnek verdi: Seed (tohum) 7 olsun.
1. $(5 \times 7 + 3) \pmod{16} = 38 \pmod{16} \rightarrow$ **6**
2. $(5 \times 6 + 3) \pmod{16} = 33 \pmod{16} \rightarrow$ **1**
*GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere bir Ã¶nceki sayÄ±, bir sonrakinin girdisidir.*

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±: MT19937
*   **Periyot (Period):** Bir engine'in tekrar baÅŸa dÃ¶nmesi iÃ§in gereken adÄ±m sayÄ±sÄ±.
*   **MT19937:** Periyodu $2^{19937}-1$'dir. Hoca: "Bu sayÄ± evrendeki atom sayÄ±sÄ±ndan bile fazladÄ±r, pratik olarak asla tekrara dÃ¼ÅŸmez" dedi.
*   **State Size:** `mt19937` nesnesi yaklaÅŸÄ±k **5000 byte** yer kaplar. Hoca uyardÄ±: **"Kopyalamaktan kaÃ§Ä±nÄ±n, referansla geÃ§in!"**

---

## 12. Default Random Engine ve DaÄŸÄ±lÄ±mlar (1:02:00 - 1:12:00)

### âš™ï¸ Teknik Detay ve Sentaks
*   `std::default_random_engine`: Derleyiciye gÃ¶re deÄŸiÅŸen bir `type alias`dÄ±r. Ã‡oÄŸu modern derleyicide (GCC, MSVC) bu `mt19937`'dir.
*   **Distributions (DaÄŸÄ±lÄ±mlar):**
    *   `discrete` (SÃ¼reksiz): SayÄ±labilir deÄŸerler (Zar: 1, 2, 3...).
    *   `continuous` (SÃ¼rekli): Reel sayÄ±lar (Boy: 1.75...1.76 arasÄ± sonsuz nokta).

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Normal DaÄŸÄ±lÄ±m (Gaussian) nedir ve nerede kullanÄ±lÄ±r?  
**Cevap:** "Ã‡an EÄŸrisi" olarak bilinir. Ortalamada (mean) yÄ±ÄŸÄ±lma, uÃ§larda azalÄ±ÅŸ gÃ¶sterir. Hoca meÅŸhur **68-95-99.7 kuralÄ±nÄ±** hatÄ±rlattÄ±:
*   Verilerin %68'i ortalamadan 1 standart sapma ($\sigma$) mesafededir.
*   Verilerin %95'i 2 standart sapma mesafededir.

---

ğŸ“Œ **Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **Kripto GÃ¼venliÄŸi:** C++ standart random kÃ¼tÃ¼phanesi kriptografik olarak gÃ¼venli deÄŸildir. Kripto iÃ§in OpenSSL gibi kÃ¼tÃ¼phaneler kullanÄ±lmalÄ±dÄ±r.
2.  **Maliyet HatasÄ±:** `mt19937` gibi engine'ler bÃ¼yÃ¼ktÃ¼r. Fonksiyonlara deÄŸerle (by value) geÃ§mek performansÄ± ciddi etkiler.
3.  **Engine vs Distribution AyÄ±rÄ±mÄ±:** BirÃ§ok programcÄ± engine'den Ã§Ä±kan sonucu doÄŸrudan kullanmaya Ã§alÄ±ÅŸÄ±r. Hoca: "Engine size sadece ham bitleri verir, onlarÄ± mutlaka bir distribution (daÄŸÄ±lÄ±m) iÃ§inden geÃ§irmelisiniz" dedi.

Hoca'nÄ±n dersine en Ã¶n sÄ±radan devam ediyoruz. Åimdi `std::random` kÃ¼tÃ¼phanesinin derinliklerine, Ã¶zellikle daÄŸÄ±lÄ±mlarÄ±n (distributions) matematiksel modellerine ve engine'lerin (motorlarÄ±n) state (durum) yÃ¶netimine giriyoruz.

---

## 13. Bernoulli ve Discrete Distribution GiriÅŸ (01:12:00 - 01:17:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
GerÃ§ek hayatta her ÅŸey eÅŸit olasÄ±lÄ±klÄ± deÄŸildir. YazÄ±-tura atarken (Bernoulli) veya bir RPG oyununda kritik vuruÅŸ (critical hit) ÅŸansÄ±nÄ± hesaplarken belirli bir olasÄ±lÄ±ÄŸa ihtiyaÃ§ duyarÄ±z.

### âš™ï¸ Teknik Detay ve Sentaks
*   **Bernoulli Distribution:** Sadece `true` veya `false` Ã¼retir. Parametresi $p$'dir ($0.0 \le p \le 1.0$).
*   **Discrete Distribution:** Belirli tam sayÄ±larÄ±n (Ã¶rn: 0, 1, 2) her birine ayrÄ± bir "aÄŸÄ±rlÄ±k" (weight) atayarak daÄŸÄ±lÄ±m yapmanÄ±zÄ± saÄŸlar.

### ğŸ” Arka Plan (Under the Hood)
Hoca burada Ã§ok kritik bir garantiye deÄŸindi:
*   **Engine Garantisi:** `mt19937` gibi engine'ler, farklÄ± derleyicilerde (GCC, MSVC, Clang) aynÄ± seed ile **aynÄ±** sayÄ± sekansÄ±nÄ± Ã¼retmek zorundadÄ±r. Bu, standart tarafÄ±ndan garanti edilmiÅŸtir.
*   **Distribution BelirsizliÄŸi:** Ancak daÄŸÄ±lÄ±m sÄ±nÄ±flarÄ± (Ã¶rn: `uniform_int_distribution`) iÃ§in bÃ¶yle bir garanti yoktur! Derleyici yazarlarÄ± farklÄ± algoritmalar kullanabilir.

---

## 14. Engine'lerin Bellek YapÄ±sÄ± ve `mt19937` (01:17:00 - 01:27:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Hoca, engine nesnelerinin neden bÃ¼yÃ¼k olduÄŸunu ve `type_id` ile tÃ¼r Ã§Ä±karÄ±mÄ±nÄ±n nasÄ±l yapÄ±lacaÄŸÄ±nÄ± gÃ¶sterdi.

### âš™ï¸ Teknik Detay ve Sentaks
```cpp
#include <random>
#include <iostream>
#include <typeinfo>

int main() {
    using namespace std;
    mt19937 eng;

    // Hoca: Boyutuna dikkat edin!
    cout << "mt19937 size: " << sizeof(eng) << " byte" << endl; // <-- YaklaÅŸÄ±k 5000 byte

    // Hoca: Bu bir Function Object'tir (Fonksiyon Nesnesi).
    auto val = eng(); // operator() Ã§aÄŸrÄ±lÄ±r, yeni sayÄ± Ã¼retilir.

    // Min-Max DeÄŸerleri
    cout << "Min: " << mt19937::min() << endl; // 0
    cout << "Max: " << mt19937::max() << endl; // 2^32 - 1 (unsigned int max)
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** "Neden `mt19937 eng` nesnesini bir dÃ¶ngÃ¼ iÃ§inde oluÅŸturmamalÄ±yÄ±z?"  
**Cevap:** Ä°ki sebeple:
1.  **Performans:** 5000 byte'lÄ±k bir nesneyi her dÃ¶ngÃ¼de `construct` etmek Ã§ok maliyetlidir.
2.  **Rastgelelik:** EÄŸer `seed` verilmezse her seferinde "default seed" ile baÅŸlar ve dÃ¶ngÃ¼ her dÃ¶ndÃ¼ÄŸÃ¼nde **aynÄ±** ilk sayÄ±yÄ± Ã¼retir.

---

## 15. Serialization (SerileÅŸtirme) ve `discard` (01:27:00 - 01:38:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir simÃ¼lasyonu durdurup sonra kaldÄ±ÄŸÄ± yerden (aynÄ± state ile) devam ettirmek isterseniz ne yaparsÄ±nÄ±z? Ä°ÅŸte burada engine'lerin serileÅŸtirme Ã¶zelliÄŸi devreye girer.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, motorun durumunu (state) bir `std::stringstream`'e aktarÄ±p geri yÃ¼kledi:

```cpp
#include <sstream>

mt19937 eng1;
// ... 1000 tane sayÄ± Ã¼retildi ...

stringstream ss;
ss << eng1; // <-- SERIALIZATION (Durum yazÄ±ya dÃ¶kÃ¼ldÃ¼)

mt19937 eng2;
ss >> eng2; // <-- DESERIALIZATION (Durum geri yÃ¼klendi)

if (eng1 == eng2) { // operator== durumlarÄ± karÅŸÄ±laÅŸtÄ±rÄ±r.
    cout << "Ayni durumdalar!" << endl;
}
```

### ğŸ” Arka Plan (Under the Hood) - `discard` Fonksiyonu
Hoca: "EÄŸer 10.000'inci sayÄ±ya ihtiyacÄ±nÄ±z varsa, 9.999 tane sayÄ±yÄ± Ã¼retip Ã§Ã¶pe atmak yerine `eng.discard(9999)` kullanÄ±n."
*   `discard` iÅŸlemi dÃ¶ngÃ¼ ile tek tek sayÄ± Ã¼retmekten Ã§ok daha hÄ±zlÄ±dÄ±r; motorun iÃ§sel durumunu (state) matematiksel olarak ileri sarar.

---

## 16. `random_device` ve Non-Deterministic Seeding (01:38:00 - 01:50:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
ProgramÄ± her Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda farklÄ± bir seed (tohum) kullanmak iÃ§in eskiden `time(0)` kullanÄ±lÄ±rdÄ± (Hoca: "Fakir adamÄ±n seed'i"). Modern C++, donanÄ±msal rastgelelik sunan `std::random_device`'Ä± sunar.

### âš™ï¸ Teknik Detay ve Sentaks (Ä°diomatik YapÄ±)
```cpp
// Modern C++'ta Engine BaÅŸlatma Ä°diomu:
std::random_device rd; 
std::mt19937 eng{rd()}; // DonanÄ±msal bir sayÄ± ile tohumla.

// Hoca: random_device'Ä±n gerÃ§ekliÄŸini test edin:
std::cout << "Entropy: " << rd.entropy() << std::endl; 
// Hoca: EÄŸer 0 ise gerÃ§ek rastgele deÄŸildir, PRNG kullanÄ±yordur.
```

---

## 17. DaÄŸÄ±lÄ±mlarÄ±n Pratik KullanÄ±mÄ±: Zar Ã–rneÄŸi (01:50:00 - 02:04:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Engine'den Ã§Ä±kan devasa sayÄ±larÄ± 1 ile 6 arasÄ±na (zar) "istatistiksel olarak bozmadan" nasÄ±l indirgeriz?

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, 10 milyon zar atÄ±ÅŸÄ± yapÄ±p sonuÃ§larÄ± `std::map` ile saydÄ±:

```cpp
mt19937 eng{random_device{}()};
uniform_int_distribution dist{1, 6}; // <-- 1 ve 6 DAHÄ°L

map<int, int> counts;
for(int i=0; i < 10'000'000; ++i) {
    counts[dist(eng)]++; // <-- Engine, distribution'a argÃ¼man geÃ§ilir.
}

for(auto [val, count] : counts) {
    cout << val << " : " << count << endl; // Hepsi ~1.66 milyon olur.
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** `uniform_int_distribution` aralÄ±ÄŸÄ±na uÃ§ deÄŸerler dahil midir?  
**Cevap:** Evet, C++ standartlarÄ±nda bu daÄŸÄ±lÄ±mda her iki uÃ§ deÄŸer (closed interval $[a, b]$) sonuca dahildir. (Python veya diÄŸer dillerden gelenlerin en Ã§ok hata yaptÄ±ÄŸÄ± yer burasÄ±dÄ±r.)

---

ğŸ“Œ **Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **Cross-Compiler FarkÄ±:** Engine'ler aynÄ± sonucu Ã¼retse de, Distribution'lar (daÄŸÄ±lÄ±mlar) derleyiciden derleyiciye farklÄ±lÄ±k gÃ¶sterebilir.
2.  **`entropy()` KontrolÃ¼:** `random_device` her sistemde donanÄ±msal destek sunmayabilir, mutlaka `entropy()` ile kontrol edilmelidir.
3.  **Mapping HatasÄ±:** Manuel olarak modulo operatÃ¶rÃ¼ (`eng() % 6`) kullanmak, bazÄ± sayÄ±larÄ±n gelme olasÄ±lÄ±ÄŸÄ±nÄ± artÄ±rÄ±r (bias oluÅŸturur). Daima `distribution` sÄ±nÄ±fÄ± kullanÄ±lmalÄ±dÄ±r.

Hoca'nÄ±n dersine en Ã¶n sÄ±radaki titizliÄŸimizle devam ediyoruz. Dersin bu son bÃ¶lÃ¼mÃ¼nde, istatistiksel modellerin C++ koduna nasÄ±l dÃ¶kÃ¼ldÃ¼ÄŸÃ¼nÃ¼ (Normal ve Discrete DaÄŸÄ±lÄ±mlar) ve algoritmalarla entegrasyonu gÃ¶rÃ¼yoruz.

---

## 18. Normal (Gaussian) DaÄŸÄ±lÄ±m ve Ã‡an EÄŸrisi (02:04:00 - 02:16:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
DoÄŸadaki olaylarÄ±n Ã§oÄŸu (insan boyu, IQ seviyeleri, Ã¶lÃ§Ã¼m hatalarÄ±) uniform (eÅŸit ÅŸanslÄ±) daÄŸÄ±lmaz. OrtalamanÄ±n etrafÄ±nda bir yÄ±ÄŸÄ±lma olur. `std::normal_distribution`, bu "Ã‡an EÄŸrisi" (Bell Curve) modelini simÃ¼le etmek iÃ§in kullanÄ±lÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, Ã¼retilen sayÄ±larÄ± gÃ¶rselleÅŸtirmek iÃ§in harika bir histogram (yÄ±ldÄ±zlarla grafik) Ã¶rneÄŸi kodladÄ±:

```cpp
#include <random>
#include <map>
#include <string>
#include <cmath> // round iÃ§in

std::mt19937 eng{std::random_device{}()};
// Parametreler: Mean (Ortalama) = 50, Std Deviation (Standart Sapma) = 5
std::normal_distribution<double> dist{50, 5}; 

std::map<int, int> hist;
for (int i = 0; i < 100'000; ++i) {
    // Hoca: Ã‡Ä±kan double sonucu en yakÄ±n tam sayÄ±ya yuvarlayÄ±p map'e atÄ±yoruz.
    hist[std::round(dist(eng))]++;
}

// GÃ¶rselleÅŸtirme (Histogram)
for (auto [val, count] : hist) {
    // Hoca: YÄ±ldÄ±z sayÄ±sÄ±nÄ± Ã¶lÃ§eklendirmek iÃ§in count / 100 yaptÄ±k.
    std::cout << val << " " << std::string(count / 100, '*') << std::endl;
}
```

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Bell Curve)
Hoca'nÄ±n kodunun Ã§Ä±ktÄ±sÄ± ÅŸuna benzer bir simetri oluÅŸturur:
```text
40 **
45 ********
50 ****************  <-- Peak (Zirve) NoktasÄ± (Mean)
55 ********
60 **
```

### ğŸ” Arka Plan (Under the Hood)
Normal daÄŸÄ±lÄ±mda **68-95-99.7 kuralÄ±** geÃ§erlidir. Hoca, standart sapma ($\sigma$) arttÄ±kÃ§a Ã§an eÄŸrisinin yassÄ±laÅŸtÄ±ÄŸÄ±nÄ±, azaldÄ±kÃ§a sivrildiÄŸini (`std::normal_distribution::sigma()`) bizzat kod Ã¼zerinde deÄŸerleri deÄŸiÅŸtirerek gÃ¶sterdi.

---

## 19. Parametre YÃ¶netimi: `param_type` (02:16:00 - 02:17:00)

### âš™ï¸ Teknik Detay ve Sentaks
Her daÄŸÄ±lÄ±m sÄ±nÄ±fÄ±nÄ±n iÃ§inde `param_type` isimli bir `nested type` (iÃ§ tÃ¼r) bulunur. 
*   **Rationale:** EÄŸer bir daÄŸÄ±lÄ±mÄ±n 5-6 parametresi varsa, bunlarÄ± tek tek taÅŸÄ±mak yerine bu paket yapÄ± kullanÄ±lÄ±r.
*   `dist.param()`: Mevcut parametreleri paket olarak dÃ¶ndÃ¼rÃ¼r.
*   `dist.param(my_params)`: DaÄŸÄ±lÄ±mÄ±n parametrelerini tek seferde gÃ¼nceller (Set/Get mantÄ±ÄŸÄ±).

---

## 20. Bernoulli DaÄŸÄ±lÄ±mÄ±: Evet/HayÄ±r OlasÄ±lÄ±ÄŸÄ± (02:17:00 - 02:20:30)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Sadece iki ihtimalin (True/False) olduÄŸu durumlarÄ± modellemek iÃ§indir. 

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** `std::bernoulli_distribution` bir sÄ±nÄ±f ÅŸablonu (class template) mudur?  
**Cevap:** **HAYIR!** Hoca burayÄ± Ã¶zellikle vurguladÄ±. DiÄŸer Ã§oÄŸu daÄŸÄ±lÄ±mÄ±n aksine bu bir template deÄŸildir. DoÄŸrudan `bool` Ã¼retir.

### âš™ï¸ Teknik Detay ve Sentaks
```cpp
std::bernoulli_distribution b_dist(0.25); // %25 ihtimalle 'true' gelir.
bool is_hit = b_dist(eng);
```

---

## 21. Discrete Distribution (Hileli Zar ve Takvim) (02:20:30 - 02:34:00)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
EÄŸer elinizde sayÄ±labilir deÄŸerler varsa ve her birinin gelme aÄŸÄ±rlÄ±ÄŸÄ± (weight) farklÄ±ysa (Ã¶rn: bir oyun karakterinin AralÄ±k ayÄ±nda daha Ã§ok eÅŸya dÃ¼ÅŸÃ¼rmesi) kullanÄ±lÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, aylara gÃ¶re "yaÄŸmur yaÄŸma olasÄ±lÄ±ÄŸÄ±" gibi artan bir aÄŸÄ±rlÄ±k modeli kurdu:

```cpp
// AÄŸÄ±rlÄ±klar: 0. index (Ocak) dÃ¼ÅŸÃ¼k, sona doÄŸru artÄ±yor.
std::vector<double> weights = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 20};
std::discrete_distribution<int> d_dist(weights.begin(), weights.end());

// Hoca: Bu daÄŸÄ±lÄ±m 0 ile 11 arasÄ± tam sayÄ± Ã¼retir.
int month_index = d_dist(eng); 
```

---

## 22. Algoritmalarla Entegrasyon: `std::shuffle` (02:34:00 - End)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Eskiden kullanÄ±lan `std::random_shuffle` artÄ±k **deprecated** (kullanÄ±mdan kaldÄ±rÄ±ldÄ±). Ã‡Ã¼nkÃ¼ arka planda zayÄ±f olan `rand()` fonksiyonunu kullanÄ±yordu. Modern C++'ta bunun yerine mutlaka `std::shuffle` kullanÄ±lmalÄ±dÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, bir iskambil destesini (string iÃ§indeki karakterler) karma Ã¶rneÄŸi verdi:

```cpp
#include <algorithm>
#include <string>

std::string deck = "AKQJ1098765432";
std::mt19937 eng{std::random_device{}()};

// Hoca: ÃœÃ§Ã¼ncÃ¼ parametre olarak mutlaka bir ENGINE nesnesi verilmelidir.
std::shuffle(deck.begin(), deck.end(), eng); 

std::cout << "Karilmis Deste: " << deck << std::endl;
```

### ğŸ” Arka Plan (Under the Hood)
`std::shuffle` algoritmasÄ±, verilen aralÄ±ÄŸÄ± **Fisher-Yates** benzeri bir algoritmayla karÄ±ÅŸtÄ±rÄ±rken, rastgelelik kaynaÄŸÄ± olarak sizin verdiÄŸiniz modern `engine` nesnesini kullanÄ±r. Bu da karÄ±ÅŸtÄ±rma iÅŸleminin istatistiksel kalitesini garanti eder.

---

ğŸ“Œ **Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **Bernoulli Template DeÄŸildir:** `std::bernoulli_distribution<double>` yazmak sentaks hatasÄ±dÄ±r. SÄ±nÄ±fÄ±n kendisi doÄŸrudan kullanÄ±lÄ±r.
2.  **`std::shuffle` vs `std::random_shuffle`:** MÃ¼lakatlarda karÅŸÄ±nÄ±za Ã§Ä±kar; `random_shuffle` C++14 ile deprecated oldu, C++17'de silindi. ArtÄ±k sadece `shuffle` var.
3.  **Discrete Dist AralÄ±ÄŸÄ±:** `discrete_distribution` her zaman **0**'dan baÅŸlar. EÄŸer aralÄ±ÄŸÄ±nÄ±z 100-110 arasÄ±ndaysa, Ã§Ä±kan sonuca 100 ekleyerek ofset (offset) vermeniz gerekir.

---

**DERS SONU NOTU:**
Hoca, `chrono` ile zamanÄ± Ã¶lÃ§meyi, `random` ile kaliteli veri Ã¼retmeyi ve bu verileri `distribution` sÄ±nÄ±flarÄ±yla gerÃ§ek dÃ¼nya modellerine (Ã§an eÄŸrisi, aÄŸÄ±rlÄ±klÄ± olasÄ±lÄ±klar vb.) nasÄ±l dÃ¶nÃ¼ÅŸtÃ¼receÄŸimizi gÃ¶stererek dersi bitirdi. Bir sonraki hafta **Concurrency** (EÅŸzamanlÄ±lÄ±k) konularÄ±na geÃ§iÅŸ yapÄ±lacaÄŸÄ±nÄ± mÃ¼jdeledi.
