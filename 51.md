Merhaba, ben Necati Ergin hocamÄ±zÄ±n dersini en Ã¶n sÄ±radan takip eden, her detayÄ± notlarÄ±na aktarmaya Ã§alÄ±ÅŸan o titiz mÃ¼hendislik Ã¶ÄŸrencisiyim. HocamÄ±zÄ±n 51. ders gÃ¼nÃ¼nde (25 AralÄ±k 2024) tuttuÄŸum teknik derinliÄŸi yÃ¼ksek notlarÄ± aÅŸaÄŸÄ±da bulabilirsin.

---

# C++ DERS NOTLARI: DERS 51
**Konu:** SÄ±nÄ±f Ä°Ã§i `operator new/delete` Overloading ve AkÄ±llÄ± Pointer'lara GiriÅŸ (`std::unique_ptr`)
**Tarih:** 25 AralÄ±k 2024
**EÄŸitmen:** Necati Ergin

---

## 1. SÄ±nÄ±f Seviyesinde `operator new` ve `operator delete` Overloading [00:00 - 08:30]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Standart kÃ¼tÃ¼phanenin sunduÄŸu global `operator new` fonksiyonu genel amaÃ§lÄ± bir **allocator**'dÄ±r (tahsis edici). Ancak belirli sÄ±nÄ±flar iÃ§in performans optimizasyonu, bellek sÄ±zÄ±ntÄ±sÄ± kontrolÃ¼ veya kÄ±sÄ±tlÄ± kaynaklara sahip gÃ¶mÃ¼lÃ¼ sistemlerde (heap alanÄ± olmayan durumlar) Ã¶zel tahsisat algoritmalarÄ± gerekebilir.

### âš™ï¸ Teknik Detay ve Sentaks
Bir sÄ±nÄ±f iÃ§in `new` ifadesi (New Expression) Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, eÄŸer sÄ±nÄ±fÄ±n kendi iÃ§inde `operator new` fonksiyonu varsa, derleyici global olanÄ± deÄŸil, sÄ±nÄ±fa Ã¶zgÃ¼ olanÄ± Ã§aÄŸÄ±rÄ±r.

```cpp
#include <iostream>
#include <cstdlib> // malloc/free iÃ§in

class MyClass {
public:
    // <-- KRÄ°TÄ°K KURAL: 'static' yazÄ±lmasa dahi bu fonksiyonlar implicit (Ã¶rtÃ¼lÃ¼) olarak statiktir.
    void* operator new(std::size_t n) {
        std::cout << "MyClass icin ozel operator new cagrildi. Boyut: " << n << " byte\n";
        void* vp = std::malloc(n);
        if (!vp) {
            throw std::bad_alloc(); // Standart kural: Yer yoksa throw et.
        }
        return vp;
    }

    void operator delete(void* vp) {
        std::cout << "MyClass icin ozel operator delete cagrildi.\n";
        std::free(vp);
    }
};

class NetNet { }; // Kendi operator new'i yok.

int main() {
    auto p1 = new MyClass; // MyClass::operator new Ã§aÄŸrÄ±lÄ±r.
    delete p1;             // MyClass::operator delete Ã§aÄŸrÄ±lÄ±r.

    auto p2 = new NetNet;  // Global ::operator new Ã§aÄŸrÄ±lÄ±r.
    delete p2;             // Global ::operator delete Ã§aÄŸrÄ±lÄ±r.
}
```

### ğŸ” Arka Plan (Under the Hood)
- **Implicit Static:** C++ kurallarÄ±na gÃ¶re `operator new` ve `operator delete` fonksiyonlarÄ± non-static (statik olmayan) Ã¼ye fonksiyon olamazlar. Siz baÅŸÄ±na `static` yazmasanÄ±z da derleyici onlarÄ± statik kabul eder (C++'daki nadir istisnalardan biri).
- **Size Parameter:** `operator new` fonksiyonundaki `size_t` parametresine derleyici, nesnenin boyutunu **implicit** (Ã¶rtÃ¼lÃ¼) olarak geÃ§er.

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**S:** "New OperatÃ¶rÃ¼" (New Operator/Expression) overload edilebilir mi?
**C:** **HAYIR.** Overload edilen ÅŸey "New OperatÃ¶rÃ¼" deÄŸil, `operator new` **fonksiyonudur**. New Expression (ifade), Ã¶nce `operator new` fonksiyonunu Ã§aÄŸÄ±rÄ±r, sonra nesnenin constructor'Ä±nÄ± (yapÄ±cÄ± fonksiyon) Ã§alÄ±ÅŸtÄ±rÄ±r. New Expression'Ä±n bu akÄ±ÅŸÄ±nÄ± deÄŸiÅŸtiremezsiniz.

---

## 2. Ham Pointer'larÄ±n (Raw Pointers) Problemleri [13:00 - 33:00]

Hoca bu bÃ¶lÃ¼mde "pointerlarÄ±n problemi yoktur, onlarÄ± kullanan programcÄ±larÄ±n problemi vardÄ±r" diyerek Ã§ok sÄ±k yapÄ±lan hatalarÄ± sÄ±raladÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ham pointerlar (Naked/Raw Pointers) bize mÃ¼lkiyet (ownership) hakkÄ±nda hiÃ§bir bilgi vermez.

### âš™ï¸ Problem SenaryolarÄ±
1.  **MÃ¼lkiyet BelirsizliÄŸi:** `MyClass* p` ifadesine bakarak nesnenin dinamik, otomatik veya statik Ã¶mÃ¼rlÃ¼ olup olmadÄ±ÄŸÄ±nÄ± anlayamayÄ±z.
2.  **Dangling Pointer (Gezgin/BaÅŸÄ±boÅŸ GÃ¶sterici):** Nesne `delete` edildikten sonra aynÄ± adresi gÃ¶steren diÄŸer pointerlarÄ±n kullanÄ±lmaya devam edilmesi.
3.  **HatalÄ± Delete Formu:** `new` ile oluÅŸturulanÄ±n `delete[]` ile, `new[]` ile oluÅŸturulanÄ±n `delete` ile silinmesi riski (UB - TanÄ±msÄ±z DavranÄ±ÅŸ).
4.  **Resource Leak vs. Memory Leak:**
    - **Memory Leak (Bellek SÄ±zÄ±ntÄ±sÄ±):** Tahsis edilen alanÄ±n geri verilmemesi.
    - **Resource Leak (Kaynak SÄ±zÄ±ntÄ±sÄ±):** Destructor Ã§aÄŸrÄ±lmadÄ±ÄŸÄ± iÃ§in dosyanÄ±n kapatÄ±lmamasÄ±, mutex'in bÄ±rakÄ±lmamasÄ± gibi durumlar.

### ğŸš© Kritik Nokta: Exception Safety
Ham pointer kullanÄ±mÄ±nda en bÃ¼yÃ¼k risklerden biri Exception Handling (Ä°stisna YÃ¶netimi) sÄ±rasÄ±nda oluÅŸur:

```cpp
void func(int n) {
    MyClass* p = new MyClass(n);
    foo(); // <-- EÄER BURADA EXCEPTION THROW EDÄ°LÄ°RSE?
    delete p; // <-- Bu satÄ±ra asla gelinemez! Nesne leak olur.
}
```
**Hoca'nÄ±n Ã‡Ã¶zÃ¼mÃ¼:** EÄŸer akÄ±llÄ± pointerlar olmasaydÄ±, her ÅŸeyi `try-catch` bloklarÄ±na alÄ±p manuel `delete` yazmamÄ±z gerekirdi ki bu kodun okunabilirliÄŸini yok eder.

---

## 3. AkÄ±llÄ± Pointer'lar (Smart Pointers): std::unique_ptr [33:00 - 55:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
RAII (*Resource Acquisition Is Initialization*) prensibini pointer mÃ¼lkiyetine uygulamak iÃ§in. **Exclusive Ownership** (Tek Sahiplik) stratejisini benimser.

### âš™ï¸ std::unique_ptr Teknik YapÄ±sÄ±
`std::unique_ptr` bir sÄ±nÄ±f ÅŸablonudur (Class Template) ve iki parametre alÄ±r:
1.  **T:** HayatÄ± kontrol edilecek nesnenin tÃ¼rÃ¼.
2.  **D:** Deleter (Silici) sÄ±nÄ±fÄ±. VarsayÄ±lanÄ± `std::default_delete<T>`'dir.

```cpp
#include <memory>

template <typename T, typename D = std::default_delete<T>>
class unique_ptr {
    T* mp; // Thin Wrapper (Ä°nce sarmalayÄ±cÄ±)
public:
    ~unique_ptr() {
        if (mp != nullptr)
            D()(mp); // Deleter nesnesini Ã§aÄŸÄ±rÄ±r (genelde delete mp yapar)
    }
};
```

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
- **C++11:** `std::unique_ptr` dile eklendi. `std::auto_ptr` depreciate (kullanÄ±mdan kaldÄ±rÄ±lma aÅŸamasÄ±) edildi.
- **C++14:** `std::make_unique` eklendi.
- **C++17/20:** Lambda ifadelerinin deleter olarak kullanÄ±mÄ± ve `unevaluated context` desteÄŸi geliÅŸtirildi.

### ğŸ” Arka Plan (Thin Wrapper)
`std::unique_ptr` iÃ§in hoca "Thin Wrapper" terimini kullandÄ±. `sizeof(std::unique_ptr<T>)` deÄŸeri, Ã§oÄŸu durumda `sizeof(T*)` deÄŸerine eÅŸittir (genelde 8 byte). Yani akÄ±llÄ± pointer kullanmanÄ±n Ã§alÄ±ÅŸma zamanÄ±nda bir bellek maliyeti yoktur.

---

## 4. `std::unique_ptr` Temel OperasyonlarÄ± [01:02:00 - 01:30:00]

### âš™ï¸ KullanÄ±m Ã–rnekleri
Hoca Ã¶rnekler iÃ§in basit bir `Point` sÄ±nÄ±fÄ± tasarladÄ±:

```cpp
auto up = std::make_unique<Point>(3, 5, 7); // C++14 Tavsiye edilen yÃ¶ntem

// Pointer-like Interface (Pointer benzeri arayÃ¼z)
std::cout << *up;   // operator* overload'u Ã§aÄŸrÄ±lÄ±r.
up->set(10, 20, 30); // operator-> overload'u Ã§aÄŸrÄ±lÄ±r.

if (up) { // operator bool Ã§aÄŸrÄ±lÄ±r (BoÅŸ mu dolu mu sorgusu)
    std::cout << "Dolu!";
}
```

### ğŸš© Kritik Nokta: Explicit Constructor
`unique_ptr`'Ä±n `T*` alan constructor'Ä± **explicit**'tir. Bu yÃ¼zden aÅŸaÄŸÄ±daki kodlar hatadÄ±r:

```cpp
void foo(std::unique_ptr<Point> p);

// foo(new Point(1, 2, 3)); // <-- HATA! Implicit conversion (Ã¶rtÃ¼lÃ¼ dÃ¶nÃ¼ÅŸÃ¼m) yasak.
foo(std::unique_ptr<Point>(new Point(1, 2, 3))); // DoÄŸru: Explicit Ã§aÄŸrÄ±.
```

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Memory Layout)
```text
STACK                          HEAP
+-------------+                +-----------------+
| up (ptr) ---|--------------->| Point (3, 5, 7) |
+-------------+                +-----------------+
| unique_ptr  |                | Dinamik Nesne   |
+-------------+                +-----------------+
```

---

NotlarÄ±ma en ince ayrÄ±ntÄ±sÄ±yla, Necati HocamÄ±zÄ±n "kulaÄŸÄ±nÄ±za kÃ¼pe olsun" dediÄŸi her teknik detayla devam ediyorum. `std::unique_ptr` konusunun kalbine, mÃ¼lkiyet deÄŸiÅŸimlerine ve custom deleter (Ã¶zel silici) mekanizmalarÄ±na giriyoruz.

---

## 5. `std::unique_ptr` ve Atama OperatÃ¶rÃ¼ Ã‡Ä±kmazÄ± [01:30:00 - 01:34:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ham pointer dÃ¼nyasÄ±nda `p = new MyClass` yazmaya alÄ±ÅŸkÄ±n olan programcÄ±lar, akÄ±llÄ± pointer'larda da aynÄ±sÄ±nÄ± bekler. Ancak `unique_ptr` mÃ¼lkiyeti sÄ±kÄ± korur.

### âš™ï¸ Teknik Detay ve Sentaks
`unique_ptr` sÄ±nÄ±fÄ±nÄ±n `T*` (ham pointer) parametreli bir atama operatÃ¶rÃ¼ **YOKTUR.**

```cpp
std::unique_ptr<Point> uptr;
// uptr = new Point(2, 6, 3); // <-- HATA! Hoca: "BÃ¶yle bir atama operatÃ¶rÃ¼ fonksiyonu yok."
```

**Derleyici ÅŸu sebeple kÄ±zÄ±yor:** `unique_ptr` nesnesine doÄŸrudan ham pointer atayamazsÄ±nÄ±z. Bunun yerine sahipliÄŸi aÃ§Ä±kÃ§a (explicit) devretmeniz gerekir. Bu noktada imdadÄ±mÄ±za `reset()` fonksiyonu yetiÅŸir.

---

## 6. `reset()` Fonksiyonu: Yeni Sahiplik ve Eski SahipliÄŸin Sonu [01:34:00 - 01:40:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Var olan bir akÄ±llÄ± pointer'Ä±n iÃ§indeki nesneyi yok edip, yeni bir nesnenin sorumluluÄŸunu Ã¼stlenmek iÃ§in kullanÄ±lÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
```cpp
uptr.reset(new Point(2, 5, 7)); // Eski nesne delete edilir, yenisi mÃ¼lkiyete alÄ±nÄ±r.
uptr.reset(); // Sadece iÃ§indeki nesneyi delete eder, uptr "Empty State" (BoÅŸ durum) geÃ§er.
```

### ğŸ” Arka Plan (Under the Hood)
Hoca'nÄ±n basitÃ§e simÃ¼le ettiÄŸi `reset()` mantÄ±ÄŸÄ±:
```cpp
void reset(T* new_p = nullptr) {
    T* old_p = mp; // mp: iÃ§teki ham pointer
    mp = new_p;    // Yeni adresi al
    if (old_p != nullptr) {
        delete old_p; // <-- Eski nesne burada hayata veda eder.
    }
}
```

---

## 7. MÃ¼lkiyetin Transferi: Move Semantics [01:43:40 - 01:55:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
`unique_ptr` "Exclusive Ownership" (Tek Sahiplik) ilkesine dayanÄ±r. EÄŸer kopyalanabilseydi, iki farklÄ± akÄ±llÄ± pointer aynÄ± nesneyi silmeye Ã§alÄ±ÅŸÄ±rdÄ± (Double Deletion - Ã‡ifte Silme).

### âš™ï¸ Teknik Detay ve Sentaks
`unique_ptr` **Move-Only** (Sadece taÅŸÄ±nabilir) bir tÃ¼rdÃ¼r. Copy Constructor ve Copy Assignment fonksiyonlarÄ± `= delete` edilmiÅŸtir.

```cpp
auto up1 = std::make_unique<Point>(1, 2, 3);
// auto up2 = up1; // <-- HATA! Copy constructor silinmiÅŸ.
auto up2 = std::move(up1); // <-- BAÅARILI: MÃ¼lkiyet up1'den up2'ye geÃ§ti.

// up1 artÄ±k "BoÅŸ durumda" (Nullptr).
// up2 artÄ±k nesnenin tek sahibi.
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**S:** Bir `unique_ptr`'Ä± baÅŸka birine taÅŸÄ±rsak (move), eski pointer'a ne olur?
**C:** Eski pointer "Empty State" (BoÅŸ durum) geÃ§er, yani iÃ§indeki ham pointer `nullptr` olur. Onu hala kullanabilirsiniz ama `dereference` (*up) ederseniz **UB (TanÄ±msÄ±z DavranÄ±ÅŸ)** oluÅŸur.

---

## 8. Fabrika Fonksiyonu: `std::make_unique` [01:55:00 - 02:04:30]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
1. **Daha KÄ±sa Kod:** `std::unique_ptr<Point>(new Point(1, 2, 3))` yazmaktan kurtarÄ±r.
2. **Exception Safety:** Fonksiyon argÃ¼manlarÄ± oluÅŸturulurken oluÅŸabilecek karmaÅŸÄ±klÄ±klarda ham pointer'Ä±n leak (sÄ±zÄ±ntÄ±) olmasÄ±nÄ± engeller.

### âš™ï¸ Teknik Detay ve Sentaks
`std::make_unique` (C++14 ile geldi), kendisine verilen argÃ¼manlarÄ± **Perfect Forwarding** (MÃ¼kemmel AktarÄ±m) ile nesnenin constructor'Ä±na iletir.

```cpp
auto up = std::make_unique<Point>(3, 5, 7);
```

### ğŸ” Arka Plan (Perfect Forwarding Connection)
Hoca'nÄ±n yazdÄ±ÄŸÄ± `make_unique` taslaÄŸÄ±:
```cpp
template <typename T, typename... Args>
std::unique_ptr<T> my_make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...)); // <-- Hoca: "Bunu Perfect Forwarding konusunda gÃ¶rmÃ¼ÅŸtÃ¼k."
}
```

---

## 9. `release()` vs `get()` vs `reset()` KarÅŸÄ±laÅŸtÄ±rmasÄ± [02:04:30 - 02:18:00]

Hoca bu Ã¼Ã§lÃ¼nÃ¼n karÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ±n "Ã¶lÃ¼mcÃ¼l" olduÄŸunu vurguladÄ±.

| Fonksiyon | MÃ¼lkiyeti BÄ±rakÄ±r mÄ±? | Nesneyi Siler mi (Delete)? | Ne DÃ¶ndÃ¼rÃ¼r? |
| :--- | :--- | :--- | :--- |
| `get()` | **HAYIR** | HAYIR | Ham Pointer adresi |
| `release()` | **EVET** | **HAYIR** | Ham Pointer adresi |
| `reset()` | **EVET** | **EVET** | void |

### ğŸš© Kritik Hatalar Senaryosu
Hoca mÃ¼lakat tadÄ±nda ÅŸu hatalarÄ± gÃ¶sterdi:

```cpp
auto up = std::make_unique<Point>(3, 5, 8);
Point* p = up.get(); 
// delete p; // <-- FELAKET! up hala nesneye sahip sanÄ±yor, scope sonunda tekrar silmeye Ã§alÄ±ÅŸacak (Double Deletion).

std::unique_ptr<Point> up2(up.get()); 
// <-- FELAKET! Ä°ki farklÄ± unique_ptr aynÄ± nesneye sahip oldu. "Unique'lik gitti!"
```

---

## 10. Custom Deleters (Ã–zel Siliciler) [02:29:00 - 02:46:07]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Her kaynak `delete` ifadesiyle sonlandÄ±rÄ±lmaz. Ã–rneÄŸin bir dosyanÄ±n `fclose` ile kapatÄ±lmasÄ±, bir C-API handle'Ä±nÄ±n `DestroyList` gibi Ã¶zel bir fonksiyonla yok edilmesi gerekebilir.

### âš™ï¸ Teknik Detay ve Sentaks
`unique_ptr`'Ä±n ikinci template parametresi deleter tÃ¼rÃ¼dÃ¼r.

```cpp
// Senaryo: C-API tipi bir Liste yapÄ±sÄ±
struct List { };
List* CreateList();
void DestroyList(List*);

// Deleter olarak bir Lambda kullanÄ±mÄ±:
auto f_deleter = [](List* p) { 
    std::cout << "Liste imha ediliyor...\n";
    DestroyList(p); 
};

// uptr tanÄ±mÄ±
std::unique_ptr<List, decltype(f_deleter)> uptr(CreateList(), f_deleter);
```

### ğŸ” Arka Plan (Under the Hood)
EÄŸer bir Free Function (global fonksiyon) kullanÄ±yorsanÄ±z, `unique_ptr` nesnesinin constructor'Ä±na o fonksiyonun adresini geÃ§mek zorundasÄ±nÄ±z.
```cpp
void my_free(int* p) { std::free(p); }
std::unique_ptr<int, void(*)(int*)> up(static_cast<int*>(malloc(10)), my_free);
```

### ğŸ”— Ã–nceki Derslerle BaÄŸlantÄ±
Hoca, `decltype` ve `std::forward` konularÄ±nÄ±n burada nasÄ±l "durumdan vazife Ã§Ä±karttÄ±ÄŸÄ±nÄ±" hatÄ±rlattÄ±. AyrÄ±ca C++20 ile stateless lambdalarÄ±n `unevaluated context` iÃ§inde nasÄ±l kullanÄ±labileceÄŸine (isimlendirmeden tÃ¼r bilgisi alma) deÄŸindi.

---

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: Sahiplik Devri (Release/Reset)
```text
DURUM: up.reset(new_p)
1. Old_p = up.mp (Eskiye tutun)
2. up.mp = new_p (Yeniyi sahiplen)
3. delete old_p  (Eskiyi Ã¶ldÃ¼r)

DURUM: p = up.release()
1. temp = up.mp
2. up.mp = nullptr (MÃ¼lkiyeti bÄ±raktÄ±m!)
3. return temp     (Adresi kullanÄ±cÄ±ya ver, ne yaparsa yapsÄ±n)
```

---

