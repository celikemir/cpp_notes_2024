    Harika bir fikir! İşte çalışkan bir öğrencinin alacağı gibi detaylı notlar:

**C++ Dersi 18 Notları (28 Ağustos 2024)**

**Ders Başlangıcı ve Genel Bilgiler (00:00.000 - 00:35.260)**

*   **Tarih ve Saat:** 28 Ağustos 2024 Çarşamba, 19:30. 18. Ders.
*   **Katılım:** Önceki günlere göre daha az. Canlı katılımın önemi vurgulandı (soru sorma, tartışma).
*   **Konu:** Sınıfların statik üyeleri (`static members`).

**1. Sınıfların Statik Üyeleri (Static Members) - Tekrar (00:36.360 - 01:06.700)**

*   **Statik Veri Üyeleri (`static data members`):**
    *   `static` anahtar sözcüğü ile bildirilirler.
    *   Sınıfa aittirler, sınıftan oluşturulan nesnelere değil. Yani, o sınıfa ait tüm nesneler aynı statik veri üyesini paylaşır.
    *   Bellekte bir kere oluşturulurlar.
*   **Statik Üye Fonksiyonlar (`static member functions`):**
    *   `static` anahtar sözcüğü ile bildirilirler.
    *   Sınıfa aittirler, belirli bir nesneye değil.
    *   Ağırlıklı olarak bu konu inceleniyor.

**1.1. Statik Üye Fonksiyonların Özellikleri - Tekrar (01:06.700 - 04:21.120)**

*   **Bildirim:** `static` anahtar sözcüğü ile. `public`, `private` veya `protected` olabilirler.
*   **Erişim Kontrolü:** Sınıfın üye fonksiyonu oldukları için erişim kontrolüne tabidirler.
*   **Private Bölüme Erişim:** Sınıfın `private` bölümüne erişim hakları vardır. Bu, global fonksiyonlardan temel farklarından biridir (global fonksiyonlar `friend` bildirimi olmadan erişemez).
    *   *Hoca Notu:* Aslında assembly düzeyinde global fonksiyonlara benzerler, ancak kapsam ve lojik olarak sınıfla ilişkilendirilmişlerdir.
*   **İkilem:** Başlangıç seviyesinde programcılar "statik üye fonksiyon mu yapsam, global fonksiyon mu yapsam?" ikilemini yaşayabilir.
*   **Yasaklar:**
    *   Operatör fonksiyonları statik üye fonksiyon olamaz.
    *   Constructor'lar ve diğer özel üye fonksiyonlar (`special member functions`) statik üye fonksiyon olamaz.
*   **Tanımlama:**
    *   Sınıf içinde `inline` olarak tanımlanabilirler: `static int foo(int p) { /* ... */ }`
    *   Tanımı `.cpp` dosyasında yapılabilir (sınıf dışında).
*   **`this` Pointer'ı Yoktur:**
    *   Belirli bir nesneyle ilişkili olmadıkları için `this` pointer'ları yoktur.
    *   Bu nedenle `this` anahtar sözcüğü statik üye fonksiyon içinde kullanılamaz.
*   **`const` Anahtar Sözcüğü Kullanılamaz:**
    *   Statik üye fonksiyonlar `const` olamaz. Çünkü `const` nitelemesi, üye fonksiyonun gizli `this` parametresini niteler (`ClassName* const this` veya `const ClassName* const this` gibi). `this` pointer'ı olmadığı için `const` anlamsızdır.
*   **Non-Statik Veri Elemanlarına Erişim:**
    *   İsim arama açısından sınıfın non-statik veri elemanlarını "görebilirler".
    *   Ancak, bir nesneye bağlı olmadan doğrudan kullanamazlar. Örneğin, `mx` non-statik bir üye ise, statik fonksiyonda doğrudan `mx` kullanımı sentaks hatasıdır. Bir nesne üzerinden (`obj.mx` veya `ptr->mx`) erişmeleri gerekir (ve o nesnenin private'ına erişebilirler).
        ```cpp
        class MyClass {
            int mx;
            static int msx;
        public:
            static void staticFoo(MyClass& obj_ref, MyClass* obj_ptr) {
                // mx = 5; // HATA: Hangi nesnenin mx'i?
                obj_ref.mx = 5; // GEÇERLİ (MyClass'ın private'ına erişim)
                obj_ptr->mx = 10; // GEÇERLİ
                msx = 20;       // GEÇERLİ (statik üyeye doğrudan erişim)
            }
        };
        int MyClass::msx; // Tanımlama
        ```
*   **Statik Veri Elemanlarına Erişim:** Sınıfın statik veri elemanlarını doğrudan kullanabilirler.
*   **Private/Protected Bölümlere Erişim:** Sınıfın `private`, `protected` bölümlerine erişebilirler.
*   **Diğer Statik Üye Fonksiyonları Çağırma:** Sınıfın diğer statik üye fonksiyonlarını çağırabilirler.

**1.2. Statik Veri Elemanları ile İlgili Ek Notlar (04:21.120 - 09:50.360)**

*   **Bir Arkadaşın Sorusu Üzerine:** Statik veri elemanları global değişkenler gibidir, statik ömürlüdürler.
*   **Default Initialization:** Default initialize edilseler bile (yani `.cpp` dosyasında `int MyClass::mx;` gibi bir tanımlama yapılsa) önce **zero initialize** edilirler.
    *   Boolean tür: `false` olur.
    *   Pointer tür: `nullptr` olur.
    *   Sayısal türler: `0` olur.
    *   *Hoca Notu:* Zero initialization, bazı initialization kategorilerinde bir ön işlemdir.
*   **Sınıf İçindeki Bildirim:** Sınıf içindeki `static int mx;` bir **bildirimdir (declaration)**, tanım (definition) değildir (C++17 `inline static` hariç).
*   **Incomplete Type Statik Veri Elemanları:** Sınıf içindeki bildirim bir "non-defining declaration" olduğu için, sınıfın `incomplete type` türünden statik veri elemanları olabilir.
    *   Örnek: `static int arr[];` (boyutu belirsiz dizi) geçerli bir bildirimdir. Tanımı `.cpp` dosyasında yapılır: `int MyClass::arr[10];`
    *   Örnek: Sınıfın kendi türünden statik veri elemanı olabilir: `static MyClass obj;` (tanımı `.cpp`de).
    *   Örnek: `class Erg; static Erg x;` (Erg incomplete type iken) geçerlidir.
*   **Constructor Initializer List ile İlişkisi Yoktur:** Statik veri elemanları, nesneye ait olmadıkları için constructor initializer list ile initialize edilemezler. Main fonksiyonu çağrılmadan önce initialize edilirler.
*   **Static Initialization Order Fiasco:** Farklı kaynak dosyalardaki global değişkenlerin ve statik veri elemanlarının hangi sırayla initialize edileceği garanti altında değildir. Bir statik veri elemanının ilklendirmesi, başka bir global/statik değişkene bağlıysa, diğeri henüz hayata gelmemiş olabilir. Bu duruma "Static Initialization Order Fiasco" denir. Programcı bu sıralamayı sağlamak için özel örüntüler kullanmalıdır.

**1.3. Statik Üyelere Nesne Üzerinden Erişim (09:50.360 - 13:42.000)**

*   **Nokta (`.`) ve Ok (`->`) Operatörleri:** Hem statik veri üyeleri hem de statik üye fonksiyonlar, bir nesne (`myObject.static_member`) veya nesne pointer'ı (`myPtr->static_member`) üzerinden çağrılabilir/erişilebilir.
    *   Bazı diller bunu yasaklar, C++ izin verir.
    *   Bu erişim, aslında o nesneyle ilgili değildir. Sadece isim arama (name lookup) için nesnenin türü kullanılır.
    *   *Hoca Uyarısı:* Bu durum, özellikle statik ve non-statik fonksiyon isimleri benzerse kafa karışıklığına ve hatalara yol açabilir. Programcı, non-statik bir fonksiyon çağırdığını sanarken aslında statik bir fonksiyon çağırabilir ve sentaks hatası almayabilir.
        ```cpp
        class MyNec {
        public:
            static int mx;
            static void foo() { /* ... */ }
            void bar() { /* ... */ }
        };
        int MyNec::mx = 10;

        MyNec n;
        MyNec* p = &n;
        n.foo();      // Geçerli, MyNec::foo() çağrılır
        p->foo();     // Geçerli, MyNec::foo() çağrılır
        n.mx = 20;    // Geçerli, MyNec::mx'e erişilir
        // n.bar();   // Bu non-statik, nesne üzerinden çağrılır (normal durum)
        // MyNec::bar(); // HATA: bar non-statik
        ```
    *   Programcı, bu erişim şeklini bilerek de tercih edebilir.

**1.4. Statik Üye Fonksiyonların Private Üyelere Erişimi ve İdiomatik Kullanımlar (13:42.000 - 17:25.360)**

*   **Temel Fayda:** Statik üye fonksiyonlar, sınıfın `private` üyelerine (veri veya fonksiyon) erişebilir. Bu, global `friend` fonksiyonlara bir alternatif sunar.
*   **Parametre Olarak Alınan Nesnelerin Private'ına Erişim:**
    ```cpp
    class Nech {
        int mx;
    public:
        static void foo(Nech& n_ref, Nech* n_ptr) {
            n_ref.mx = 1; // GEÇERLİ
            Nech local_n;
            local_n.mx = 2; // GEÇERLİ
        }
    };
    ```
*   **Private Constructor İdiomu:** Sınıfın constructor'ı `private` yapılabilir. Bu durumda client kodlar doğrudan nesne oluşturamaz.
    *   Ancak, sınıfın (statik) üye fonksiyonları bu `private` constructor'ı çağırabilir.
    *   Bu, nesne oluşturma sürecini kontrol altına almak için kullanılır.
        ```cpp
        class MySingleton {
        private:
            MySingleton() { /* ... */ } // Private constructor
        public:
            static MySingleton& getInstance() {
                static MySingleton instance; // Private constructor burada çağrılır
                return instance;
            }
        };
        // MySingleton s; // HATA: constructor private
        MySingleton& ref = MySingleton::getInstance(); // GEÇERLİ
        ```

**2. Named Constructor Idiom (İsimlendirilmiş Constructor İdiomu) (17:25.360 - 25:31.500)**

*   **Problem:** Bazen aynı parametre türlerine sahip birden fazla constructor'a ihtiyaç duyulur, bu da C++'ta doğrudan mümkün değildir (overloading imzaya bakar, isimlere değil).
    *   Örnek: `Complex` sınıfı için kartezyen (`double re, double im`) ve kutupsal (`double angle, double distance`) koordinatlarla nesne oluşturma. İkisi de `Complex(double, double)` imzasına sahip olur, bu da sentaks hatasıdır.
*   **Çözüm (Named Constructor Idiom):**
    1.  Asıl constructor'ları `private` yapın. Gerekirse imzalarını ayırmak için (kullanılmayacak) farklı türde ek parametreler (tag dispatching gibi) eklenebilir.
        ```cpp
        class Complex {
            double m_re, m_im;
            // Helper struct'lar (tag'ler)
            struct CartesianTag {};
            struct PolarTag {};

        private:
            Complex(double p1, double p2, CartesianTag) { /* p1=re, p2=im */ }
            Complex(double p1, double p2, PolarTag) { /* p1=angle, p2=distance, dönüşüm yap */ }
        public:
            // ...
        };
        ```
    2.  `public static` üye fonksiyonlar oluşturun. Bu fonksiyonlar, isimleriyle hangi türde bir oluşturma yaptıklarını belirtirler ve `private` constructor'ları çağırarak nesne döndürürler.
        ```cpp
        class Complex {
            // ... (önceki private constructor'lar)
        public:
            static Complex createCartesian(double re, double im) {
                return Complex(re, im, CartesianTag{});
            }
            static Complex createPolar(double angle, double dist) {
                return Complex(angle, dist, PolarTag{});
            }
        };
        ```
*   **Avantajları:**
    *   Kodun okunabilirliği artar.
    *   Constructor overloading kısıtlamalarını aşar.
    *   Nesne oluşturma sürecini tek bir noktadan (bu statik fonksiyonlar) yönetme imkanı sunar.

**3. Sadece Dinamik Ömürlü Nesneler Oluşturma (28:53.000 - 33:46.640)**

*   **Amaç:** Bir sınıf türünden nesnelerin sadece `new` ifadesiyle (dinamik ömürlü) oluşturulmasını zorunlu kılmak; otomatik veya statik ömürlü nesne oluşturulmasını engellemek.
*   **Yöntem:**
    1.  Tüm constructor'ları `private` yapın.
        ```cpp
        class DynamicOnly {
        private:
            DynamicOnly() { /* ... */ }
            // DynamicOnly(int x) { /* ... */ } // Diğer constructor'lar da private
        public:
            // ...
        };
        ```
    2.  Nesneyi `new` ile oluşturan ve pointer (`DynamicOnly*`) döndüren bir `public static` üye fonksiyon sağlayın (örneğin `createObject`).
        ```cpp
        class DynamicOnly {
            // ... (önceki private constructor)
        public:
            static DynamicOnly* createObject() {
                return new DynamicOnly();
            }
            // ... (belki parametreli create versiyonları)
        };
        ```
*   **Kullanım:**
    ```cpp
    // DynamicOnly obj1; // HATA: constructor private
    // static DynamicOnly obj2; // HATA: constructor private
    DynamicOnly* p_dyn = DynamicOnly::createObject(); // GEÇERLİ
    // delete p_dyn; // Sorumluluk kullanıcıda veya sınıf bir delete mekanizması sunabilir.
    ```
*   **Not:** Kopyalama ve taşıma semantikleri de bu tasarımda dikkatle ele alınmalıdır (genellikle `delete` edilirler). `delete` işleminin nasıl yönetileceği (client mı, sınıfın başka bir statik üyesi mi vb.) tasarım kararıdır.

**4. Hayattaki Nesne Sayısını Takip Etme (34:02.320 - 42:46.720)**

*   **Amaç:** Belirli bir sınıf türünden o anda kaç tane nesnenin hayatta olduğunu ve/veya toplamda kaç nesne oluşturulduğunu bilmek.
*   **Yöntem:**
    1.  Sınıfa `private static` sayaç değişkenleri ekleyin (C++17 `inline` ile doğrudan sınıf içinde initialize edilebilirler, öncesinde `.cpp` dosyasında tanım gerekir).
        ```cpp
        class Countable {
        private:
            inline static int s_live_count = 0;
            inline static int s_total_created_count = 0;
        public:
            // ...
        };
        ```
    2.  Constructor(lar)'da bu sayaçları artırın.
        ```cpp
        Countable() {
            ++s_live_count;
            ++s_total_created_count;
        }
        ```
    3.  Destructor'da hayattaki nesne sayacını (`s_live_count`) azaltın.
        ```cpp
        ~Countable() {
            --s_live_count;
        }
        ```
    4.  Sayaç değerlerine erişim için `public static` get fonksiyonları sağlayın.
        ```cpp
        public:
            static int getLiveCount() { return s_live_count; }
            static int getTotalCreatedCount() { return s_total_created_count; }
        ```
*   **Önemli Uyarı:** Kopyalama (copy constructor, copy assignment) ve taşıma (move constructor, move assignment) işlemleri bu sayaçları doğru yönetmek için özel olarak implemente edilmeli veya `delete` edilerek yasaklanmalıdır. Aksi takdirde derleyicinin ürettiği kopyalama/taşıma işlemleri sayaçları güncellemeyeceği için yanlış sonuçlar alınır.
    *   Örnek: `Countable c2 = c1;` Eğer copy constructor özel olarak sayaçları artırmazsa, `s_live_count` hatalı olur. Bu tür sınıflar genellikle kopyalanamaz (`= delete`) yapılır.

**5. Nesneler Arası İletişim (Fighter Örneği) (42:46.720 - 01:02:58.060)**

*   **Amaç:** Bir sınıf türünden hayatta olan tüm nesnelerin birbirlerinden haberdar olmasını ve gerektiğinde iletişim kurabilmesini sağlamak (örneğin bir oyundaki karakterlerin diğer aktif karakterlerden yardım istemesi).
*   **Yöntem:**
    1.  Sınıf içinde, hayattaki nesnelerin adreslerini tutacak bir `private static` konteyner (örneğin `std::vector<Fighter*>`) tanımlayın. (Yine C++17 `inline` ile initialize edilebilir).
        ```cpp
        #include <vector>
        #include <string>
        #include <algorithm> // std::erase_if için (C++20) veya std::remove, std::find

        class Fighter {
        private:
            std::string m_name;
            inline static std::vector<Fighter*> s_active_fighters;
            // Kopyalamayı ve taşımayı engellemek genellikle bu senaryoda daha basittir
            Fighter(const Fighter&) = delete;
            Fighter& operator=(const Fighter&) = delete;
            Fighter(Fighter&&) = delete;
            Fighter& operator=(Fighter&&) = delete;
        public:
            // ...
        };
        ```
    2.  Constructor: Oluşturulan nesnenin adresini (`this`) bu statik konteynere ekleyin.
        ```cpp
        Fighter(const std::string& name) : m_name(name) {
            s_active_fighters.push_back(this);
        }
        ```
    3.  Destructor: Nesne yok edilirken adresini statik konteynerden çıkarın.
        *   C++20 ve sonrası için `std::erase(s_active_fighters, this);` veya `std::erase_if`.
        *   Öncesi için "erase-remove idiom": `s_active_fighters.erase(std::remove(s_active_fighters.begin(), s_active_fighters.end(), this), s_active_fighters.end());`
        ```cpp
        ~Fighter() {
            // C++20 std::erase
            std::erase(s_active_fighters, this);
        }
        ```
    4.  İletişim Fonksiyonu (örneğin `askForHelp`): Bu fonksiyon, statik konteyneri dolaşarak diğer hayattaki nesnelere erişir (kendisi hariç).
        ```cpp
        public:
            const std::string& getName() const { return m_name; }

            void askForHelp() const {
                std::cout << "[" << m_name << "]: Düşmanlar saldırıyor! Yardıma gelin:" << std::endl;
                for (const Fighter* other_fighter : s_active_fighters) {
                    if (other_fighter != this) { // Kendisinden yardım istemesin
                        std::cout << "  - " << other_fighter->getName() << std::endl;
                    }
                }
                std::cout << "Yetişin!" << std::endl;
            }
        ```
*   **Kullanım:** Farklı `Fighter` nesneleri oluşturulup yok edildiğinde, `s_active_fighters` listesi güncel kalır. Herhangi bir `Fighter` nesnesi `askForHelp` çağırdığında, o an hayatta olan diğer `Fighter`'lara ulaşır.

**GitHub Repo Bilgisi (25:54.000 - 27:15.020)**

*   Hoca, derslerde yazdığı örnek kodları ve ilgili C++ konularına ait kodları GitHub'da paylaşıyor.
*   Repolar belirli bir sıra izlemiyor, arama veya hocaya sorma yoluyla ilgili kodlar bulunabilir.
*   Bazı konular eksik, kurs sonuna kadar tamamlanacak.

**Ders İndeksi Talebi (27:18.800 - 28:46.060)**

*   Bir öğrenci, işlenen konuların ders numaralarıyla eşleştirildiği bir indeks talep etti.
*   Hoca, bunun faydalı olacağını kabul etti ve gönüllü yardımıyla oluşturulabileceğini belirtti.

**6. Singleton Tasarım Kalıbı (Design Pattern) (01:02:58.060 - 01:16:38.000)**

*   **Tanım:** Bir sınıfın yalnızca bir örneğinin (instance) olmasını garanti eden ve bu örneğe global bir erişim noktası sağlayan bir oluşturucu (creational) tasarım kalıbıdır.
*   **Köken ve Tartışma:**
    *   "Gang of Four" (GoF) - Design Patterns kitabında bahsedilen 23 kalıptan biri. (Gamma, Helm, Vlissides, Johnson).
    *   GoF yazarlarından birinin (hoca hangisi olduğunu hatırlamıyor) sonradan Singleton'ı kitaba dahil etmekten pişmanlık duyduğu belirtiliyor; "anti-pattern" olarak gördüğü söyleniyor.
    *   **Anti-Pattern Argümanları:**
        *   Global state yaratır, bu da test edilebilirliği zorlaştırır ve bağımlılıkları gizler.
        *   Sıklıkla, başlangıçta tek nesne yeterli gibi görünse de, projenin ilerleyen aşamalarında birden fazla nesneye ihtiyaç duyulabilir (örneğin, tek yazıcıdan çoklu yazıcıya geçiş). Bu durumda Singleton tasarımı büyük bir engel teşkil eder.
    *   **Kullanım Alanları:** Gömülü sistemler gibi bazı alanlarda veya mevcut tasarımdaki kısıtlamalar nedeniyle ehvenişer olarak kullanılabilir.
*   **Singleton'dan Beklentiler Değişebilir:**
    *   Nesne ömrü (program sonuna kadar mı, isteğe bağlı yok edilebilir mi?).
    *   Lazy initialization (ilk kullanımda mı oluşturulsun?).
    *   Thread-safety (çoklu thread ortamında güvenli mi?).
    *   Kalıtım (Singleton sınıfından kalıtım alınabilir mi?).
    *   Bu beklentilere göre farklı implementasyonlar gerekebilir.

**6.1. Temel Singleton Implementasyonu (Thread-Safe Değil) (01:16:38.000 - 01:23:33.080)**

*   **Yöntem:**
    1.  Constructor'ı (`Singleton()`) `private` yapın.
    2.  Kopyalama ve taşıma constructor/assignment operatörlerini `private` ve `delete` edin.
    3.  `private static` bir pointer (`Singleton* s_instance = nullptr;`) tanımlayın, bu pointer tek nesneyi tutacaktır. (C++17 `inline` ile sınıf içinde initialize edilebilir).
    4.  `public static` bir `getInstance()` metodu oluşturun (genellikle `Singleton&` veya `Singleton*` döndürür).
        *   Bu metod, `s_instance` null ise `new Singleton()` ile nesneyi oluşturur ve `s_instance`'a atar.
        *   Ardından `s_instance`'ı döndürür.
*   **Kod Örneği:**
    ```cpp
    class Singleton {
    private:
        inline static Singleton* s_instance = nullptr;

        Singleton() { std::cout << "Singleton created." << std::endl; }
        Singleton(const Singleton&) = delete;
        Singleton& operator=(const Singleton&) = delete;
        Singleton(Singleton&&) = delete;
        Singleton& operator=(Singleton&&) = delete;

    public:
        static Singleton* getInstance() {
            if (s_instance == nullptr) {
                s_instance = new Singleton();
            }
            return s_instance;
        }
        void doSomething() { std::cout << "Singleton doing something." << std::endl; }
        // NOT: s_instance'ın delete edilmesi için bir mekanizma yok.
        // Program sonuna kadar yaşar. Gerekirse destroyInstance() gibi bir
        // statik fonksiyon eklenebilir ama bu da kullanımını karmaşıklaştırır.
    };
    ```
*   **Dezavantajlar:**
    *   Bu basit implementasyon thread-safe değildir. Birden fazla thread aynı anda `getInstance()`'a girerse ve `s_instance` null ise, birden fazla nesne oluşturulabilir.
    *   Nesnenin ne zaman `delete` edileceği bir sorundur. Genellikle program sonuna kadar hayatta kalır.

**6.2. Meyers Singleton (01:24:42.160 - 01:30:20.280)**

*   **Scott Meyers** tarafından popülerleştirilmiş bir yöntemdir.
*   **Yöntem:**
    1.  Constructor'ı (`Singleton()`) `private` yapın.
    2.  Kopyalama ve taşıma constructor/assignment operatörlerini `private` ve `delete` edin.
    3.  `public static` bir `getInstance()` metodu oluşturun. Bu metod, `Singleton&` (referans) döndürür.
    4.  `getInstance()` metodunun *içinde* `static` bir yerel (local) değişken olarak nesneyi tanımlayın ve döndürün.
*   **Kod Örneği:**
    ```cpp
    class MeyersSingleton {
    private:
        MeyersSingleton() { std::cout << "MeyersSingleton created." << std::endl; }
        MeyersSingleton(const MeyersSingleton&) = delete;
        MeyersSingleton& operator=(const MeyersSingleton&) = delete;
        MeyersSingleton(MeyersSingleton&&) = delete;
        MeyersSingleton& operator=(MeyersSingleton&&) = delete;

    public:
        static MeyersSingleton& getInstance() {
            static MeyersSingleton instance; // Sihir burada!
            return instance;
        }
        void doSomething() { std::cout << "MeyersSingleton doing something." << std::endl; }
    };
    ```
*   **Avantajları:**
    *   **Lazy Initialization:** `instance` nesnesi, `getInstance()` fonksiyonu ilk kez çağrıldığında oluşturulur. Fonksiyon hiç çağrılmazsa nesne de oluşturulmaz.
    *   **Thread-Safe Initialization (C++11 ve sonrası):** Statik yerel değişkenlerin ilklendirilmesi C++11'den beri thread-safe olarak garanti edilir. Yani birden fazla thread aynı anda `getInstance()`'ı ilk kez çağırsa bile, `instance` yalnızca bir kez ve güvenli bir şekilde oluşturulur. (Nesnenin *kullanımı* thread-safe olmak zorunda değildir, sadece *ilklendirilmesi*.)
    *   **Otomatik Yok Edilme:** Program bittiğinde statik yerel değişken `instance` otomatik olarak yok edilir (destructor'ı çağrılır). `new`/`delete` ile uğraşmaya gerek kalmaz.
    *   Daha basit ve şık bir çözümdür.

---

---

Tamamdır, `Namespace` konusundan devam ediyoruz:

**7. Namespace (İsim Alanları) (01:30:34.300 - Devam Ediyor)**

**7.1. Namespace Kavramı ve Amacı (01:31:11.540 - 01:41:52.120)**

*   **Temel Problem: İsim Çakışması (Name Collision / Name Clash):**
    *   Büyük projelerde, özellikle farklı kişiler/ekipler tarafından geliştirilen veya farklı kütüphanelerden gelen modüller kullanıldığında, aynı isme sahip fonksiyonların, sınıfların, değişkenlerin vb. olması çok yaygın bir sorundur.
    *   C dilinde bu problemle başa çıkmak için genellikle isimlendirme konvansiyonları (örneğin, kütüphane önekleri: `mylib_open_file()`) kullanılır, ancak bu tam bir çözüm değildir ve isimlendirmeyi karmaşıklaştırır.
*   **Namespace'in Çözümü:**
    *   Namespace'ler, isimler için bir **kapsam (scope)** oluşturarak onları birbirinden **izole eder**.
    *   Bir dosya sistemindeki klasör (directory/folder) yapısına benzetilebilir: Farklı klasörlerde aynı isimde dosyalar bulunabilir. `C:\Belgelerim\rapor.txt` ile `C:\Muzik\rapor.txt` farklı dosyalardır.
    *   Namespace'ler de global isim alanını "bölümlere ayırarak" isimlerin karışmasını engeller.
*   **Global Namespace:** Hiçbir namespace içinde olmayan, en dıştaki kapsamdır. C'deki global kapsamın C++'taki karşılığıdır.
*   **Standart Kütüphane ve `std` Namespace:**
    *   C++ standart kütüphanesindeki tüm isimler (sınıflar, fonksiyonlar, nesneler vb.) `std` isimli bir namespace içinde tanımlanmıştır.
    *   Örneğin, `vector`, `cout`, `string` gibi isimler aslında `std::vector`, `std::cout`, `std::string` olarak kullanılır. Bu, kullanıcı kodundaki `vector` isimli bir değişkenle standart kütüphanenin `vector`'ünün çakışmasını engeller.

**7.2. Namespace Oluşturma (Defining Namespaces) (01:41:52.120 - 01:51:30.740)**

*   **Sentaks:**
    ```cpp
    namespace namespace_adi {
        // Bildirimler ve tanımlamalar buraya gelir
        // (değişkenler, fonksiyonlar, sınıflar, başka namespace'ler vb.)
        int x;
        void foo();
        class MyClass { /* ... */ };
        namespace NestedNamespace { /* ... */ }
    } // namespace_adi (kapanışta noktalı virgül YOKTUR!)
    ```
*   **Noktalı Virgül Uyarısı:** Namespace tanımının sonunda noktalı virgül (` ; `) **olmaz**. Eğer konulursa, sentaks hatası vermeyebilir çünkü global kapsamda boş bir ifade olarak yorumlanabilir, ancak namespace tanımının bir parçası değildir. Bu durum, sınıf tanımlarının sonundaki zorunlu noktalı virgülden dolayı kafa karışıklığına yol açabilir.
*   **Namespace'lerin Kapsamı:**
    *   Namespace'ler **yerel (local) düzeyde (bir fonksiyon içinde) oluşturulamaz**. Sentaks hatasıdır.
    *   Namespace'ler ya **global namespace** içinde ya da başka bir **namespace içinde (nested namespace)** oluşturulabilir.
*   **Nested Namespaces (İç İçe İsim Alanları):** Bir namespace başka bir namespace içinde tanımlanabilir.
    ```cpp
    namespace Outer {
        int outer_var;
        namespace Inner {
            int inner_var;
            void printVars() {
                // outer_var = 10; // Geçerli, Inner Outer'ı "görür"
                // inner_var = 20;
            }
        }
    }
    // Outer::Inner::inner_var kullanılabilir.
    ```
*   **Unnamed (Anonymous) Namespaces (İsimsiz İsim Alanları) (01:48:09.140 - 01:48:47.020):**
    *   Bir namespace isimsiz olarak da tanımlanabilir:
        ```cpp
        namespace {
            int internal_var; // Bu değişken sadece bu çeviri birimi (translation unit) içinde erişilebilir.
            void internal_func() { /* ... */ }
        }
        ```
    *   İsimsiz namespace içindeki bildirimler, bulundukları çeviri birimine (genellikle `.cpp` dosyası) **özeldir (internal linkage)**. Yani, C'deki `static` global değişkenler/fonksiyonlar gibi davranırlar. Başka `.cpp` dosyalarından erişilemezler. Bu, isimlendirilmiş namespace'lerden farklı bir davranıştır ve özellikle C'den geçiş yapanlar veya modül içi gizlilik isteyenler için önemlidir. Bu konuya daha sonra detaylı değinilecek.
*   **Namespace İçeriği:** Global namespace'de tanımlanabilen her şey (değişken, fonksiyon, sınıf, enum, başka namespace vb.) bir namespace içinde de tanımlanabilir.
    *   Namespace içindeki değişkenler de (eğer fonksiyon içinde değillerse) statik ömürlüdür.
*   **Namespace Bir Kapsamdır (Scope):**
    *   Aynı namespace içinde aynı isim birden fazla varlığa verilemez (overloading hariç).
    *   Farklı namespace'lerde aynı isimler çakışma yaratmadan kullanılabilir.
    *   Function overloading, aynı namespace içinde farklı imzalara sahip fonksiyonlar için geçerlidir. Farklı namespace'lerdeki aynı isimli fonksiyonlar overloading oluşturmaz.

**7.3. Namespace İçindeki İsimlere Erişim (01:56:23.240 - 02:01:36.060)**

*   **Scope Resolution Operator (`::`)**:
    *   **Binary Kullanım (Sınıf):** `ClassName::member_name` (Daha önce görüldü). `member_name`'i `ClassName` içinde arar.
    *   **Binary Kullanım (Namespace):** `namespace_adi::isim`
        *   `isim`'i `namespace_adi` içinde arar.
        *   Örnek: `std::cout`, `std::vector<int>`, `MyNamespace::my_function()`
    *   **Unary Kullanım:** `::global_isim`
        *   `global_isim`'i **doğrudan global namespace** içinde arar. Bu, yerel bir isim global bir ismi maskelediğinde (name shadowing/hiding) global isme erişmek için kullanılır.
        ```cpp
        int count = 100; // Global count

        void func() {
            int count = 10; // Yerel count, global count'u maskeler
            std::cout << count << std::endl;    // 10 (yerel)
            std::cout << ::count << std::endl;  // 100 (global)
        }
        ```
*   **Qualified Name (Nitelenmiş İsim):** `::`, `.` veya `->` operatörleriyle bir kapsam belirtilerek kullanılan isimlerdir (örneğin, `std::cout`, `myObject.member`, `ptr->member`).
*   **Unqualified Name (Nitelenmemiş İsim):** Doğrudan, kapsam belirtilmeden kullanılan isimlerdir. İsim arama kurallarına göre bulunurlar (genellikle en içteki kapsamdan dışa doğru).

**7.4. Namespace'lerin Kümülatif Doğası (02:04:51.680 - 02:09:52.900)**

*   **Aynı İsimli Namespace Bildirimleri Birleşir:** Bir çeviri birimi (translation unit) içinde aynı isme sahip birden fazla namespace tanımı yapılırsa, bunlar **tek bir namespace** olarak kabul edilir. İçerikleri birleşir.
    ```cpp
    // Dosya1.h
    namespace MyLib {
        void func1();
        int var1;
    }

    // Dosya2.h
    namespace MyLib { // Aynı MyLib'e ekleme yapar
        void func2();
        class Helper;
    }

    // Kullanici.cpp
    #include "Dosya1.h"
    #include "Dosya2.h"
    // MyLib şimdi func1, var1, func2, Helper içerir.
    // MyLib::func1();
    // MyLib::func2();
    ```
*   **Varlık Nedeni:** Bu özellik, büyük kütüphanelerin farklı bileşenlerini farklı başlık dosyalarında (`.h`) sunarken hepsini aynı ana namespace altında toplamasına olanak tanır. Standart kütüphane (`std`) bu şekilde çalışır. `iostream` başlık dosyası `std`'ye `cout`'u eklerken, `vector` başlık dosyası `std`'ye `vector` sınıfını ekler. Kullanıcı her iki başlığı da include ettiğinde, tüm bu isimler `std` namespace'i altında birleşmiş olur.
*   **Çakışma Durumu:** Eğer kümülatif namespace tanımlarında aynı isimde (ve overloading oluşturmayan) varlıklar bildirilirse, bu bir "redeclaration" veya "redefinition" hatası olur.
    ```cpp
    namespace Test { int x; }
    // ... başka kodlar ...
    namespace Test { double x; } // HATA: Test::x zaten var ve türü farklı (redefinition)
    ```
*   **Case Sensitivity:** Namespace isimleri, C++'taki tüm identifier'lar gibi **case-sensitive**'dir. `MyNS` ile `myns` farklı namespace'lerdir.

**7.5. Nested Namespaces ve Erişim Detayları (02:15:40.940 - 02:23:57.540)**

*   **Nested Namespace Kullanımı:** Standart kütüphanede de yaygındır.
    *   Örnek: `std::ranges::views::filter` (C++20 Ranges)
        *   `ranges` namespace'i `std` içinde nested.
        *   `views` namespace'i `std::ranges` içinde nested.
*   **Nested Namespace Tanımlama (Geleneksel):**
    ```cpp
    namespace N1 {
        namespace N2 {
            namespace N3 {
                int val;
            }
        }
    }
    // Erişim: N1::N2::N3::val
    ```
*   **Nested Namespace Tanımlama (C++17 ve Sonrası):** Daha kısa bir sentaksla birden fazla seviyede nested namespace tek seferde tanımlanabilir.
    ```cpp
    namespace N1::N2::N3 { // C++17
        int val;
        double other_val;
    }
    // Erişim: N1::N2::N3::val
    // N1::N2::N3::other_val
    ```
*   **Kümülatif Özellik Nested Durumda da Geçerli:**
    ```cpp
    namespace MyCompany::Networking {
        void init();
    }
    namespace MyCompany::Networking::Protocols { // Networking'e nested Protocols eklenir
        class HTTP;
    }
    namespace MyCompany { // Var olan MyCompany'e ekleme
        int version;
    }
    // MyCompany::version
    // MyCompany::Networking::init()
    // MyCompany::Networking::Protocols::HTTP
    ```
    Bu sentaks, `MyCompany`'nin var olduğunu, içinde `Networking`'in var olduğunu ve `Networking` içinde `Protocols`'ün var olduğunu (veya oluşturulacağını) belirtir.
*   **Operatör Önceliği:** Scope resolution operatörü (`::`), `++`, fonksiyon çağrı `()` gibi operatörlerden daha yüksek önceliğe sahiptir. Bu nedenle `MyNS::func()` yazdığınızda önce `MyNS::func` çözümlenir, sonra fonksiyon çağrılır; ekstra paranteze gerek yoktur.

**7.6. Nitelemesiz İsim Kullanımı Sağlayan Araçlar (02:32:00.120 - 02:34:31.680)**

Bir namespace içindeki ismi her seferinde `namespace_adi::isim` şeklinde nitelemek yerine, bazı durumlarda ismi nitelemeden kullanabilmek için C++ çeşitli mekanizmalar sunar. Bunlar, kod yazımını kısaltabilir ancak dikkatli kullanılmadığında isim çakışmalarına veya belirsizliklere yol açabilirler.

*   **Başlıca Araçlar:**
    1.  **`using` Declaration (Using Bildirimi)**
    2.  **`using namespace` Directive (Using Namespace Direktifi)**
    3.  **Argument Dependent Lookup (ADL) (Koenig Lookup olarak da bilinir)**
    4.  **`inline` Namespaces (C++11'de eklendi, ama C++17 ile kullanımı daha yaygınlaştı)** (Hoca bunu ayrı başlıkta ele alacak)

**7.7. `using` Declaration (Using Bildirimi) (02:34:31.680 - 02:42:31.360)**

*   **Sentaks:**
    ```cpp
    using namespace_adi::isim;
    ```
    *   Bu, `namespace_adi` içindeki belirli bir `isim`'i, `using` bildiriminin yapıldığı kapsama **sanki orada bildirilmiş gibi** enjekte eder. Sadece o tek ismi getirir, namespace'in tamamını değil.
    *   Birden fazla isim için (C++17 ve sonrası):
        ```cpp
        using namespace_adi::isim1, namespace_adi::isim2, namespace_adi::isim3;
        ```
        (Modern C++ öncesinde her isim için ayrı `using` bildirimi gerekiyordu.)
*   **Etkisi:**
    *   `using` bildirimi bir **bildirimdir** ve kendi skopuna sahiptir.
        *   Global skopta yapılırsa, etki alanı tüm global skop ve içindeki fonksiyonlar olur.
        *   Bir fonksiyon veya blok içinde yapılırsa, etki alanı sadece o fonksiyon/blok ile sınırlıdır.
    *   **Enjeksiyon ve Çakışma:** İsim, `using` bildiriminin yapıldığı skopa enjekte edildiği için, o skopta zaten aynı isimde başka bir varlık varsa (veya sonradan tanımlanırsa) **isim çakışması (redefinition/redeclaration hatası)** olur.
        ```cpp
        namespace NS {
            int x = 10;
            void func() {}
        }

        int x = 20; // Global x

        // using NS::x; // HATA: Global skopta zaten 'x' var.
                       // NS::x'i global skopa enjekte etmeye çalışır.

        void test() {
            int x = 30; // Yerel x
            // using NS::x; // HATA: test() skopunda zaten 'x' var.

            using NS::func; // GEÇERLİ: test() skopuna NS::func enjekte edilir.
            func();         // Aslında NS::func() çağrılır.
        }

        namespace AnotherNS {
            using NS::x; // GEÇERLİ: NS::x'i AnotherNS'e enjekte eder.
                         // Artık AnotherNS::x kullanılabilir (NS::x'e işaret eder).
            // int x = 5; // HATA: AnotherNS'de x zaten using ile enjekte edildi.
        }
        // AnotherNS::x; // Kullanılabilir.
        ```
*   **Kullanım Yeri ve Faydası:**
    *   Genellikle `.cpp` dosyalarında veya fonksiyonların içinde kullanılır. Başlık dosyalarında (`.h`) global skopta `using` bildirimi yapmak, o başlığı include eden tüm dosyalara bu ismi enjekte edeceği için genellikle kötü bir pratiktir (isim çakışması riskini artırır).
    *   Uzun namespace isimlerini tekrar tekrar yazmaktan kurtarır, ancak sadece ihtiyaç duyulan belirli isimleri kapsama dahil ettiği için `using namespace` direktifine göre daha güvenlidir.
*   **Modern C++ ile Gelen Değişiklik:** C++17 ile virgülle ayrılmış liste halinde birden fazla `using` bildirimi tek bir `using` anahtar sözcüğüyle yapılabilir hale geldi. Bu, özellikle variadic template'lerle çalışırken kullanışlıdır.

---

---

Tamamdır, `using namespace` direktifinden devam ediyoruz:

**7.8. `using namespace` Directive (Using Namespace Direktifi) (Bir sonraki dersin konusu, ancak genel bir bakış)**

*   **Sentaks:**
    ```cpp
    using namespace namespace_adi;
    ```
*   **Temel Farkı ve Etkisi:**
    *   `using` declaration'dan farklı olarak, `using namespace namespace_adi;` direktifi, `namespace_adi` içindeki **tüm isimleri** direktifin bulunduğu kapsama **enjekte etmez**.
    *   Bunun yerine, direktifin geçerli olduğu kapsamda **niteliksiz isim arama (unqualified name lookup)** yapıldığında, derleyicinin belirtilen `namespace_adi`'nin **içine de bakmasını** sağlar.
    *   Yani, `isim` yazdığınızda, derleyici önce mevcut kapsamda (ve onu çevreleyen kapsamlarda) arar. Bulamazsa ve bir `using namespace SomeNS;` direktifi aktifse, `SomeNS`'in içine de bakar.
*   **Kapsamı:** `using` declaration gibi, `using namespace` direktifinin de bir skopu vardır.
    *   Global skopta yapılırsa, o çeviri biriminin sonuna kadar geçerlidir.
    *   Bir fonksiyon veya blok içinde yapılırsa, sadece o fonksiyon/blok için geçerlidir.
*   **Potansiyel Sorunlar:**
    *   **İsim Çakışması ve Belirsizlik (Ambiguity):** Eğer `using namespace NS1;` ve `using namespace NS2;` direktifleri aynı skopta aktifse ve hem `NS1` hem de `NS2` içinde aynı `isim` varsa (ve bu `isim` mevcut skopta tanımlı değilse), `isim`'i niteliksiz kullanmak **belirsizlik (ambiguity) hatasına** yol açar. Derleyici hangi `isim`'in kastedildiğini bilemez.
        ```cpp
        namespace Alpha { void commonFunc(); int val; }
        namespace Beta  { void commonFunc(); double val; }

        void process() {
            using namespace Alpha;
            using namespace Beta;
            // commonFunc(); // HATA: Belirsiz! Alpha::commonFunc mu, Beta::commonFunc mu?
            // val = 10;   // HATA: Belirsiz! Alpha::val mi, Beta::val mi?

            Alpha::commonFunc(); // GEÇERLİ (Nitelikli kullanım)
            Beta::val = 3.14;    // GEÇERLİ (Nitelikli kullanım)
        }
        ```
    *   **Gizli Bağımlılıklar ve Okunabilirlik Zorluğu:** Bir isim niteliksiz kullanıldığında, hangi namespace'den geldiği hemen anlaşılamayabilir, bu da kodun okunabilirliğini ve bakımını zorlaştırır. Özellikle çok sayıda `using namespace` direktifi kullanıldığında bu sorun büyür.
*   **Kullanım Önerileri:**
    *   **Başlık Dosyalarında (`.h`) ASLA Kullanmayın (Global Skopta):** Bir başlık dosyasının global skopunda `using namespace std;` gibi bir direktif kullanmak, o başlığı include eden tüm `.cpp` dosyalarının global namespace'ini "kirletir" ve çok ciddi isim çakışması riskleri doğurur. Bu, C++'ta yapılan en yaygın ve tehlikeli hatalardan biridir.
    *   **`.cpp` Dosyalarında (Yerel Kapsamlarda) Dikkatli Kullanım:** Fonksiyon içleri gibi dar kapsamlarda, belirli bir namespace'den çok sayıda isim kullanılacaksa ve isim çakışması riski düşükse tercih edilebilir. Ancak yine de `using` declaration'lar genellikle daha güvenli bir alternatiftir.
    *   **`std` Namespace İçin:** `using namespace std;` direktifini global skopta kullanmaktan kesinlikle kaçınılmalıdır. Gerekirse, fonksiyon içlerinde veya `.cpp` dosyasının en üstünde (diğer include'lardan sonra) çok dikkatli bir şekilde kullanılabilir, ancak genellikle `std::` ön ekiyle veya spesifik `using std::cout;` gibi `using` declaration'larla çalışmak daha iyidir.

**7.9. Argument Dependent Lookup (ADL) / Koenig Lookup (Bir sonraki dersin konusu, ancak genel bir bakış)**

*   **Amacı:** Özellikle operatörlerin ve bazı fonksiyonların, argümanlarının türlerinin bulunduğu namespace'lerde de aranmasını sağlayarak daha doğal bir sentaksla çağrılmalarına olanak tanımaktır.
*   **Nasıl Çalışır (Basitçe):**
    *   Bir fonksiyon çağrısı niteliksiz bir isimle yapıldığında (örneğin, `myFunc(obj)`), normal isim arama kurallarına ek olarak, derleyici fonksiyonun argümanlarının (`obj`'nin) türlerinin tanımlandığı namespace'lere (ve onların üst namespace'lerine) de bakar.
*   **Neden Önemlidir?**
    *   **Operatör Overloading:** `std::cout << myCustomObject;` gibi bir ifadenin çalışabilmesi ADL sayesindedir. Eğer `operator<<` fonksiyonu `myCustomObject`'in namespace'inde (veya global namespace'de) tanımlıysa, `std::` namespace'inde olmasa bile ADL ile bulunur.
        ```cpp
        namespace MyNS {
            class MyType { /* ... */ };
            // MyType için << operatörü MyNS içinde tanımlanıyor
            std::ostream& operator<<(std::ostream& os, const MyType& mt) {
                // ... MyType'ı os'ye yazdır ...
                return os;
            }
        }

        int main() {
            MyNS::MyType obj;
            // using namespace MyNS; // Gerekli DEĞİL
            // MyNS::operator<<(std::cout, obj); // Yazılabilir ama hantal
            std::cout << obj; // ADL sayesinde çalışır!
                              // Derleyici, obj'nin türü olan MyNS::MyType'ın namespace'i olan
                              // MyNS içinde de operator<< arar.
            return 0;
        }
        ```
    *   **Genel Fonksiyonlar:** Bazı genel amaçlı fonksiyonlar da (örneğin `swap`), argümanlarının namespace'lerinde bulunarak daha jenerik bir şekilde kullanılabilir.
*   **Potansiyel Sürprizler:** ADL, bazen beklenmedik fonksiyonların çağrılmasına neden olabilir eğer isimler farklı namespace'lerde çakışıyorsa ve argüman türleri bu namespace'lerle ilişkiliyse. Bu nedenle, ADL'nin nasıl çalıştığını anlamak önemlidir.
*   **ADL ve `using` Direktifleri:** ADL, `using namespace` direktiflerinden bağımsız olarak çalışır.

**7.10. `inline` Namespaces (C++11) (Bir sonraki dersin konusu, ancak genel bir bakış)**

*   **Sentaks:**
    ```cpp
    inline namespace V1 { // V1 inline bir namespace olarak işaretlendi
        void func();
        class Data {};
    }
    // İleride yeni bir versiyon:
    // namespace V2 {
    //    void func(); // Belki farklı implementasyon
    //    class Data {}; // Belki farklı yapı
    // }
    ```
*   **Amacı ve Etkisi:**
    *   Bir `inline namespace`, sanki üyeleri bir üst (parent/enclosing) namespace'de tanımlanmış gibi davranır. Yani, `inline namespace MyLib_V2 { ... }` içindeki bir `foo` fonksiyonuna, doğrudan üst namespace üzerinden `MyLib::foo()` şeklinde erişilebilir, `MyLib::MyLib_V2::foo()` yazmaya gerek kalmaz.
    *   **Sürüm Yönetimi (Versioning):** Kütüphane geliştiricilerinin, kütüphanelerinin farklı sürümlerini aynı anda sunmalarına ve kullanıcıların varsayılan olarak en son (veya belirli bir) inline edilmiş sürüme erişmelerine olanak tanır.
        *   Bir kütüphanenin `namespace MyLib { inline namespace V2 { ... } namespace V1 { ... } }` yapısı olabilir. Kullanıcı `MyLib::someFunc()` yazdığında, eğer `V2` inline ise `V2::someFunc` çağrılır. Eski bir sürüme (`V1`) erişmek isteyen kullanıcılar ise açıkça `MyLib::V1::someFunc()` yazabilirler.
    *   Kütüphaneler, yeni bir sürüm çıkardıklarında eski `inline namespace V1`'i `inline` olmaktan çıkarıp yeni `inline namespace V2`'yi `inline` yapabilirler. Bu, mevcut kullanıcı kodlarının çoğunun kırılmadan yeni sürüme geçişini kolaylaştırır.
*   **ADL ile Etkileşim:** `inline namespace` içindeki isimler, ADL açısından da üst namespace'in bir parçası olarak kabul edilir.

**Genel Namespace Kullanım Stratejileri ve İyi Pratikler (Özet)**

1.  **Global `using namespace` Direktiflerinden Kaçının:** Özellikle başlık dosyalarında (`.h`) global `using namespace std;` gibi direktifler kesinlikle kullanılmamalıdır.
2.  **`using` Declaration'ları Tercih Edin:** Belirli isimlere ihtiyaç duyulduğunda, `using namespace_adi::isim;` bildirimi, `using namespace` direktifine göre daha güvenli ve okunabilirdir. Bunları da genellikle `.cpp` dosyalarında veya dar kapsamlarda kullanın.
3.  **Tam Nitelikli İsimler (Fully Qualified Names):** Şüpheye düştüğünüzde veya başlık dosyalarında isimlere atıfta bulunurken, `std::vector`, `MyNamespace::MyClass` gibi tam nitelikli isimler kullanmak en güvenli yoldur.
4.  **Kendi Kütüphanelerinizi Namespace İçine Alın:** Kendi yazdığınız kütüphane veya modülleri, başka kodlarla çakışmaması için mutlaka kendi özel namespace'iniz içine alın.
5.  **ADL'nin Farkında Olun:** Özellikle operatörlerle ve jenerik kodlarla çalışırken ADL'nin isim aramasını nasıl etkilediğini bilin.
6.  **`inline` Namespace'leri Anlayın:** Eğer kütüphane sürüm yönetimi gibi bir senaryonuz varsa veya bu şekilde tasarlanmış kütüphaneler kullanıyorsanız `inline` namespace'lerin nasıl çalıştığını öğrenin.

**Tüm Anlatılanları Kapsayan Bir Kod Bloğu Örneği (Basitleştirilmiş):**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric> // std::iota için

// 1. Kendi Namespace'imiz ve Nested Namespace
namespace MyLibrary {
    std::string library_name = "My Awesome Lib";

    namespace Utilities { // Nested Namespace
        void printMessage(const std::string& msg) {
            std::cout << "[Utility] " << msg << std::endl;
        }

        // C++17 inline namespace örneği (versiyonlama için)
        inline namespace V2 {
            int getVersion() { return 2; }
            void processData(const std::vector<int>& data) {
                std::cout << "Processing data (V2): ";
                for (int x : data) std::cout << x << " ";
                std::cout << std::endl;
            }
        }
        namespace V1 { // Eski versiyon, inline değil
            int getVersion() { return 1; }
             void processData(const std::vector<int>& data) {
                std::cout << "Processing data (V1 - legacy): ";
                for (int x : data) std::cout << x << " ";
                std::cout << std::endl;
            }
        }
    } // namespace Utilities

    // ADL için örnek bir sınıf ve operatör
    class Point {
    public:
        int x, y;
        Point(int x_val, int y_val) : x(x_val), y(y_val) {}
    };

    // Point için operator<< MyLibrary namespace'inde tanımlı
    std::ostream& operator<<(std::ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }

} // namespace MyLibrary

// İsimsiz namespace (internal linkage)
namespace {
    void log_internal(const std::string& log_msg) {
        // Bu fonksiyon sadece bu .cpp dosyasından erişilebilir
        std::cout << "[Internal Log] " << log_msg << std::endl;
    }
}

void demo_function() {
    // 2. using declaration örneği
    using MyLibrary::Utilities::printMessage;
    printMessage("Using declaration in action!"); // Niteliksiz kullanım

    using std::vector; // std::vector için using declaration
    vector<int> numbers(5);
    // std::iota(numbers.begin(), numbers.end(), 1); // iota için using yapmadık, std:: gerekli
    // veya:
    using std::iota;
    iota(numbers.begin(), numbers.end(), 10);


    // 3. using namespace directive örneği (dar kapsamda)
    // { // Daha da dar bir skop oluşturabilirdik
    //    using namespace MyLibrary::Utilities;
    //    processData(numbers); // V2::processData çağrılır (inline olduğu için)
    //    std::cout << "Version: " << getVersion() << std::endl; // V2::getVersion
    // }
    // Yukarıdaki blok yerine daha güvenli:
    MyLibrary::Utilities::processData(numbers);
    std::cout << "Current Lib Version: " << MyLibrary::Utilities::getVersion() << std::endl;
    std::cout << "Legacy Lib V1 Version: " << MyLibrary::Utilities::V1::getVersion() << std::endl;


    // 4. Tam nitelikli isim kullanımı
    std::cout << "Library Name: " << MyLibrary::library_name << std::endl;

    // 5. ADL (Argument Dependent Lookup)
    MyLibrary::Point p1(5, 7);
    std::cout << "Point p1: " << p1 << std::endl; // MyLibrary::operator<< ADL ile bulunur

    log_internal("Demo function finished."); // İsimsiz namespace'den fonksiyon çağrısı
}

// Global namespace'de bir değişken (ADL veya using ile karıştırılmamalı)
int global_value = 42;

int main() {
    // Unary scope resolution ile global erişim
    int global_value = 100; // main içindeki local global_value
    std::cout << "Local global_value: " << global_value << std::endl;   // 100
    std::cout << "Global global_value: " << ::global_value << std::endl; // 42

    demo_function();

    return 0;
}
```

Bu notlar ve örnek, `Namespace` konusunun temel ve bazı ileri düzey yönlerini kapsamaktadır. Bir sonraki derste muhtemelen `using namespace` direktifinin ve ADL'nin daha derinlemesine incelenmesi, isim arama kurallarının detayları ve olası kenar durumlar ele alınacaktır.

