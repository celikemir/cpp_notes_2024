Harika bir ders! İşte çalışkan bir öğrencinin alacağı notlar:

**Ders Notları: C++ `std::string` Sınıfı - Devam (21. Ders)**
**Tarih:** 9 Eylül 2024 Pazartesi
**Saat:** 19.30

---

**I. Giriş ve Hatırlatmalar (00:00.000 - 00:33.020)**

*   **Genel Bakış:** `std::string` sınıfı incelenmeye devam edilecek.
*   **`std::string` Temeli:**
    *   `std::string` bir sınıf şablonu olan `std::basic_string<char>`'ın bir tür eş ismidir (type-def). `basic_string` bir "class template"ten oluşturulmuş bir "instantiation"dır.
    *   Aynı zamanda bir STL **container**'ıdır ve container olmanın tüm gereklerini karşılar.
*   **Container Olmanın Avantajları:**
    *   STL algoritmaları (jenerik global fonksiyonlar) stringler üzerinde çalıştırılabilir.
    *   Bazı string işlemleri üye fonksiyonlarla, bazıları ise global algoritmalarla yapılır.
*   **"Algoritm" Terimi:**
    1.  Computer Science'daki genel algoritma kavramı.
    2.  C++ STL'deki jenerik, global fonksiyonlar (çoğu veri yapıları üzerinde temel algoritmaları implemente eder).
*   **Temel `get` Fonksiyonları (Özet):** `size()`, `length()`, `empty()`, `capacity()`.
    *   `std::string` dinamik bir dizi (dynamic array) veri yapısı kullandığı için **kapasite** kavramı önemlidir.
    *   Kapasite tipik olarak `size` (veya `length`) değerinden büyüktür veya eşittir.
    *   `size == capacity` olduğunda bir ekleme (insertion) işlemi **reallocation**'a (yeniden yer tahsisine) neden olur.
*   **Reallocation'ın Önemli Sonuçları:**
    1.  **`reallocation takes time`**: Zaman alan, maliyetli bir işlemdir.
    2.  **`reallocation invalidates pointers, references, and iterators`**: Eski bellek alanını gösteren işaretçiler, referanslar ve iteratörler geçersiz (invalid/dangling) hale gelir.
*   **`std::string` Arayüzü:**
    *   Çok geniş bir arayüze sahiptir çünkü yazılarla ilgili ihtiyaçlar fazladır.
    *   Jenerik bir sınıf olduğu için, çağrılmayan fonksiyonların kodu üretilmez, bu da büyük arayüzün dezavantajını azaltır.
    *   **Function Overloading** ve **Operator Overloading** için mükemmel bir örnektir.
        *   Toplama (`+`), indexleme (`[]`), karşılaştırma (`==`, `<`, vb.), ekleyerek atama (`+=`) operatörleri overload edilmiştir.

---

**II. `std::string` Öğrenme Zorlukları ve Parametrik Yapı Kalıpları (00:34.040 - 01:17.480, Resimlerle Tekrar: 18:27.940 - 20:17.480)**

*   **İki Ayrı Arayüz:**
    1.  **İteratör Arayüzü:** Container olmasından kaynaklı, bazı fonksiyonlar iteratör parametreleri alır.
    2.  **İndeks Tabanlı Arayüz:** Yazı işlemleri için özelleşmiş, `size_type` (genellikle `size_t` için tür eş ismi) kullanan arayüz.
*   **`size_type` Kullanım Alanları:**
    1.  Yazı uzunluğu.
    2.  Karakter indeksi.
    3.  Karakter adedi (örn: "bu kadar tane bu karakterden").
*   **Parametrik Yapı Kalıpları (Fonksiyon Overload'larını Anlamak İçin Anahtar):**
    1.  **`const char*` (C-string parametresi):** Null-terminated byte stream (NTBS) bekler.
        *   Örnek: `std::string s("Merhaba");`
    2.  **`const char* ptr, size_t len` (Data parametresi):** `ptr` adresinden başlayarak `len` kadar karakter. Null karakterin özel bir anlamı yoktur.
        *   Örnek: `char arr[] = {'H', 'e', '\0', 'l', 'o'}; std::string s(arr, 5); // "He\0lo"`
    3.  **`size_t count, char ch` (Fill parametresi):** `count` tane `ch` karakterinden oluşur.
        *   Örnek: `std::string s(5, 'A'); // "AAAAA"`
    4.  **`const std::string& str` (String parametresi):** Başka bir `std::string` nesnesi.
    5.  **Substring Parametreleri:**
        *   `const std::string& str, size_t pos`: `str`'nin `pos` indeksinden sonuna kadar olan alt yazı. **Dikkat:** `pos` indeksli tek karakter *değil*.
        *   `const std::string& str, size_t pos, size_t count`: `str`'nin `pos` indeksinden başlayarak `count` adet karakterlik alt yazı.
    6.  **`char ch` (Tek karakter parametresi):** Az sayıda fonksiyonda bulunur.
    7.  **`Iterator begin, Iterator end` (Range parametresi):** `[begin, end)` aralığındaki karakterler. Bu iteratörler `char*` veya `std::string::iterator` gibi türlerden olabilir.
        *   Örnek (C-string ile):
            ```cpp
            char buf[] = "Deniz Akkus";
            // std::string s(buf + 6, buf + 11); // "Akkus"
            ```
        *   Örnek (Başka container ile):
            ```cpp
            std::vector<char> cvec = {'A', 'h', 'm', 'e', 't'};
            // std::string s(cvec.begin(), cvec.end()); // "Ahmet"
            ```
    8.  **`std::initializer_list<char> ilist` (Initializer list parametresi):** Küme parantezleri `{}` içinde verilen karakter listesi.
        *   Örnek: `std::string s({'H', 'e', 'l', 'l', 'o'}); // "Hello"`

*   **Hoca Önerisi (16:43.660):** Nicolai Josuttis - "The C++ Standard Library" kitabı (STL için başucu kitabı, string bölümü 70-80 sayfa).

---

**III. `std::string` Constructor'ları (Kurucu Fonksiyonlar) (20:37.640 - 01:13:52.100)**

1.  **Default Constructor (Varsayılan Kurucu) (20:55.160):**
    *   `std::string s;` veya `std::string s{};`
    *   Boş bir string nesnesi oluşturur (`s.size() == 0`, `s.empty() == true`).
    *   `s.begin()` çağrılabilir, ancak `*s.begin()` tanımsız davranıştır (UB).
    *   `empty()`: Boş olup olmadığını sorgular (`is_empty` anlamında), `true` veya `false` döner. Boşaltmaz.
    *   `clear()`: String'i boşaltır (`make_empty` anlamında, tüm karakterleri siler).

2.  **C-string Constructor (29:15.100):**
    *   `std::string s("alican");`
    *   Parametre olarak null-terminated byte stream (NTBS) alır.
    *   **Dikkat:** Eğer verilen `char*` null ile sonlanmıyorsa, bu tanımsız davranışa (UB) yol açar.
        ```cpp
        char name[] = "Emre Can";
        std::string s1(name); // OK

        char bad_name[3] = {'C', 'A', 'N'}; // Not null-terminated
        // std::string s2(bad_name); // UB!
        ```

3.  **Copy Constructor (Kopyalayıcı Kurucu) (32:00.500):**
    *   `std::string s1 = "Alihan Bozkir";`
    *   `std::string s2 = s1;`
    *   `std::string s3(s1);`
    *   `std::string s4{s1};`
    *   Hepsi `s1`'in bir kopyasını oluşturur.

4.  **Move Constructor (Taşıyıcı Kurucu) (33:07.920):**
    *   `std::string s2 = std::move(s1);`
    *   `s1`'in kaynağını `s2`'ye taşır.
    *   **`move_from_state` (Taşınmış Nesne Durumu):** `s1` geçerli (valid) ama içeriği belirsiz (unspecified) bir duruma gelir.
        *   Standart kütüphane sınıfları için taşınmış nesneler hala kullanılabilir (yeni değer atanabilir, yok edilebilir).
        *   Birçok implementasyon, taşınmış string'i boş string haline getirir, ama bu bir garanti değildir.

5.  **Data Constructor (Veri Kurucusu) (41:12.000):**
    *   `std::string s(const char* ptr, size_t len);`
    *   `ptr` adresinden başlayarak `len` kadar karakter alır. Null karakterin özel bir anlamı yoktur.
        ```cpp
        char data[] = "Fatih Akgül";
        std::string s1(data, 5); // s1, "Fatih" olur
        std::string s2(data + 6, 2); // s2, "Ak" olur (data[6]'dan başlayarak 2 karakter)
        // std::string s3(data, 20); // UB! data dizisi 20 karakterden kısa.
        ```

6.  **Fill Constructor (Doldurma Kurucusu) (45:13.440):**
    *   `std::string s(size_t count, char ch);`
    *   `count` tane `ch` karakteriyle string'i başlatır.
        ```cpp
        std::string stars(10, '*'); // "**********"
        size_t n = 5;
        std::cout << std::string(n, '-'); // Ekrana "-----" yazar
        ```

7.  **Tek `char` Parametreli Constructor (YOKTUR!) (45:14.520):**
    *   `std::string s('A'); // BU GEÇERSİZ! Syntax hatası.`
    *   Tek karakterli bir string oluşturmak için yollar:
        1.  C-string: `std::string s1("A");`
        2.  Fill: `std::string s2(1, 'A');`
        3.  Initializer list: `std::string s3{'A'};`
    *   **Not:** Tek `char` parametreli *atama operatörü* vardır: `s = 'A'; // Bu GEÇERLİ.`

8.  **`std::initializer_list` Constructor (49:55.060 - 01:09:31.780):**
    *   `std::string s{'A', 'n', 'i', 'l'}; // s, "Anil" olur`
    *   **ÖNEMLİ AYRIM (Overload Resolution):**
        *   `std::string s1(10, 'A');` -> Fill constructor çağrılır. `s1` = 10 tane 'A'. Uzunluk 10.
        *   `std::string s2{10, 'A'};` -> `initializer_list<char>` constructor çağrılır. ASCII değeri 10 olan karakter (Line Feed) ve 'A' karakteri. `s2`'nin içeriği `"\n"` + `"A"`. Uzunluk 2.
        *   Eğer `initializer_list` parametreli bir constructor varsa, `{}` ile başlatma (list initialization) onu tercih eder.

9.  **Substring Constructor (Alt Yazı Kurucusu) (01:11:36.000):**
    *   `std::string s2(const std::string& str, size_t pos);`
        *   `str`'nin `pos` indeksinden sonuna kadar olan kısmıyla başlatır.
    *   `std::string s3(const std::string& str, size_t pos, size_t count);`
        *   `str`'nin `pos` indeksinden başlayarak `count` adet karakterle başlatır.
        ```cpp
        std::string base = "Adem Duygu";
        std::string s_duygu(base, 5); // s_duygu, "Duygu" olur (5. indeksten sona kadar)
        std::string s_dem(base, 1, 3); // s_dem, "dem" olur (1. indeksten 3 karakter)
        ```

10. **Range Constructor (Aralık Kurucusu) (Daha önce Parametrik Yapılarda bahsedildi):**
    *   `std::string s(InputIterator begin, InputIterator end);`
    *   Verilen iteratör aralığındaki karakterlerle string'i başlatır.
        ```cpp
        std::vector<char> chars = {'H', 'e', 'l', 'l', 'o'};
        std::string from_vector(chars.begin(), chars.end()); // "Hello"

        char c_array[] = "World";
        // std::string from_c_array(c_array, c_array + strlen(c_array)); // "World"
        ```

---

**IV. `std::string::npos` (01:14:01.360 - 01:36:37.760)**

*   **Tanım:** `static constexptr size_type npos;`
    *   `std::string` sınıfının statik, `constexpr` bir veri üyesidir.
    *   Türü `std::string::size_type`'tır (genellikle `size_t`).
    *   Değeri, `size_type`'ın alabileceği en büyük değerdir (genellikle `(size_t)-1` olarak implemente edilir, bu da işaretli türe dönüştüğünde -1, işaretsiz olarak en büyük değerdir).
    *   Geçerli bir indeks olamayacak kadar büyük bir değerdir.
*   **Kullanım Alanları:**
    1.  **Başarısız Arama Sonucu:** `find`, `rfind`, `find_first_of` gibi arama fonksiyonları, aranan öğeyi bulamazsa `npos` döndürür.
        ```cpp
        std::string text = "hello world";
        size_t found_pos = text.find('z');
        if (found_pos == std::string::npos) {
            std::cout << "'z' not found!" << std::endl;
        }
        ```
    2.  **"Sonuna Kadar" Anlamında Adet Belirteci:** `substr`, `insert`, `replace` gibi `(pos, count)` çifti alan fonksiyonlarda `count` yerine `npos` geçilirse, `pos` indeksinden string'in sonuna kadar olan tüm karakterler kastedilir.
        ```cpp
        std::string data = "0123456789";
        std::string sub = data.substr(5, std::string::npos); // sub, "56789" olur
        // Çoğu zaman count için npos varsayılan argümandır:
        // std::string sub_default = data.substr(5); // Bu da "56789" olur
        ```

---

**V. C++17: `if with initializer` (Koşullu İfade İçinde Başlatıcı) (01:23:26.760 - 01:32:21.200)**

*   **Amaç:** Değişkenlerin kapsamını (scope) `if` ve `else` bloklarıyla sınırlayarak "scope leakage" (kapsam sızıntısı) önlemek.
*   **Syntax:** `if ( <initializer_statement> ; <condition> ) { ... } else { ... }`
    *   `<initializer_statement>` içinde tanımlanan değişken, hem `<condition>`'da hem de `if`/`else` gövdelerinde geçerlidir.
    ```cpp
    std::string s = "example";
    if (size_t pos = s.find('a'); pos != std::string::npos) {
        std::cout << "'a' found at index: " << pos << std::endl; // pos burada geçerli
    } else {
        std::cout << "'a' not found. pos is: " << pos << std::endl; // pos burada da geçerli (npos değerinde)
    }
    // std::cout << pos << std::endl; // HATA: pos burada kapsam dışı
    ```
*   **C++98'den Beri Var Olan `if (declaration)` ile Karıştırılmamalı:**
    *   `if (int* ptr = some_function_returning_ptr()) { /* ptr burada geçerli ve null değil */ }`
    *   Bu yapı C++98'den beri vardır ve `if with initializer` değildir. Burada `ptr` hem tanımlanır hem de `if`'in koşulu olarak (null olup olmadığı) test edilir. Kapsamı yine `if/else` ile sınırlıdır. C dilinde bu yoktur.

---

**VI. Dinamik Dizi Davranışı: Reallocation ve `reserve()` (01:39:41.380 - 01:47:39.000)**

*   `std::string` (ve `std::vector`) dinamik dizi kullandığı için, eleman eklendikçe kapasite yetersiz kalırsa yeniden yer tahsisi (reallocation) yapılır.
*   **Reallocation Maliyeti:**
    *   Yeni, daha büyük bir bellek alanı tahsis edilir.
    *   Eski alandaki tüm elemanlar yeni alana kopyalanır/taşınır.
    *   Eski alan serbest bırakılır.
    *   Bu işlem zaman alıcıdır.
*   **Kapasite Artış Stratejisi:** Genellikle kapasite geometrik olarak artar (örn: 1.5 katı, 2 katı). Bu, amortize edilmiş sabit zamanlı ekleme sağlar ama implementasyona bağlıdır.
*   **`reserve(size_type new_cap)` Fonksiyonu:**
    *   String'in kapasitesini en az `new_cap` olacak şekilde ayarlar. Eğer mevcut kapasite zaten yeterliyse bir şey yapmayabilir.
    *   String'in `size()`'ını (uzunluğunu) değiştirmez, sadece ayrılan bellek miktarını etkiler.
    *   Eğer string'e eklenecek eleman sayısı önceden biliniyor veya tahmin edilebiliyorsa, `reserve()` çağrısı gereksiz reallocation'ları önleyerek performansı artırır.
    ```cpp
    std::string log_data;
    // Tahmini olarak 1MB veri eklenecekse:
    log_data.reserve(1024 * 1024); // 1 Milyon karakterlik yer ayır
    for (int i = 0; i < 100000; ++i) {
        log_data.append("some data to append "); // Daha az reallocation olur
    }
    ```
*   **Bellek Bütünlüğü (Contiguous Memory):** `std::string` tarafından tutulan karakterler her zaman bellekte bitişik (contiguous) bir blokta yer alır.

---

**VII. Eleman Erişimi (Element Access) (01:47:51.160 - 02:05:16.180)**

1.  **`operator[](size_type pos)` (Köşeli Parantez Operatörü):**
    *   `s[pos]`
    *   Const olmayan string için `char&`, const string için `const char&` döndürür.
    *   **Sınır kontrolü yapmaz.** Geçersiz `pos` (örn: `pos >= s.size()`) tanımsız davranışa (UB) yol açar.
        *   (İstisna: `pos == s.size()` için C++ standardı `charT()` yani `\0` döndürmesini ve eğer `pos == size()` ise `s[pos] = \0` atamasının geçerli olmasını belirtir. Ancak genel kural olarak `pos < size()` varsaymak daha güvenlidir.)
2.  **`at(size_type pos)` Fonksiyonu:**
    *   `s.at(pos)`
    *   Const olmayan string için `char&`, const string için `const char&` döndürür.
    *   **Sınır kontrolü yapar.** Eğer `pos >= s.size()` ise `std::out_of_range` exception fırlatır.
3.  **`front()` Fonksiyonu:**
    *   `s.front()`
    *   String'in ilk karakterine referans (`char&` veya `const char&`) döndürür.
    *   Boş string üzerinde çağrılması tanımsız davranıştır (UB).
4.  **`back()` Fonksiyonu:**
    *   `s.back()`
    *   String'in son karakterine referans (`char&` veya `const char&`) döndürür.
    *   Boş string üzerinde çağrılması tanımsız davranıştır (UB).
5.  **İteratörler ile Erişim:**
    *   `begin()`, `end()`, `cbegin()`, `cend()`, `rbegin()`, `rend()` vb. fonksiyonlar iteratör döndürür.
    *   `*iterator` ifadesi ile karaktere erişilir.
6.  **Range-based `for` loop (Aralık Tabanlı `for` Döngüsü):**
    *   Derleyici tarafından iteratör tabanlı bir döngüye çevrilir.
    *   `for (char ch : s)`: `ch`, `s`'teki karakterin bir kopyasıdır.
    *   `for (char& ch : s)`: `ch`, `s`'teki karaktere referanstır (değiştirilebilir).
    *   `for (const char& ch : s)`: `ch`, `s`'teki karaktere const referanstır (salt okunur).
    *   `for (auto&& ch : s)`: Universal reference, en genel form.
    ```cpp
    std::string greeting = "Hello";
    greeting[0] = 'J'; // greeting = "Jello"
    // greeting[10] = 'X'; // UB!

    try {
        char c = greeting.at(10);
    } catch (const std::out_of_range& e) {
        std::cerr << "Out of range: " << e.what() << std::endl;
    }

    if (!greeting.empty()) {
        greeting.front() = 'H'; // greeting = "Hello"
        greeting.back() = 'p';  // greeting = "Hellp"
    }

    for (char& c : greeting) {
        c = std::toupper(c); // HELLP
    }
    ```

---

**VIII. Karşılaştırma İşlemleri (Comparison) (02:05:17.020 - 02:20:18.920)**

1.  **Karşılaştırma Operatörleri (`==`, `!=`, `<`, `<=`, `>`, `>=`):**
    *   `std::string` için overload edilmiştir.
    *   Leksikografik (sözlük sırasına göre) karşılaştırma yaparlar.
    *   Şu çiftler için tanımlıdır:
        *   `string` vs `string`
        *   `string` vs `const char*` (C-string)
        *   `const char*` vs `string`
    *   Tek bir `char` ile doğrudan karşılaştırma için overload **yoktur** (`s == 'A'` geçerli değil, `s == "A"` geçerli).
    *   C++20 ile gelen `operator<=>` (three-way comparison / spaceship operator), bu 6 operatörün implementasyonunu kolaylaştırır ama kullanıcı yine bu 6 operatörü kullanır.
2.  **`compare()` Üye Fonksiyonu:**
    *   C'deki `strcmp` benzeri bir arayüz sunar ancak çok daha fazla overload'a sahiptir.
    *   Geri dönüş değeri `int`'tir:
        *   `> 0`: Çağıran string (`this`), argüman olarak verilen yazıdan leksikografik olarak büyüktür.
        *   `< 0`: Çağıran string, argüman olarak verilen yazıdan küçüktür.
        *   `== 0`: İki yazı eşittir.
    *   **Unutmayın:** Dönen değer `1` veya `-1` olmak zorunda değildir, sadece işareti önemlidir.
    *   **Overload'lar:**
        *   `s1.compare(s2)`
        *   `s1.compare(const char* cstr)`
        *   `s1.compare(pos1, len1, s2)`: `s1`'in `[pos1, pos1+len1)` alt string'i ile `s2`'yi karşılaştırır.
        *   `s1.compare(pos1, len1, s2, pos2, len2)`: İki alt string'i karşılaştırır.
        *   `s1.compare(pos1, len1, const char* cstr)`
        *   `s1.compare(pos1, len1, const char* cstr, count)`: `s1`'in alt string'i ile C-string'in ilk `count` karakterini.
    ```cpp
    std::string s1 = "apple";
    std::string s2 = "apricot";
    if (s1 < s2) { /* true */ }

    int res = s1.compare(s2); // res < 0
    res = s1.compare(0, 2, s2, 0, 2); // s1'in "ap" vs s2'nin "ap", res == 0
    ```

---

**IX. String Değiştirme (Mutation) (02:20:19.680 - Devam Ediyor...)**

*   **Genel Not:** Değiştirme işlemleri kapasiteyi aşarsa otomatik reallocation yapılır.

1.  **Atama (`operator=` ve `assign()` üye fonksiyonu) (02:20:43.920):**
    *   **`operator=`:**
        *   `s1 = s2;` (Copy assignment)
        *   `s1 = std::move(s2);` (Move assignment)
        *   `s1 = "C-string literal";`
        *   `s1 = 'X';` (Tek karakter ataması, `s1` içeriği "X" olur)
        *   `s1 = {'a', 'b', 'c'};` (`initializer_list` ataması)
    *   **`assign()`:** Daha fazla esneklik sunan overload'lar. Geri dönüş değeri `*this` (yani `std::string&`).
        *   `s.assign(s2);`
        *   `s.assign(s2, pos, count);` (Substring ataması)
        *   `s.assign("C-string");`
        *   `s.assign("C-string", count);` (Data ataması: C-string'den `count` karakter)
        *   `s.assign(count, 'X');` (Fill ataması: `count` tane 'X')
        *   `s.assign(iter_begin, iter_end);` (Range ataması)
        *   `s.assign({'x', 'y', 'z'});` (`initializer_list` ataması)

2.  **Sona Ekleme (`operator+=`, `append()`, `push_back()`) (02:29:42.220):**
    *   **`operator+=`:** Atama operatörüne benzer overload'lara sahiptir. Geri dönüş değeri `*this`.
        *   `s += s2;`
        *   `s += "C-string";`
        *   `s += 'X';`
        *   `s += {'x', 'y', 'z'};`
    *   **`push_back(char ch)`:** String'in sonuna tek bir karakter ekler. Geri dönüş değeri `void`'dir. Amortize edilmiş sabit zamanlıdır.
    *   **`append()`:** `assign()` ile benzer overload setine sahiptir, ancak var olan içeriğin sonuna ekler. Geri dönüş değeri `*this`.
        *   `s.append(s2);`
        *   `s.append(s2, pos, count);` (Substring ekleme)
        *   `s.append(count, 'X');` (Fill ekleme)
        *   vb.
    ```cpp
    std::string str = "Murat";
    std::string surname = "Can";
    str += " ";       // str = "Murat "
    str.append(surname); // str = "Murat Can"
    str.push_back('!');  // str = "Murat Can!"
    ```

3.  **Araya Ekleme (`insert()`) (02:36:02.020 - 02:43:34.440):**
    *   Belirtilen pozisyona karakterler/yazılar ekler. Mevcut karakterleri sağa kaydırır.
    *   **İndeks Tabanlı Overload'lar:** İlk parametre `size_type index` (eklemenin yapılacağı indeks). Geri dönüş değeri `*this`.
        *   `s.insert(index, s2);`
        *   `s.insert(index, s2, pos, count);` (Başka string'in substring'ini ekleme)
        *   `s.insert(index, "C-string");`
        *   `s.insert(index, "C-string", count);` (Data ekleme)
        *   `s.insert(index, count, 'X');` (Fill ekleme)
        *   `s.insert(index, {'x', 'y', 'z'});` (`initializer_list` ekleme)
    *   **İteratör Tabanlı Overload'lar (STL Container Arayüzü):** İlk parametre `const_iterator pos` (eklemenin yapılacağı konumu gösteren iteratör). Geri dönüş değeri, eklenen ilk karaktere işaret eden bir `iterator`'dür.
        *   `s.insert(iter_pos, 'X');`
        *   `s.insert(iter_pos, count, 'X');`
        *   `s.insert(iter_pos, input_iter_begin, input_iter_end);` (Range ekleme)
        *   `s.insert(iter_pos, {'x', 'y', 'z'});`
    ```cpp
    std::string s = "Mot"; // Murat olacak
    s.insert(2, "ra");   // s = "Morat"
    s.insert(s.begin() + 2, 'u'); // s = "Mourat"
    s.insert(s.length(), " Keskin"); // s = "Mourat Keskin" (sona ekleme)
    s.insert(s.end(), '!'); // s = "Mourat Keskin!" (sona ekleme)
    ```
    *   `s.insert(s.end(), ...)` ile sona ekleme yapılabilir, `push_back` veya `append` ile benzer işlev görür.

---

**Devam Edilecek Konular:**
*   `erase()`
*   `replace()`
*   `substr()` (metod olarak)
*   `copy()`
*   `resize()`
*   `swap()`
*   Arama fonksiyonları (`find`, `rfind`, `find_first_of`, `find_first_not_of`, `find_last_of`, `find_last_not_of`) detayları
*   C-string dönüşümleri (`c_str()`, `data()`)
*   Diğer yardımcı fonksiyonlar (`starts_with`, `ends_with` - C++20)

**Öğrencinin Notu:** Ders `insert` fonksiyonlarının iteratör tabanlı overload'larının detaylarına girilmeden bitti. Bir sonraki derste buradan devam edilmesi bekleniyor. `std::string`'in `get_allocator`, `max_size`, `shrink_to_fit`, `operator string_view` gibi daha az kullanılan veya daha spesifik üyeleri de henüz işlenmedi.

```cpp
// Genel Kapsayıcı Örnek Kod Bloğu (Derste İşlenen Bazı Kavramlar)
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept> // std::out_of_range
#include <algorithm> // std::toupper (char için)
#include <cstring>   // strlen (c_array örneği için)

void print_string_details(const std::string& s, const std::string& name = "s") {
    std::cout << "--- " << name << " ---" << std::endl;
    std::cout << "Content: \"" << s << "\"" << std::endl;
    std::cout << "Size: " << s.size() << std::endl;
    std::cout << "Length: " << s.length() << std::endl;
    std::cout << "Capacity: " << s.capacity() << std::endl;
    std::cout << "Empty?: " << (s.empty() ? "Yes" : "No") << std::endl;
    std::cout << "------------------" << std::endl;
}

int main() {
    // --- Constructors ---
    std::string s1; // Default
    print_string_details(s1, "s1 (default)");

    std::string s2 = "Hello C-string"; // C-string
    print_string_details(s2, "s2 (C-string)");

    std::string s3 = s2; // Copy
    print_string_details(s3, "s3 (copy of s2)");

    std::string s4 = std::move(s3); // Move (s3 is now in a valid but unspecified state)
    print_string_details(s4, "s4 (moved from s3)");
    print_string_details(s3, "s3 (after move)");

    char data_arr[] = {'D', 'a', 't', 'a', '\0', 'X'};
    std::string s5(data_arr, 4); // Data (ptr, len)
    print_string_details(s5, "s5 (data ptr, len)");

    std::string s6(5, 'F'); // Fill
    print_string_details(s6, "s6 (fill)");

    std::string s7{'I', 'n', 'i', 't'}; // Initializer_list
    print_string_details(s7, "s7 (initializer_list)");

    std::string base_substr = "SubstringExample";
    std::string s8(base_substr, 9); // Substring (from pos to end)
    print_string_details(s8, "s8 (substring pos to end)");
    std::string s9(base_substr, 0, 9); // Substring (pos, count)
    print_string_details(s9, "s9 (substring pos, count)");

    std::vector<char> char_vec = {'R', 'a', 'n', 'g', 'e'};
    std::string s10(char_vec.begin(), char_vec.end()); // Range
    print_string_details(s10, "s10 (range from vector)");

    // --- npos and find ---
    std::cout << "std::string::npos = " << std::string::npos << std::endl;
    size_t find_idx = s2.find("C-string");
    if (find_idx != std::string::npos) {
        std::cout << "\"C-string\" found in s2 at index: " << find_idx << std::endl;
    }
    find_idx = s2.find("NonExistent");
    if (find_idx == std::string::npos) {
        std::cout << "\"NonExistent\" NOT found in s2." << std::endl;
    }
    std::string sub_npos = s2.substr(6, std::string::npos); // from index 6 to end
    std::cout << "s2.substr(6, npos): \"" << sub_npos << "\"" << std::endl;


    // --- if with initializer ---
    if (std::string temp_str = "Temporary; Check"; temp_str.length() > 10) {
        std::cout << "temp_str is long: \"" << temp_str << "\"" << std::endl;
    } else {
        std::cout << "temp_str is short: \"" << temp_str << "\"" << std::endl;
    }
    // temp_str is not accessible here

    // --- Reserve and Capacity ---
    std::string s_cap;
    std::cout << "Initial capacity of s_cap: " << s_cap.capacity() << std::endl;
    s_cap.reserve(100);
    std::cout << "Capacity of s_cap after reserve(100): " << s_cap.capacity() << std::endl;
    for(int i = 0; i < 10; ++i) s_cap.push_back('c');
    print_string_details(s_cap, "s_cap after push_backs");

    // --- Element Access ---
    std::string access_str = "Access";
    access_str[0] = 'a'; // operator[]
    std::cout << "After access_str[0]='a': " << access_str << std::endl;
    try {
        access_str.at(0) = 'A'; // at()
        // char c_ub = access_str.at(100); // this would throw
    } catch (const std::out_of_range& e) {
        std::cerr << "Access error: " << e.what() << std::endl;
    }
    if(!access_str.empty()){
        std::cout << "Front: " << access_str.front() << ", Back: " << access_str.back() << std::endl;
    }
    std::cout << "Access_str using range-based for: ";
    for(const char& c : access_str) {
        std::cout << c;
    }
    std::cout << std::endl;

    // --- Comparison ---
    std::string cmp1 = "alpha";
    std::string cmp2 = "beta";
    if (cmp1 < cmp2) std::cout << cmp1 << " < " << cmp2 << std::endl;
    int cmp_res = cmp1.compare(cmp2); // cmp_res < 0
    std::cout << "cmp1.compare(cmp2) result: " << cmp_res << std::endl;


    // --- Mutation ---
    // Assignment
    std::string mut_str = "Initial";
    print_string_details(mut_str, "mut_str (initial)");
    mut_str = "New Value by C-string";
    print_string_details(mut_str, "mut_str (assigned C-string)");
    mut_str.assign(3, 'Z');
    print_string_details(mut_str, "mut_str (assigned fill ZZZ)");

    // Appending
    mut_str += " Appended";
    print_string_details(mut_str, "mut_str (+= Appended)");
    mut_str.push_back('!');
    print_string_details(mut_str, "mut_str (push_back !)");
    mut_str.append(s10); // s10 was "Range"
    print_string_details(mut_str, "mut_str (appended s10)");

    // Insertion
    mut_str.insert(3, "---INSERTED_HERE---"); // Insert at index 3
    print_string_details(mut_str, "mut_str (inserted at index 3)");
    mut_str.insert(mut_str.begin(), '*'); // Insert at beginning using iterator
    print_string_details(mut_str, "mut_str (inserted '*' at begin)");


    return 0;
}

```

Harika, devam edelim!

---

**IX. String Değiştirme (Mutation) - Devam**

*   **Araya Ekleme (`insert()`) - İteratör Tabanlı Overload'lar (Devam)**
    *   İteratör tabanlı `insert` fonksiyonları, eklemenin yapılacağı konumu bir iteratör olarak alır. Bu, STL container'ları için standart bir arayüzdür.
    *   **Temel Formlar:**
        1.  **`iterator insert(const_iterator pos, charT ch);`**
            *   `pos` ile gösterilen konuma `ch` karakterini ekler.
            *   Geri dönüş değeri: Eklenen karaktere işaret eden bir `iterator`.
        2.  **`iterator insert(const_iterator pos, size_type count, charT ch);`**
            *   `pos` ile gösterilen konuma `count` tane `ch` karakteri ekler.
            *   Geri dönüş değeri: Eklenen ilk karaktere işaret eden bir `iterator`. (Eğer `count == 0` ise `pos` döner).
        3.  **`template<class InputIt> iterator insert(const_iterator pos, InputIt first, InputIt last);`**
            *   `pos` ile gösterilen konuma `[first, last)` aralığındaki karakterleri ekler. `InputIt` bir girdi iteratörü (input iterator) olmalıdır.
            *   Geri dönüş değeri: Eklenen ilk karaktere işaret eden bir `iterator`. (Eğer `first == last` ise `pos` döner).
        4.  **`iterator insert(const_iterator pos, std::initializer_list<charT> ilist);`**
            *   `pos` ile gösterilen konuma `ilist` içindeki karakterleri ekler.
            *   Geri dönüş değeri: Eklenen ilk karaktere işaret eden bir `iterator`. (Eğer `ilist` boş ise `pos` döner).

    ```cpp
    #include <iostream>
    #include <string>
    #include <vector>
    #include <list>

    int main() {
        std::string s = "World";
        std::cout << "Original: \"" << s << "\"" << std::endl;

        // 1. Tek karakter ekleme
        auto it = s.insert(s.begin(), ' '); // Başına boşluk
        s.insert(it, 'H'); // it şimdi boşluğa işaret ediyor, boşluğun önüne 'H' eklenir
                           // s = "H World" olur. it, 'H'ye işaret eder.
        std::cout << "After insert 'H' and ' ': \"" << s << "\"" << std::endl;

        // 2. Birden fazla aynı karakteri ekleme
        s.insert(s.begin() + 1, 3, 'e'); // "H"den sonra 3 tane 'e' ekle
                                         // s = "Heee World"
        std::cout << "After insert 3 'e's: \"" << s << "\"" << std::endl;

        // 3. Başka bir container'dan aralık ekleme
        std::vector<char> prefix = {'P', 'r', 'e', ':'};
        s.insert(s.begin(), prefix.begin(), prefix.end()); // s = "Pre:Heee World"
        std::cout << "After insert vector range: \"" << s << "\"" << std::endl;

        // 4. Initializer list ekleme
        s.insert(s.end(), {'!', '!'}); // s = "Pre:Heee World!!"
        std::cout << "After insert initializer_list: \"" << s << "\"" << std::endl;
        return 0;
    }
    ```
    *   **Önemli Not:** İteratör tabanlı `insert` işlemleri, eğer reallocation olursa, var olan tüm iteratörleri (parametre olarak verilen `pos` dahil) geçersiz kılabilir. Geri dönen iteratör her zaman geçerlidir.

4.  **Silme (`erase()`)**
    *   String'den karakterleri veya karakter aralıklarını siler.
    *   **Overload'lar:**
        1.  **`string& erase(size_type index = 0, size_type count = npos);`**
            *   `index` konumundan başlayarak `count` adet karakteri siler.
            *   Eğer `count` belirtilmezse veya `npos` ise, `index`'ten string'in sonuna kadar tüm karakterler silinir.
            *   `index` string sınırları dışındaysa `std::out_of_range` fırlatır.
            *   Geri dönüş değeri: `*this` (yani `std::string&`).
        2.  **`iterator erase(const_iterator position);`**
            *   `position` iteratörünün gösterdiği tek karakteri siler.
            *   Geri dönüş değeri: Silinen karakterden sonraki karaktere işaret eden bir `iterator`. Eğer son karakter silindiyse `end()` iteratörünü döndürür.
            *   Geçersiz bir `position` (örn: `end()`) tanımsız davranışa yol açar.
        3.  **`iterator erase(const_iterator first, const_iterator last);`**
            *   `[first, last)` aralığındaki karakterleri siler.
            *   Geri dönüş değeri: Silinen son karakterden sonraki (yani `last`'ın orijinal olarak işaret ettiği) karaktere işaret eden bir `iterator`.
            *   Geçersiz aralık tanımsız davranışa yol açabilir.

    ```cpp
    #include <iostream>
    #include <string>
    #include <algorithm> // std::remove

    int main() {
        std::string s = "Hello, Beautiful World!";
        std::cout << "Original: \"" << s << "\"" << std::endl;

        // 1. İndeks ve adet ile silme
        s.erase(5, 11); // ", Beautiful" kısmını sil (indeks 5'ten 11 karakter)
                        // s = "Hello World!"
        std::cout << "After erase(5, 11): \"" << s << "\"" << std::endl;

        s.erase(5);     // İndeks 5'ten sonrasını sil (" World!")
                        // s = "Hello"
        std::cout << "After erase(5): \"" << s << "\"" << std::endl;

        s = "Remove XsX XhereX";
        // 2. İteratör ile tek karakter silme (genellikle döngü içinde kullanılır)
        // Örnek: İlk 'X'i silme
        auto it_x = s.find('X');
        if (it_x != std::string::npos) {
            s.erase(s.begin() + it_x); // s = "Remove sX XhereX" (sadece ilk X silindi)
        }
        std::cout << "After erasing first 'X': \"" << s << "\"" << std::endl;


        // 3. İteratör aralığı ile silme
        // Tüm 'X'leri silmek için erase-remove deyimi (idiom)
        s = "Remove XsX XhereX";
        // std::remove algoritması, silinecek öğeleri sona taşır ve yeni sonun iteratörünü döndürür.
        // Kendisi container'ın boyutunu değiştirmez.
        s.erase(std::remove(s.begin(), s.end(), 'X'), s.end());
        // s = "Remove s here"
        std::cout << "After erase-remove 'X': \"" << s << "\"" << std::endl;

        return 0;
    }
    ```
    *   **`clear()` Fonksiyonu:** Aslında `erase(0, npos)` veya `erase(begin(), end())` ile eşdeğerdir. String'in tüm içeriğini siler, `size()`'ı 0 yapar.

5.  **Değiştirme (`replace()`)**
    *   String'in belirli bir bölümünü başka bir karakter dizisiyle değiştirir. Çok sayıda overload'a sahiptir ve oldukça esnektir.
    *   **Genel Form:** `string& replace(size_type pos, size_type count, <kaynak_veri>);` veya `string& replace(const_iterator first, const_iterator last, <kaynak_veri>);`
    *   `<kaynak_veri>` şunlar olabilir:
        *   Başka bir `std::string`.
        *   Başka bir `std::string`'in alt string'i (`const std::string& str, size_type pos2, size_type count2`).
        *   C-string (`const char* cstr`).
        *   C-string'in belirli bir kısmı (`const char* cstr, size_type count2`).
        *   Belirli sayıda aynı karakter (`size_type num_chars, charT ch`).
        *   İteratör aralığı (`InputIt first2, InputIt last2`).
        *   `std::initializer_list<charT>`.
    *   Geri dönüş değeri: `*this` (yani `std::string&`).
    *   Eğer değiştirilecek bölüm (`count`) ile yerine konulacak kaynak verinin uzunluğu farklıysa, string'in boyutu buna göre değişir.

    ```cpp
    #include <iostream>
    #include <string>
    #include <vector>

    int main() {
        std::string s = "This is an old string.";
        std::cout << "Original: \"" << s << "\"" << std::endl;

        // 1. İndeks tabanlı: "old" kelimesini "new" ile değiştir
        s.replace(11, 3, "new"); // 11. indeksten 3 karakter ("old") yerine "new"
                                 // s = "This is a new string."
        std::cout << "After replace 'old' with 'new': \"" << s << "\"" << std::endl;

        // 2. İndeks tabanlı: "string" kelimesini 5 tane 'X' ile değiştir
        s.replace(s.find("string"), 6, 5, 'X'); // "string" (6 karakter) yerine 5 tane 'X'
                                                 // s = "This is a new XXXXX."
        std::cout << "After replace 'string' with 5 'X's: \"" << s << "\"" << std::endl;

        // 3. İteratör tabanlı: Baştaki "This " kısmını başka bir string'in substring'i ile değiştir
        std::string source = "Actually, that was";
        s.replace(s.begin(), s.begin() + 5, source, 0, 9); // "This " yerine source'un "Actually," kısmı
                                                            // s = "Actually,is a new XXXXX."
        std::cout << "After replace with substring: \"" << s << "\"" << std::endl;

        // 4. İndeks tabanlı: "XXXXX" kısmını bir C-string'in ilk N karakteri ile değiştir
        const char* c_source = "message!!!";
        s.replace(s.find("XXXXX"), 5, c_source, 7); // "XXXXX" yerine "message" (c_source'un ilk 7 karakteri)
                                                   // s = "Actually,is a new message."
        std::cout << "After replace with C-string part: \"" << s << "\"" << std::endl;

        // 5. İteratör tabanlı: "new " kısmını initializer_list ile değiştir
        auto start_it = s.find("new ");
        if (start_it != std::string::npos) {
             s.replace(s.begin() + start_it, s.begin() + start_it + 4, {'N', 'O', 'W', ' '});
             // s = "Actually,is a NOW message."
        }
        std::cout << "After replace with initializer_list: \"" << s << "\"" << std::endl;

        // 6. Tüm string'i değiştirmek için:
        s.replace(0, s.length(), "Completely different!");
        // veya s.replace(s.begin(), s.end(), "Completely different!");
        std::cout << "After replacing entire string: \"" << s << "\"" << std::endl;

        return 0;
    }
    ```

---

**X. Diğer String Manipülasyonları**

1.  **Alt String Alma (`substr()`)**
    *   `std::string substr(size_type pos = 0, size_type count = npos) const;`
    *   String'in `pos` indeksinden başlayarak `count` adet karakter içeren **yeni bir `std::string` nesnesi** döndürür.
    *   Orijinal string'i **değiştirmez** (const üye fonksiyondur).
    *   Eğer `pos` string sınırları dışındaysa `std::out_of_range` fırlatır.
    *   Eğer `count` `npos` ise veya `pos + count` string'in sonunu aşıyorsa, `pos`'tan string'in sonuna kadar olan karakterler alınır.

    ```cpp
    std::string text = "0123456789";
    std::string sub1 = text.substr(5);    // sub1 = "56789" (indeks 5'ten sona kadar)
    std::string sub2 = text.substr(2, 4); // sub2 = "2345" (indeks 2'den 4 karakter)
    std::cout << "sub1: " << sub1 << ", sub2: " << sub2 << std::endl;
    ```

2.  **Karakter Dizisine Kopyalama (`copy()`)**
    *   `size_type copy(charT* dest, size_type count, size_type pos = 0) const;`
    *   String'in `pos` indeksinden başlayarak en fazla `count` adet karakteri, kullanıcı tarafından sağlanan `dest` C-stili karakter dizisine kopyalar.
    *   **ÖNEMLİ:** `dest` dizisini **null ile sonlandırmaz**. Kullanıcının bunu ayrıca yapması veya `dest`'in yeterince büyük olduğundan ve null sonlandırıcı için yer olduğundan emin olması gerekir.
    *   Orijinal string'i değiştirmez.
    *   Geri dönüş değeri: Kopyalanan karakter sayısı.
    *   `pos` string sınırları dışındaysa `std::out_of_range` fırlatır.

    ```cpp
    std::string s_source = "Hello";
    char buffer[10];

    size_t copied_len = s_source.copy(buffer, 3, 1); // s_source'un 1. indeksinden 3 karakter ("ell") kopyala
    buffer[copied_len] = '\0'; // Elle null sonlandırma
    std::cout << "Copied to buffer: \"" << buffer << "\"" << std::endl; // "ell"

    // Tüm string'i kopyalamak için:
    char full_buffer[6]; // "Hello" (5) + '\0' (1)
    s_source.copy(full_buffer, s_source.length());
    full_buffer[s_source.length()] = '\0';
    std::cout << "Full copy: \"" << full_buffer << "\"" << std::endl; // "Hello"
    ```
    *   Genellikle `c_str()` veya `data()` tercih edilir, çünkü `copy()` daha manuel ve hata yapmaya açıktır.

3.  **Boyutlandırma (`resize()`)**
    *   `void resize(size_type count);`
    *   `void resize(size_type count, charT ch);`
    *   String'in boyutunu (uzunluğunu) `count` olarak değiştirir.
    *   Eğer `count < current_size()`: String sondan `current_size() - count` karakter kadar kısaltılır.
    *   Eğer `count > current_size()`: String'in sonuna karakterler eklenir.
        *   İkinci overload kullanılırsa, eklenen karakterler `ch` olur.
        *   İlk overload kullanılırsa, eklenen karakterler varsayılan olarak oluşturulmuş `charT` olur (yani `char` için `\0`).
    *   `capacity()` de bu işlemden etkilenebilir (eğer yeni boyut kapasiteyi aşarsa reallocation).

    ```cpp
    std::string s_resize = "Test";
    std::cout << "Original resize: \"" << s_resize << "\", size: " << s_resize.size() << std::endl;

    s_resize.resize(10); // Boyutu 10'a çıkar, boşluklar '\0' ile dolar (genellikle)
    std::cout << "After resize(10): \"" << s_resize << "\", size: " << s_resize.size() << std::endl;
    // Ekrana yazdırırken null karakterler görünmeyebilir veya terminal davranışını etkileyebilir.
    // Gerçek içeriği görmek için karakter karakter bakmak gerekebilir.
    // for(char c : s_resize) { std::cout << (isprint(c) ? c : '.') << " "; } std::cout << std::endl;


    s_resize.resize(15, 'X'); // Boyutu 15'e çıkar, boşluklar 'X' ile dolar
    std::cout << "After resize(15, 'X'): \"" << s_resize << "\", size: " << s_resize.size() << std::endl;

    s_resize.resize(3); // Boyutu 3'e düşür (sondan keser)
    std::cout << "After resize(3): \"" << s_resize << "\", size: " << s_resize.size() << std::endl; // "Tes" (veya ilk 3 karakteri neyse)
    ```

4.  **İçerik Takası (`swap()`)**
    *   `void swap(std::string& other) noexcept;` (C++11'den itibaren `noexcept`)
    *   İki string nesnesinin içeriğini takas eder.
    *   Çok verimli bir işlemdir (genellikle O(1) sabit zamanda), çünkü sadece iç işaretçileri ve boyut/kapasite bilgilerini takas eder. Gerçek karakter verileri kopyalanmaz.
    *   Ayrıca global bir `std::swap(s1, s2)` fonksiyonu da `s1.swap(s2)`'yi çağıracak şekilde overload edilmiştir.

    ```cpp
    std::string sw1 = "String One";
    std::string sw2 = "String Two Longer";

    std::cout << "Before swap: sw1 = \"" << sw1 << "\", sw2 = \"" << sw2 << "\"" << std::endl;
    sw1.swap(sw2); // veya std::swap(sw1, sw2);
    std::cout << "After swap: sw1 = \"" << sw1 << "\", sw2 = \"" << sw2 << "\"" << std::endl;
    ```

---

**XI. Arama Fonksiyonları (Detaylar)**

*   Tüm arama fonksiyonları, bulunan ilk karakterin/alt string'in indeksini (`size_type`) veya bulunamazsa `std::string::npos` döndürür.
*   Çoğu arama fonksiyonu, aramaya başlanacak bir `pos` (varsayılanı 0) parametresi alır.

1.  **`find()`**
    *   Belirli bir alt string'i veya karakteri arar.
    *   **Overload'lar:**
        *   `size_type find(const std::string& str, size_type pos = 0) const noexcept;`
        *   `size_type find(const charT* s, size_type pos, size_type count) const;` (C-string'in `count` karakterini arar)
        *   `size_type find(const charT* s, size_type pos = 0) const;` (Null-terminated C-string'i arar)
        *   `size_type find(charT ch, size_type pos = 0) const noexcept;`

2.  **`rfind()` (Reverse Find)**
    *   `find` ile aynı overload'lara sahiptir, ancak aramayı string'in sonundan başına doğru yapar ve bulunan **son** örneğin indeksini döndürür.
    *   `pos` parametresi hala aramaya başlanacak maksimum indeksi belirtir (yani `pos` ve öncesinde arar).

    ```cpp
    std::string text_rf = "one two one three one";
    std::cout << "text_rf.find(\"one\"): " << text_rf.find("one") << std::endl;     // 0
    std::cout << "text_rf.rfind(\"one\"): " << text_rf.rfind("one") << std::endl;   // 18
    std::cout << "text_rf.rfind(\"one\", 10): " << text_rf.rfind("one", 10) << std::endl; // 8 (10. indeksten geriye doğru "one" arar)
    ```

3.  **`find_first_of()`**
    *   Verilen karakter setindeki **herhangi bir karakterin** string içindeki **ilk** bulunduğu konumu arar.
    *   **Overload'lar (aranacak karakter seti için):**
        *   `size_type find_first_of(const std::string& str, size_type pos = 0) const noexcept;`
        *   `size_type find_first_of(const charT* s, size_type pos, size_type count) const;`
        *   `size_type find_first_of(const charT* s, size_type pos = 0) const;`
        *   `size_type find_first_of(charT ch, size_type pos = 0) const noexcept;` (Tek karakter için `find` ile aynı)

4.  **`find_last_of()`**
    *   Verilen karakter setindeki **herhangi bir karakterin** string içindeki **son** bulunduğu konumu arar (aramayı sondan başa yapar).
    *   `find_first_of` ile benzer overload'lara sahiptir.

    ```cpp
    std::string data_fof = "axbyc123";
    std::string vowels = "aeiou";
    std::string digits = "0123456789";

    // data_fof içinde ilk sesli harfi bul
    std::cout << "data_fof.find_first_of(vowels): " << data_fof.find_first_of(vowels) << std::endl; // 0 ('a')

    // data_fof içinde son rakamı bul
    std::cout << "data_fof.find_last_of(digits): " << data_fof.find_last_of(digits) << std::endl; // 7 ('3')
    ```

5.  **`find_first_not_of()`**
    *   Verilen karakter setinde **bulunmayan** bir karakterin string içindeki **ilk** bulunduğu konumu arar.
    *   `find_first_of` ile benzer overload'lara sahiptir.

6.  **`find_last_not_of()`**
    *   Verilen karakter setinde **bulunmayan** bir karakterin string içindeki **son** bulunduğu konumu arar (aramayı sondan başa yapar).
    *   `find_first_of` ile benzer overload'lara sahiptir.

    ```cpp
    std::string s_fnof = "!!!Hello???";
    std::string punctuation = "!?.";

    // s_fnof içinde ilk noktalama işareti olmayan karakteri bul
    size_t first_char_idx = s_fnof.find_first_not_of(punctuation); // 3 ('H')
    if(first_char_idx != std::string::npos) {
        std::cout << "First non-punctuation: " << s_fnof[first_char_idx] << " at " << first_char_idx << std::endl;
    }

    // s_fnof içinde son noktalama işareti olmayan karakteri bul
    size_t last_char_idx = s_fnof.find_last_not_of(punctuation); // 7 ('o')
    if(last_char_idx != std::string::npos) {
        std::cout << "Last non-punctuation: " << s_fnof[last_char_idx] << " at " << last_char_idx << std::endl;
    }
    ```

---

**XII. C-String ve Veri Erişimi**

1.  **`c_str()`**
    *   `const charT* c_str() const noexcept;`
    *   String'in içeriğini gösteren, null ile sonlandırılmış bir C-stili karakter dizisine (`const char*`) işaretçi döndürür.
    *   Döndürülen işaretçi, string'in iç belleğine işaret eder.
    *   **ÖNEMLİ:** Bu işaretçi, string üzerinde yapılan ve reallocation'a neden olabilecek herhangi bir non-const işlem (örn: `push_back`, `insert`, `erase`, `assign`, `+=`, `replace`, `resize` (boyut büyürse)) sonrasında geçersiz hale gelir. String yok edildiğinde de geçersiz olur.
    *   Salt okunur erişim için kullanılmalıdır.

2.  **`data()`**
    *   `const charT* data() const noexcept;` (C++11 öncesi)
    *   `charT* data() noexcept;` (C++17'den itibaren, non-const overload)
    *   String'in karakter dizisine bir işaretçi döndürür.
    *   **C++11 ve sonrası:** `data()` tarafından döndürülen dizi de null ile sonlandırılmıştır (string boş değilse). Bu durumda `c_str()` ile aynı işlevi görür.
    *   **C++17 non-const overload:** String'in içeriğini doğrudan değiştirmek için kullanılabilir (dikkatli olunmalı, null sonlandırıcıyı bozmamak ve string'in `size`'ını aşmamak gerekir). Bu genellikle özel durumlar için önerilir.
    *   `c_str()` gibi, döndürülen işaretçi reallocation durumunda geçersiz kalır.

    ```cpp
    std::string my_str = "Example";
    const char* cstyle_str = my_str.c_str();
    std::cout << "C-style string: " << cstyle_str << std::endl;

    // printf("%s\n", my_str.c_str()); // C fonksiyonlarıyla kullanım

    // Geçersizleştirme örneği
    // const char* ptr_before = my_str.data();
    // my_str.push_back('s'); // Reallocation olabilir
    // // ptr_before şimdi geçersiz olabilir! Yeniden my_str.data() çağrılmalı.

    // C++17 non-const data() kullanımı (dikkatli olunmalı):
    #if __cplusplus >= 201703L
        std::string mod_str = "Change Me";
        char* mod_ptr = mod_str.data();
        if (mod_str.length() >= 7) {
            mod_ptr[0] = 'S';
            mod_ptr[7] = 'U'; // "Shange Mu"
        }
        // mod_str.size() hala orijinal değerde. Bu tür doğrudan değişiklikler
        // string'in tutarlılığını bozmuyorsa yapılabilir.
        std::cout << "Modified string via data(): " << mod_str << std::endl;
    #endif
    ```

---

**XIII. C++20 ile Gelen Yardımcı Fonksiyonlar**

1.  **`starts_with()`**
    *   String'in belirli bir önek (prefix) ile başlayıp başlamadığını kontrol eder.
    *   **Overload'lar (önek için):**
        *   `bool starts_with(std::basic_string_view<charT, Traits> sv) const noexcept;`
        *   `bool starts_with(charT ch) const noexcept;`
        *   `bool starts_with(const charT* s) const;`
    *   Geri dönüş değeri `bool`'dur.

2.  **`ends_with()`**
    *   String'in belirli bir sonek (suffix) ile bitip bitmediğini kontrol eder.
    *   `starts_with` ile benzer overload'lara sahiptir.
    *   Geri dönüş değeri `bool`'dur.

    ```cpp
    #if __cplusplus >= 202002L // C++20 kontrolü
    #include <iostream>
    #include <string>
    #include <string_view> // basic_string_view için

    int main_cpp20() { // Ayrı bir main fonksiyonu olarak gösterelim
        std::string filename = "document.pdf";

        if (filename.starts_with("doc")) {
            std::cout << "\"" << filename << "\" starts with \"doc\"" << std::endl;
        }

        if (filename.ends_with(".pdf")) {
            std::cout << "\"" << filename << "\" ends with \".pdf\"" << std::endl;
        }

        if (filename.starts_with('d')) {
            std::cout << "\"" << filename << "\" starts with 'd'" << std::endl;
        }
        return 0;
    }
    #endif // C++20
    ```
    *   Bu fonksiyonlar `std::string_view` ile de çalışır, bu da gereksiz string kopyalamalarını önler.

---

**XIV. Diğer Fonksiyonlar (Kısaca)**

1.  **`get_allocator()`:**
    *   String tarafından kullanılan allocator nesnesinin bir kopyasını döndürür. Genellikle ileri düzey bellek yönetimi senaryolarında kullanılır.
2.  **`max_size()`:**
    *   String'in teorik olarak ulaşabileceği maksimum boyutu (`size_type` olarak) döndürür. Bu, sistemdeki bellek miktarı veya `size_type`'ın sınırları ile kısıtlıdır.
3.  **`shrink_to_fit()` (C++11):**
    *   String'in kapasitesini mevcut `size()`'ına düşürmek için bir "talep"te bulunur.
    *   Implementasyon bu talebi görmezden gelebilir; kapasitenin kesin olarak düşeceği garanti edilmez.
    *   Eğer kapasite düşürülürse, reallocation gerçekleşir ve iteratörler/referanslar/işaretçiler geçersiz kalabilir.
4.  **`operator std::basic_string_view<charT, Traits>()` (C++17):**
    *   `std::string`'den `std::string_view`'e örtük (implicit) veya açık (explicit) dönüşüm sağlar.
    *   `std::string_view` string'in kendisine sahip olmayan, sadece bir karakter dizisine "bakan" bir türdür. Bu, gereksiz kopyalamaları önler.

---

**Öğrencinin Notu:** Bu notlar `std::string` sınıfının temel ve sık kullanılan üye fonksiyonlarının çoğunu kapsamaktadır. Her fonksiyonun tüm overload'ları ve köşe durumları için resmi C++ referans dokümanlarına (örn: cppreference.com) başvurmak faydalı olacaktır. Özellikle `noexcept` belirteçleri, `constexpr` durumları ve C++ standart versiyonlarına göre gelen değişiklikler bu tür kaynaklarda detaylı olarak bulunur.

**Genel Kapsayıcı Örnek Kod Bloğu (Devamı - Yeni Eklenenler)**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>
#include <algorithm> // std::remove, std::toupper
#include <cstring>   // strlen
#include <list>      // insert örneği için
#include <string_view> // starts_with/ends_with örneği için

// (print_string_details fonksiyonu bir önceki yanıtta mevcut)
void print_string_details(const std::string& s, const std::string& name = "s") {
    std::cout << "--- " << name << " ---" << std::endl;
    std::cout << "Content: \"" << s << "\"" << std::endl;
    std::cout << "Size: " << s.size() << std::endl;
    std::cout << "Length: " << s.length() << std::endl;
    std::cout << "Capacity: " << s.capacity() << std::endl;
    std::cout << "Empty?: " << (s.empty() ? "Yes" : "No") << std::endl;
    std::cout << "------------------" << std::endl;
}


int main() {
    // ... (Bir önceki yanıttaki main fonksiyonunun ilk kısmı) ...

    std::string s_ops = "This is a test string for operations.";
    print_string_details(s_ops, "s_ops (initial for ops)");

    // --- Erase ---
    std::string s_erase_copy = s_ops;
    s_erase_copy.erase(10, 5); // "test " kısmını sil
    print_string_details(s_erase_copy, "s_erase_copy (after erase by pos,count)");

    s_erase_copy = s_ops;
    auto it_erase = s_erase_copy.begin() + 5; // 'i' of "is"
    it_erase = s_erase_copy.erase(it_erase); // 'i' silinir, it_erase şimdi 's'e işaret eder
    print_string_details(s_erase_copy, "s_erase_copy (after erase by iterator)");

    s_erase_copy = s_ops;
    s_erase_copy.erase(s_erase_copy.begin() + 5, s_erase_copy.begin() + 10); // "is a " kısmını sil
    print_string_details(s_erase_copy, "s_erase_copy (after erase by iterator range)");


    // --- Replace ---
    std::string s_replace_copy = s_ops;
    s_replace_copy.replace(5, 2, "WAS"); // "is" yerine "WAS"
    print_string_details(s_replace_copy, "s_replace_copy (after replace 'is' with 'WAS')");

    s_replace_copy = s_ops;
    s_replace_copy.replace(s_replace_copy.find("test"), 4, 5, '*'); // "test" yerine "*****"
    print_string_details(s_replace_copy, "s_replace_copy (after replace 'test' with 5 '*')");


    // --- Substr ---
    std::string s_substr_orig = "0123456789";
    std::string sub = s_substr_orig.substr(3, 4); // "3456"
    std::cout << "Substring from s_substr_orig: \"" << sub << "\"" << std::endl;
    print_string_details(s_substr_orig, "s_substr_orig (unchanged by substr)");


    // --- Copy ---
    char c_buffer[20];
    size_t copied_count = s_ops.copy(c_buffer, 10, 5); // "is a test "
    c_buffer[copied_count] = '\0'; // MANUALLY null-terminate
    std::cout << "Copied to c_buffer: \"" << c_buffer << "\"" << std::endl;


    // --- Resize ---
    std::string s_resize_ops = "ResizeMe";
    print_string_details(s_resize_ops, "s_resize_ops (initial)");
    s_resize_ops.resize(10, '+'); // "ResizeMe+++"
    print_string_details(s_resize_ops, "s_resize_ops (resized to 10 with '+')");
    s_resize_ops.resize(3); // "Res"
    print_string_details(s_resize_ops, "s_resize_ops (resized to 3)");


    // --- Swap ---
    std::string sw_a = "Alpha";
    std::string sw_b = "Beta";
    std::cout << "Before swap: sw_a=\"" << sw_a << "\", sw_b=\"" << sw_b << "\"" << std::endl;
    sw_a.swap(sw_b);
    std::cout << "After swap: sw_a=\"" << sw_a << "\", sw_b=\"" << sw_b << "\"" << std::endl;


    // --- Search Functions (find_first_of etc.) ---
    std::string search_text = "abc123def456ghi";
    std::string search_chars = "dx1";
    size_t ff_idx = search_text.find_first_of(search_chars); // 'd' (index 6)
    if (ff_idx != std::string::npos) {
        std::cout << "First char from \"" << search_chars << "\" in \"" << search_text << "\" is '"
                  << search_text[ff_idx] << "' at index " << ff_idx << std::endl;
    }

    std::string non_search_chars = "abcdefghi";
    size_t ffn_idx = search_text.find_first_not_of(non_search_chars); // '1' (index 3)
     if (ffn_idx != std::string::npos) {
        std::cout << "First char NOT from \"" << non_search_chars << "\" in \"" << search_text << "\" is '"
                  << search_text[ffn_idx] << "' at index " << ffn_idx << std::endl;
    }


    // --- c_str() / data() ---
    const char* c_ptr = s_ops.c_str();
    std::cout << "s_ops.c_str(): " << c_ptr << std::endl;
    // Be careful: if s_ops is modified and reallocates, c_ptr becomes invalid.

    // --- C++20 starts_with / ends_with ---
    #if __cplusplus >= 202002L
        std::string file = "report.txt";
        if (file.starts_with("report")) std::cout << "\"" << file << "\" starts with \"report\"" << std::endl;
        if (file.ends_with(".txt")) std::cout << "\"" << file << "\" ends with \".txt\"" << std::endl;
    #else
        std::cout << "C++20 starts_with/ends_with not available." << std::endl;
    #endif

    // --- shrink_to_fit ---
    std::string s_shrink = "Lots of initial text to make capacity large";
    s_shrink.reserve(200);
    print_string_details(s_shrink, "s_shrink (after reserve)");
    s_shrink = "short";
    print_string_details(s_shrink, "s_shrink (after assigning short)");
    s_shrink.shrink_to_fit(); // Request to reduce capacity
    print_string_details(s_shrink, "s_shrink (after shrink_to_fit)");


    std::cout << "Max size for a string: " << s_ops.max_size() << std::endl;


    return 0;
}
```