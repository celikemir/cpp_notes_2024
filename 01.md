
---

**C++ Dersi Notları - 1. Ders (01.07.2024)**

**Ders Gündemi:**
1.  Kurs Tanıtımı ve Metodolojisi
2.  C++ Dilinin Genel Özellikleri ve Zorlukları
3.  C++ Standartları ve Modern C++
4.  Temel Kavramlar: Derleyici Optimizasyonları, Davranış Türleri
5.  C ve C++ Arasındaki Temel Sentaks Farklılıkları (Giriş)

---

**1. Kurs Tanıtımı ve Metodolojisi (00:00.000 - 00:30.060)**
*   **Ders Başlangıcı:** 1 Temmuz 2024 Pazartesi, 19:30. Bu, kursun ilk dersi.
*   **Amaç:** İlk derste kursun genel tanıtımı yapılacak, öğrencilerin soruları yanıtlanacak ve kursla ilgili önemli noktalara değinilecek.

**1.1. C++ Kursunun Kapsamı ve Ön Koşullar (00:33.040 - 01:30.660)**
*   **Dil:** Kurs C++ dilini öğretmeyi amaçlamaktadır.
*   **Sıfırdan Başlamama:** Kurs, C++ dilini sıfırdan anlatmayacaktır.
    *   **Neden?** C++ çok büyük ve karmaşık bir dildir. Standart kütüphanesi de geniştir. Kurs süresi 200 saattir. Eğer C dilinden gelen temel sentaks (syntax) da bu süre içinde anlatılırsa, kurs sonunda hedeflenen ileri seviyeye ulaşılamaz.
*   **Ön Koşul:** Kursa katılanların belirli bir seviyede C diline hakim oldukları varsayılacaktır.
    *   Hocanın kendi C kursunu bitirenler için bu bir sorun teşkil etmeyecektir.
    *   Diğer öğrenciler C'yi kendi çabalarıyla veya iş hayatında öğrenmiş olabilirler.

**1.2. C Bilgisindeki Eksikliklerin Giderilmesi (01:30.660 - 04:11.080)**
*   **Panik Yok:** C bilgisinde eksik olanlar endişelenmemeli. Bu eksiklikler kurs sırasında giderilecektir.
*   **Kaynak Paylaşımı:** Hoca, iyi C kaynakları (kitaplar vb.) paylaşarak öğrencilere yardımcı olacaktır.
*   **Önemli C Konuları:** C++'da sık kullanılan ve C'de de öğrenilmesi zor olan bazı konulara (örneğin, `function pointers` - fonksiyon göstericileri) gelindiğinde, bu konular özetlenerek eksiklikler kapatılmaya çalışılacaktır.
*   **Soru Sorma:** C bilgisi varsayılsa da, C++ içindeki C ile ilgili sorular sorulabilir. Hoca, kısa cevaplar verebilir, kaynak gösterebilir veya konuyu başka bir derste özetleyebilir.

**1.3. Kursa Uyum ve Alternatif Çözümler (04:11.080 - 04:50.020)**
*   **Gözlem Süreci:** İlk 3-4 (belki 5) ders boyunca öğrenciler kendilerini gözlemlemeli. Eğer C bilgisi eksikliği C++ kursunu takip etmeyi olanaksız kılıyorsa, alternatif çözümler aranmalıdır.
*   **Alternatifler:**
    *   16 Temmuz'da başlayacak C kursuna geçiş.
    *   Hocayla kişisel iletişim kurarak başka bir çözüm bulma.

**1.4. Kursun Dili ve Terminoloji (04:50.020 - 06:39.540)**
*   **Süre:** 200 saat.
*   **Anlatım Dili:** Türkçe.
*   **Terminoloji:** Anlatım dili Türkçe olsa da, **İngilizce teknik terminoloji** kullanılacaktır.
    *   **Neden?** C ve C++ dillerinde çok katı (İng. *strict*) bir terminoloji vardır. Kendini doğru ifade edebilmek için doğru terimleri kullanmak zorunludur.
    *   Kendi kendine öğrenenlerdeki en büyük eksikliklerden biri terminoloji bilgisidir. Yanlış terimlerle sorulan sorular anlaşılamayabilir.
    *   Hoca, endüstride kullanılacak İngilizce terimleri ders Türkçe olsa bile mutlaka belirtecektir.
    *   Öğrenciler, hocanın kullandığı bir Türkçe terimin İngilizce karşılığı hakkında şüpheye düşerse sormalıdır.

**1.5. Soru Sorma Yöntemleri (06:41.120 - 06:59.300)**
*   **İlk Dersler:** Sesli soru sorulması istenmiyor.
*   **Sonraki Dersler (5-6 ders sonra):** Sesli soru sormakta sakınca yok.
*   Alternatif: Chat ekranından soru sorulabilir.

**1.6. C++ Dilinin Gelişimi ve Modern C++ (07:00.600 - 08:23.000)**
*   **Süre Yetersizliği:** 200 saat, C++ gibi büyük bir dil için aslında yeterli değildir, özellikle dilin hala büyüdüğü göz önüne alındığında.
*   **C++11 Devrimi:** 2011 yılında yayınlanan standart ile dil radikal bir değişime uğramıştır.
*   **Modern C++:** 2011 ve sonraki standartlara göre kullanılan C++'a popüler olarak "Modern C++" denir. Bu kurs Modern C++ öğretecektir.
*   **Standart Güncellemeleri:** 2011'den sonra her 3 yılda bir yeni standart yayınlanmaktadır (2011, 2014, 2017, 2020).
*   **C++23 Standardı:** "Feature Complete" (İng. özellik seti tamamlanmış) durumdadır, resmi prosedürler beklenmektedir.

**1.7. C++ Standartları: Majör ve Minör Ayrımı (08:23.000 - 09:39.720)**
*   **Kursun Tabanı:** Bu kursta minimal baz (İng. *minimal base*) **C++17** standardı olacaktır.
*   **Standartların Önemi:** Standart konusu çok önemlidir.
    *   **Majör Standartlar:** Dile köklü değişiklikler veya büyük eklemeler getiren standartlar (popüler bir terim, resmi değil).
    *   **Minör Standartlar:** Daha küçük yamalar (İng. *patches*), küçük eklemeler getiren standartlar.
    *   Örnekler:
        *   C++11: Majör
        *   C++14: Minör
        *   C++17: Majör
        *   C++20: Majör
        *   C++23: Minör
*   **Kullanılan Adlandırma:** C++11, C++17, C++20 şeklinde kullanılır.

**1.8. Kursta İşlenecek Standartlar ve İleri C++ Kursu (09:59.560 - 11:25.100)**
*   **C++17:** Minimal tabanımızdır, C++17 ile gelen tüm araçlar öğrenilecektir.
*   **C++20:** Bazı araçları anlatılacak, ancak C++20 standardının tamamı zaman kısıtı nedeniyle kapsanamayacaktır.
*   **İleri C++ (Advanced C++) Kursu:** Bu kursu bitirenler için isteğe bağlı, gerçekten ileri seviye bir kurstur.
    *   İçerik: İleri teknikler, deyimler (İng. *idioms*), C++20 standardıyla gelen araçlar.
    *   Piyasadaki bazı "Advanced C++" kursları çok temel konuları anlatırken, bu kursun ileri seviyesi gerçekten derinlemesine olacaktır.

**1.9. Kurs Sonrası Yetkinlik ve İş Olanakları (11:26.460 - 12:28.140)**
*   **İş Piyasası:** Kursu verimli bitirenler, yurt içi veya yurt dışında C++ geliştiricisi olarak çalışmaya aday olurlar.
*   **Domain Bilgisi:** Bu kurs dil yetkinliğine odaklanır, spesifik domain (alan) bilgisi (gömülü sistemler, oyun programlama, otonomi vb.) vermez.
*   **Mülakat Başarısı:** Özellikle yeni mezun veya kariyer değiştirenler için C++ mülakatlarını geçebilecek seviyeye gelinecektir.

**1.10. Ders Programı ve Yapısı (12:33.700 - 13:11.900)**
*   **Haftalık Ders:** Haftada 2 gün, 3'er saatten toplam 6 saat.
*   **Ders Saati:** Türkiye saati ile 19:30 - 22:30.
*   **Ara:** Tek bir ara, 20 dakika. (Net ders süresi: 2 saat 40 dakika).

**1.11. Ders Materyalleri ve Kaynak Kitaplar (13:13.220 - 13:59.280)**
*   **Takip Edilen Kitap:** Belirli bir kitap takip edilmeyecek.
*   **Kaynak Paylaşımı:** C++ öğrenme sürecini destekleyecek kitaplar paylaşılacak.
    *   Paylaşım Yöntemi: Hoca, kendi Google Drive linkini verecek. Kitaplar ya ücretsiz dağıtılan ya da hocanın satın aldığı kitaplar olacak.
    *   Etik Sorumluluk: Kitapları indirmek veya bakıp satın almak öğrencinin kendi sorumluluğundadır. Hoca, "indirin" diye paylaşım yapmıyor, erişime açıyor.

**1.12. Kaynakların Önemi ve Zaman Ayırma (14:00.200 - 15:32.140)**
*   **Kaynak Filtreleme:** Günümüzde kaynak sıkıntısı yok, ancak iyi kaynakları filtreleme problemi var.
*   **Başarı Faktörleri:** Ayrılan zaman, öğrenme metodolojisi, okunan kitapların kalitesi.
*   **Kendi Kendine Öğrenme Zorluğu:** Genellikle yetersiz kalır, çünkü kötü kitaplardan veya eksik eğitimlerden öğrenilmeye çalışılabilir.
*   **Kısa Süreli Eğitimler:** Udemy gibi platformlardaki 3-4 saatlik C++ eğitimleri ancak tanışma niteliğinde fayda sağlar, dili derinlemesine öğretmez.

**1.13. İlk Ders Konusu: C ve C++ Farklılıkları (15:34.560 - 17:03.420)**
*   **Genel Tanıtım:** C++ dili hakkında genel bilgiler verilecek, ancak bu zamanla yayılacak.
*   **İlk Ana Konu:** C++'ın içindeki C (İng. *C in C++*) ile bağımsız programlama dili olan C arasındaki temel sentaks düzeyindeki farklılıklar.
    *   Bu konu, C bilgisi varsayımını pekiştirecek ve öğrencilerin seviyesini görmesi için iyi bir gösterge olacak.
    *   Süre: Tempoya ve sorulara göre en fazla 3-4 saat.
    *   Sonrası: Bu farklılıklar biliniyor kabul edilerek, C++'da olan ama C'de olmayan araçlara geçilecek.

**2. C++ Dilinin Genel Özellikleri ve Zorlukları (17:04.380 - ...)**

**2.1. Öğrenci Profili ve Yanlış Bilgilerin Düzeltilmesi (17:04.380 - 18:49.280)**
*   **Deneyimli Katılımcılar:** Kursa katılanlar arasında C++ developer olarak çalışan, hatta iyi seviyede olanlar mevcut.
*   **Öğrenme Fırsatı:** Bu kişiler de bilmedikleri noktaları öğrenebilir veya yanlış bildiklerini düzeltebilirler.
*   **En Büyük Zorluk:** Hiç bilmeyen birine öğretmek, yanlış öğrenmiş birine öğretmekten daha kolaydır. Yanlış oluşturulmuş bir modeli yıkıp doğrusunu inşa etmek gerekir (İng. *unlearn*).

**2.2. C++ Algısı: Sevenler ve Sevmeyenler (18:50.700 - 20:39.720)**
*   **Tartışmalı Dil:** C++ eleştireni, sevmeyeni çok olan bir dildir.
*   **İki Uç:** Seveni çok sever, sevmeyeni nefret eder. Ortada duran azdır.
*   **Dilin Yaratıcısı (Bjarne Stroustrup):** "Hiçbir programlama dili mükemmel değildir."
*   **Amaç:** C++'ı, kusurlarına rağmen, endüstride yaygın kullanıldığı için iyi öğrenmek.

**2.3. C++'ın Zorluğu (20:49.560 - 22:25.640)**
*   **Kabul:** C++ zor bir dildir. Diğer popüler dillere göre daha karmaşıktır.
*   **Neden Zor?**
    1.  **Düşük Seviyeye Yakınlık:** Yüksek seviyeli diller arasında C gibi verimlilik (İng. *efficiency*) odaklıdır. C# ve Java gibi dillerin amacı geliştirici üretkenliğini (İng. *productivity*) artırmakken, C++'da temel amaç oluşan kodun verimli olmasıdır. Bu yüzden öğrenme eğrisi daha diktir.
    2.  **Kullanıcı Dostu Olmayan Sentaks:** Sentaksı (İng. *syntax*) başlangıçta kullanıcı dostu (İng. *user-friendly*) değildir, ancak öğrenildikten sonra ifade gücü (İng. *expressiveness*) yüksektir.

**2.4. C++'ın Zorluk Nedenleri (Devam): Büyüklük (22:25.640 - 26:20.040)**
*   **Dilin Büyüklüğü:** C küçük bir dil iken, C++ çok büyük bir dildir.
    *   **Çok Sayıda Araç:** Dilin sentaksı geniştir, öğrenilecek çok kural vardır.
    *   **Anksiyete:** Bir işi yapmanın çok fazla yolu olması (araç çeşitliliği) öğrenende kararsızlık yaratabilir.
    *   **Stroustrup Rivayeti:** Dilin yaratıcısının bile dilin %70'ine hakim olduğu söylenir.
    *   Kursta, endüstride yaygın kullanılan araçların çoğu öğretilecektir.

**2.5. Standart Kütüphane Büyüklüğü (26:20.040 - 26:28.520)**
*   Sadece dilin kendisi değil, standart kütüphanesi de çok büyüktür.
*   Kursun en az yarısı (yaklaşık 100 saat) standart kütüphanenin öğrenilmesine ayrılacaktır.

**2.6. C++'ın Zorluğu (Devam): Multi-Paradigma Olması (28:25.900 - 33:26.980)**
*   **Programlama Paradigmaları:** Dillerin yaslandığı temel yaklaşımlar (Örn: Procedural, Object-Oriented (OOP), Functional, Generic).
*   **C# / Java:** Temel olarak OOP odaklıdır.
*   **C++: Multi-Paradigma Bir Dildir!** (Bjarne Stroustrup'un tanımı)
    *   Salt OOP dili değildir. OOP için gerekli araçlara sahiptir ve yoğun kullanılır.
    *   Ancak C++, farklı paradigmaları bir arada kullanmaya olanak tanır:
        *   **Procedural Programming:** C'den miras.
        *   **Object-Oriented Programming:** Sınıflar, kalıtım vb.
        *   **Generic Programming:** Şablonlar (templates) ile türden bağımsız programlama. C++'ın en güçlü olduğu alanlardan biridir.
        *   **Functional Programming:** Özellikle Modern C++ ile gelen lambda ifadeleri gibi araçlarla desteklenir.
    *   Büyük projelerde bu paradigmalar işbirliği içinde kullanılır.
*   **Data Abstraction (Veri Soyutlama):** C++'ın en güçlü olduğu noktalardan biridir. Problem domenindeki varlıkların yazılımsal olarak temsil edilmesi için güçlü araçlar sunar.
*   **Öğrenme Yükü:** C++ öğrenmek, bu farklı paradigmaları da öğrenmeyi gerektirir.

**2.7. Öğrenme Süreci ve Beklentiler (33:27.140 - 35:08.020)**
*   **Kitaplar:** Çok sayıda kitap paylaşılacak, ancak belirli bir kitap takip edilmeyecek.
*   **Not Tutma:** Derslerde not tutmaya gerek yok.
    *   Daha önceki kurslardan kalan iyi notlar mevcut.
    *   Hoca, yazdığı kodları ve benzerlerini kendi kitabında (muhtemelen online bir kaynak) paylaşacak.
*   **C++ Türkiye Topluluğu:** Hocanın kurucusu olduğu, aktif bir Telegram grubu olan topluluğa katılım faydalı olacaktır (tartışmalar, sorular, cevaplar).

**2.8. Adanmışlık ve Pratik (35:59.040 - 36:59.980)**
*   **Hayatın Parçası:** C++'ı ileri seviyede öğrenmek için hayatın bir parçası haline getirmek gerekir.
*   **Pratik:** Sadece ders dinlemek yetmez. Kodları tekrar yazmak, ödevleri yapmak, anlaşılmayan yerleri sormak önemlidir.
*   **Zaman Ayırma:** Haftada 6 saat derse ek olarak, en az 6-8 saat ders dışı çalışma (kaynak okuma, kod yazma) önerilir.

**2.9. Soru Sorma Kültürü (36:59.980 - 38:22.360)**
*   Anlaşılmayan yerler mutlaka sorulmalı.
*   Cevaplar, ders akışını bozmamak için hemen verilmeyebilir ama mutlaka ele alınacaktır.
*   Chat'teki sorular kaydedilir ve bir sonraki derste gözden geçirilir.
*   Ders dışında Telegram grubundan da soru sorulabilir.

**2.10. C++ Kullanım Alanları (Öğrenci Geri Bildirimleri İle) (38:30.000 - 42:53.280)**
*   C++ çok geniş bir alanda kullanılır.
*   **Öğrencilerin Çalıştığı/Hedeflediği Alanlar:**
    *   Oyun Programlama (Game Programming, örn: Unreal Engine)
    *   Gömülü Sistemler (Embedded Systems), Robotik
    *   Masaüstü Uygulamalar (Desktop Applications)
    *   Otomatik Ücret Toplama (Automated Fare Collection)
    *   Otonom Sürüş Yazılımları (Autonomous Driving Software)
    *   Güvenlik, Zararlı Yazılım Geliştirme/Önleme (Security, Malware Development/Prevention)
    *   Kriptoloji (Cryptography)
    *   Blok Zinciri (Blockchain)
    *   İleri Otonomi (Advanced Autonomy - Otomotiv)
    *   Finans Teknolojileri (Fintech, örn: Borsa uygulamaları)
    *   Haberleşme (Telecommunications)
*   **Gömülü Sistemlerde C++:** Genellikle C++'ın daha küçük bir alt kümesi kullanılır. Bu durum, geliştiricilerde C++'a tam hakimiyet yanılgısı yaratabilir. Diğer alanlara geçişte bu eksiklik sorun olabilir.

**3. C++ Dilinin Detayları: Terminoloji ve Evrim (43:13.860 - ...)**

**3.1. Eski C++ vs. Modern C++ (Tekrar) ve Terminoloji Ayrımı (43:13.860 - 44:46.820)**
*   **Modern C++:** Standartın kullandığı bir terim değil, popüler bir yakıştırmadır.
*   **Terminoloji Farkındalığı:**
    *   **Teknik Terimler:** Dilin standardının kullandığı terimler (Örn: `undefined behavior`, `unspecified behavior`).
    *   **Popüler Terimler:** Programcıların yaygın kullandığı, genel kabul görmüş terimler (Örn: `Modern C++`).
    *   Bu ayrım önemlidir.

**3.2. C++11'in Önemi ve Eski Kodlar (44:46.820 - 46:32.020)**
*   **C++11:** 2011'de resmileşen standart, dile radikal değişimler getirmiştir.
*   Bu tarihten önceki ve sonraki C++ kullanımı arasında net bir ayrım yapılmalıdır.
*   **Eski C++ (Ancient C++):** Modern C++ öncesi C++ için esprili bir tabir.
*   **Legacy Kod:** Bazı firmalar hala eski C++ standartlarını (Modern C++ öncesi) kullanmak zorunda kalabilirler, bu geliştiriciler için dezavantajlı bir durumdur.

**3.3. Endüstride Kullanılan C++ Standartları (Öğrenci Geri Bildirimleri) (46:32.020 - 47:50.480)**
*   Firmalarda kullanılan standartlar çeşitlilik gösterir:
    *   C++11 (yaygın)
    *   C++98'den C++17'ye kadar (geçiş süreçleri)
    *   C++14
    *   C++17 (yaygınlaşıyor)
    *   C++20 (az sayıda firma)
*   Bu kurs C++17 ve tüm araçlarını öğretecektir.

**3.4. Modern C++ ile Gelen Değişiklikler (47:50.580 - 50:21.680)**
*   **C++11'in Kilit Özellikleri:** Taşıma semantiği (İng. *move semantics*), lambda ifadeleri (İng. *lambda expressions*).
*   Modern C++ (C++11 ve sonrası) ile dilde neler değişti?
    1.  **Daha Güvenli (Safer):** Kodlama hatası yapma riski azaldı. Dilin araçları, yanlış veya kötü kod yazma ihtimalini düşürdü.
    2.  **Daha Verimli (More Efficient):** Özellikle taşıma semantiği, mükemmel yönlendirme (İng. *perfect forwarding*) gibi yeni araçlar sayesinde yazılan kodlar daha verimli hale geldi.
    3.  **Dil Büyüdü:** Hem dilin temel sentaksına (İng. *core syntax*) hem de standart kütüphaneye çok sayıda araç eklendi.

**3.5. C ve C++ Arasındaki Ayrışmanın Artması (50:21.680 - 54:16.540)**
*   Modern C++ ile birlikte C ve C++ arasındaki ayrışma arttı.
*   **Eski Yanılgı:** C'nin C++'ın bir alt kümesi (İng. *subset*) olduğu veya C++'ın C'yi kapsayan bir üst küme (İng. *superset*) olduğu düşüncesi artık tam olarak doğru değil. "C/C++" gibi ifadeler bu yanılgıyı pekiştirebilir.
*   **Ayrışma Nedenleri:**
    *   C++'ın kendi evrimi (Modern C++ özellikleri).
    *   C dilinin de kendi içinde evrilmesi (C89/90, C95, C99, C11, C17, C23). C99 standardı C'ye önemli eklemeler getirmiştir.
*   **C'de Olup C++'da Olmayan Özellikler:**
    *   Compound Literals (Bileşik değişmezler)
    *   Flexible Array Members (Esnek dizi üyeleri)
    *   VLA (Variable Length Array - Değişken uzunluklu diziler) (C++'da VLA yoktur, C99 ile C'ye eklenmiştir.)
    *   `restrict` anahtar sözcüğü (pointer'lar için)
*   **Sonuç:** Geçerli bir C kodu yazmak ve bunun aynı zamanda geçerli bir C++ kodu olmasını sağlamak, bu farklılıklara ve C'ye özgü araçlara dikkat etmeyi gerektirir.

**3.6. Hocanın Soru Sorma Stili (Tekrar) (54:16.540 - 56:35.040)**
*   Hoca çok soru sorar.
*   **Amaç:**
    *   Anlamayı test etmek (genellikle evet/hayır veya A/B şeklinde cevaplanabilen sorular).
    *   Katılımı sağlamak.
*   Yanlış cevap vermekten çekinilmemeli, bu bir öğrenme fırsatıdır. Daha önceki yanlış öğrenmeleri düzeltmeye yardımcı olur.
*   Sıkça duyulan geri bildirim: "C++'ı iyi bildiğimi sanıyordum, meğer ne kadar çok şeyi yanlış öğrenmişim."

**3.7. Mevcut Konu: C vs C++ Temel Sentaks Farklılıkları (56:35.040 - 57:08.700)**
*   Bu bölümde C++'a özgü (C'de olmayan) referans semantiği, namespace'ler gibi konulara girilmeyecek.
*   Odak: "C'de kural böyleydi, artık C++'da böyle değil" şeklindeki temel sentaks farklılıkları.

**4. Temel Kavramlar: Derleyici Davranışları ve Kod Geçerliliği (58:31.940 - ...)**

**4.1. Geriye Uyumluluk ve Derleyici Esnekliği (58:31.940 - 01:00:16.240)**
*   **Standart Kuralları vs. Derleyici Davranışı:** Dil standardının getirdiği kurallar ile GCC, Clang, MSVC gibi derleyicilerin eski kodları kabul etme eğilimleri farklı olabilir (geriye uyumluluk - İng. *backward compatibility*).
*   **Kod Geçerliliği (Validity):** Bir kodun dil kurallarına uygun olması.
*   **Yanlış Kanı:** Kurallara aykırı kod derlenmez.
    *   **Standart Der Ki:** Kurallara uygun (İng. *well-formed*) programlar derlenmelidir. Kurallara aykırı (İng. *ill-formed*) programların derlenip derlenmeyeceği derleyiciye bağlıdır; standart, derlenmemesini zorunlu kılmaz.

**4.2. Hatalı Kodlar İçin Bildirimler (Diagnostics) ve ODR (01:00:16.240 - 01:03:44.300)**
*   **Diagnostik (Bulgu İletisi):** Eğer derleyici kurallara aykırı bir kodu derlerse, genellikle bir "diagnostik" (hata veya uyarı mesajı) vermek zorundadır.
*   **"No diagnostic required":** Bazı durumlarda, kod kurallara aykırı olsa bile derleyicinin diagnostik verme zorunluluğu yoktur. Bu, genellikle hatanın tespiti derleyicinin tek bir kaynak dosyayı işlerken yapamayacağı durumlar için geçerlidir.
*   **ODR (One Definition Rule - Tek Tanımlama Kuralı):**
    *   Bir programdaki her bir değişkenin, fonksiyonun, türün vb. (non-inline olanlar için) yalnızca bir tanımı olabilir.
    *   Örnek: Farklı kaynak dosyalarda (`A.cpp`, `B.cpp`) aynı kullanıcı tanımlı türün (İng. *user-defined type*) farklı tanımları varsa bu ODR ihlalidir ve tanımsız davranışa (UB) yol açar. Derleyici bunu tek dosyayı derlerken fark edemeyebilir; linker aşamasında hata verebilir veya vermeyebilir.

**4.3. Derleyici Optimizasyonları (Compiler Optimizations) (01:03:44.300 - 01:06:16.620)**
*   C ve C++ öğrenenlerin sıkça gözden kaçırdığı, ancak çok önemli bir konu.
*   Derleyici, kaynak kodu assembly veya makine koduna birebir çeviren basit bir araç değildir.
*   Anahtar işlevlerinden biri kodu optimize etmektir.

**4.4. Gözlenebilir Davranış (Observable Behavior) (01:06:16.620 - 01:09:48.740)**
*   **Derleyicinin Sözleşmesi:** Derleyici, kodu istediği gibi değiştirebilir (optimize edebilir), ANCAK programın çalışma zamanındaki gözlenebilir davranışı (çıktıları, etkileşimleri vb.) değişmemelidir. Yani, optimize edilmiş kod, birebir çevrilmiş kodla aynı sonucu üretmelidir.
    *   Hocanın esprisi: "Senin kodunun %50'si sensen, %50'si (hatta daha fazlası) benim (derleyiciyim). Ben optimize etmesem kodun nal toplardı!"
*   Amaç: Daha verimli kod (daha hızlı çalışma, daha az yer kaplama).

**4.5. Derleyici Optimizasyon Örnekleri (01:09:48.740 - 01:12:29.400)**
*   Derleyici, gözlenebilir davranışı değiştirmemek kaydıyla şunları yapabilir:
    *   Deyimlerin (İng. *statements*) sırasını değiştirmek.
    *   Kullanılmayan veya etkisi olmayan kodu (İng. *dead code*) silmek.
    *   Döngüleri yeniden düzenlemek (Örn: artan sıralı bir döngüyü azalan sıralı yapmak, eğer sonuç değişmiyorsa).
        ```c
        // Öğrencinin yazdığı:
        for (int i = 0; i < 10; ++i) { /* işlem */ }
        // Derleyicinin eşdeğer kabul edebileceği:
        for (int i = 9; i >= 0; --i) { /* işlem */ }
        ```
*   Kendi kendine öğrenenler, genelde birebir çeviri beklentisi içinde olduklarından bu optimizasyonları göz ardı edebilirler.

**4.6. Davranış Türleri: Tanımsız, Belirlenmemiş, Implementasyona Bağlı (01:12:29.400 - 01:14:18.380)**
*   Hoca, sınıfa bu terimleri bilip bilmediklerini sordu. Çoğunluk tam olarak bilmediğini belirtti. Bu kavramlar C/C++ için hayati önemdedir.
    1.  **Undefined Behavior (UB)** (Tanımsız Davranış)
    2.  **Unspecified Behavior** (Belirlenmemiş Davranış)
    3.  **Implementation-Defined Behavior** (Implementasyona Bağlı Davranış)

**4.7. Tanımsız Davranış (Undefined Behavior - UB) (01:14:18.380 - 01:19:22.720)**
*   **Tanım:** Eğer kod, standardın "tanımsız davranış" olarak belirttiği bir durumu tetiklerse, standarda göre programın ne yapacağı konusunda **hiçbir garanti yoktur.**
*   **Sonuçlar:** Program beklendiği gibi çalışabilir, çökebilir, yanlış sonuçlar üretebilir, güvenlik açığı oluşturabilir. Hocanın esprili deyişiyle "sadece Cenab-ı Allah'ın bildiği durumlar" veya Anthony Williams'ın kitabından alıntıyla "monitörden dumanlar çıkabilir."
*   **Yaygın UB Örnekleri:**
    *   Tam sayıyı sıfıra bölme.
    *   `NULL` (veya `nullptr`) göstericiyi çözme (İng. *dereferencing*).
    *   Dizi sınırlarının dışına taşma (İng. *array out-of-bounds access*).
    *   `strcpy`, `strcat` gibi fonksiyonlarda hedef ve kaynak bellek bölgelerinin çakışması (İng. *overlapping memory regions*).
*   **Önemli Yanılgı:** "Kodum çalışıyor, demek ki UB yok." Bu %100 yanlıştır. UB, kodun *o an için* çalışıyor gibi görünmesini de kapsar. UB'li kod, farklı derleyicide, farklı optimizasyon seviyesinde veya farklı zamanda farklı davranabilir. Saatli bomba gibidir.
*   Kodun doğruluğu, UB içermemesine bağlıdır. Çalışma zamanı testi ile tüm UB'ler tespit edilemez.

**4.8. UB ve Derleyici Optimizasyonları İlişkisi (01:19:22.720 - 01:24:56.960)**
*   **Kritik Nokta:** Derleyici, kodu optimize ederken, **kodda UB olmadığı varsayımına güvenir.**
*   Eğer bir kod yapısı belirli koşullar altında UB'ye yol açıyorsa, derleyici bu koşulların *hiçbir zaman* gerçekleşmeyeceğini varsayarak optimizasyon yapabilir.
*   **Örnek 1: Sıfıra Bölme**
    ```c
    a = b / c;
    // ... arada başka kodlar ...
    if (c == 0) { /* bu blok optimize edilip silinebilir */ }
    ```
    Derleyici, `c`'nin asla 0 olmayacağını varsayabilir, çünkü olursa `b / c` UB olur. Dolayısıyla `if (c == 0)` koşulunun her zaman yanlış olduğunu düşünüp bu bloğu silebilir.
*   **Örnek 2: Bitsel Kaydırma (Bitwise Shift)**
    ```c
    // int 32-bit ise, x'in değeri 0-31 aralığında olmalı
    val = some_int << x; // x >= 32 veya x < 0 ise UB
    // ...
    if (x > 45) { /* bu blok da silinebilir */ }
    ```
    Derleyici, `x`'in her zaman geçerli aralıkta (örn: 0-31) olduğunu varsayar. `x > 45` durumu zaten UB'ye işaret edeceği için bu koşulun da gerçekleşmeyeceğini varsayabilir.
*   **Kural:** Kodda **bir tane bile UB olmamalıdır.** UB içeren kod yazmak, programcının hatasıdır.

**4.9. Belirlenmemiş Davranış (Unspecified Behavior) (01:25:01.660 - 01:31:16.620)**
*   **Tanım:** Standart, derleyiciye belirli bir durumda birkaç geçerli alternatiften birini seçme özgürlüğü tanır.
*   Derleyici, hangi alternatifi seçtiğini belgelemek zorunda değildir ve seçimi farklı derlemelerde veya kodun farklı yerlerinde değişebilir.
*   Bu bir hata değildir, ancak programcı kodu yazarken bu alternatiflerden herhangi birine güvenceli olmamalıdır.
*   **Örnek 1: String Literallerinin Saklanması**
    ```c
    const char* p1 = "hello";
    const char* p2 = "hello";
    // if (p1 == p2) { /* ... */ } // Sonuç belirsiz
    ```
    Derleyici "hello" stringini bellekte bir kez saklayıp `p1` ve `p2`'yi aynı adrese yönlendirebilir (`p1 == p2` doğru olur) veya iki ayrı kopya oluşturabilir (`p1 == p2` yanlış olur). Bu durum "unspecified behavior"dır.
*   **Örnek 2: Fonksiyon Argümanlarının veya Yan Yana İfadelerin Değerlendirme Sırası (Sıralama noktası olmayan durumlar)**
    ```c
    int g_val = 20;
    int func_foo(int x) { return x * g_val; }
    int func_bar(int y) { g_val *= 2; return y + 3; }

    int main_result = func_foo(10) + func_bar(5); // foo mu önce bar mı?
    ```
    Eğer `func_foo` önce çağrılırsa: `10 * 20 = 200`. Sonra `func_bar` çağrılır: `g_val` 40 olur, `func_bar` `5+3=8` döndürür. Sonuç: `200 + 8 = 208`.
    Eğer `func_bar` önce çağrılırsa: `g_val` 40 olur, `func_bar` `5+3=8` döndürür. Sonra `func_foo` çağrılır: `10 * 40 = 400`. Sonuç: `400 + 8 = 408`.
    Çağrı sırası "unspecified" olduğu için sonuç değişebilir. Kod, her iki duruma da hazırlıklı olmalıdır.

**4.10. Implementasyona Bağlı Davranış (Implementation-Defined Behavior) (01:31:16.620 - 01:34:56.440)**
*   **Tanım:** "Unspecified behavior"ın bir alt kümesidir. Derleyici yine birkaç alternatiften birini seçer, ancak bu seçimini **belgelemek (dokümante etmek) zorundadır.**
*   Seçilen davranış, o derleyici ve platform için tutarlı olacaktır.
*   **Örnek:** `sizeof(int)` değeri. Bir platformda 2 byte, diğerinde 4 byte, başkasında 8 byte olabilir. Derleyici üreticisi, kendi implementasyonunda `int`'in kaç byte olduğunu belgeler.
*   **Taşınabilirlik (Portability) Sorunu:** Bir derleyicide `sizeof(int) == 4` varsayımına dayanan kod, `sizeof(int) == 2` olan başka bir derleyicide farklı davranabilir.
*   **Özet:**
    *   **UB:** Her zaman hatadır, kaçınılmalıdır.
    *   **Unspecified:** Hata değildir, ancak belirli bir sonuca güvenilmemelidir.
    *   **Implementation-Defined:** Hata değildir, derleyici tarafından belgelenir, ancak taşınabilirlik açısından dikkatli olunmalıdır.

**4.11. Sıralama Noktaları (Sequence Points) ve C++'daki Karşılıkları (01:34:56.440 - 01:38:19.860)**
*   **Tanım:** Belirli operatörler, operandlarının değerlendirme sırasını garanti eder.
*   C'deki terim: **Sequence Point**. C++'da daha modern terimler: "sequenced before", "unsequenced", "indeterminately sequenced".
*   Sıralamayı garanti eden operatörler:
    *   Mantıksal AND (`&&`): Sol operand önce. Yanlışsa, sağ operand değerlendirilmez (kısa devre - İng. *short-circuit*).
    *   Mantıksal OR (`||`): Sol operand önce. Doğruysa, sağ operand değerlendirilmez (kısa devre).
    *   Virgül Operatörü (`,`): Sol operand önce değerlendirilir (sonucu atılır), sonra sağ operand değerlendirilir.
    *   Koşul Operatörü (`? :`): Önce koşul (`şart ? doğru_ifade : yanlış_ifade`). Sonra koşula göre ya `doğru_ifade` ya da `yanlış_ifade` değerlendirilir.
*   Örnek: `foo() && bar()` ifadesinde, `foo()` fonksiyonunun `bar()` fonksiyonundan önce çağrılacağı garantidir. `foo()`'nun yan etkileri (İng. *side effects*), `bar()` (eğer çağrılırsa) tarafından görülebilir.

**4.12. Derleyici Optimizasyonu: Sabit Katlama (Constant Folding) Örneği (01:38:19.860 - 01:40:23.120)**
```c
int main() {
    const int x = 10; // const eklemek optimizasyonu kolaylaştırır
    const int y = 20;
    int z = x * y;
    return z;
}
// Derleyici şu şekilde optimize edebilir:
int main() {
    return 200;
}
```
Bu, "sabit katlama" (İng. *constant folding*) adı verilen bir optimizasyon tekniğidir. Programın gözlenebilir davranışı (200 döndürmesi) değişmez.

---

---


Okay, devam ediyoruz:

---

**5. C ve C++ Arasındaki Temel Sentaks Farklılıkları (Devam)**

**5.1. Fonksiyon Bildirim ve Tanımları İle İlgili Farklılıklar (01:41:02.620 - ...)**

**5.1.1. Örtülü Fonksiyon Bildirimi (Implicit Function Declaration) (01:44:11.320 - 01:50:52.340)**
*   **Kavram:** Bir fonksiyon çağrıldığında, eğer o fonksiyon daha önce bildirilmemişse (declare edilmemişse) derleyicinin davranışı.
*   **Name Lookup (İsim Arama):** Derleyici bir isimle (identifier) karşılaştığında, bu ismin neye karşılık geldiğini (değişken, fonksiyon, tür vb.) bulmak için "name lookup" yapar.
*   **C89/90 Davranışı:**
    *   Eğer bir isim name lookup ile bulunamazsa ve fonksiyon çağrı operatörü `()` ile kullanılmışsa, C89/90 derleyicileri bu fonksiyon için örtülü bir bildirim (implicit/default function declaration) varsayar.
    *   Bu örtülü bildirim genellikle `int func_name();` şeklinde olurdu (yani geri dönüş değeri `int`, parametreleri hakkında bilgi yok).
    *   **Örnek (C89/90'da geçerli, uyarı verebilir):**
        ```c
        // foo.c (C89/90 modu)
        int main() {
            foo(10, 20); // foo bildirilmediği halde derleyici int foo() varsayar.
                         // Linker aşamasında hata alınır eğer tanımı yoksa.
            return 0;
        }
        // Derleyici sanki şunu görmüş gibi davranır:
        // extern int foo(); // (Parametreler hakkında bilgi yok)
        ```
*   **C99 Davranışı:** Örtülü fonksiyon bildirimi C99 standardı ile kaldırılmıştır. Artık C99'da bir fonksiyon çağrılmadan önce bildirilmelidir. Ancak birçok derleyici geriye uyumluluk nedeniyle uyarı vererek bu eski davranışı kabul edebilir.
*   **C++ Davranışı:**
    *   C++'da **hiçbir zaman** örtülü fonksiyon bildirimi olmamıştır.
    *   Bir fonksiyon çağrılmadan önce mutlaka bildirilmelidir. Aksi takdirde, name lookup başarısız olur ve derleyici **sentaks hatası** verir.
    *   **Örnek (C++'da HATA):**
        ```cpp
        // bar.cpp (C++ modu)
        int main() {
            bar(10, 20); // HATA: 'bar' was not declared in this scope
            return 0;
        }
        ```
*   **Tokenizing (Tekrar):** (01:50:52.340 - 01:52:49.340) Muhammed Ateşoğlu'nun sorusu üzerine hoca, "tokenizing" veya "lexical analysis" kavramını açıkladı. Derleme işleminin ilk aşamasıdır. Kaynak kod, derleyici için anlamlı en küçük birimlere (token'lar: keyword, identifier, operator, literal, delimiter vb.) ayrılır ve kategorize edilir.

**5.1.2. Boş Parametre Listesi (Empty Parameter List) (01:52:49.340 - 01:56:37.860)**
*   **C Davranışı:**
    *   `int func();` bildirimi: Bu, `func` fonksiyonunun **parametreleri hakkında bilgi verilmediği** anlamına gelir. Fonksiyona herhangi bir sayıda argümanla çağrı yapılabilir ve bu durum derleme zamanında bir hata vermez (ancak tanımsız davranışa yol açabilir).
    *   `int func(void);` bildirimi: Bu, `func` fonksiyonunun **hiç parametre almadığı** anlamına gelir. Fonksiyona argümanla çağrı yapılırsa derleyici hata verir.
    *   **Örnek (C'de):**
        ```c
        // C Kodu
        void foo();       // Parametreleri hakkında bilgi yok
        void bar(void);   // Hiç parametre almaz

        int main() {
            foo(1, 2, 3); // C'de geçerli (ama muhtemelen yanlış)
            // bar(1);    // HATA: too many arguments to function bar
            return 0;
        }
        ```
*   **C++ Davranışı:**
    *   `int func();` ve `int func(void);` bildirimleri **tamamen aynı anlama gelir:** `func` fonksiyonu **hiç parametre almaz.**
    *   C++'da bir fonksiyonun parametre almadığını belirtmek için `void` yazmak isteğe bağlıdır, boş parantez yeterlidir.
    *   **Örnek (C++'da):**
        ```cpp
        // C++ Kodu
        void foo();    // Hiç parametre almaz
        void bar(void); // Hiç parametre almaz (foo ile aynı anlamda)

        int main() {
            // foo(1, 2, 3); // HATA: too many arguments to function foo
            // bar(1);       // HATA: too many arguments to function bar
            return 0;
        }
        ```

**5.1.3. Örtülü `int` (Implicit `int`) (01:56:37.860 - 02:02:41.120)**
*   **Kavram:** Bir tür (data type) belirtilmesi gereken bazı sentaktik konumlarda, tür yazılmadığında derleyicinin `int` varsayması.
*   **C89/90 Davranışı:** Implicit `int` kuralı yaygındı.
    *   **Fonksiyon Geri Dönüş Değeri:** Eğer bir fonksiyon tanımında veya bildiriminde geri dönüş değeri türü belirtilmezse, `int` varsayılırdı.
        ```c
        // C89/90 Kodu
        my_func(int a) { // Geri dönüş değeri int varsayılır
            return a * 2;
        }
        ```
    *   **Değişken Bildirimleri:** `static x;` gibi bir bildirimde `x`'in türü `int` varsayılırdı (`static int x;`).
*   **C99 Davranışı:** Implicit `int` kuralı C99 standardı ile büyük ölçüde kaldırılmıştır. Ancak derleyiciler geriye uyumluluk için hala kabul edebilir (genellikle uyarı ile).
*   **C++ Davranışı:**
    *   C++'da **implicit `int` kuralı yoktur.**
    *   Fonksiyonların geri dönüş değeri türü, değişkenlerin türü vs. açıkça belirtilmelidir. Aksi takdirde **sentaks hatası** alınır.
        ```cpp
        // C++ Kodu
        // my_func(int a) { // HATA: return type defaults to 'int' (derleyiciye göre mesaj değişir)
        //    return a * 2;
        //}

        // static x; // HATA: 'x' does not name a type veya benzeri
        ```
*   **`unsigned` ve `signed` Anahtar Kelimeleriyle Kullanım (C ve C++'da Geçerli):** (02:02:41.120 - 02:04:07.240)
    *   `unsigned x;` bildirimi `unsigned int x;` anlamına gelir.
    *   `signed y;` bildirimi `signed int y;` (veya sadece `int y;`) anlamına gelir.
    *   Bu durum, C ve C++'da geçerlidir ve implicit `int` kuralından farklıdır. `unsigned` ve `signed` anahtar kelimeleri tek başına kullanıldığında `int`'i niteler. Programcılar sıkça `unsigned int` yerine sadece `unsigned` yazar.

**5.1.4. Eski Tip Fonksiyon Tanımları (Old-Style/K&R Function Definitions) (02:04:07.240 - 02:06:41.720)**
*   **C Davranışı (K&R C stili):**
    *   C'nin ilk dönemlerinden kalma, artık önerilmeyen bir fonksiyon tanımlama biçimidir.
    *   Parametre isimleri parantez içinde listelenir, türleri ise parantezden sonra ama fonksiyon bloğundan önce bildirilir.
    *   Eğer bir parametrenin türü bildirilmezse, `int` varsayılır (implicit `int` burada da geçerli).
    *   **Örnek (C'de geçerli, ama eski stil):**
        ```c
        // C Kodu (Eski Stil)
        sum_old(a, b, c) // Geri dönüş türü yazılmazsa int varsayılır
        double a;        // a'nın türü double
        int b;           // b'nin türü int
                         // c'nin türü yazılmazsa int varsayılır
        {
            return a + b + c;
        }
        ```
*   **C99 Davranışı:** Bu stil C99'da "obsolescent" (kullanımdan kalkan) olarak işaretlenmiştir ve kaldırılması planlanmaktadır. Derleyiciler uyarı verebilir.
*   **C++ Davranışı:**
    *   C++'da eski tip fonksiyon tanımları **hiçbir zaman geçerli olmamıştır.**
    *   Bu şekilde bir tanım C++'da **sentaks hatasıdır.**

**5.2. Kapsam (Scope) Kuralları ile İlgili Farklılıklar (02:13:46.260 - ...)**

**5.2.1. `for` Döngüsünde Değişken Tanımlama ve Kapsamı (02:13:46.260 - 02:19:35.540)**
*   **`for` Döngüsünün İlk Kısmında Değişken Tanımlama:**
    *   **C89:** Desteklenmezdi. Döngü değişkeni döngüden önce tanımlanmalıydı.
    *   **C99:** `for (int i = 0; ...)` şeklinde tanımlama C99 ile dile eklendi.
    *   **C++:** Başlangıcından beri `for (int i = 0; ...)` desteklenmektedir.
*   **`for` Döngü Değişkeninin Kapsamı:**
    *   **C++:** `for (int i = 0; ...)` şeklinde tanımlanan `i` değişkeninin kapsamı (scope) **sadece `for` döngüsünün kendisidir** (başlığı ve gövdesi). Döngü bittikten sonra `i`'ye erişilemez.
        ```cpp
        // C++ Kodu
        for (int i = 0; i < 5; ++i) {
            // i burada geçerli
        }
        // i = 10; // HATA: 'i' was not declared in this scope
        ```
    *   **C99:** Bu konuda C++'dan farklı ve biraz kafa karıştırıcı bir kurala sahiptir.
        *   `for (int i = 0; ...)` ile tanımlanan `i` için, C99 standardı derleyicinin sanki `for` döngüsünü çevreleyen **görünmez (zahiri) bir blok** varmış gibi davranmasını söyler.
        *   Bu, `for` döngüsünün başlığında tanımlanan değişkenin, döngüyü içeren bloktan **farklı bir iç blokta** olduğu anlamına gelir.
        *   Bu nedenle, C99'da aşağıdaki gibi bir kod geçerlidir, çünkü iç `i` dış `i`'yi gölgeler (hide/shadow) ama aynı kapsamda yeniden tanım olmazlar (çünkü `for`'un `i`'si kendi sanal bloğundadır).
        ```c
        // C99 Kodu
        int main() {
            for (int i = 0; i < 5; ++i) { // Bu 'i'nin kapsamı for döngüsü ve sanal dış bloğu
                int i = 100; // YENİ BİR 'i'. Döngüdeki 'i'yi gölgeler. Kapsamı bu iç blok.
                printf("%d\n", i); // 100 yazar
            }
            // printf("%d\n", i); // HATA: 'i' döngü dışında tanımsız.
            
            int i = 50; // Dış blokta yeni bir i
            for (int i = 0; i < 2; ++i) { // Bu i, dıştaki 50 olan i'den farklı
                // ...
            }
            printf("%d\n", i); // 50 yazar
            return 0;
        }
        ```
        C++'da ise `for (int i ...)` ve hemen altında aynı blokta `int i ...` tanımlamak hata olurdu (redefinition). C99'daki bu "zahiri blok" kuralı, `for` döngüsü ile aynı blokta aynı isimde başka bir değişken tanımlanmasına (yanlışlıkla bile olsa) izin verir, ki bu genellikle istenen bir durum değildir.
        Hocanın kullandığı terimler:
        *   **Name Hiding / Name Shadowing:** İç kapsamdaki bir ismin, dış kapsamdaki aynı adlı bir ismi gizlemesi.
        *   **Redeclaration / Redefinition:** Aynı kapsamda bir ismin birden fazla kez bildirilmesi/tanımlanması (genellikle hata).

**5.2.2. Kontrol Yapılarında (`if`, `while`, `switch`) Değişken Tanımlama (C++'a Özgü, Eski Özellik) (02:19:35.540 - 02:25:22.680)**
*   **C Davranışı:** `if`, `while`, `switch` gibi kontrol yapılarının koşul parantezleri içinde doğrudan değişken tanımlanamaz.
*   **C++ Davranışı (Başlangıcından Beri Var Olan Özellik):**
    *   C++'da `if`, `while` ve `switch` deyimlerinin parantezleri içinde değişken tanımlanabilir.
    *   Bu şekilde tanımlanan değişkenin kapsamı, o kontrol deyiminin kendisiyle sınırlıdır.
    *   Bu, **kapsam sızıntısını (scope leakage)** önlemek için çok kullanışlı bir özelliktir.
    *   **`if` Örneği:**
        ```cpp
        // C++ Kodu
        extern int some_function();
        if (int x = some_function()) { // x burada tanımlanır ve some_function() sonucuyla ilklendirilir
                                       // x'in değeri lojik olarak yorumlanır (0 ise false, değilse true)
            // x burada geçerli ve kullanılabilir
            printf("x is %d\n", x);
        } else {
            // x burada da geçerli (if-else yapısının tamamı x'in kapsamındadır)
            printf("x is zero or some_function failed, x = %d\n", x);
        }
        // x = 10; // HATA: 'x' if deyiminin dışında tanımsızdır.
        ```
        Anlamı: `x` değişkeni `some_function()` çağrısının sonucuyla ilklendirilir. Sonra `x`'in değeri (tam sayı ise sıfır olup olmadığı, pointer ise null olup olmadığı) if koşulu olarak değerlendirilir. `x`'in kapsamı `if` ve varsa `else` bloğunu kapsar.
    *   **`while` Örneği:**
        ```cpp
        // C++ Kodu
        extern int get_value();
        while (int val = get_value()) { // val her döngü başında ilklendirilir
                                        // val'in değeri lojik olarak yorumlanır
            // val burada geçerli
            if (val == 5) break;
        }
        // val burada tanımsız
        ```
    *   **`switch` Örneği:**
        ```cpp
        // C++ Kodu
        extern int get_option();
        switch (int opt = get_option()) { // opt burada tanımlanır
            case 1:
                // opt burada geçerli
                break;
            // ...
            default:
                // opt burada geçerli
                break;
        }
        // opt burada tanımsız
        ```
    *   **Önemli Not (Emir Çağrı'nın Sorusu Üzerine):** (02:35:07.800 - 02:36:11.200)
        `if (int x = foo())` gibi bir yapıda, tanımlanan `x` değişkeni, *koşul parantezinin içinde başka bir ifadede hemen kullanılamaz.* Yani `if (int x = foo(); x > 10)` gibi bir şey bu eski C++ özelliğiyle **doğrudan yapılamaz.** `x`'in değeri, tanımlandığı ifadenin ( `int x = foo()` ) değeri olarak lojik yorumlamaya tabi tutulur. `x`'i if/while/switch bloğunun *içinde* kullanabilirsiniz.

**5.2.3. `if with initializer` (C++17 Yeniliği) - Kısa Değini (02:36:11.200 - 02:37:28.700)**
*   Hoca, öğrencilerin `if (int x = foo())` yapısını C++17 ile gelen `if with initializer` ile karıştırmaması gerektiğini vurguladı.
*   **`if with initializer` (C++17):**
    ```cpp
    // C++17 Kodu
    if (int x = get_value(); x > 10) { // Önce x ilklendirilir, sonra x > 10 koşulu kontrol edilir.
        // x burada geçerli
    }
    // x burada tanımsız
    ```
    Bu yapı, bir ilklendirme deyimi ve ayrı bir koşul ifadesi içerir. `x`'in kapsamı yine `if` deyimiyle sınırlıdır. Bu, daha önceki C++ özelliğinden **farklı bir sentakstır** (noktalı virgül ve ayrı koşul).

**5.2.4. Kapsam Sızıntısı (Scope Leakage) (02:25:22.680 - 02:32:41.260)**
*   **Tanım:** Bir değişkenin (veya herhangi bir ismin) aslında ihtiyaç duyulduğu yerden daha geniş bir kapsamda bilinir/erişilebilir olması durumudur.
*   **Neden Kötü?**
    1.  **Okunabilirlik Azalır:** Kodu okuyan kişi, değişkenin daha sonra da kullanılacağını varsayabilir, bu da yanlış anlamalara yol açar. "Hiçbir kod, kodlayanın acemiliği göz önüne alınarak okunmaz."
    2.  **Kodlama Hatası Riski Artar:** Geniş kapsamdaki bir değişken, yanlışlıkla başka bir değişken yerine kullanılabilir ve bu durum derleyici tarafından fark edilmeyebilir (çünkü isim geçerlidir).
        ```cpp
        int x = some_function(); // x'in sadece if'te kullanılması gerekiyor
        int mx = another_value();

        if (x > 10) { /* ... */ }

        // ... çok satır sonra ...
        // mx yerine yanlışlıkla x kullanılırsa:
        int result = x * 5; // Mantık hatası, ama sentaks hatası değil!
                              // Eğer x'in kapsamı dar olsaydı, burada 'x' tanımsız olurdu ve derleyici hata verirdi.
        ```
    3.  **Kaynak Yönetimi (User-Defined Tipler İçin):** Özellikle sınıf türünden nesneler (örneğin, dosya, ağ bağlantısı, bellek bloğu gibi kaynakları yöneten nesneler) için önemlidir.
        *   Bir nesnenin ömrü (İng. *lifespan*), kapsamıyla yakından ilişkilidir (özellikle otomatik ömürlü nesneler için).
        *   Eğer bir nesne gereğinden daha geniş bir kapsamda yaşarsa, tuttuğu kaynakları da gereksiz yere uzun süre meşgul edebilir. Kapsamı daraltmak, kaynakların daha erken serbest bırakılmasını sağlayabilir.
*   **C++'da Önemi:** C'de çok önemsenmeyebilirken, C++'da `scope leakage`'dan kaçınmak kod kalitesi açısından çok önemlidir. Hocanın kod review'larında en çok işaretlediği konulardan biridir.

**5.3. Lojik Veri Türü (`bool`) Farklılığı (02:37:32.880 - 02:48:30.860)**

**5.3.1. C'de Lojik Değerler (02:37:32.880 - 02:38:33.580)**
*   **C89/90:** Ayrı bir `bool` türü yoktur.
*   Lojik ifadeler (karşılaştırma, mantıksal operatörler) `int` türünde sonuç üretir:
    *   Doğru (true) için `1`.
    *   Yanlış (false) için `0`.
    *   Örnek: `(5 > 3)` ifadesinin türü `int`, değeri `1`'dir.
*   Koşul ifadelerinde (if, while vb.) sıfır olmayan herhangi bir tam sayı değeri "doğru", sıfır değeri "yanlış" olarak yorumlanır.
*   Genellikle `flag` değişkenleri için `int` kullanılır.

**5.3.2. C99'da `_Bool` ve `stdbool.h` (02:40:51.320 - 02:42:46.280)**
*   **`_Bool` Anahtar Kelimesi:** C99 ile dile `_Bool` adında yeni bir tam sayı türü eklenmiştir. Bu tür sadece `0` veya `1` değerlerini alabilir.
    ```c
    // C99 Kodu
    _Bool my_flag = 1;
    // my_flag = 5; // my_flag'e 1 atanır (0 olmayan değerler 1'e dönüşür)
    ```
*   **`stdbool.h` Başlık Dosyası:** C99, C++ benzeri bir kullanım sağlamak için `stdbool.h` başlık dosyasını sunar. Bu dosya şunları tanımlar:
    *   `bool` (makro olarak `_Bool`'a genişler)
    *   `true` (makro olarak `1`'e genişler)
    *   `false` (makro olarak `0`'a genişler)
    ```c
    // C99 Kodu
    #include <stdbool.h>
    bool is_valid = true;
    if (is_valid) { /* ... */ }
    ```
    Bu, C++'daki `bool` türüne benzer bir kullanım sunsa da, temelde `_Bool` ve makrolara dayanır ("çakma bir bool").

**5.3.3. C++'da `bool` Türü (02:38:33.580 - 02:40:51.320 ve 02:42:46.280 - 02:48:30.860)**
*   **Yerel (Native) Tür:** C++'da `bool` dilin **doğal, ayrı bir tam sayı türüdür.** Bir makro veya `typedef` değildir.
*   **Anahtar Kelimeler:**
    *   `bool`: Türün kendisi bir anahtar kelimedir.
    *   `true`, `false`: `bool` türünün alabileceği değişmez (literal) değerlerdir ve bunlar da anahtar kelimelerdir.
*   **Boyut (`sizeof(bool)`):** Standart, `sizeof(bool)`'un minimal bir değeri olmasını garanti etmez ancak genellikle derleyiciler tarafından **1 byte** olarak implemente edilir. Bu, "implementation-defined" bir davranıştır.
*   **Operatör Sonuçları:**
    *   Karşılaştırma (`==`, `!=`, `<`, `>`, `<=`, `>=`) ve mantıksal (`!`, `&&`, `||`) operatörler C++'da **`bool` türünde** sonuç üretir (`true` veya `false`).
    *   Örnek: `(5 > 3)` ifadesinin C++'da türü `bool`, değeri `true`'dur.
*   **Örtülü Tür Dönüşümleri (Implicit Type Conversions):**
    1.  **`bool`'dan Diğer Aritmetik Türlere:**
        *   `true` değeri, hedef tam sayı türüne `1` olarak dönüşür.
        *   `false` değeri, hedef tam sayı türüne `0` olarak dönüşür.
        ```cpp
        bool b_true = true;
        int i = b_true; // i = 1
        double d = false; // d = 0.0

        bool flag1 = true, flag2 = true;
        int sum = flag1 + flag2; // flag1 -> 1, flag2 -> 1, sum = 2
        ```
    2.  **Aritmetik Türlerden (tam sayı, ondalıklı sayı) `bool`'a:**
        *   Sıfır değeri (`0`, `0.0` vb.) `false`'a dönüşür.
        *   Sıfır olmayan herhangi bir değer (`5`, `-1`, `3.14` vb.) `true`'ya dönüşür.
        ```cpp
        int x = 6;
        int y = -1;
        int z = 0;
        bool b_val;

        b_val = x; // b_val = true (çünkü x != 0)
        b_val = y; // b_val = true (çünkü y != 0)
        b_val = z; // b_val = false (çünkü z == 0)

        // Ali Büyüktepe'nin sorusu:
        int a = 5;
        int b_val2 = -5;
        bool c_val = a + b_val2; // a + b_val2 = 0, bu nedenle c_val = false
        ```
    3.  **Pointer Türlerinden `bool`'a:** (02:47:03.500 - 02:51:07.600)
        *   Null pointer değeri (`nullptr`, veya C'den kalma `NULL`, veya `0` sabiti) `false`'a dönüşür.
        *   Null olmayan herhangi bir pointer değeri `true`'ya dönüşür.
        ```cpp
        int val = 6;
        int* ptr_valid = &val;
        int* ptr_null = nullptr; // veya = 0;

        bool flag_p1 = ptr_valid; // flag_p1 = true (çünkü ptr_valid null değil)
        bool flag_p2 = ptr_null;  // flag_p2 = false (çünkü ptr_null null)

        // Emir Çağrı'nın sorusu:
        // int x_val = 0;
        // int* p_to_zero_val = &x_val; // p_to_zero_val null değil, x_val'in adresini tutuyor.
        // bool b_flag_ptr_zero = p_to_zero_val; // true olur.
        // Eğer int* p_from_zero_literal = 0; (null pointer conversion)
        // bool b_flag_ptr_null = p_from_zero_literal; // false olur.
        ```
        **Null Pointer Dönüşümü (Null Pointer Conversion):** (02:50:19.400) `0` tam sayı sabiti bir pointer bağlamında kullanıldığında, null pointer değerine dönüşür. `int* p = 0;` ifadesi `p`'yi null pointer yapar.

---

Saat 22:30'a yaklaştık, dersin sonuna geldik. (02:51:08.460) Hoca dersi bitirdi.

**Özet Olarak Tüm Farklılıkları Kapsayan Örnek Kod Bloğu (Sentaks Karşılaştırması):**

```cpp
// --- C++ Kodu (Genellikle daha katı ve bool destekli) ---
#include <cstdio> // C++'da C başlıkları için <cxxx> önerilir

// 1. Fonksiyon bildirimi: Parametre almaz
void cpp_func_no_param() {
    printf("C++: No params\n");
}

// 2. Geri dönüş değeri açıkça belirtilmeli
int cpp_add(int a, int b) {
    return a + b;
}

// 3. for döngü değişkeni kapsamı döngü ile sınırlı
void cpp_for_scope() {
    for (int i = 0; i < 2; ++i) {
        printf("C++ for: i = %d\n", i);
    }
    // int i = 5; // Burada yeni 'i' tanımlanabilir, döngüdeki 'i' ile çakışmaz
}

// 4. if içinde değişken tanımlama
void cpp_if_var(int val) {
    if (int x = val * 2) { // x'in kapsamı if-else
        printf("C++ if: x = %d (true)\n", x);
    } else {
        printf("C++ if: x = %d (false)\n", x);
    }
}

// 5. bool türü ve lojik operatörler
void cpp_bool_logic() {
    bool flag = (5 > 3); // flag = true, türü bool
    if (flag) {
        printf("C++: 5 > 3 is true\n");
    }
    int result = flag + true; // true -> 1, result = 1 + 1 = 2
    printf("C++: flag + true = %d\n", result);
}

// --- C Kodu (C99 modu varsayılarak, bazıları C89'da farklı) ---
// Not: Aynı dosyada hem C hem C++ kodu derlenemez, bu sadece karşılaştırma amaçlıdır.
/*
#include <stdio.h>
#include <stdbool.h> // C99 bool için

// 1. Fonksiyon bildirimi: (void) ile parametre almadığı belirtilir
void c_func_no_param(void) {
    printf("C: No params (void)\n");
}
// void c_func_unknown_params(); // Bu, parametreleri hakkında bilgi yok demek

// 2. Geri dönüş değeri C89'da yazılmazsa int varsayılırdı, C99'da hata (derleyiciye bağlı uyarı)
int c_add(int a, int b) {
    return a + b;
}

// 3. for döngü değişkeni C99'da "zahiri blok" içinde
void c_for_scope() {
    for (int i = 0; i < 2; ++i) { // Bu i'nin kendi "zahiri" kapsamı var
        printf("C99 for: i = %d\n", i);
        // int i = 10; // Bu C99'da geçerli, yeni bir i, döngüdekini gölgeler
    }
}

// 4. if içinde değişken tanımlama C'de yok
void c_if_no_var(int val) {
    int x = val * 2; // Önce tanımlanmalı
    if (x) {
        printf("C: x = %d (true if non-zero)\n", x);
    } else {
        printf("C: x = %d (false if zero)\n", x);
    }
}

// 5. C99'da _Bool veya stdbool.h ile bool; lojik op'ler int (0/1) üretir (C89)
void c_bool_logic() {
    // C89:
    // int flag_c89 = (5 > 3); // flag_c89 = 1, türü int
    // if (flag_c89) {
    //     printf("C89: 5 > 3 is 1 (true)\n");
    // }

    // C99:
    bool flag_c99 = (5 > 3); // stdbool.h ile; flag_c99 = true (_Bool -> 1)
    if (flag_c99) {
        printf("C99: 5 > 3 is true\n");
    }
    int result_c99 = flag_c99 + true; // true -> 1, result_c99 = 1 + 1 = 2
    printf("C99: flag_c99 + true = %d\n", result_c99);
}
*/
```