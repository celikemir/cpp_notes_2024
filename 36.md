# C++ Programlama Dili - 36. Ders NotlarÄ±

**Tarih:** 4 KasÄ±m 2024  
**Konu:** Fold Expressions (Katlama Ä°fadeleri) DetaylarÄ± ve STL (Standard Template Library) GiriÅŸ

---

## 1. Katlama Ä°fadeleri (Fold Expressions) [00:02:23 - 00:15:33]

C++17 ile dile eklenen katlama ifadeleri (fold expressions), deÄŸiÅŸken sayÄ±da argÃ¼man alan (variadic) ÅŸablonlarda parametre paketlerini (parameter packs) belirli bir operatÃ¶r eÅŸliÄŸinde iÅŸlemek iÃ§in kullanÄ±lan sentaks araÃ§larÄ±dÄ±r. Derleyici, bu ifadeyi gÃ¶rdÃ¼ÄŸÃ¼nde paketi kurallara gÃ¶re aÃ§arak ardÄ±ÅŸÄ±k operatÃ¶r iÅŸlemlerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

### Katlama Ä°fadelerinin Temel YapÄ±sÄ±
*   **Parametre Paketleri ile Ä°liÅŸki:** Katlama ifadeleri doÄŸrudan parametre paketlerinin geniÅŸletilmesi (expansion) ile ilgilidir. Eskiden "Recursive Expansion" (Ã¶zyinelemeli geniÅŸletme) ile yapÄ±lan iÅŸlemler, artÄ±k tek bir satÄ±rda daha temiz bir sentaksla ifade edilebilmektedir.
*   **OperatÃ¶r ZorunluluÄŸu:** Katlama ifadeleri ikili (binary) bir operatÃ¶r ile birlikte kullanÄ±lmalÄ±dÄ±r (toplama, Ã§Ä±karma, lojik operatÃ¶rler, virgÃ¼l operatÃ¶rÃ¼ vb.).
*   **Parantez GerekliliÄŸi:** Fold expression sentaksÄ±nda parantez kullanÄ±mÄ± zorunludur. Buradaki parantezler iÅŸlem Ã¶nceliÄŸi iÃ§in deÄŸil, sentaksÄ±n bir parÃ§asÄ± olarak derleyiciye "burada bir katlama ifadesi var" mesajÄ±nÄ± verir.

### Unary Fold (Tekli Katlama) TÃ¼rleri
Unary fold iÅŸlemleri sadece parametre paketini ve operatÃ¶rÃ¼ iÃ§erir:
1.  **Unary Left Fold (Soldan Katlama):** `(... op pack)` formatÄ±ndadÄ±r. Elipsis (Ã¼Ã§ nokta) paketin solundadÄ±r. Derleyici iÅŸlemi soldan saÄŸa doÄŸru gruplandÄ±rÄ±r: `((P1 op P2) op P3)...`
2.  **Unary Right Fold (SaÄŸdan Katlama):** `(pack op ...)` formatÄ±ndadÄ±r. Elipsis paketin saÄŸÄ±ndadÄ±r. Derleyici iÅŸlemi saÄŸdan sola doÄŸru gruplandÄ±rÄ±r: `(P1 op (P2 op ... (Pn-1 op Pn)))`

> ğŸ’¡ **Ã–ÄŸrenci Notu:** Hoca, "Elipsis paketin neresindeyse isimlendirme oradan gelir" diyerek akÄ±lda tutma yÃ¶ntemini paylaÅŸtÄ±. Elipsis soldaysa "Left Fold", saÄŸdaysa "Right Fold".

### Associativity (BirleÅŸme Ã–zelliÄŸi) FarkÄ±
Toplama gibi iÅŸlemlerde (eÄŸer tÃ¼rler aynÄ±ysa) soldan veya saÄŸdan katlama sonucu deÄŸiÅŸtirmez. Ancak bÃ¶lme (`/`) veya Ã§Ä±karma (`-`) gibi birleÅŸme Ã¶zelliÄŸi olmayan operatÃ¶rlerde, iÅŸlemin hangi yÃ¶nden baÅŸladÄ±ÄŸÄ± sonucu tamamen deÄŸiÅŸtirir.

```cpp
// Unary Left Fold Ã–rneÄŸi (Toplama)
template<typename... Args>
auto sum_left(Args... args) {
    return (... + args); // ((P1 + P2) + P3) ...
}

// Unary Right Fold Ã–rneÄŸi (Toplama)
template<typename... Args>
auto sum_right(Args... args) {
    return (args + ...); // (P1 + (P2 + (P3 ...)))
}
```

---

## 2. Binary Fold Expressions (Ä°kili Katlama Ä°fadeleri) [00:15:34 - 00:26:02]

Binary fold, unary fold'dan farklÄ± olarak iÅŸleme parametre paketinin dÄ±ÅŸÄ±ndan bir "baÅŸlangÄ±Ã§ deÄŸeri" (init/identity value) dahil eder.

### Sentaks ve YapÄ±
*   **Binary Left Fold:** `(init op ... op pack)` - Ä°ÅŸlem baÅŸlangÄ±Ã§ deÄŸeri (init) ile baÅŸlar ve soldan saÄŸa doÄŸru devam eder.
*   **Binary Right Fold:** `(pack op ... op init)` - Ä°ÅŸlem saÄŸdaki baÅŸlangÄ±Ã§ deÄŸeri ile baÅŸlar ve saÄŸdan sola doÄŸru devam eder.
*   **Neden Binary Fold?** En Ã¶nemli kullanÄ±m motivasyonlarÄ±ndan biri, parametre paketinin boÅŸ olmasÄ± durumunda bir "default" deÄŸer saÄŸlamaktÄ±r. Unary fold'da paket boÅŸsa (belirli operatÃ¶rler hariÃ§) hata alÄ±nÄ±rken, binary fold'da `init` deÄŸeri sonuÃ§ olarak dÃ¶ner.

### BoÅŸ Paket KurallarÄ± (Unary Fold iÃ§in)
Normalde unary fold'da paket boÅŸsa derleme hatasÄ± oluÅŸur. Ancak Ã¼Ã§ operatÃ¶r iÃ§in istisna vardÄ±r:
*   **Lojik VE (`&&`):** Paket boÅŸsa `true` Ã¼retir.
*   **Lojik VEYA (`||`):** Paket boÅŸsa `false` Ã¼retir.
*   **VirgÃ¼l OperatÃ¶rÃ¼ (`,`):** Paket boÅŸsa `void()` Ã¼retir.
*   *Toplama, Ã§Ä±karma gibi diÄŸer tÃ¼m operatÃ¶rlerde boÅŸ paket unary fold ile kullanÄ±lÄ±rsa sentaks hatasÄ±dÄ±r.*

```cpp
// Binary Left Fold Ã–rneÄŸi
template<typename... Args>
auto sum_with_init(int x, Args... args) {
    return (x + ... + args); // x + P1 + P2 + ...
}

// BoÅŸ paket durumunda hata almamak iÃ§in binary fold kullanÄ±mÄ±
template<typename... Args>
auto safe_sum(Args... args) {
    return (0 + ... + args); // Paket boÅŸsa 0 dÃ¶ner
}
```

---

## 3. VirgÃ¼l OperatÃ¶rÃ¼ ve Ä°diyomatik KullanÄ±mlar [00:26:03 - 00:42:21]

VirgÃ¼l operatÃ¶rÃ¼ (`comma operator`), fold expressions ile birleÅŸtirildiÄŸinde son derece gÃ¼Ã§lÃ¼ ve idiyomatik (kalÄ±plaÅŸmÄ±ÅŸ) yapÄ±lar oluÅŸturmamÄ±za olanak saÄŸlar.

### VirgÃ¼l OperatÃ¶rÃ¼ Ãœzerinde Katlama
Bu teknik genellikle bir fonksiyonu parametre paketindeki her Ã¶ÄŸe iÃ§in sÄ±rayla Ã§aÄŸÄ±rmak amacÄ±yla kullanÄ±lÄ±r. 
*   **Ã–rnek: `print` fonksiyonu:** Parametre paketindeki tÃ¼m Ã¶ÄŸeleri `std::cout` ile yazdÄ±rmak iÃ§in dÃ¶ngÃ¼ kurmak yerine fold expression kullanÄ±labilir.

```cpp
template<typename... Args>
void print_all(Args&&... args) {
    // VirgÃ¼l operatÃ¶rÃ¼ ile Unary Right Fold
    // Her argÃ¼man iÃ§in (std::cout << arg, " ") ifadesi Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.
    (void)( (std::cout << args << " ", 0) + ... ); // YaygÄ±n olmayan bir yÃ¶ntem
    
    // Daha idiyomatik (Comma Fold):
    ( (std::cout << args << " "), ... ); 
}
```

### Son ElemanÄ± Elde Etme Ä°diyomu
VirgÃ¼l operatÃ¶rÃ¼nÃ¼n Ã¶zelliÄŸi, sol operantÄ± Ã§alÄ±ÅŸtÄ±rÄ±p saÄŸ operantÄ±n deÄŸerini dÃ¶ndÃ¼rmesidir. Bu Ã¶zellik sayesinde variadic bir fonksiyona gÃ¶nderilen "en son" argÃ¼manÄ± kolayca Ã§ekebiliriz.

```cpp
template<typename... Args>
auto get_last(Args... args) {
    return (args , ...); // Unary Right Fold over comma
}
// get_last(1, 2.5, "Selam") -> "Selam" dÃ¶ndÃ¼rÃ¼r.
```

### Binary Fold ile Stream Zinciri
Binary fold kullanarak bir stream nesnesini (Ã¶rneÄŸin `std::cout`) iÅŸlemin baÅŸÄ±na ekleyebiliriz. Bu, iÅŸlem zincirini baÅŸlatmak iÃ§in Ã§ok ÅŸÄ±ktÄ±r.

```cpp
template<typename... Args>
void print_with_cout(Args... args) {
    (std::cout << ... << args) << std::endl; // Binary Left Fold
}
```

âš ï¸ **UyarÄ±:** `std::cout << ... << args` ifadesinde araya boÅŸluk koymak zordur. Bu yÃ¼zden virgÃ¼l operatÃ¶rÃ¼ ile yapÄ±lan fold (`( (std::cout << args << " "), ... );`) Ã¶ÄŸeler arasÄ±na karakter koymak iÃ§in daha elveriÅŸlidir.

---

## 4. STL (Standard Template Library) GiriÅŸ ve Temel Kavramlar [00:42:22 - 01:05:00]

C++'Ä±n en gÃ¼Ã§lÃ¼ yanÄ± olan STL, veri yapÄ±larÄ±nÄ± (containers) ve algoritmalarÄ± birbirinden ayÄ±rarak jenerik bir programlama modeli sunar.

### STL'in DoÄŸasÄ±
*   **Generic Library (Jenerik KÃ¼tÃ¼phane):** STL, nesne yÃ¶nelimli (OOP) bir kÃ¼tÃ¼phane deÄŸildir. OOP veriyi ve fonksiyonu paketlerken, STL veriyi (containers) ve fonksiyonu (algorithms) birbirinden tamamen ayÄ±rÄ±r.
*   **Verimlilik:** STL, soyutlama yaparken "zero-cost abstraction" ilkesine sadÄ±k kalÄ±r. Yani elinizle yazdÄ±ÄŸÄ±nÄ±z en hÄ±zlÄ± C koduna yakÄ±n bir performans sergiler.
*   **ÃœÃ§ Temel BileÅŸen:**
    1.  **Containers (Kaplar):** Veriyi tutan yapÄ±lar (vector, list, set).
    2.  **Iterators (Yineleyiciler):** Kaplar ile algoritmalar arasÄ±nda kÃ¶prÃ¼ kuran, iÅŸaretÃ§i (pointer) benzeri yapÄ±lar.
    3.  **Algorithms (Algoritmalar):** Veri Ã¼zerinde iÅŸlem yapan jenerik fonksiyonlar (sort, find, copy).

### Kaplar (Containers) TÃ¼rleri
STL kaplarÄ± Ã¼Ã§ ana kategoriye ayrÄ±lÄ±r:
1.  **Sequence Containers (SÄ±ralÄ± Kaplar):** Ã–ÄŸelerin sÄ±rasÄ±, onlarÄ±n kap iÃ§erisindeki konumuna veya eklenme zamanÄ±na baÄŸlÄ±dÄ±r.
    *   `vector`: Dinamik dizi (bellekte bitiÅŸik - contiguous).
    *   `deque`: Ä°ki uÃ§lu kuyruk.
    *   `list`: Ã‡ift yÃ¶nlÃ¼ baÄŸlÄ± liste (bellekte daÄŸÄ±nÄ±k).
    *   `forward_list`: Tek yÃ¶nlÃ¼ baÄŸlÄ± liste.
    *   `array`: Sabit boyutlu dizi (C dizisinin sarmalayÄ±cÄ±sÄ±).
2.  **Associative Containers (Ä°liÅŸkisel Kaplar):** Ã–ÄŸeler belirli bir anahtar deÄŸerine gÃ¶re ve belirli bir sÄ±ralama iliÅŸkisiyle (genelde ikili arama aÄŸacÄ± - Red-Black Tree) tutulur.
    *   `set`, `multiset`, `map`, `multimap`.
3.  **Unordered Associative Containers (SÄ±rasÄ±z Ä°liÅŸkisel Kaplar):** Hash tablosu (Hash Table) mimarisini kullanÄ±rlar. Arama iÅŸlemleri ortalama olarak sabit zaman karmaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r ($O(1)$).

> ğŸ’¡ **Ã–ÄŸrenci Notu:** Hoca, "Standartlar bir kabÄ±n arkasÄ±nda hangi veri yapÄ±sÄ±nÄ±n olduÄŸunu (Ã¶rn: Red-Black Tree) zorunlu kÄ±lmaz, ancak kabÄ±n saÄŸlamasÄ± gereken zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± ve arayÃ¼zÃ¼ zorunlu kÄ±lar. Bu da pratikte tÃ¼m derleyicilerin aynÄ± veri yapÄ±larÄ±nÄ± kullanmasÄ±na yol aÃ§ar" dedi.

---

## Master Kod Ã–rneÄŸi (BÃ¶lÃ¼m Ã–zeti)

AÅŸaÄŸÄ±daki kod, derste iÅŸlenen fold expressions ve STL konteynerlarÄ±na dair jenerik bir print mantÄ±ÄŸÄ±nÄ± birleÅŸtirir.

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>

// FOLD EXPRESSION: Parametre paketindeki her ÅŸeyi yazdÄ±ran jenerik fonksiyon
template<typename... Args>
void logger(Args&&... args) {
    std::cout << "[LOG]: ";
    // Comma fold: Her argÃ¼manÄ± sÄ±rayla yazdÄ±rÄ±r
    ((std::cout << args << " | "), ...);
    std::cout << std::endl;
}

// STL & ITERATORS: Herhangi bir konteyner aralÄ±ÄŸÄ±nÄ± yazdÄ±ran jenerik algoritma
template<typename Iter>
void print_range(Iter beg, Iter end) {
    while (beg != end) {
        std::cout << *beg << " ";
        ++beg; // Ä°teratÃ¶r ilerletme
    }
    std::cout << "\n";
}

int main() {
    // Fold Expression Test
    logger(10, 4.5, "Merhaba STL", 'A');

    // Sequence Containers
    std::vector<int> v = {1, 2, 3, 4, 5};
    std::list<std::string> l = {"C++", "Templates", "Generic"};

    std::cout << "Vector: ";
    print_range(v.begin(), v.end());

    std::cout << "List: ";
    print_range(l.begin(), l.end());

    // C-Style Array ile STL uyumu (Global begin/end kullanÄ±mÄ±)
    int arr[] = {10, 20, 30};
    std::cout << "Array: ";
    print_range(std::begin(arr), std::end(arr));

    return 0;
}
```

---

## 5. Ä°liÅŸkisel Kaplar ve KarmaÅŸÄ±klÄ±k [01:05:01 - 01:08:40]

Ä°liÅŸkisel kaplar (associative containers), Ã¶ÄŸeleri anahtar-deÄŸer (key-value) iliÅŸkisiyle veya sadece anahtar olarak tutan, Ã¶ÄŸe eklendiÄŸinde otomatik olarak sÄ±ralayan yapÄ±lardÄ±r.

### Set, Multiset ve Map FarklarÄ±
*   **std::set:** Her anahtardan (key) sadece bir adet bulunabilir. Bir kÃ¼me gibi Ã§alÄ±ÅŸÄ±r; aynÄ± Ã¶ÄŸeyi ikinci kez eklemeye Ã§alÄ±ÅŸÄ±rsanÄ±z iÅŸlem baÅŸarÄ±sÄ±z olur (duplicate Ã¶ÄŸeye izin vermez).
*   **std::multiset:** AynÄ± anahtardan birden fazla bulunmasÄ±na izin verir. Ã–rneÄŸin, bir sÄ±nÄ±ftaki Ã¶ÄŸrencilerin isimlerini tutuyorsanÄ±z ve iki tane "Alihan" varsa, her ikisi de multiset iÃ§inde yer alabilir.
*   **std::map:** Bir anahtara karÅŸÄ±lÄ±k gelen bir deÄŸer (value) tutar. "ID numarasÄ± -> Ä°sim" eÅŸleÅŸmesi gibi Ã§alÄ±ÅŸÄ±r. Sorgulama anahtar Ã¼zerinden yapÄ±lÄ±r, sonuÃ§ olarak deÄŸer dÃ¶ndÃ¼rÃ¼lÃ¼r.
*   **std::multimap:** Bir anahtara karÅŸÄ±lÄ±k birden fazla deÄŸerin atanmasÄ±na izin verir.

### Algoritmik KarmaÅŸÄ±klÄ±k (Complexity)
*   **SÄ±ralÄ± Ä°liÅŸkisel Kaplar (set, map):** Arka planda genellikle **Red-Black Tree** (KÄ±rmÄ±zÄ±-Siyah AÄŸacÄ±) gibi dengeli ikili arama aÄŸaÃ§larÄ± kullanÄ±lÄ±r. Bu nedenle ekleme, silme ve arama iÅŸlemleri **Logaritmik Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±na ($O(\log N)$)** sahiptir.
*   **SÄ±rasÄ±z Ä°liÅŸkisel Kaplar (unordered_set, unordered_map):** C++11 ile eklenen bu kaplar, arka planda **Hash Table** mimarisini kullanÄ±r. Bir sÄ±ralama iliÅŸkisi gÃ¼tmezler ancak ortalama durumda **Sabit Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±nda ($O(1)$)** eriÅŸim saÄŸlarlar.

---

## 6. SÄ±nÄ±f Åablonu Olarak Kaplar ve Custom TÃ¼rler [01:08:41 - 01:15:50]

STL konteynerlarÄ± birer sÄ±nÄ±f ÅŸablonudur (class template). Derleyici, bu ÅŸablonlarÄ± kullanÄ±rken belirttiÄŸimiz tÃ¼rlere gÃ¶re gerÃ§ek sÄ±nÄ±flar Ã¼retir (instantiation).

### Åablon Parametreleri ve VarsayÄ±lanlar
KonteynerlarÄ±n sadece tuttuÄŸu Ã¶ÄŸenin tÃ¼rÃ¼nÃ¼ deÄŸil, aynÄ± zamanda davranÄ±ÅŸlarÄ±nÄ± belirleyen parametreleri de vardÄ±r. Ã–rneÄŸin `std::set<int>` aslÄ±nda `std::set<int, std::less<int>, std::allocator<int>>` ÅŸeklinde tam bir aÃ§Ä±lÄ±ma sahiptir.
*   **std::less:** KarÅŸÄ±laÅŸtÄ±rma kriterini belirleyen "Function Object" (fonksiyon nesnesi). VarsayÄ±lan olarak `<` operatÃ¶rÃ¼nÃ¼ kullanÄ±r.
*   **std::allocator:** Dinamik bellek yÃ¶netiminden sorumlu olan yapÄ±dÄ±r.

### STL'in GeniÅŸletilebilirliÄŸi (Extensibility)
STL'in en bÃ¼yÃ¼k gÃ¼cÃ¼, "open-source" bir mimariye sahip olmasÄ±dÄ±r. Standart kÃ¼tÃ¼phanede bulunmayan ancak STL standartlarÄ±na (iterator arayÃ¼zÃ¼ gibi) uygun yazÄ±lmÄ±ÅŸ Ã¼Ã§Ã¼ncÃ¼ parti konteynerlar (Ã¶rneÄŸin Boost kÃ¼tÃ¼phanesindeki kaplar), standart STL algoritmalarÄ±yla hiÃ§bir ek Ã§aba sarf etmeden kullanÄ±labilir. Bu durum, veri yapÄ±sÄ± ile algoritmanÄ±n iteratÃ¶rler sayesinde birbirinden tamamen baÄŸÄ±msÄ±z olmasÄ±nÄ±n bir sonucudur.

```cpp
// Custom bir tÃ¼rÃ¼n STL kaplarÄ±nda tutulmasÄ±
struct Fighter {
    int id;
    std::string name;
};

// VektÃ¶rde kendi tÃ¼rÃ¼mÃ¼zÃ¼ tutuyoruz
std::vector<Fighter> squad; 
```

---

## 7. Ä°teratÃ¶rler: SoyutlamanÄ±n KÃ¶prÃ¼sÃ¼ [01:15:51 - 01:30:40]

Ä°teratÃ¶rler, kaplarda (containers) tutulan Ã¶ÄŸelerin konumlarÄ±nÄ± temsil eden deÄŸiÅŸkenlerdir. Pointer'larÄ±n (iÅŸaretÃ§ilerin) daha yÃ¼ksek dÃ¼zeyde soyutlanmÄ±ÅŸ bir versiyonu olarak dÃ¼ÅŸÃ¼nÃ¼lebilirler.

### Neden Pointer Yetmez?
Pointer'lar bellek adresleriyle Ã§alÄ±ÅŸÄ±r. EÄŸer bir dizi (`vector`) kullanÄ±yorsanÄ±z pointer'Ä± `++` ile artÄ±rdÄ±ÄŸÄ±nÄ±zda bir sonraki adrese geÃ§mek mantÄ±klÄ±dÄ±r. Ancak bir baÄŸlÄ± liste (`list`) kullanÄ±yorsanÄ±z, Ã¶ÄŸeler bellekte daÄŸÄ±nÄ±ktÄ±r. Bir pointer'Ä± `++` ile artÄ±rmak sizi bir sonraki "dÃ¼ÄŸÃ¼me" (node) gÃ¶tÃ¼rmez. Ä°teratÃ¶rler, bu noktada devreye girer: `++it` dediÄŸinizde, arka plandaki veri yapÄ±sÄ± ne olursa olsun (liste, aÄŸaÃ§, dizi), iteratÃ¶r mantÄ±ksal olarak "bir sonraki Ã¶ÄŸeye" geÃ§er.

### Ä°teratÃ¶r OperatÃ¶rleri ve Overloading
Ä°teratÃ¶rler "Pointer-like" (iÅŸaretÃ§i benzeri) bir arayÃ¼ze sahiptirler. Bu arayÃ¼z operatÃ¶r aÅŸÄ±rÄ± yÃ¼klemesi (operator overloading) ile saÄŸlanÄ±r:
*   **`*it` (Dereferencing):** Ä°teratÃ¶rÃ¼n iÅŸaret ettiÄŸi konumdaki nesneye eriÅŸim saÄŸlar.
*   **`++it` (Increment):** Ä°teratÃ¶rÃ¼ bir sonraki konuma taÅŸÄ±r.
*   **`it != end` (Comparison):** Ä°teratÃ¶rlerin aynÄ± konumu gÃ¶sterip gÃ¶stermediÄŸini kontrol eder.

### `begin()` ve `end()` KavramlarÄ±
*   **`begin()`:** Konteynerdaki ilk Ã¶ÄŸenin konumunu dÃ¶ndÃ¼rÃ¼r.
*   **`end()`:** Konteynerdaki **son Ã¶ÄŸeden bir sonraki** (one-past-the-last) konumu dÃ¶ndÃ¼rÃ¼r. Bu bir "sentinel" (nÃ¶betÃ§i) deÄŸerdir; bu konumda bir nesne yoktur, sadece dÃ¶ngÃ¼nÃ¼n bittiÄŸini anlamamÄ±zÄ± saÄŸlar.

ğŸ’¡ **Ã–ÄŸrenci Notu:** C tarzÄ± dizilerin (`int arr[5]`) `.begin()` gibi Ã¼ye fonksiyonlarÄ± yoktur. Ancak Modern C++ ile gelen `std::begin(arr)` ve `std::end(arr)` gibi global fonksiyonlar sayesinde C dizileri de iteratÃ¶r tabanlÄ± algoritmalarla uyumlu hale gelmiÅŸtir.

---

## 8. Algoritmalar ve STL KonvensiyonlarÄ± [01:30:41 - 01:51:20]

Algoritmalar, iteratÃ¶rler Ã¼zerinden veri yapÄ±larÄ±yla haberleÅŸen jenerik fonksiyon ÅŸablonlarÄ±dÄ±r. STL'de yÃ¼zÃ¼n Ã¼zerinde algoritma bulunur (`std::find`, `std::copy`, `std::sort` vb.).

### STL TasarÄ±m KurallarÄ± (Conventions)
Hoca, STL algoritmalarÄ±nÄ±n uyduÄŸu iki temel kuralÄ±n altÄ±nÄ± Ã§izdi:
1.  **Girdi ve Ã‡Ä±ktÄ± SÄ±rasÄ±:** EÄŸer bir algoritma (Ã¶rneÄŸin `std::copy`) hem okuma hem yazma yapÄ±yorsa, **okuma aralÄ±ÄŸÄ± (source range) her zaman ilk parametrelerdir.** Yazma konumu (destination) ise daha sonra gelir. (C'deki `memcpy` fonksiyonunun tam tersidir).
2.  **Geri DÃ¶nÃ¼ÅŸ DeÄŸeri:** Yazma iÅŸlemi yapan algoritmalar (copy gibi), genellikle **en son yazdÄ±klarÄ± Ã¶ÄŸeden bir sonraki konumu** (iterator) dÃ¶ndÃ¼rÃ¼rler. Bu, kopyalama iÅŸleminin nerede bittiÄŸini anlamamÄ±zÄ± ve ardÄ±ÅŸÄ±k iÅŸlemler yapmamÄ±zÄ± saÄŸlar.

### `std::copy` AlgoritmasÄ±nÄ±n MantÄ±ÄŸÄ± (Elle Implementasyon)
Hoca, derleyicinin arka planda nasÄ±l bir kod Ã¼rettiÄŸini anlamamÄ±z iÃ§in `copy` algoritmasÄ±nÄ±n jenerik halini ÅŸÃ¶yle Ã¶rnekledi:

```cpp
template<typename InIter, typename OutIter>
OutIter my_copy(InIter beg, InIter end, OutIter dest_beg) {
    while (beg != end) {
        *dest_beg = *beg; // OkunanÄ± hedefe yaz
        ++beg;      // KaynaÄŸÄ± ilerlet
        ++dest_beg; // Hedefi ilerlet
    }
    return dest_beg; // Hedefin son ulaÅŸtÄ±ÄŸÄ± konumu dÃ¶ndÃ¼r
}
```

---

## 9. Range (AralÄ±k) KavramÄ±: $[first, last)$ [01:51:21 - 02:17:00]

C++ STL'de aralÄ±klar her zaman "yarÄ± aÃ§Ä±k aralÄ±k" (half-open range) mantÄ±ÄŸÄ±yla ifade edilir.

*   **Matematiksel GÃ¶sterim:** $[first, last)$
*   **AnlamÄ±:** `first` konumu aralÄ±ÄŸa dahildir (inclusive), ancak `last` konumu aralÄ±ÄŸa dahil deÄŸildir (exclusive).
*   **Garantiler:** Bir aralÄ±ÄŸÄ±n geÃ§erli olmasÄ± iÃ§in, `first` konumunun sÃ¼rekli artÄ±rÄ±larak (iterated) `last` konumuna ulaÅŸÄ±labilir olmasÄ± gerekir. EÄŸer `first` artÄ±rÄ±larak asla `last`'a ulaÅŸamÄ±yorsa bu "geÃ§ersiz bir range"dir ve tanÄ±msÄ±z davranÄ±ÅŸa yol aÃ§ar.

### `std::find` Ã–rneÄŸi ve KoÅŸullar (Constraints)
Bir algoritmanÄ±n Ã§alÄ±ÅŸabilmesi iÃ§in tutulan tÃ¼rlerin bazÄ± operatÃ¶rleri desteklemesi gerekir.
*   `std::find(beg, end, val)` algoritmasÄ±nÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in, Ã¶ÄŸelerin `==` operatÃ¶rÃ¼yle (equality comparable) karÅŸÄ±laÅŸtÄ±rÄ±labilir olmasÄ± ÅŸarttÄ±r.
*   EÄŸer kendi `struct` veya `class` tÃ¼rÃ¼nÃ¼zÃ¼ bir `std::set` iÃ§inde tutmak isterseniz, bu tÃ¼rÃ¼n `<` operatÃ¶rÃ¼nÃ¼ (less-than comparable) desteklemesi gerekir, Ã§Ã¼nkÃ¼ set Ã¶ÄŸeleri sÄ±ralayarak tutar.

---

## Master Kod Ã–rneÄŸi (BÃ¶lÃ¼m Ã–zeti)

Bu kod Ã¶rneÄŸi, STL'in jenerik yapÄ±sÄ±nÄ±, farklÄ± konteynerlar (`vector`, `list`, `C array`) arasÄ±nda nasÄ±l `std::copy` ve `std::find` kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶sterir.

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm> // find, copy
#include <iterator>  // begin, end

class Point {
public:
    int x, y;
    // find iÃ§in == operatÃ¶rÃ¼ ÅŸart
    bool operator==(const Point& other) const { return x == other.x && y == other.y; }
};

int main() {
    // 1. Kaynak: std::vector
    std::vector<int> source = {10, 20, 30, 40, 50};

    // 2. Hedef: std::list (AynÄ± boyutta olmalÄ±)
    std::list<int> target(5);

    // 3. Jenerik Kopyalama: Vector'den List'e (Cross-container)
    std::copy(source.begin(), source.end(), target.begin());

    // 4. Jenerik Arama: List iÃ§inde 30'u ara
    auto it = std::find(target.begin(), target.end(), 30);

    if (it != target.end()) {
        std::cout << "Deger bulundu: " << *it << std::endl;
    } else {
        std::cout << "Deger bulunamadi!" << std::endl;
    }

    // 5. C Dizisi Ã¼zerinde STL algoritmasÄ±
    int arr[] = {1, 2, 3};
    // Global std::begin/end kullanÄ±mÄ± her tÃ¼rlÃ¼ yapÄ±yÄ± "range" yapar
    auto found_arr = std::find(std::begin(arr), std::end(arr), 2);
    
    return 0;
}
```

---
## 10. AlgoritmalarÄ±n TÃ¼rler Ãœzerindeki KÄ±sÄ±tlamalarÄ± (Constraints) [02:30:01 - 02:39:00]

STL algoritmalarÄ± "jenerik" olsalar da, Ã¼zerinde iÅŸlem yapacaklarÄ± veri tÃ¼rlerinden belirli yetenekler beklerler. EÄŸer bu yetenekler (operatÃ¶rler) saÄŸlanmazsa, derleyici oldukÃ§a karmaÅŸÄ±k gÃ¶rÃ¼nen "template instantiation" hatalarÄ± Ã¼retir.

### Equality Comparable (EÅŸitlik KarÅŸÄ±laÅŸtÄ±rÄ±labilirliÄŸi)
`std::find` gibi bir arama algoritmasÄ±, aranan deÄŸeri bulmak iÃ§in `==` operatÃ¶rÃ¼nÃ¼ kullanÄ±r. 
*   EÄŸer bir `std::vector<MyClass>` iÃ§inde arama yapÄ±yorsanÄ±z ve `MyClass` iÃ§in `operator==` tanÄ±mlanmamÄ±ÅŸsa kod derlenmeyecektir.
*   **Hata MesajÄ± Analizi:** Derleyici genellikle "binary '==': 'MyClass' does not define this operator" (ikili '==': 'MyClass' bu operatÃ¶rÃ¼ tanÄ±mlamÄ±yor) ÅŸeklinde bir hata verir.

### Less-Than Comparable (KÃ¼Ã§Ã¼ktÃ¼r KarÅŸÄ±laÅŸtÄ±rÄ±labilirliÄŸi)
`std::set`, `std::map` gibi kaplar ve `std::sort` gibi algoritmalar, Ã¶ÄŸeleri belirli bir sÄ±raya dizmek iÃ§in `<` operatÃ¶rÃ¼nÃ¼ kullanÄ±r.
*   Bir `std::set` iÃ§ine Ã¶ÄŸe eklerken (insert), setin iÃ§indeki ikili arama aÄŸacÄ± yapÄ±sÄ± yeni Ã¶ÄŸenin nereye konulacaÄŸÄ±nÄ± `<` operatÃ¶rÃ¼yle belirler.
*   Bu kÄ±sÄ±tlama saÄŸlanmadÄ±ÄŸÄ±nda "strict weak ordering" (kesin zayÄ±f sÄ±ralama) kuralÄ± bozulur ve derleme hatasÄ± alÄ±nÄ±r.

```cpp
class MyClass {
    int m_id;
public:
    MyClass(int id) : m_id(id) {}
    // set ve sort iÃ§in zorunlu
    bool operator<(const MyClass& other) const { return m_id < other.m_id; }
    // find iÃ§in zorunlu
    bool operator==(const MyClass& other) const { return m_id == other.m_id; }
};
```

---

## 11. Ä°teratÃ¶r Kategorileri (Iterator Categories) [02:39:01 - 02:46:55]

Hoca, dersin en kritik teknik ayrÄ±mÄ±na giriÅŸ yaptÄ±: TÃ¼m iteratÃ¶rler aynÄ± yeteneklere sahip deÄŸildir. Bir iteratÃ¶rÃ¼n hangi iÅŸlemleri ( `++`, `--`, `+n`, `[]` ) yapabileceÄŸi, onun **kategorisi** tarafÄ±ndan belirlenir.

### 1. Input Iterator (GiriÅŸ Ä°teratÃ¶rÃ¼)
*   **Ã–zellik:** Sadece okuma amaÃ§lÄ±dÄ±r. Sadece ileri gider (`++`). 
*   **KÄ±sÄ±t:** Bir kez okunan konumdan tekrar geÃ§ilemeyebilir (tek geÃ§iÅŸli - single pass).

### 2. Output Iterator (Ã‡Ä±kÄ±ÅŸ Ä°teratÃ¶rÃ¼)
*   **Ã–zellik:** Sadece yazma amaÃ§lÄ±dÄ±r. Sadece ileri gider (`++`).
*   **Ã–rnek:** `std::back_inserter` tarafÄ±ndan Ã¼retilen iteratÃ¶rler.

### 3. Forward Iterator (Ä°leri YÃ¶nlÃ¼ Ä°teratÃ¶r)
*   **Ã–zellik:** Hem okunabilir hem yazÄ±labilir (eÄŸer const deÄŸilse). Sadece ileri gider (`++`).
*   **Fark:** Ã‡oklu geÃ§iÅŸ (multi-pass) yapÄ±labilir; aynÄ± konumdan tekrar geÃ§ilebilir.
*   **Ã–rnek:** `std::forward_list` iteratÃ¶rleri.

### 4. Bidirectional Iterator (Ã‡ift YÃ¶nlÃ¼ Ä°teratÃ¶r)
*   **Ã–zellik:** Hem ileri (`++`) hem geri (`--`) gidebilir.
*   **Ã–rnek:** `std::list`, `std::set`, `std::map` iteratÃ¶rleri.
*   âš ï¸ **Dikkat:** Bu iteratÃ¶rlere tam sayÄ± eklenemez (`it + 5` hatadÄ±r). ElemanlarÄ± tek tek gezmek zorundadÄ±rlar.

### 5. Random Access Iterator (Rastgele EriÅŸimli Ä°teratÃ¶r)
*   **Ã–zellik:** Ä°ÅŸaretÃ§i (pointer) aritmetiÄŸinin tÃ¼m Ã¶zelliklerini destekler.
*   **Ä°ÅŸlemler:** `it + n`, `it - n`, `it[n]`, `<`, `>`.
*   **Ã–rnek:** `std::vector`, `std::deque`, `std::array` ve ham pointer'lar.

### 6. Contiguous Iterator (BitiÅŸik EriÅŸimli - C++20)
*   **Ã–zellik:** Random access yeteneklerine ek olarak, Ã¶ÄŸelerin bellekte fiziksel olarak bitiÅŸik (contiguous) olduÄŸunu garanti eder.
*   **Ã–rnek:** `std::vector`, `std::array`.

> ğŸ’¡ **Ã–ÄŸrenci Notu:** Hoca, "Neden `std::list` iteratÃ¶rÃ¼ne `+5` ekleyemiyoruz?" sorusuna ÅŸÃ¶yle cevap verdi: "Ã‡Ã¼nkÃ¼ listenin 5 sonraki elemanÄ±na gitmek iÃ§in tÃ¼m dÃ¼ÄŸÃ¼mleri tek tek gezmek gerekir. Bu iÅŸlem $O(1)$ deÄŸil $O(N)$ maliyetlidir. STL, performansÄ± gizlemek yerine, yavaÅŸ olan bu iÅŸlemi doÄŸrudan operatÃ¶rle (`+`) yapmanÄ±za izin vermez."

---

## 12. Ders Sonu Ã–zeti ve Gelecek Program [02:46:00 - 02:46:55]

Hoca, STL dÃ¼nyasÄ±na girerken kapÄ±larÄ±n ardÄ±ndaki "Iterator Category" mantÄ±ÄŸÄ±nÄ±n Ã¶nemini vurgulayarak dersi bitirdi:
*   STL algoritmalarÄ± genellikle belirli bir kategoride iteratÃ¶r bekler (Ã¶rneÄŸin `std::sort` mutlaka **Random Access Iterator** ister, bu yÃ¼zden `std::list` nesnesini `std::sort` ile sÄ±ralayamazsÄ±nÄ±z).
*   Ã‡arÅŸamba gÃ¼nkÃ¼ derste bu kategorilerin hiyerarÅŸisi, birbirleriyle iliÅŸkileri ve algoritmalarÄ±n bu kategorilere gÃ¶re nasÄ±l seÃ§ildiÄŸi (tag dispatching vb.) iÅŸlenecektir.

---

## Master Kod Ã–rneÄŸi (Ders Sonu BÃ¼tÃ¼nlemesi)

AÅŸaÄŸÄ±daki kod, farklÄ± iteratÃ¶r kategorilerinin yeteneklerini ve neden bazÄ± konteynerlarÄ±n bazÄ± iÅŸlemlerle (sort gibi) uyumsuz olduÄŸunu simÃ¼le eder.

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <forward_list>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1};
    std::list<int> lst = {5, 2, 8, 1};
    std::forward_list<int> flst = {5, 2, 8, 1};

    // 1. Random Access Test (Vector)
    auto vit = vec.begin();
    vit = vit + 2; // GEÃ‡ERLÄ°: Vector random access destekler.
    std::cout << "Vector[2]: " << *vit << std::endl;
    std::sort(vec.begin(), vec.end()); // GEÃ‡ERLÄ°

    // 2. Bidirectional Test (List)
    auto lit = lst.begin();
    ++lit; // GEÃ‡ERLÄ°
    --lit; // GEÃ‡ERLÄ°: List bidirectional'dÄ±r.
    // lit = lit + 2; // HATA: List random access DEÄÄ°LDÄ°R.
    // std::sort(lst.begin(), lst.end()); // HATA: Sort random access ister.
    lst.sort(); // GEÃ‡ERLÄ°: List'in kendi Ã¶zel (member) sort fonksiyonu vardÄ±r.

    // 3. Forward Test (Forward List)
    auto fit = flst.begin();
    ++fit; // GEÃ‡ERLÄ°
    // --fit; // HATA: Forward list geri gidemez!

    std::cout << "Program baÅŸarÄ±yla tamamlandÄ± (Kategoriler anlaÅŸÄ±ldÄ±)." << std::endl;

    return 0;
}
```

---
