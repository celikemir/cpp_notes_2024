Merhaba! Necati Ergin hocamÄ±zÄ±n 40. ders gÃ¼nÃ¼nÃ¼n ilk saatini, en Ã¶n sÄ±radan aldÄ±ÄŸÄ±m detaylÄ± teknik notlarla aÅŸaÄŸÄ±da bulabilirsin. HocamÄ±zÄ±n Ã¶zellikle vurguladÄ±ÄŸÄ± "Raw loop (ham dÃ¶ngÃ¼) kullanmayÄ±n" felsefesini merkeze alarak hazÄ±rladÄ±m.

---

# C++ Programlama Dili - 40. Ders NotlarÄ± (Part 1)
**Tarih:** 18 KasÄ±m 2024  
**Konu:** STL AlgoritmalarÄ± Derin DalÄ±ÅŸ (Copy, Reverse, Replace ve Remove Ailesi)

---

## 1. Ä°teratÃ¶r ManipÃ¼lasyon FonksiyonlarÄ± HatÄ±rlatmasÄ± [00:31 - 01:15]

HocamÄ±z derse geÃ§tiÄŸimiz dersin sonunda gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z ve STL algoritmalarÄ±nÄ±n temel yapÄ± taÅŸlarÄ±nÄ± oluÅŸturan yardÄ±mcÄ± fonksiyonlarÄ± hatÄ±rlatarak baÅŸladÄ±.

*   **Fonksiyonlar:** `std::advance`, `std::distance`, `std::iter_swap`, `std::next`, `std::prev`.
*   **Kritik Bilgi:** Bu fonksiyonlar **Generic Programming** (Jenerik Programlama) teknikleriyle iteratÃ¶r kategorisini derleme zamanÄ±nda elde eder ve o kategoriye en uygun (en verimli) kodu seÃ§erler.

---

## 2. Copy AlgoritmalarÄ± ve AdlandÄ±rma Notasyonu [02:01 - 07:15]

HocamÄ±z algoritmalarÄ±n isimlendirilmesindeki standart mantÄ±ÄŸÄ± aÃ§Ä±kladÄ±:
*   `_if` son eki: Bir **Unary Predicate** (tek argÃ¼manlÄ± mantÄ±ksal sÄ±nayÄ±cÄ±) bekler.
*   `_n` son eki: Ä°ÅŸlemin kaÃ§ Ã¶ÄŸe Ã¼zerinde yapÄ±lacaÄŸÄ±nÄ± belirten bir sayÄ± bekler.
*   `_copy` son eki: Ä°ÅŸlemi kaynaÄŸÄ±n Ã¼zerinde deÄŸil, hedef bir range (aralÄ±k) Ã¼zerine yazarak yapar.

### std::copy_n (C++11) [03:03 - 06:40]
ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):** Bazen elimizde kaynak aralÄ±ÄŸÄ±n sonunu belirten bir iteratÃ¶r (`end`) yoktur, sadece baÅŸlangÄ±Ã§ ve kaÃ§ adet Ã¶ÄŸe kopyalayacaÄŸÄ±mÄ±z bilgisi vardÄ±r.

ğŸ” **Arka Plan (Under the Hood):**
```cpp
// 06:13 - Ã–rnek KullanÄ±m
std::copy_n(svec.begin(), svec.size(), std::back_inserter(s_list)); 
// ^-- HocamÄ±z burada back_inserter kullanarak listeye sondan ekleme yapÄ±ldÄ±ÄŸÄ±nÄ± vurguladÄ±.
```

### std::copy_if [02:19 - 10:43]
HocamÄ±z burada bir Lambda ifadesi kullanarak belirli uzunluktaki string Ã¶ÄŸelerini kopyaladÄ±.

```cpp
// 09:05 - HocamÄ±zÄ±n yazdÄ±ÄŸÄ± Lambda Ã¶rneÄŸi
std::copy_if(svec.begin(), svec.end(), std::back_inserter(dest_vec), [len](const std::string& s) {
    return s.length() == len; // <-- Kritik: KoÅŸulu saÄŸlayanlar kopyalanÄ±r
});
```

---

## 3. Overlapping Ranges ve copy_backward [10:44 - 14:45]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):** Bir veri bloÄŸunu aynÄ± konteyner iÃ§inde saÄŸa doÄŸru kaydÄ±rmak istediÄŸimizde, standart `std::copy` kullanÄ±rsak kaynak verinin Ã¼zerine yazarÄ±z ve veri bozulur.

ğŸ–¼ï¸ **GÃ¶rselleÅŸtirme (Overlapping Range):**
```text
Kaynak: [2, 5, 7, 9, 3]
Hedef:     [2, 5, 7, 9, 3] (1 birim saÄŸa kaydÄ±rmak istiyoruz)

copy kullanÄ±lÄ±rsa: 2, 2, 2, 2... (Veri kaybÄ±!)
copy_backward kullanÄ±lÄ±rsa: Sondan baÅŸlar: ..., 9, 7, 5, 2
```

ğŸ” **Arka Plan (Under the Hood):**
`std::copy_backward` kopyalamaya aralÄ±ÄŸÄ±n sonundan baÅŸlar. Bu yÃ¼zden Ã¼Ã§Ã¼ncÃ¼ parametre olarak hedef aralÄ±ÄŸÄ±n **baÅŸlangÄ±cÄ±nÄ± deÄŸil, sonunu** bekler.

```cpp
// 14:08 - Kritik Parametre KullanÄ±mÄ±
std::copy_backward(evec.begin(), evec.end(), destvec.end()); 
// <-- Hoca buraya dikkat Ã§ekti: ÃœÃ§Ã¼ncÃ¼ parametre hedef aralÄ±ÄŸÄ±n SONUDUR!
```

---

## 4. Reverse Ailesi [14:46 - 23:07]

### std::reverse vs std::reverse_copy
*   `std::reverse`: Orijinal range Ã¼zerinde Ã¶ÄŸelerin yerini deÄŸiÅŸtirir (**In-place**). Minimum **Bidirectional Iterator** gerektirir.
*   `std::reverse_copy`: Orijinal range'i deÄŸiÅŸtirmez, ters Ã§evrilmiÅŸ halini baÅŸka bir yere yazar.

ğŸš© **MÃ¼lakat Sorusu / Kritik Nokta:**
**Soru:** `std::list` iÃ§in neden genel `std::reverse` algoritmasÄ± yerine `list::reverse()` Ã¼ye fonksiyonu tercih edilmelidir?
**Cevap:** Genel `std::reverse` algoritmasÄ± Ã¶ÄŸeleri `std::swap` ile takas eder. EÄŸer Ã¶ÄŸeler Ã§ok bÃ¼yÃ¼kse (Ã¶rneÄŸin 1000 byte'lÄ±k struct'lar), bu ciddi maliyettir. Ancak `list::reverse()` Ã¼ye fonksiyonu sadece dÃ¼ÄŸÃ¼mlerin (node) iÃ§indeki pointer baÄŸlantÄ±larÄ±nÄ± deÄŸiÅŸtirir, Ã¶ÄŸeleri fiziken taÅŸÄ±maz. (O(N) karmaÅŸÄ±klÄ±k ama Ã§ok daha dÃ¼ÅŸÃ¼k sabit katsayÄ±).

ğŸ”— **KÃ¼mÃ¼latif BaÄŸlantÄ±lar:** HocamÄ±z `std::string`in de bir STL konteyneri olduÄŸunu ve Ã¼zerinde `std::reverse` Ã§alÄ±ÅŸtÄ±rÄ±labileceÄŸini, ancak string'in kendi iÃ§inde bir `reverse` fonksiyonu olmadÄ±ÄŸÄ±nÄ± hatÄ±rlattÄ± [16:43].

---

## 5. Replace Ailesi [23:08 - 32:40]

HocamÄ±z "KÃ¶tÃ¼ kodun en tipik belirtisi, STL algoritmasÄ± kullanmak yerine ham dÃ¶ngÃ¼ (raw loop) yazmaktÄ±r" diyerek `replace` grubunu inceledi.

*   `std::replace`: Belirli bir deÄŸerin gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ her yeri yeni deÄŸerle deÄŸiÅŸtirir.
*   `std::replace_if`: Predicate `true` dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nde deÄŸiÅŸimi yapar.
*   `std::replace_copy_if`: DeÄŸiÅŸtirilmiÅŸ halini baÅŸka bir yere kopyalar.

```cpp
// 26:28 - HocamÄ±zÄ±n replace_if Ã¶rneÄŸi
std::replace_if(ivec.begin(), ivec.end(), [n](int e) {
    return e % n == 0; // n'e tam bÃ¶lÃ¼nenleri...
}, val); // ...val deÄŸeriyle deÄŸiÅŸtir.
```

---

## 6. STL'de Silme AlgoritmalarÄ± (The "Remove" Problem) [32:41 - 42:00]

HocamÄ±z dersin en can alÄ±cÄ± noktalarÄ±ndan birine giriÅŸ yaptÄ±: **Algoritmalar neden Ã¶ÄŸe silemez?**

ğŸš© **Kritik Kural:** Algoritmalar sadece iteratÃ¶r alÄ±rlar. Ä°teratÃ¶rler Ã¼zerinden konteynerÄ±n kendisine eriÅŸip bellek boÅŸaltma (`erase`) iÅŸlemi yapamazlar. Ã‡Ã¼nkÃ¼ iteratÃ¶r, konteynerÄ±n yapÄ±sÄ±nÄ± (size, capacity) bilmez.

### Lojik Silme vs Fiziksel Silme [38:44 - 40:12]
*   **std::remove**: Ã–ÄŸeleri konteynÄ±rdan gerÃ§ekten silmez. Silinmeyecek Ã¶ÄŸeleri baÅŸa kaydÄ±rÄ±r ve "yeni son" (logical end) konumunu dÃ¶ndÃ¼rÃ¼r.
*   **std::erase**: KonteynerÄ±n Ã¼ye fonksiyonudur, boyutu fiziksel olarak deÄŸiÅŸtirir.

ğŸ–¼ï¸ **ASCII Art (Logical Remove MantÄ±ÄŸÄ±):**
```text
BaÅŸlangÄ±Ã§: [2, 1, 3, 2, 4, 2, 5] (2'leri remove et)
Ä°ÅŸlem SonrasÄ±: [1, 3, 4, 5, ?, ?, ?] 
                           ^-- Return edilen iteratÃ¶r (Logical End)
```

HocamÄ±zÄ±n dersinin ikinci bÃ¶lÃ¼mÃ¼nde, C++ dÃ¼nyasÄ±nÄ±n en Ã¼nlÃ¼ kullanÄ±m kalÄ±plarÄ±ndan biri olan "Erase-Remove" idiyomunu ve ardÄ±ndan STL konteynerlarÄ±nÄ±n mimari temellerini incelemeye devam ediyoruz.

---

# C++ Programlama Dili - 40. Ders NotlarÄ± (Part 2)
**Konu:** Erase-Remove Ä°diyomu, C++20 Yenilikleri ve Konteyner SemantiÄŸi

---

## 1. Erase-Remove Ä°diyomu ve Geri DÃ¶nÃ¼ÅŸ DeÄŸeri [42:00 - 52:27]

HocamÄ±z, `std::remove` algoritmasÄ±nÄ±n neden tek baÅŸÄ±na yeterli olmadÄ±ÄŸÄ±nÄ± ve neden bir "lojik son" (logical end) iteratÃ¶rÃ¼ dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ detaylandÄ±rdÄ±.

ğŸ” **Arka Plan (Under the Hood):**
`std::remove`, Ã¶ÄŸeleri gerÃ§ekten yok etmez. Silinmeyecek Ã¶ÄŸeleri **Move Assignment** (taÅŸÄ±ma atamasÄ±) ile Ã¶ne Ã§eker. Arka tarafta kalan Ã¶ÄŸeler ise "Moved-from state" (kaynaÄŸÄ± Ã§alÄ±nmÄ±ÅŸ durum) veya belirsiz bir durumda kalÄ±r.

ğŸš© **MÃ¼lakat Sorusu / Kritik Nokta:**
**Soru:** `std::remove` sonrasÄ± arta kalan Ã¶ÄŸelerin deÄŸeri ne olur?
**Cevap:** HiÃ§bir garanti yoktur! Bu Ã¶ÄŸeler ya eski deÄŸerlerini korur ya da baÅŸka bir yere taÅŸÄ±ndÄ±klarÄ± iÃ§in belirsiz bir durumdadÄ±r. Bu Ã¶ÄŸelere eriÅŸmek **Undefined Behavior** (TanÄ±msÄ±z DavranÄ±ÅŸ) deÄŸildir ama lojik olarak hatalÄ±dÄ±r. [48:00]

```cpp
// 51:10 - Klasik Erase-Remove Ä°diyomu (C++20 Ã–ncesi)
ivec.erase(std::remove(ivec.begin(), ivec.end(), val), ivec.end()); 
// ^-- Ã–nce lojik silme (remove), sonra fiziksel silme (erase).
```

---

## 2. C++20 Modern Silme: std::erase (Uniform Container Erasure) [52:28 - 54:31]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):** Erase-Remove yazÄ±mÄ± karmaÅŸÄ±ktÄ±r ve hata yapmaya mÃ¼saittir. C++20 ile bu iÅŸlem tek bir global fonksiyona indirgenmiÅŸtir.

```cpp
// 53:30 - C++20 TarzÄ± Modern Silme
auto num_erased = std::erase(ivec, val); // <-- Hoca: "Ã‡ok daha temiz!"
std::cout << num_erased << " eleman silindi.";
```

---

## 3. std::unique ve SÄ±ralama GerekliliÄŸi [59:31 - 01:07:41]

HocamÄ±z `std::unique` algoritmasÄ±nÄ±n sadece **ardÄ±ÅŸÄ±k (adjacent)** eÅŸdeÄŸer Ã¶ÄŸeleri teke indirdiÄŸini vurguladÄ±.

ğŸ–¼ï¸ **ASCII Art (Unique MantÄ±ÄŸÄ±):**
```text
Range: [1, 2, 2, 3, 2, 2]
Unique sonrasÄ±: [1, 2, 3, 2, ?, ?]
                      ^-- Sadece ardÄ±ÅŸÄ±k 2'ler teke indi.
                      
Tam benzersizlik iÃ§in: sort -> unique -> erase
```

ğŸš© **Kritik Nokta:** EÄŸer bir konteynerdaki tÃ¼m duplikeleri silmek istiyorsanÄ±z, `std::unique` Ã§aÄŸÄ±rmadan Ã¶nce mutlaka `std::sort` Ã§aÄŸÄ±rmalÄ±sÄ±nÄ±z. [1:06:33]

### Ã–nemli MÃ¼lakat Sorusu: YazÄ± Ä°Ã§indeki BoÅŸluklarÄ± DÃ¼zenleme [01:07:42 - 01:13:39]
HocamÄ±z bir string iÃ§indeki birden fazla boÅŸluÄŸu tek boÅŸluÄŸa indiren zarif bir Ã§Ã¶zÃ¼m sundu:

```cpp
// 01:10:10 - Hoca'nÄ±n mÃ¼lakat sorusu Ã§Ã¶zÃ¼mÃ¼
auto it = std::unique(s.begin(), s.end(), [](char c1, char c2) {
    return std::isspace(c1) && std::isspace(c2); // Ä°ki karakter de boÅŸluksa "eÅŸdeÄŸer" say.
});
s.erase(it, s.end());
```

---

## 4. STL Konteyner SÄ±nÄ±flandÄ±rmasÄ± [01:16:39 - 01:21:40]

HocamÄ±z konteynerlarÄ± Ã¼Ã§ ana gruba ayÄ±rarak inceleyeceÄŸimizi belirtti:

1.  **Sequence Containers (ArdÄ±ÅŸÄ±l Konteynerlar):** Ã–ÄŸelerin konumu sizin eklediÄŸiniz sÄ±raya baÄŸlÄ±dÄ±r. (`vector`, `deque`, `list`, `forward_list`, `array`, `string`).
2.  **Associative Containers (Ä°liÅŸkisel Konteynerlar):** Ã–ÄŸeler belirli bir anahtara/sÄ±raya gÃ¶re otomatik dizilir. (`set`, `map`, `multiset`, `multimap`).
3.  **Unordered Associative Containers (SÄ±rasÄ±z Ä°liÅŸkisel):** Hash tabanlÄ± yapÄ±lar.

---

## 5. std::vector Derinlemesine BakÄ±ÅŸ [01:21:41 - 01:25:05]

VektÃ¶rÃ¼n en temel Ã¶zelliÄŸi **Contiguous Memory** (ArdÄ±ÅŸÄ±k bellek) yapÄ±sÄ±dÄ±r.

ğŸ” **Arka Plan (Under the Hood):**
*   **Size:** Åu an tutulan Ã¶ÄŸe sayÄ±sÄ±.
*   **Capacity:** Reallocation (yeniden bellek tahsisi) yapmadan tutulabilecek Ã¶ÄŸe sayÄ±sÄ±.
*   **Reallocation Maliyeti:** `size == capacity` olduÄŸunda vektÃ¶r bÃ¼yÃ¼mek zorundadÄ±r. Yeni bir yere taÅŸÄ±nÄ±r ve tÃ¼m iteratÃ¶rler **Invalidate** (geÃ§ersiz) olur. [01:23:20]

ğŸ“Š **Strateji FarkÄ±:**
*   **GCC/Clang:** Kapasiteyi genellikle 2 kat (2x) artÄ±rÄ±r.
*   **MSVC (Microsoft):** Kapasiteyi 1.5 kat artÄ±rÄ±r.

---

## 6. Algoritma mÄ±, Ãœye Fonksiyon mu? [01:25:06 - 01:33:30]

HocamÄ±zdan altÄ±n kural: **EÄŸer bir iÅŸlemin hem genel algoritmasÄ± (std::find) hem de konteynerÄ±n Ã¼ye fonksiyonu (c.find) varsa, HER ZAMAN Ã¼ye fonksiyonu tercih edin.**

ğŸ§  **Neden? (Rationale):**
1.  **HÄ±z:** Algoritma iteratÃ¶rle Ã§alÄ±ÅŸÄ±r ve konteynerin iÃ§ yapÄ±sÄ±nÄ± gÃ¶remez (Ã–rn: `std::find` O(N) iken `std::set::find` O(log N)'dir).
2.  **Semantik:** BazÄ± konteynerlar (Ã–rn: `std::set`), "Equality" (EÅŸitlik) yerine "Equivalence" (EÅŸdeÄŸerlik) kavramÄ±nÄ± kullanÄ±r. Algoritmalar bunu bilmeyebilir. [01:32:20]

---

## 7. Referans Tutma SorunsalÄ± ve Reference Wrapper [01:51:00 - 01:53:50]

ğŸš© **Kritik Kural:** STL konteynerlarÄ±nda ham referans (`T&`) tutamazsÄ±nÄ±z. Ã–rn: `std::vector<int&>` geÃ§ersizdir.

ğŸ§  **Neden? (Rationale):** Konteynerlar Ã¶ÄŸelerini kopyalayabilmeli veya taÅŸÄ±yabilmelidir. Referanslar ise bir kez baÄŸlandÄ±ÄŸÄ±nda baÅŸka bir nesneye "rebind" (tekrar baÄŸlanamaz) edilemezler.

ğŸ” **Ã‡Ã¶zÃ¼m:** `std::reference_wrapper<T>` kullanmak. Bu sÄ±nÄ±f, bir referansÄ± nesne gibi davranacak ÅŸekilde sarmalar.

---
Dersin son bÃ¶lÃ¼mÃ¼nde Necati HocamÄ±z, `std::vector` Ã¶zelinde elemanlara eriÅŸim yÃ¶ntemlerini, bellek garantilerini ve C++23 ile gelen yeni arayÃ¼z Ã¶zelliklerini detaylandÄ±rarak gÃ¼nÃ¼ tamamlÄ±yor.

---

# C++ Programlama Dili - 40. Ders NotlarÄ± (Part 3)
**Konu:** VektÃ¶r Eleman EriÅŸimi, Bellek Garantileri ve GÃ¼venli Kod YazÄ±mÄ±

---

## 1. VektÃ¶rde ArdÄ±ÅŸÄ±klÄ±k (Contiguous) Garantisi ve C API Uyumu [02:20:00 - 02:21:40]

HocamÄ±z, vektÃ¶rÃ¼n Ã¶ÄŸelerinin bellekte tek bir blok halinde ardÄ±ÅŸÄ±k (contiguous) bulunmak zorunda olduÄŸunu ve bunun C tipi API'lerle Ã§alÄ±ÅŸÄ±rken bÃ¼yÃ¼k avantaj saÄŸladÄ±ÄŸÄ±nÄ± belirtti.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):** Eski C kÃ¼tÃ¼phaneleri parametre olarak ham dizi (raw array) ve boyut bekler. VektÃ¶rdeki veriyi bu fonksiyonlara gÃ¼venle gÃ¶nderebilmek iÃ§in bir kÃ¶prÃ¼ye ihtiyaÃ§ vardÄ±r.

ğŸ” **Arka Plan (Under the Hood):**
Ä°lk Ã¶ÄŸenin adresini almak iÃ§in Ã¼Ã§ farklÄ± yol vardÄ±r ancak hocamÄ±z en jenerik olanÄ± vurguladÄ±:
1. `v.data()`: En temiz ve modern yÃ¶ntem.
2. `&v[0]`: Klasik yÃ¶ntem.
3. `&*v.begin()`: Ä°teratÃ¶rÃ¼ dereferans edip adresini almak.

```cpp
// 02:18:30 - C API KÃ¶prÃ¼sÃ¼ Ã–rneÄŸi
void print_array(const int* p, std::size_t n); // Bir C API fonksiyonu varsayalÄ±m

std::vector<int> ivec = {3, 6, 9};
print_array(ivec.data(), ivec.size()); // <-- Hoca buraya dikkat Ã§ekti: GÃ¼venli ve standart yÃ¶ntem.
```

---

## 2. Eleman EriÅŸim FonksiyonlarÄ±: `operator[]` vs `at()` [02:24:40 - 02:27:00]

HocamÄ±z, performans ve gÃ¼venlik arasÄ±ndaki o ince Ã§izgiyi bu iki fonksiyon Ã¼zerinden anlattÄ±.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):** HÄ±zÄ±n kritik olduÄŸu yerlerde sÄ±nÄ±r kontrolÃ¼ (bounds check) maliyettir. Ancak hatalÄ± indis eriÅŸiminin sistemi Ã§Ã¶kertmemesi gereken yerlerde kontrol ÅŸarttÄ±r.

ğŸ“Š **Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±:**
*   **`v[i]` (Subscript Operator):** HÄ±zlÄ±dÄ±r, sÄ±nÄ±r kontrolÃ¼ yapmaz. GeÃ§ersiz indiste **UB (Undefined Behavior - TanÄ±msÄ±z DavranÄ±ÅŸ)** oluÅŸur.
*   **`v.at(i)`:** SÄ±nÄ±r kontrolÃ¼ yapar. GeÃ§ersiz indiste `std::out_of_range` exception (istisna) fÄ±rlatÄ±r.

ğŸš© **MÃ¼lakat Sorusu / Kritik Nokta:**
**Soru:** "Safe Code" (GÃ¼venli Kod) nedir?
**Cevap:** HocamÄ±zÄ±n tanÄ±mÄ±yla; bÃ¼nyesinde hiÃ§bir **UB (TanÄ±msÄ±z DavranÄ±ÅŸ)** barÄ±ndÄ±rmayan koddur. EÄŸer indisinden emin olmadÄ±ÄŸÄ±nÄ±z bir eriÅŸim yapÄ±yorsanÄ±z `at()` kullanmak kodu "safe" hale getirir. [02:39:20]

---

## 3. Kapasite ve Boyut YÃ¶netimi [02:27:00 - 02:29:10]

VektÃ¶rÃ¼n dinamik bÃ¼yÃ¼me stratejisi iÃ§in kullanÄ±lan temel fonksiyonlar:

*   **`reserve(n)`:** Kapasiteyi (capacity) en az `n` olacak ÅŸekilde ayarlar. Ã–ÄŸeleri oluÅŸturmaz, sadece yer ayÄ±rÄ±r. **Reallocation** maliyetini dÃ¼ÅŸÃ¼rmek iÃ§in kritiktir.
*   **`resize(n)`:** Boyutu (size) deÄŸiÅŸtirir. EÄŸer `n` mevcut boyuttan bÃ¼yÃ¼kse yeni Ã¶ÄŸeler default construct edilir.
*   **`shrink_to_fit()`:** Kapasiteyi, mevcut boyuta (size) dÃ¼ÅŸÃ¼rerek kullanÄ±lmayan belleÄŸi sisteme geri verir. [02:29:00]

---

## 4. Konteyner Swap PerformansÄ± [02:29:40 - 02:31:30]

ğŸš© **Kritik Nokta:** Ä°ster `std::swap(v1, v2)` ister `v1.swap(v2)` kullanÄ±n, vektÃ¶rler arasÄ± takas iÅŸlemi **O(1)** zaman karmaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r.

ğŸ” **Arka Plan (Under the Hood):**
VektÃ¶rler iÃ§indeki 10.000 elemanÄ± tek tek kopyalamaz. Sadece iÃ§sel (internal) bellek bloklarÄ±nÄ± gÃ¶steren pointer'larÄ± ve size/capacity bilgilerini takas eder. 

ğŸ–¼ï¸ **GÃ¶rselleÅŸtirme (Internal Swap):**
```text
V1 [Ptr A] ----> [Bellek BloÄŸu 1 (10.000 eleman)]
V2 [Ptr B] ----> [Bellek BloÄŸu 2 (5 eleman)]

Swap sonrasÄ±:
V1 [Ptr B] ----> [Bellek BloÄŸu 2]
V2 [Ptr A] ----> [Bellek BloÄŸu 1]
```

---

## 5. C++23: `append_range` ve `assign_range` [02:23:40]

HocamÄ±z C++23 ile gelen "Range" temelli yeni Ã¼ye fonksiyonlara deÄŸindi.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):** Daha Ã¶nce bir vektÃ¶rÃ¼n sonuna baÅŸka bir konteynerÄ±n aralÄ±ÄŸÄ±nÄ± eklemek iÃ§in `v.insert(v.end(), other.begin(), other.end())` gibi hantal bir yazÄ±m gerekiyordu.

```cpp
// 01:47:00'deki mantÄ±kla C++23 Ã¶rneÄŸi
svec.append_range(another_container); // <-- Hoca: "Ranges konseptiyle gelen kolaylÄ±k."
```

---

## 6. BoÅŸ Konteyner ve Ä°teratÃ¶r Tehlikesi [02:31:30 - 02:34:40]

HocamÄ±z dersi kapatÄ±rken Ã§ok Ã¶nemli bir uyarÄ±da bulundu:
*   BoÅŸ bir vektÃ¶rÃ¼n `begin()` ve `end()` deÄŸerlerini alabilirsiniz.
*   `begin == end` karÅŸÄ±laÅŸtÄ±rmasÄ± yapabilirsiniz.
*   **ANCAK**, boÅŸ bir vektÃ¶rÃ¼n `begin()` iteratÃ¶rÃ¼nÃ¼ asla **dereferans** (`*it`) etmemelisiniz. Bu doÄŸrudan **UB**'dir.

```cpp
std::vector<std::string> svec; // BoÅŸ
auto it = svec.begin();
if (it != svec.end()) {
    std::cout << *it; // GÃ¼venli
}
// std::cout << *it; // <-- Hoca buraya dikkat Ã§ekti: KONTEYNER BOÅSA FACÄ°A! (UB)
```

---

**Necati Ergin'in Notu:** Ã‡arÅŸamba gÃ¼nÃ¼ vektÃ¶r sÄ±nÄ±fÄ±nÄ± bitirip diÄŸer ardÄ±ÅŸÄ±l konteynerlara (list, deque) geÃ§eceÄŸiz. [02:41:33]

