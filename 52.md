HaklÄ±sÄ±n, o kadar yoÄŸun teknik detayÄ± tek bir seferde geÃ§mek, Necati Hoca'nÄ±n her bir satÄ±ra yÃ¼klediÄŸi anlamÄ± Ä±skalamak olur. HocanÄ±n "Ã–zetleme, yeniden inÅŸa et!" dediÄŸi yerden, dersin ilk 20 dakikasÄ±ndaki o kritik **Custom Deleter ve C-API** dÃ¼ÄŸÃ¼mÃ¼nÃ¼ ilmik ilmik Ã§Ã¶zelim.

---

### [00:00 - 10:00] Sahiplik (Ownership) ve `std::default_delete` MekanizmasÄ±

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Hoca derse girer girmez "Smart pointerlar detay mÄ±, yoksa Ã¼retimde (production) sÃ¼rekli kullanacaÄŸÄ±mÄ±z araÃ§lar mÄ±?" sorusunu soruyor. Cevap net: Ä°kincisi. Dinamik Ã¶mÃ¼rlÃ¼ nesnelerin hayatÄ±nÄ± manuel yÃ¶netmek, "exception safety" (istisna gÃ¼venliÄŸi) zÄ±rhÄ±nÄ± deler. `unique_ptr` bu zÄ±rhÄ± takan en temel araÃ§tÄ±r.

âš™ï¸ **Teknik Detay ve Sentaks:**
Hoca, `unique_ptr`'nin aslÄ±nda iki template parametresi olduÄŸunu, ancak ikinci parametrenin default bir deÄŸeri olduÄŸu iÃ§in Ã§oÄŸunlukla gÃ¶rmediÄŸimizi hatÄ±rlatÄ±yor:

```cpp
template <typename T, typename D = std::default_delete<T>> 
class unique_ptr {
    // ...
    ~unique_ptr() {
        if (mp != nullptr) {
            D{}(mp); // <-- Hoca: "D tÃ¼rÃ¼nden bir geÃ§ici nesne oluÅŸturulup fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼ tetikleniyor"
        }
    }
private:
    T* mp;
};
```

ğŸ” **Arka Plan (Under the Hood):**
Hoca, `default_delete` sÄ±nÄ±fÄ±nÄ±n nasÄ±l bir "functor" (fonksiyon nesnesi) olduÄŸunu tahtaya ÅŸu ÅŸekilde resmediyor:

```cpp
template <typename T>
struct default_delete {
    void operator()(T* p) const {
        delete p; // <-- Kritik nokta: Default davranÄ±ÅŸ her zaman 'delete' operatÃ¶rÃ¼dÃ¼r.
    }
};
```

ğŸš© **Kritik Nokta:** EÄŸer `mp` null pointer ise `delete` Ã§aÄŸrÄ±lmÄ±yor. Ancak biz `D` parametresini deÄŸiÅŸtirerek bu "silme" (destruction) iÅŸlemini Ã¶zelleÅŸtirebiliyoruz.

---

### [10:00 - 20:00] C-Style API ve `unique_ptr` Uyumu (FILE* Ã–rneÄŸi)

Hoca, Alihan Bey'in sorusu Ã¼zerine konuyu Ã¶yle bir yere getiriyor ki; `unique_ptr`'nin sadece `new` ile oluÅŸturulan nesneler iÃ§in deÄŸil, her tÃ¼rlÃ¼ kaynak (resource) iÃ§in kullanÄ±labileceÄŸini kanÄ±tlÄ±yor.

âš™ï¸ **Teknik Detay ve Sentaks (HatalÄ± ve DoÄŸru YaklaÅŸÄ±m):**

**Senaryo:** C kÃ¼tÃ¼phanesinden bir dosya aÃ§Ä±yoruz (`fopen`). EÄŸer kodun devamÄ±nda bir exception fÄ±rlarsa `fclose` asla Ã§aÄŸrÄ±lmaz.

```cpp
// --- HOCANIN YAZDIÄI HATALI/RÄ°SKLÄ° KOD ---
void bar() {
    FILE* f = std::fopen("alihan.txt", "w");
    // ... burada bir fonksiyon exception throw ederse ...
    std::fprintf(f, "Alihan Bozkir");
    std::fclose(f); // <-- BURAYA ASLA GELEMEYÄ°Z! Kaynak sÄ±zÄ±ntÄ±sÄ± (Resource Leak).
}

// --- HOCANIN Ä°NÅA ETTÄ°ÄÄ° SMART POINTER Ã‡Ã–ZÃœMÃœ ---
void bar_safe() {
    // 1. Ã–nce siliciyi (deleter) bir lambda ile tanÄ±mlÄ±yoruz
    auto f_deleter = [](FILE* f) {
        if (f) {
            std::cout << "F-CLOSE cagrildi!\n";
            std::fclose(f);
        }
    };

    // 2. unique_ptr'yi bu silici tÃ¼rÃ¼yle uzmanlaÅŸtÄ±rÄ±yoruz
    // Hoca: "Ä°kinci parametre tÃ¼rdÃ¼r, lambda nesnesinin kendisi deÄŸil!"
    std::unique_ptr<FILE, decltype(f_deleter)> up(std::fopen("alihan.txt", "w"), f_deleter);

    if (up) {
        // Hoca: "fprintf benden FILE* istiyor, unique_ptr nesnesini doÄŸrudan veremem!"
        std::fprintf(up.get(), "Alihan Bozkir\n"); // <-- get() kullanÄ±mÄ± burada hayati.
    }
    // Kapsam bittiÄŸinde (scope end), up'Ä±n destructor'Ä± f_deleter'Ä± Ã§aÄŸÄ±racak.
}
```

ğŸ” **Arka Plan (C++20 Lambda In Unevaluated Context):**
Hoca burada Ã§ok ince bir C++20 Ã¶zelliÄŸine deÄŸiniyor. "Eskiden (C++20 Ã¶ncesi) lambdalar `default constructible` deÄŸildi, bu yÃ¼zden `unique_ptr`'nin constructor'Ä±na `f_deleter` nesnesini argÃ¼man olarak geÃ§mek zorundaydÄ±k" diyor.

```cpp
// C++20 ve sonrasÄ± iÃ§in HocanÄ±n gÃ¶sterdiÄŸi "MÃ¼thiÅŸ Pratik" sentaks:
std::unique_ptr<FILE, decltype([](FILE* f){ std::fclose(f); })> up(std::fopen("test.txt", "w"));
// <-- Hoca: "ArtÄ±k nesneyi argÃ¼man geÃ§meye gerek yok, decltype iÃ§indeki lambda tÃ¼rÃ¼nden derleyici bir tane oluÅŸturur."
```

ğŸš© **Kritik Nokta (Derleyici GÃ¶zÃ¼):**
EÄŸer `decltype` kullanmadan sadece `unique_ptr<FILE>` yazsaydÄ±k, derleyici nesne yok olurken `delete` operatÃ¶rÃ¼nÃ¼ Ã§aÄŸÄ±rmaya Ã§alÄ±ÅŸacaktÄ±. Ancak `FILE` bir `struct` olduÄŸu ve `delete` ile silinmeye uygun olmadÄ±ÄŸÄ± iÃ§in ya Ã§alÄ±ÅŸma zamanÄ± hatasÄ± ya da tanÄ±msÄ±z davranÄ±ÅŸ (UB) oluÅŸacaktÄ±.

---

### [20:00 - 25:00] Handle Sistemleri ve Custom Functorlar

Hoca, Lambda dÄ±ÅŸÄ±nda "Custom Deleter" yazmanÄ±n ikinci yolunu gÃ¶steriyor: **Struct/Class Functor**.

âš™ï¸ **Teknik Detay ve Sentaks:**

```cpp
struct Data {};
Data* create_data();
void clean_up(Data*);

// Hoca: "Buna 'DataCleaner' diyelim, bu bir function object sÄ±nÄ±fÄ±."
struct DataCleaner {
    void operator()(Data* p) {
        std::cout << "Data temizleniyor...\n";
        clean_up(p);
    }
};

void example() {
    // TÃ¼rÃ¼ doÄŸrudan template argÃ¼manÄ± olarak veriyoruz
    std::unique_ptr<Data, DataCleaner> up(create_data()); 
}
```

Hoca burada ÅŸu tespiti yapÄ±yor: "Lambda kullanmak daha pratik ama bazen bu temizlik kodunu (deleter) tekrar tekrar kullanacaksanÄ±z, bÃ¶yle bir struct tanÄ±mlamak daha 'temiz' (clean) bir koddur."

Necati Hoca hÄ±zlanÄ±yor, biz de kalemi kaÄŸÄ±dÄ± daha sÄ±kÄ± tutuyoruz. Åimdi `unique_ptr`'nin iÃ§ organlarÄ±na (member functions) ve sÄ±nÄ±flarÄ±n iÃ§inde bir "zÄ±rh" olarak nasÄ±l kullanÄ±ldÄ±ÄŸÄ±na bakacaÄŸÄ±z.

---

### [025:00 - 034:00] `std::make_unique` ve Ãœye FonksiyonlarÄ±n Anatomisi

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Hoca, `new` ifadesini doÄŸrudan kullanmanÄ±n hem riskli hem de zahmetli olduÄŸunu sÃ¶ylÃ¼yor. `std::make_unique` (C++14), bizi hem `new` yazmaktan kurtarÄ±yor hem de karmaÅŸÄ±k ifadelerde "exception safety" (istisna gÃ¼venliÄŸi) saÄŸlÄ±yor.

âš™ï¸ **Teknik Detay ve Sentaks:**

```cpp
#include <memory>
#include "person.h"

void member_func_demo() {
    // 1. make_unique kullanÄ±mÄ±
    auto up = std::make_unique<Person>("Necati", "Ergin"); // <-- Hoca: "En gÃ¼venli ve modern yol budur."

    // 2. get() fonksiyonu
    Person* pRaw = up.get(); // <-- SahipliÄŸi devretmez, sadece adresi verir.

    // 3. operator bool
    if (up) { /* dolu mu? */ } // <-- Hoca: "Smart pointer'Ä±n bir nesneyi sahiplenip sahiplenmediÄŸini denetler."

    // 4. release()
    Person* pManual = up.release(); // <-- SahipliÄŸi bÄ±rakÄ±r, ama nesneyi DELETE ETMEZ!
    delete pManual; // <-- Hoca: "Bunu yapmazsanÄ±z kaynak sÄ±zar, release() Ã§ok tehlikelidir."

    // 5. reset()
    up.reset(new Person("Ali", "Han")); // <-- Eskiyi siler, yeniyi sahiplenir.
    up.reset(); // <-- Sadece siler, null hale gelir.
}
```

ğŸ” **Arka Plan (Under the Hood):**
Hoca `up.get()` ve `up` (direkt kullanÄ±m) farkÄ±nÄ± ÅŸÃ¶yle aÃ§Ä±klÄ±yor: `std::cout << up;` dediÄŸinizde aslÄ±nda arka planda `up.get()` Ã§aÄŸrÄ±lÄ±r. Ã‡Ã¼nkÃ¼ `unique_ptr` iÃ§in bir `operator<<` overload (aÅŸÄ±rÄ± yÃ¼kleme) mevcuttur.

---

### [034:00 - 041:00] SÄ±nÄ±f Veri ElemanÄ± Olarak `unique_ptr` (ZÄ±rhlÄ± SÄ±nÄ±flar)

Bu bÃ¶lÃ¼m dersin **mÃ¼lakatlarda en Ã§ok sorulan** ve HocanÄ±n en Ã§ok Ã¼zerinde durduÄŸu kÄ±sÄ±mlardan biri.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Bir sÄ±nÄ±fÄ±n constructor'Ä± (yapÄ±landÄ±rÄ±cÄ±) iÃ§inde birden fazla dinamik nesne oluÅŸturuluyorsa ve constructor tamamlanmadan bir exception fÄ±rlarsa, o ana kadar oluÅŸmuÅŸ nesneler "leak" (sÄ±zÄ±ntÄ±) olur. Ã‡Ã¼nkÃ¼ nesne tam oluÅŸmadÄ±ÄŸÄ± iÃ§in destructor (sonlandÄ±rÄ±cÄ±) asla Ã§aÄŸrÄ±lmaz.

âš™ï¸ **Teknik Detay (HocanÄ±n "Leak" Senaryosu):**

```cpp
// --- HATA SENARYOSU (RAW POINTER) ---
class MyClass {
    Person* mp;
public:
    MyClass(const std::string& n) {
        mp = new Person(n, "Ergin"); 
        throw std::runtime_error("Hata!"); // <-- HATA: MyClass asla oluÅŸmadÄ±, mp leak oldu!
    }
    ~MyClass() { delete mp; }
};

// --- GÃœVENLÄ° SENARYO (SMART POINTER) ---
class SafeClass {
    std::unique_ptr<Person> mp; // <-- "Resource Management is Member Management"
public:
    SafeClass(const std::string& n) 
        : mp(new Person(n, "Ergin")) {
        throw std::runtime_error("Hata!"); 
        // <-- GÃœVENLÄ°: MyClass oluÅŸmasa bile, mp bir 'sub-object'tir. 
        // Stack Unwinding (yÄ±ÄŸÄ±n boÅŸaltma) sÄ±rasÄ±nda mp'nin destructor'Ä± Ã§alÄ±ÅŸÄ±r ve Person'Ä± siler!
    }
};
```

ğŸš© **Kritik Nokta:** Hoca burada hayati bir kuralÄ± hatÄ±rlatÄ±yor: "EÄŸer sÄ±nÄ±fÄ±n bir veri elemanÄ± `unique_ptr` ise, derleyicinin yazdÄ±ÄŸÄ± 'copy constructor' ve 'copy assignment' otomatik olarak **deleted** (silinmiÅŸ) kabul edilir. Yani sÄ±nÄ±fÄ±nÄ±z kopyalanamaz hale gelir!"

---

### [041:00 - 053:00] `unique_ptr<T[]>` Array Specialization (Dizi Ã–zelleÅŸtirmesi)

Hoca tahtaya bÃ¼yÃ¼k harflerle **"DIKKAT"** yazÄ±yor. `new T` ve `new T[]` arasÄ±ndaki o meÅŸhur fark.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Standart `unique_ptr<T>`, nesne yok olurken `delete` Ã§aÄŸÄ±rÄ±r. Ancak bir dizi (`new T[n]`) oluÅŸturduÄŸumuzda `delete[]` Ã§aÄŸrÄ±lmalÄ±dÄ±r. YanlÄ±ÅŸ operatÃ¶r kullanÄ±mÄ± **Undefined Behavior (UB)**'dir.

âš™ï¸ **Teknik Detay ve Sentaks:**

```cpp
// --- YANLIÅ KULLANIM ---
std::unique_ptr<Date> up_wrong(new Date[5]); // <-- FELAKET! Destructor 'delete' Ã§aÄŸÄ±racak, oysa 'delete[]' lazÄ±m.

// --- DOÄRU KULLANIM ---
std::unique_ptr<Date[]> up_array(new Date[5]); // <-- Partial Specialization (KÄ±smi UzmanlaÅŸma)
```

ğŸ” **Arka Plan (Interface FarklarÄ±):**
Hoca, dizi sÃ¼rÃ¼mÃ¼nÃ¼n (`<T[]>`) arayÃ¼zÃ¼nÃ¼n (interface) farklÄ± olduÄŸunu gÃ¶steriyor:
1.  `operator*` ve `operator->` **YOKTUR**. (Ã‡Ã¼nkÃ¼ dizi tek bir nesne deÄŸildir).
2.  `operator[]` (Subscript) **VARDIR**.
3.  Default deleter olarak `std::default_delete<T[]>` kullanÄ±lÄ±r (Ä°Ã§inde `delete[]` yazar).

---

### [053:00 - 01:03:00] Runtime Polymorphism ve `unique_ptr`

Hoca eski derslerdeki (Runtime Polymorphism) bilgileri buraya baÄŸlÄ±yor.

ğŸš© **AltÄ±n Kural:** "Taban sÄ±nÄ±f tÃ¼rÃ¼nden bir `unique_ptr`, tÃ¼remiÅŸ sÄ±nÄ±f nesnesini gÃ¶sterebilir. Ancak taban sÄ±nÄ±fÄ±n destructor'Ä± mutlaka **virtual** olmalÄ±dÄ±r!"

```cpp
std::unique_ptr<Car> pCar = std::make_unique<Mercedes>(); 
pCar->start(); // Virtual Dispatch (Sanal GÃ¶nderim) tÄ±kÄ±r tÄ±kÄ±r Ã§alÄ±ÅŸÄ±r.
// Scope bittiÄŸinde:
// EÄŸer Car::~Car virtual ise Mercedes destructor'Ä± Ã§aÄŸrÄ±lÄ±r. (DOÄRU)
// EÄŸer virtual deÄŸilse SADECE Car destructor'Ä± Ã§aÄŸrÄ±lÄ±r. (RESOURCE LEAK!)
```

Hoca burada `create_random_car()` fonksiyonunu modernize ediyor: "ArtÄ±k `Car*` dÃ¶ndÃ¼rmeyin, `unique_ptr<Car>` dÃ¶ndÃ¼rÃ¼n. BÃ¶ylece sahipliÄŸi gÃ¼venli bir ÅŸekilde fonksiyondan dÄ±ÅŸarÄ±ya taÅŸÄ±rsÄ±nÄ±z (Move Semantics)."


Necati Hoca dersin bu bÃ¶lÃ¼mÃ¼nde `unique_ptr`â€™yi fonksiyonlarla nasÄ±l dans ettireceÄŸimizi ve ardÄ±ndan "paylaÅŸÄ±mlÄ± sahiplik" dÃ¼nyasÄ±na (`shared_ptr`) nasÄ±l geÃ§iÅŸ yapacaÄŸÄ±mÄ±zÄ± anlatÄ±yor. Kalemleri hazÄ±rlayÄ±n, burasÄ± Move Semantics (TaÅŸÄ±ma SemantiÄŸi) bilgilerimizi tazeleyeceÄŸimiz yer.

---

### [01:04:00 - 01:22:00] Sahiplik Transfer Modelleri: Sink, Factory ve Pass-Through

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
`unique_ptr` kopyalanamaz ama taÅŸÄ±nabilir. Bu Ã¶zellik, nesne sahipliÄŸinin (ownership) kodun farklÄ± katmanlarÄ± arasÄ±nda "gÃ¼venli bir el sÄ±kÄ±ÅŸma" ile devredilmesini saÄŸlar.

âš™ï¸ **Teknik Detay ve Sentaks (3 Temel Model):**

1.  **Sink (AlÄ±cÄ±/Yutucu) Modeli:** Fonksiyon, nesnenin mÃ¼lkiyetini alÄ±r ve scope sonunda onu yok eder.
```cpp
void sink(std::unique_ptr<Person> p) { 
    // ... p ile iÅŸlemler yapÄ±lÄ±r ...
} // <-- Hoca: "p burada hayata gÃ¶zlerini yumar (delete edilir)."

void sink_demo() {
    auto up = std::make_unique<Person>("Ahmet", "Aksoy");
    // sink(up); // <-- HATA: L-value kopyalanamaz!
    sink(std::move(up)); // <-- DOÄRU: Sahiplik devredildi. up artÄ±k boÅŸ (null).
}
```

2.  **Factory (Fabrika) Modeli:** Fonksiyon nesneyi Ã¼retir ve sahipliÄŸi Ã§aÄŸÄ±rana teslim eder.
```cpp
std::unique_ptr<Person> make_person(std::string name, std::string surname) {
    return std::make_unique<Person>(name, surname); 
    // Hoca: "Return ederken gizli bir move iÅŸlemi gerÃ§ekleÅŸir, kopyalama deÄŸil!"
}
```

3.  **Pass-Through (AktarÄ±cÄ±) Modeli:** Fonksiyon nesneyi alÄ±r, Ã¼zerinde iÅŸlem yapar ve tekrar geri dÃ¶ndÃ¼rÃ¼r.
```cpp
std::unique_ptr<Person> process_and_return(std::unique_ptr<Person> p) {
    p->set_name("Mustafa");
    return p; // SahipliÄŸi geri veriyoruz.
}
```

ğŸš© **Kritik Nokta (MÃ¼lakat Sorusu):**
**Soru:** Bir fabrika fonksiyonu `unique_ptr` dÃ¶ndÃ¼rÃ¼yorsa, biz bu nesneyi `shared_ptr` olarak saklayabilir miyiz?
**Cevap:** **EVET.** `shared_ptr`'nin `unique_ptr&&` alan bir constructor'Ä± vardÄ±r. Hoca: "Bu mÃ¼thiÅŸ bir esneklik saÄŸlar; fabrikayÄ± `unique_ptr` ile yazarsÄ±nÄ±z, isteyen `unique` isteyen `shared` olarak kullanÄ±r."

---

### [01:22:00 - 01:52:00] Konteynerlarda `unique_ptr` ve AlgoritmalarÄ±n TaÅŸÄ±ma GÃ¼cÃ¼

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Eskiden `std::vector<Person*>` kullanÄ±rdÄ±k ve vektÃ¶rden bir Ã¶ÄŸe sildiÄŸimizde pointer'Ä± manuel `delete` etmeyi unuturduk. `unique_ptr` konteynerlarÄ± bu derdi bitiriyor.

âš™ï¸ **Teknik Detay (Kritik Algoritma FarklarÄ±):**

```cpp
std::vector<std::unique_ptr<Person>> pvec;
pvec.push_back(std::make_unique<Person>("Ali", "Han")); // GeÃ§ici nesne (r-value) olduÄŸu iÃ§in OK.

// --- ALGORÄ°TMA DÃœÄÃœMÃœ ---
std::list<std::unique_ptr<Person>> plist(10); // 10 tane boÅŸ unique_ptr

// std::copy(pvec.begin(), pvec.end(), plist.begin()); 
// <-- HATA: copy algoritmasÄ± kopyalama (assignment) yapmaya Ã§alÄ±ÅŸÄ±r. unique_ptr kopyalanamaz!

// Ã‡Ã–ZÃœM 1: std::move algoritmasÄ± (algorithm baÅŸlÄ±ÄŸÄ±ndaki)
std::move(pvec.begin(), pvec.end(), plist.begin()); // <-- DOÄRU!

// Ã‡Ã–ZÃœM 2: Move Iterators
std::copy(std::make_move_iterator(pvec.begin()), 
          std::make_move_iterator(pvec.end()), 
          plist.begin()); // <-- Bu da DOÄRU!
```

ğŸ” **Arka Plan (Under the Hood):**
Hoca, `std::move` algoritmasÄ±nÄ±n `std::copy`'den farkÄ±nÄ± tahtaya yazÄ±yor: `std::move` algoritmasÄ± her bir Ã¶ÄŸeyi `*dest = std::move(*src)` ÅŸeklinde aktarÄ±r. Ä°ÅŸlem bittiÄŸinde kaynak konteyner (`pvec`) iÃ§indeki pointerlar **null** (boÅŸ) hale gelir.

---

### [01:52:00 - 02:11:00] `std::shared_ptr`: PaylaÅŸÄ±mlÄ± Sahiplik ve Kontrol BloÄŸu (Control Block)

Hoca `shared_ptr` dÃ¼nyasÄ±na girerken "Burada 'Exclusive Ownership' biter, 'Shared Ownership' baÅŸlar" diyor.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
BazÄ± veri yapÄ±larÄ±nda (Ã¶rneÄŸin graph/graf yapÄ±larÄ±) bir dÃ¼ÄŸÃ¼me birden fazla yerden eriÅŸilmesi gerekebilir. Kimin en son iÅŸinin biteceÄŸi belli deÄŸilse, "en son Ã§Ä±kan Ä±ÅŸÄ±ÄŸÄ± kapatsÄ±n" mantÄ±ÄŸÄ± (`reference counting`) gerekir.

ğŸ” **Arka Plan (Bellek Mimarisi):**
Hoca, `shared_ptr`'nin neden `unique_ptr` gibi "zero-cost" olmadÄ±ÄŸÄ±nÄ± ÅŸu Ã§izimle aÃ§Ä±klÄ±yor:

ğŸ–¼ï¸ **ASCII Memory Map:**
```text
Shared_ptr Nesnesi (Stack'te):
[ Ptr to Object (T*) ]  --> Dinamik Nesne (Heap)
[ Ptr to Control Block ] --> [ Reference Count ]
                             [ Weak Count      ]
                             [ Custom Deleter  ]
```

âš™ï¸ **Teknik Detay: `std::make_shared` Optimizasyonu (Kritik!)**
Hoca mÃ¼lakatlarÄ±n vazgeÃ§ilmez sorusuna geliyor: "Neden `make_shared` kullanmalÄ±yÄ±z?"

1.  **Normal Yol:** `std::shared_ptr<T> sp(new T);`
    *   Ä°ki ayrÄ± allocation (bellek tahsisi) yapÄ±lÄ±r: Biri nesne iÃ§in, biri kontrol bloÄŸu iÃ§in. **YavaÅŸ!**
2.  **Modern Yol:** `auto sp = std::make_shared<T>();`
    *   Tek bir bÃ¼yÃ¼k bellek bloÄŸu allocate edilir. Nesne ve Kontrol BloÄŸu yan yana (contiguous) yerleÅŸir. **HÄ±zlÄ± ve Cache Dostu!**

ğŸš© **Kritik Nokta (Use Count):**
`sp.use_count()` fonksiyonu o an nesneye kaÃ§ tane `shared_ptr`'nin sahip olduÄŸunu dÃ¶ndÃ¼rÃ¼r. KopyaladÄ±kÃ§a artar, her birinin destructor'Ä± Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda azalÄ±r. SÄ±fÄ±r olduÄŸunda `delete` tetiklenir.
