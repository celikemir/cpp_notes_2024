## C++ Ders NotlarÄ±: Associative Containers (Ders 44)
**Tarih:** 2 AralÄ±k 2024
**EÄŸitmen:** Necati Ergin

---

### 1. Associative Containers (Ä°liÅŸkisel Konteynerlar) Temelleri
[00:00.000 --> 00:28.740]

Bu grup dÃ¶rt ana konteynerdan oluÅŸur: `std::set`, `std::multiset`, `std::map`, ve `std::multimap`. Bu konteynerlar Ã¶ÄŸeleri belirli bir karÅŸÄ±laÅŸtÄ±rma kriterine (comparator) gÃ¶re sÄ±ralÄ± tutarlar.

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Sequence containers (ArdÄ±ÅŸÄ±l konteynerlar - vector, list vb.) Ã¶ÄŸeleri ekleme sÄ±rasÄ±na veya manuel konumlandÄ±rmaya gÃ¶re tutar. Ancak veride "var mÄ±?" sorgusu veya sÄ±ralÄ± eriÅŸim $O(n)$ karmaÅŸÄ±klÄ±ÄŸÄ±ndadÄ±r. Associative containers, veriyi kendi iÃ§sel dÃ¼zeninde (genellikle Red-Black Tree - KÄ±rmÄ±zÄ±-Siyah AÄŸaÃ§) sÄ±ralÄ± tutarak arama, ekleme ve silme iÅŸlemlerini $O(\log n)$ seviyesine indirir.

**ğŸ” Arka Plan (Under the Hood):**
*   **Template Parametreleri:** 
    1.  `T`: Tutulacak Ã¶ÄŸenin tÃ¼rÃ¼.
    2.  `Compare`: KarÅŸÄ±laÅŸtÄ±rma kriteri (Default: `std::less<T>`).
    3.  `Allocator`: Bellek yÃ¶netiminden sorumlu tÃ¼r.
*   **Strict Weak Ordering:** KarÅŸÄ±laÅŸtÄ±rma kriteri ÅŸu 4 kuralÄ± saÄŸlamalÄ±dÄ±r; aksi halde **UB (Undefined Behavior - TanÄ±msÄ±z DavranÄ±ÅŸ)** oluÅŸur:
    1.  `f(a, b)` doÄŸruysa `f(b, a)` yanlÄ±ÅŸ olmalÄ±.
    2.  `f(a, a)` her zaman yanlÄ±ÅŸ olmalÄ± (Irreflexivity).
    3.  `f(a, b)` ve `f(b, c)` doÄŸruysa `f(a, c)` doÄŸru olmalÄ± (Transitivity).
    4.  **Transitivity of Equivalence:** `a` ekvivalent `b` ve `b` ekvivalent `c` ise `a` ekvivalent `c` olmalÄ±.

**ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Arama AÄŸacÄ± YapÄ±sÄ±):**
```text
        [ 9 ]          <-- Root
       /     \
    [ 2 ]   [ 13 ]     <-- Sol < KÃ¶k < SaÄŸ
      \
     [ 7 ]             <-- std::set aynÄ± key'den 2.yi kabul etmez.
```

---

### 2. `insert` Ä°ÅŸlemi ve Geri DÃ¶nÃ¼ÅŸ DeÄŸeri
[04:40.280 --> 10:14.240]

`std::set::insert` fonksiyonu, eleman zaten varsa ekleme yapmaz. Bu durumun kontrolÃ¼ geri dÃ¶nÃ¼ÅŸ deÄŸeriyle yapÄ±lÄ±r.

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±:**
*   **C++98/11/14:** `std::pair<iterator, bool>` dÃ¶ner.
*   **C++17:** **Structured Binding (YapÄ±sal BaÄŸlama)** ile daha okunabilir kontrol saÄŸlar.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
std::set<int> myset {2, 7, 9, 13};
auto [iter, inserted] = myset.insert(7); // <-- C++17 Structured Binding

if (inserted) {
    std::cout << "Ekleme yapildi: " << *iter << "\n";
} else {
    std::cout << "Zaten vardi, eklenmedi. Mevcut oge: " << *iter << "\n"; // <-- Kritik: Mevcut Ã¶ÄŸeye iteratÃ¶r dÃ¶ner.
}
```

**ğŸš© MÃ¼lakat Sorusu / Kritik Nokta:**
**Soru:** `std::set::insert` baÅŸarÄ±sÄ±z olursa (eleman zaten varsa) geri dÃ¶nen iteratÃ¶r neyi gÃ¶sterir?
**Cevap:** Sette zaten var olan (eklemeye engel olan) mevcut Ã¶ÄŸenin konumunu gÃ¶sterir.

---

### 3. Arama FonksiyonlarÄ±: `find`, `count`, `contains`
[11:30.120 --> 30:22.340]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
KonteynerÄ±n kendi Ã¼ye fonksiyonu olan `find`, aÄŸaÃ§ yapÄ±sÄ±nÄ± bildiÄŸi iÃ§in $O(\log n)$ hÄ±zÄ±nda Ã§alÄ±ÅŸÄ±r. Global `std::find` algoritmasÄ± ise konteyneri dÃ¼z bir dizi gibi taradÄ±ÄŸÄ± iÃ§in $O(n)$ hÄ±zÄ±ndadÄ±r.

**ğŸ” Arka Plan (Under the Hood):**
*   **Equivalence vs Equality:** Ãœye `find`, `==` operatÃ¶rÃ¼nÃ¼ deÄŸil, komparatÃ¶rÃ¼ (`std::less`) kullanarak **Equivalence (EÅŸdeÄŸerlik)** kontrolÃ¼ yapar: `!(a < b) && !(b < a)`.
*   **Multi-set Garantisi:** `std::multiset::find`, eÅŸdeÄŸer Ã¶ÄŸelerden **ilkini** bulma garantisi verir.

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±:**
*   `find()` / `count()`: TÃ¼m standartlarda var.
*   `contains()`: **C++20** ile eklendi (DoÄŸrudan `bool` dÃ¶ner, daha semantiktir).

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
if (myset.contains(12)) { // <-- C++20: if (myset.find(12) != myset.end()) yazmanÄ±n kÄ±sa yolu.
    std::cout << "Oge bulundu.\n";
}

auto cnt = myset.count(7); // set iÃ§in 0 veya 1, multiset iÃ§in miktar dÃ¶ner.
```

---

### 4. Sette Const-ness ve YanlÄ±ÅŸ Mutasyon
[30:23.900 --> 33:36.600]

**ğŸš© Kritik Nokta:**
Setteki Ã¶ÄŸeler (anahtarlar) **const** olarak ele alÄ±nÄ±r. Ã‡Ã¼nkÃ¼ bir Ã¶ÄŸenin deÄŸerini deÄŸiÅŸtirmek, aÄŸacÄ±n sÄ±ralama mantÄ±ÄŸÄ±nÄ± bozar ve veri yapÄ±sÄ±nÄ± bozarsÄ±nÄ±z (corrupt).

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
auto iter = myset.begin();
// *iter = 100; // <-- Syntax HatasÄ±! Set Ã¶ÄŸeleri deÄŸiÅŸtirilemez.

// TEHLÄ°KELÄ° HÄ°LE (UB):
const_cast<int&>(*iter) = 100; // <-- Necati Hoca: "Tanimsiz davranistir, veri yapisini bozarsiniz!"
```

---

### 5. Modern Key DeÄŸiÅŸtirme: `extract` ve `node_handle`
[40:00.000 --> 54:00.000]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Eskiden bir anahtarÄ± deÄŸiÅŸtirmek iÃ§in; eskiyi sil (`erase`) ve yeniyi ekle (`insert`) yapÄ±lÄ±rdÄ±. Bu durum, Ã¶ÄŸenin bellekte yok edilip (`destructor`) tekrar oluÅŸturulmasÄ±na (`constructor`) ve gereksiz bellek tahsisine (`allocation`) neden olurdu. Ã–zellikle aÄŸÄ±r sÄ±nÄ±flarda bu bÃ¼yÃ¼k bir maliyettir.

**ğŸ” Arka Plan (Under the Hood):**
**C++17** ile gelen `extract` fonksiyonu, dÃ¼ÄŸÃ¼mÃ¼ (node) aÄŸaÃ§tan kopartÄ±r ama belleÄŸini serbest bÄ±rakmaz. Bize bir **Node Handle (DÃ¼ÄŸÃ¼m TutamacÄ±)** verir. Bu tutamaÃ§ iÃ§indeki deÄŸeri deÄŸiÅŸtirip tekrar "insert" edebiliriz.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
std::set<std::string> myset {"Necati", "Hakan", "Ali"};

auto handle = myset.extract("Necati"); // <-- DÃ¼ÄŸÃ¼m aÄŸaÃ§tan koptu, size azaldÄ±.
if (!handle.empty()) {
    handle.value() = "Ouzhan"; // <-- Bellek re-allocation yok! Sadece veri deÄŸiÅŸti.
    myset.insert(std::move(handle)); // <-- Yeni yerine yerleÅŸti (R-value insert).
}
```

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±:**
*   **C++11:** Erase + Insert ($2 \times \log n$ + re-allocation).
*   **C++17:** `extract` + `insert` (Daha verimli, bellek korumalÄ±).

---

### 6. Hint Insert (Ä°puculu Ekleme)
[54:00.000 --> 01:04.000]

**ğŸ” Arka Plan (Under the Hood):**
`insert(iter, value)` fonksiyonunda verilen iteratÃ¶r, eklemenin yapÄ±lacaÄŸÄ± yer iÃ§in bir "ipucu" (hint) teÅŸkil eder. EÄŸer ipucu doÄŸruysa (Ã¶ÄŸe tam oraya veya yakÄ±nÄ±na eklenecekse), arama maliyeti $O(\log n)$'den **Amortized $O(1)$** seviyesine dÃ¼ÅŸer.

**ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar:**
`std::inserter` adaptÃ¶rÃ¼, arka planda bu "hint insert" fonksiyonunu Ã§aÄŸÄ±rÄ±r. Bu sayede `std::copy` gibi algoritmalar set konteynerÄ±na veri ekleyebilir.

---

### 7. Heterojen Arama ve Transparent Comparators
[01:04.000 --> 01:21:00]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Elimizde `std::set<std::string>` olsun. `find("ali")` dediÄŸimizde, "ali" (const char*) ifadesinden geÃ§ici bir `std::string` nesnesi oluÅŸturulur. Bu gereksiz bir maliyettir. Sadece karÅŸÄ±laÅŸtÄ±rma yapmak iÃ§in neden nesne yaratalÄ±m?

**ğŸ” Arka Plan (Under the Hood):**
**C++14** ile gelen "Transparent Comparator" (Åeffaf KarÅŸÄ±laÅŸtÄ±rÄ±cÄ±) Ã¶zelliÄŸi, farklÄ± tÃ¼rlerin birbiriyle (Ã¶rneÄŸin `string` ile `const char*`) doÄŸrudan karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlar. Bunun iÃ§in komparatÃ¶r sÄ±nÄ±fÄ±nda `is_transparent` isimli bir iÃ§ tÃ¼r (nested type) tanÄ±mÄ± olmalÄ±dÄ±r.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
// std::less<void> (veya std::less<>) ÅŸeffaftÄ±r.
std::set<std::string, std::less<>> myset; 

myset.find("ali"); // <-- GeÃ§ici string nesnesi OLUÅTURULMAZ. DoÄŸrudan karÅŸÄ±laÅŸtÄ±rma yapÄ±lÄ±r.
```

### 8. `std::map` ve `std::multimap` YapÄ±sÄ±
[01:35:00 --> 01:40:00]

`std::map`, anahtar-deÄŸer (**Key-Value**) Ã§iftlerini tutan bir iliÅŸkisel konteynerdÄ±r. `std::set`'ten temel farkÄ±, her anahtarÄ±n karÅŸÄ±lÄ±k geldiÄŸi bir deÄŸer (value) bulunmasÄ±dÄ±r.

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Sadece bir verinin varlÄ±ÄŸÄ±nÄ± kontrol etmek deÄŸil (set), bir anahtar Ã¼zerinden (Ã–rn: TC Kimlik No) baÅŸka bir veriye (Ã–rn: Ä°sim) $O(\log n)$ karmaÅŸÄ±klÄ±ÄŸÄ±nda eriÅŸmek iÃ§in kullanÄ±lÄ±r.

**ğŸ” Arka Plan (Under the Hood):**
*   **Ã–ÄŸelerin TÃ¼rÃ¼:** Map iÃ§inde tutulan her Ã¶ÄŸe aslÄ±nda `std::pair<const Key, T>` tÃ¼rÃ¼ndedir. 
*   **Kritik Kural:** Anahtar (`Key`) kÄ±smÄ± **const**'tÄ±r. Ã‡Ã¼nkÃ¼ anahtarÄ±n deÄŸiÅŸmesi, dÃ¼ÄŸÃ¼mÃ¼n aÄŸaÃ§taki yerinin deÄŸiÅŸmesi demektir.
*   **Template Parametreleri:** 
    1. `Key`: Anahtar tÃ¼rÃ¼.
    2. `T`: DeÄŸer (mapped) tÃ¼rÃ¼.
    3. `Compare`: AnahtarlarÄ± karÅŸÄ±laÅŸtÄ±rma kriteri.
    4. `Allocator`: Bellek tahsisatÃ§Ä±sÄ±. (Pair iÃ§in Ã¶zelleÅŸir).

**ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Map Pair YapÄ±sÄ±):**
```text
[Node]
  â”œâ”€â”€ std::pair<const Key, T> 
  â”‚      â”œâ”€â”€ first  (Key)   <-- Const (DeÄŸiÅŸmez)
  â”‚      â””â”€â”€ second (Value) <-- Mutable (DeÄŸiÅŸebilir)
  â”œâ”€â”€ Left Child Pointer
  â””â”€â”€ Right Child Pointer
```

---

### 9. Map'e Ekleme ve `std::pair` KullanÄ±mÄ±
[01:40:00 --> 01:44:00]

Map'e veri eklerken bir `std::pair` nesnesi vermemiz gerekir.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
std::map<int, std::string> mymap;

// 1. Pair nesnesi ile (Copy/Move)
std::pair<int, std::string> p1 {45, "Suleyman"};
mymap.insert(p1);

// 2. std::make_pair ile
mymap.insert(std::make_pair(12, "Necati")); // <-- Eskiden cok yaygindi

// 3. initializer_list ile (Modern C++)
mymap.insert({24, "Turgut"}); // <-- En pratik yol

// 4. emplace (Perfect Forwarding)
mymap.emplace(41, "SevinÃ§"); // <-- Nesne doÄŸrudan map belleÄŸinde oluÅŸturulur.
```

---

### 10. Modern Iterasyon: Structured Binding (YapÄ±sal BaÄŸlama)
[01:44:00 --> 01:52:00]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Eskiden map'i dolaÅŸÄ±rken `it->first` ve `it->second` yazmak kodun okunabilirliÄŸini dÃ¼ÅŸÃ¼rÃ¼yordu.

**ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±:**
*   **C++11/14:** `for (const auto& p : mymap) { ... p.first ... p.second ... }`
*   **C++17:** **Structured Binding** ile anahtar ve deÄŸere doÄŸrudan isim verilebilir.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
std::map<int, std::string> mymap {{1, "Adnan"}, {2, "Atakan"}};

// C++17 sonrasÄ± idiomatik kullanÄ±m:
for (const auto& [id, name] : mymap) { // <-- Hoca buraya dikkat Ã§ekti: Okunabilirlik tavan!
    std::cout << "ID: " << id << ", Isim: " << name << "\n";
}
```

---

### 11. Map'te Anahtar DeÄŸiÅŸtirme (`extract`)
[02:03:00 --> 02:06:00]

Map'te de set'te olduÄŸu gibi anahtar (first) doÄŸrudan deÄŸiÅŸtirilemez. DeÄŸer (second) ise her zaman deÄŸiÅŸtirilebilir.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
auto node_handle = mymap.extract("EskiKey"); // <-- DÃ¼ÄŸÃ¼mÃ¼ aÄŸaÃ§tan sÃ¶k
if (!node_handle.empty()) {
    node_handle.key() = "YeniKey"; // <-- C++17 ile Key deÄŸiÅŸtirmek artÄ±k mÃ¼mkÃ¼n!
    mymap.insert(std::move(node_handle)); // <-- Yeni anahtarla geri yerleÅŸtir
}
```

---

### 12. Map'in "Sihirli" Fonksiyonu: `operator[]`
[02:16:00 --> 02:26:00]

Map'in kÃ¶ÅŸeli parantez operatÃ¶rÃ¼, diÄŸer konteynerlardan Ã§ok farklÄ± Ã§alÄ±ÅŸÄ±r.

**ğŸ” Arka Plan (Under the Hood):**
`mymap[key]` ifadesi Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda:
1.  **Anahtar Varsa:** O anahtara karÅŸÄ±lÄ±k gelen deÄŸerin (`second`) referansÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
2.  **Anahtar Yoksa:** O anahtarÄ± **insert** eder! KarÅŸÄ±lÄ±k gelen deÄŸeri ise **Value Initialize** eder (int ise 0, string ise boÅŸ string yapar) ve onun referansÄ±nÄ± dÃ¶ner.

**ğŸš© Kritik Nokta / Tehlike:**
Sadece "bu anahtar var mÄ±?" diye kontrol etmek iÃ§in `[]` operatÃ¶rÃ¼nÃ¼ kullanÄ±rsanÄ±z, yanlÄ±ÅŸlÄ±kla o anahtarÄ± map'e eklemiÅŸ olursunuz. **Arama iÃ§in `find` veya `contains` kullanÄ±n!**

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
std::map<std::string, int> grades;

grades["Necati"] = 100; // <-- Necati yoktu, eklendi ve deÄŸeri 100 yapÄ±ldÄ±.
std::cout << grades["Hakan"]; // <-- Hakan yoktu, SESSÄ°ZCE eklendi ve deÄŸeri 0 yapÄ±ldÄ±!
```

---

### 13. Map'in En Tipik KullanÄ±mÄ±: Eleman Sayma (Count Idiom)
[02:26:00 --> 02:38:00]

Bir veri kÃ¼mesinde hangi Ã¶ÄŸeden kaÃ§ tane olduÄŸunu bulmak iÃ§in `std::map` ve `operator[]` ikilisi kullanÄ±lÄ±r.

**ğŸš© MÃ¼lakat Sorusu / Kritik Nokta:**
**Soru:** Elindeki 10.000 kelimelik bir listede her kelimenin kaÃ§ar kez geÃ§tiÄŸini en verimli nasÄ±l sayarsÄ±n?
**Cevap:** `std::map<string, int>` kullanarak tek bir dÃ¶ngÃ¼de sayarÄ±m.

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
std::vector<std::string> words {"ali", "veli", "ali", "can", "veli", "ali"};
std::map<std::string, int> counter;

for (const auto& s : words) {
    counter[s]++; // <-- Kritik SatÄ±r: Yoksa ekler 0'Ä± 1 yapar, varsa mevcut deÄŸeri artÄ±rÄ±r.
}

// SonuÃ§: ali:3, veli:2, can:1
```

---

### 14. `at()` vs `operator[]`
[02:38:00 --> 02:44:44]

**ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Bazen bir anahtarÄ±n map'te olduÄŸundan eminizdir veya yoksa eklenmesini istemiyoruzdur.

**ğŸ“Š KarÅŸÄ±laÅŸtÄ±rma Tablosu:**

| Ã–zellik | `operator[]` | `at()` |
| :--- | :--- | :--- |
| **Anahtar Yoksa** | Yeni Ã¶ÄŸe ekler. | `std::out_of_range` fÄ±rlatÄ±r. |
| **Const Map** | KullanÄ±lamaz (Mutativedir). | KullanÄ±labilir (Okuma amaÃ§lÄ±). |
| **Maliyet** | Daha dÃ¼ÅŸÃ¼ktÃ¼r. | Exception kontrolÃ¼ nedeniyle biraz fazladÄ±r. |

**ä»£ç  (Kod Ã–rneÄŸi):**
```cpp
try {
    auto value = mymap.at("OlmayanKey"); // <-- Hoca: "at() exception throw eder."
} catch (const std::out_of_range& e) {
    std::cerr << "Anahtar bulunamadi!\n";
}
```

---

### 15. KapanÄ±ÅŸ ve Gelecek Ders
[02:43:00 --> 02:44:44]

Necati Hoca dersi bitirirken, Ã§arÅŸamba gÃ¼nÃ¼ Map ve Multimap konularÄ±nÄ± tamamlayÄ±p, **Unordered Associative Containers** (Hash tabanlÄ± yapÄ±lar: `unordered_set`, `unordered_map`) grubuna geÃ§ileceÄŸini belirtti. AyrÄ±ca kursun ilerleyen bÃ¶lÃ¼mlerinde **Concurrency** (EÅŸzamanlÄ±lÄ±k), `std::atomic` ve **Thread** mekanizmalarÄ±na deÄŸinileceÄŸinin mÃ¼jdesini verdi.

