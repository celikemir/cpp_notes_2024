### ğŸ“ C++ Programlama NotlarÄ±: STL GeliÅŸmiÅŸ Konteynerlar ve AdaptÃ¶rler (46. GÃ¼n)

Bu derste, `std::array` konteynerÄ±nÄ±n ileri dÃ¼zey Ã¶zellikleri, Ã§ok boyutlu diziler, C++20 ile gelen yenilikler ve STL'in "Container Adapters" (Konteyner UyumlandÄ±rÄ±cÄ±larÄ±) grubuna giriÅŸ yapÄ±lmÄ±ÅŸtÄ±r.

---

### 1. `std::array` Derinlemesine BakÄ±ÅŸ ve HatÄ±rlatma [00:00 - 07:07]

`std::array`, C dizileri Ã¼zerinde maliyeti olmayan "lightweight wrapper" (hafif sarmalayÄ±cÄ±) bir sÄ±nÄ±ftÄ±r.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C dizileri (C-style arrays), fonksiyonlara geÃ§ildiklerinde **Array-to-pointer decay** (dizinin ilk elemanÄ±nÄ±n adresine dÃ¶nÃ¼ÅŸmesi) nedeniyle boyut bilgilerini kaybederler. AyrÄ±ca C dizileri birer nesne olmadÄ±klarÄ± iÃ§in atama yapÄ±lamaz ve STL algoritmalarÄ±yla doÄŸrudan bir "container-like interface" (konteyner benzeri arayÃ¼z) sunmazlar. `std::array` bu eksiklikleri gidermek iÃ§in tasarlanmÄ±ÅŸtÄ±r.

#### ğŸ” Arka Plan (Under the Hood)
`std::array` bir **Aggregate Type** (toplu tÃ¼r) yapÄ±sÄ±ndadÄ±r. Yani kullanÄ±cÄ± tanÄ±mlÄ± bir constructor'Ä± yoktur. Elemanlar doÄŸrudan sÄ±nÄ±fÄ±n iÃ§inde, bellekte ardÄ±ÅŸÄ±k olarak tutulur.
```cpp
std::array<int, 5> ar = {1, 2, 3, 4, 5}; 
// Arka planda: struct { int _data[5]; }; yapÄ±sÄ±na benzer.
```

#### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
*   **C++11:** `std::array` dile eklendi.
*   **C++17:** `std::array` iÃ§in CTAD (Class Template Argument Deduction - SÄ±nÄ±f Åablonu ArgÃ¼man Ã‡Ä±karÄ±mÄ±) desteÄŸi geldi.
    ```cpp
    std::array ar = {1, 2, 3}; // <-- C++17 ile geÃ§erli (int, 3) olarak Ã§Ä±karÄ±lÄ±r.
    ```

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::array<int, 5>` ile `std::array<int, 10>` aynÄ± tÃ¼r mÃ¼dÃ¼r?
**Cevap:** HayÄ±r. `std::array`'in ikinci template parametresi bir "non-type template parameter"dÄ±r. Boyut farklÄ± olduÄŸunda tÃ¼r tamamen farklÄ± olur. Bu iki nesne birbirine atanamaz (assignment) veya birbirini initialize edemez.

---

### 2. Ã‡ok Boyutlu `std::array` ve Initialization [14:39 - 20:30]

`std::array` nesneleri iÃ§ iÃ§e kullanÄ±larak Ã§ok boyutlu diziler oluÅŸturulabilir.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Matris yapÄ±larÄ±nÄ± veya tablo verilerini STL gÃ¼vencesiyle (sÄ±nÄ±r kontrolÃ¼, iteratÃ¶r desteÄŸi) yÃ¶netebilmek iÃ§in.

#### ğŸ” Arka Plan (Under the Hood)
Ä°Ã§ iÃ§e `std::array` kullanÄ±mÄ±nda **Double Braces** (Ã§ift kÃ¼me parantezi) kullanÄ±mÄ± kritik bir detaydÄ±r. `std::array` bir aggregate olduÄŸu ve iÃ§inde bir C dizisi barÄ±ndÄ±rdÄ±ÄŸÄ± iÃ§in, ilk parantez sÄ±nÄ±fÄ±n kendisini, ikinci parantez iÃ§indeki veriyi temsil eder.

```cpp
// 2 boyutlu dizi: 4 satÄ±r, 3 sÃ¼tun
std::array<std::array<int, 3>, 4> matrix = {{
    {2, 2, 2}, // 1. satÄ±r (bir std::array<int, 3> nesnesi)
    {4, 4, 4}, 
    {6, 6, 6}, 
    {8, 8, 8}
}}; // <-- Hoca vurguladÄ±: DÄ±ÅŸtaki Ã§ift parantez aggregate yapÄ±sÄ±ndan kaynaklÄ±dÄ±r.

// EriÅŸim:
int val = matrix[2][1]; // matrix.operator[](2).operator[](1)
```

#### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Memory Layout)
```text
[std::array<std::array, 4>]
|
+-- [0] [int, int, int] (ArdÄ±ÅŸÄ±k bellek)
+-- [1] [int, int, int]
+-- [2] [int, int, int]
+-- [3] [int, int, int]
```

---

### 3. C++20 `std::to_array` [27:43 - 30:22]

C++20 ile birlikte dizi oluÅŸturmayÄ± kolaylaÅŸtÄ±ran bir yardÄ±mcÄ± fonksiyon (helper function) eklenmiÅŸtir.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ã–zellikle "string literal"lardan (karakter dizisi sabitlerinden) veya mevcut dizilerden hÄ±zlÄ±ca `std::array` elde etmek zahmetliydi. `std::to_array` ile tÃ¼r ve boyut Ã§Ä±karÄ±mÄ± otomatikleÅŸir.

```cpp
auto ar1 = std::to_array("Necati"); // std::array<char, 7> (null char dahil)
auto ar2 = std::to_array({2, 3, 5, 7, 11}); // std::array<int, 5>
```

#### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar
Bu Ã¶zellik, 45. derste bahsedilen jenerik kod yazÄ±mÄ±nda (template programming) tip Ã§Ä±karÄ±mÄ± (deduction) yaparken bÃ¼yÃ¼k kolaylÄ±k saÄŸlar.

---

### 4. Konteyner AdaptÃ¶rleri: `std::stack` [30:23 - 56:20]

Konteyner adaptÃ¶rleri aslÄ±nda birer konteyner deÄŸildir; mevcut bir konteynerÄ±n arayÃ¼zÃ¼nÃ¼ (interface) deÄŸiÅŸtirerek belirli bir **Abstract Data Type (ADT - Soyut Veri TÃ¼rÃ¼)** kuralÄ±na uygun hale getirirler.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Programlamada LIFO (Last In First Out - Son Giren Ä°lk Ã‡Ä±kar) prensibi Ã§ok yaygÄ±ndÄ±r (Ã–rn: Fonksiyon Ã§aÄŸrÄ± yÄ±ÄŸÄ±tÄ±, parantez eÅŸleÅŸtirme). `std::stack`, bu mantÄ±ÄŸÄ± kÄ±sÄ±tlanmÄ±ÅŸ bir arayÃ¼zle sunarak hata riskini azaltÄ±r (Ã¶rneÄŸin stack'in ortasÄ±ndan eleman silinemez).

#### ğŸ” Arka Plan (Under the Hood)
`std::stack` iki template parametresi alÄ±r: `T` (TÃ¼r) ve `Container`.
*   VarsayÄ±lan konteyner (Underlying Container): `std::deque`'dir.
*   Neden `std::vector` deÄŸil? `std::deque`, bellek yeniden tahsisatÄ±nda (reallocation) elemanlarÄ± kopyalamaz, bu da bÃ¼yÃ¼k stack yapÄ±larÄ±nda daha verimlidir.

```cpp
template <typename T, typename Container = std::deque<T>>
class stack {
protected:
    Container c; // <-- Hoca buraya dikkat Ã§ekti: Ãœye konteyner 'c' ismindedir ve protected'dÄ±r.
public:
    void push(const T& val) { c.push_back(val); }
    void pop() { c.pop_back(); }
    T& top() { return c.back(); }
};
```

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta: Pop Neden `void`?
**Soru:** Neden `pop()` fonksiyonu silinen elemanÄ± geri dÃ¶ndÃ¼rmÃ¼yor (return etmiyor)?
**Cevap:** **Exception Safety** (Ä°stisna GÃ¼venliÄŸi) nedeniyle. EÄŸer `pop()` elemanÄ± dÃ¶ndÃ¼rseydi ve kopyalama sÄ±rasÄ±nda bir exception (istisna) oluÅŸsaydÄ±, eleman yÄ±ÄŸÄ±ttan silinmiÅŸ ama kullanÄ±cÄ±ya ulaÅŸmamÄ±ÅŸ olurdu (Data Loss). C++ felsefesinde `top()` ile elemana bakÄ±lÄ±r, `pop()` ile silinir.

#### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
*   **C++20:** `std::stack` ve `std::queue` iÃ§in **Range Constructor** eklendi. ArtÄ±k bir aralÄ±ktan (iterator range) doÄŸrudan stack oluÅŸturulabilir.


### 5. `std::stack` UygulamasÄ± ve Operasyonlar [00:56:20 - 01:17:44]

Necati Hoca, dersin bu bÃ¶lÃ¼mÃ¼nde bir `stack` sÄ±nÄ±fÄ±nÄ±n arka planda nasÄ±l kodlandÄ±ÄŸÄ±nÄ± (manual implementation) simÃ¼le ederek adaptÃ¶r mantÄ±ÄŸÄ±nÄ± pekiÅŸtirmiÅŸtir.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Konteyner adaptÃ¶rlerinin (stack, queue) nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± anlamak, sadece hazÄ±r sÄ±nÄ±flarÄ± kullanmak deÄŸil, gerektiÄŸinde kendi Ã¶zel veri yapÄ±larÄ±nÄ±zÄ± (Ã–rn: `pop()` yapÄ±nca deÄŸer dÃ¶ndÃ¼ren bir stack) yazabilmenizi saÄŸlar.

#### ğŸ” Arka Plan (Under the Hood)
`std::stack` fonksiyonlarÄ±, Ã§aÄŸrÄ±larÄ± doÄŸrudan iÃ§indeki Ã¼ye konteynerÄ±n (member container) fonksiyonlarÄ±na yÃ¶nlendirir. 
*   `push()` -> `push_back()`
*   `pop()` -> `pop_back()`
*   `top()` -> `back()`
*   `emplace()` -> `emplace_back()`

```cpp
template <typename T, typename C = std::deque<T>>
class MyStack {
protected:
    C c; // <-- Hoca: Ä°sim standartta 'c'dir ve protected olmasÄ± kalÄ±tÄ±m imkanÄ± saÄŸlar.

public:
    void push(const T& val) { c.push_back(val); }
    void push(T&& val) { c.push_back(std::move(val)); } // <-- TaÅŸÄ±ma semantiÄŸi desteÄŸi
    
    template <typename... Args>
    void emplace(Args&&... args) {
        c.emplace_back(std::forward<Args>(args)...); // <-- Perfect Forwarding (MÃ¼kemmel AktarÄ±m)
    }

    void pop() { c.pop_back(); }
    T& top() { return c.back(); } // <-- L-value referans dÃ¶ner, top eleman deÄŸiÅŸtirilebilir.
};
```

#### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
*   **C++11:** `emplace` fonksiyonu eklendi.
*   **C++20:** **Range Constructor** eklendi. ArtÄ±k bir iterator aralÄ±ÄŸÄ±yla stack baÅŸlatÄ±labilir.
    ```cpp
    std::vector<int> v = {1, 2, 3};
    std::stack<int> s(v.begin(), v.end()); // <-- C++20 Ã¶zelliÄŸi
    ```

#### ğŸš© Kritik Nokta: YÄ±ÄŸÄ±n ElemanlarÄ±nÄ± BoÅŸaltma Ä°diyomu
Hoca, yÄ±ÄŸÄ±ndaki tÃ¼m elemanlarÄ± sÄ±rayla iÅŸleyip silmek iÃ§in `while` yerine daha kompakt olan `for` dÃ¶ngÃ¼sÃ¼nÃ¼ Ã¶nermiÅŸtir:
```cpp
for (; !myStack.empty(); myStack.pop()) {
    process(myStack.top()); // <-- Ã–nce bak, sonra pop et!
}
```

---

### 6. Uygulama Sorusu: Parantez EÅŸleÅŸtirme (Parenthesis Matching) [01:17:45 - 01:24:12]

Stack veri yapÄ±sÄ±nÄ±n en klasik kullanÄ±m senaryolarÄ±ndan biridir.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Derleyicilerin kod analizinde (parsing) parantez hiyerarÅŸisini doÄŸrulamasÄ± gerekir. Bu problem yÄ±ÄŸÄ±n (stack) olmadan verimli Ã§Ã¶zÃ¼lemez.

#### ğŸ” Algoritma MantÄ±ÄŸÄ±
1.  Karakter dizisini dolaÅŸ.
2.  AÃ§Ä±lan parantez (`(`, `[`, `{`, `<`) gÃ¶rÃ¼rsen stack'e **push** et.
3.  Kapanan parantez gÃ¶rÃ¼rsen:
    *   Stack boÅŸsa -> **HATA** (EÅŸleÅŸmeyen kapanan parantez).
    *   Stack'in **top** elemanÄ±, bu kapanan parantezin eÅŸi deÄŸilse -> **HATA**.
    *   EÅŸi ise -> **pop** et.
4.  YazÄ± bittiÄŸinde stack boÅŸ deÄŸilse -> **HATA** (KapanmamÄ±ÅŸ parantez var).

---

### 7. `std::queue` (Kuyruk) [01:24:13 - 01:31:07]

FIFO (First In First Out - Ä°lk Giren Ä°lk Ã‡Ä±kar) prensibiyle Ã§alÄ±ÅŸan adaptÃ¶rdÃ¼r.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bilet kuyruklarÄ±, yazÄ±cÄ± gÃ¶rev listeleri veya iÅŸlemci zamanlama (scheduling) algoritmalarÄ± gibi verilerin giriÅŸ sÄ±rasÄ±na gÃ¶re iÅŸlendiÄŸi senaryolar iÃ§in.

#### ğŸ” Arka Plan (Under the Hood)
*   `std::stack`'ten farkÄ±: Eleman bir uÃ§tan eklenir (`back`), diÄŸer uÃ§tan Ã§Ä±karÄ±lÄ±r (`front`).
*   **ArayÃ¼z FarkÄ±:** `top()` yerine `front()` ve `back()` fonksiyonlarÄ± vardÄ±r.
*   **Dayanak Konteyner:** VarsayÄ±lan olarak `std::deque` kullanÄ±r. `std::vector` kuyruk iÃ§in **uygun deÄŸildir** Ã§Ã¼nkÃ¼ vektÃ¶rÃ¼n baÅŸÄ±ndan eleman silmek (pop) $O(N)$ maliyetlidir.

```cpp
std::queue<int> q;
q.push(10); // Arkaya ekler
q.front();  // En Ã¶ndekine (10) bakar
q.back();   // En arkadakine bakar
q.pop();    // En Ã¶ndekini siler
```

---

### 8. `std::priority_queue` (Ã–ncelik KuyruÄŸu) [01:31:08 - 01:46:17]

ElemanlarÄ±n giriÅŸ sÄ±rasÄ±na gÃ¶re deÄŸil, Ã¶ncelik deÄŸerlerine (priority) gÃ¶re Ã§Ä±ktÄ±ÄŸÄ± veri yapÄ±sÄ±dÄ±r.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Hastanelerdeki acil servis mantÄ±ÄŸÄ± gibidir; sÄ±raya kimin Ã¶nce girdiÄŸinden ziyade durumu en acil (Ã¶nceliÄŸi en yÃ¼ksek) olan Ã¶nce iÅŸlem gÃ¶rÃ¼r.

#### ğŸ” Arka Plan (Under the Hood)
*   **Veri YapÄ±sÄ±:** Arka planda bir **Heap** (yÄ±ÄŸÄ±n aÄŸacÄ±) yapÄ±sÄ± kullanÄ±r.
*   **Dayanak Konteyner:** Heap yapÄ±sÄ± rastgele eriÅŸim (random access) gerektirdiÄŸi iÃ§in varsayÄ±lan konteyner `std::vector`'dÃ¼r (`std::deque` de kullanÄ±labilir).
*   **SÄ±ralama:** VarsayÄ±lan olarak **Max-Heap** (en bÃ¼yÃ¼k eleman en Ã¼stte) mantÄ±ÄŸÄ±yla Ã§alÄ±ÅŸÄ±r (`std::less`).

#### ğŸ“Š Template Parametreleri
```cpp
template <
    typename T, 
    typename Container = std::vector<T>, 
    typename Compare = std::less<typename Container::value_type>
> class priority_queue;
```

#### ğŸš© MÃ¼lakat Sorusu: Min-Heap NasÄ±l YapÄ±lÄ±r?
**Soru:** `priority_queue`'nun en kÃ¼Ã§Ã¼k elemanÄ± ilk Ã§Ä±karmasÄ±nÄ± (Min-Heap) nasÄ±l saÄŸlarÄ±z?
**Cevap:** ÃœÃ§Ã¼ncÃ¼ template parametresine `std::greater` geÃ§ilmelidir.
```cpp
// KÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe (Min-Priority Queue)
std::priority_queue<int, std::vector<int>, std::greater<int>> minQ;
```

---

### 9. `std::tuple` (GenelleÅŸtirilmiÅŸ Pair) [01:46:18 - 02:06:20]

`std::pair` sadece iki eleman tutabilirken, `std::tuple` derleme zamanÄ±nda belirlenen $N$ sayÄ±da farklÄ± tÃ¼rden elemanÄ± bir arada tutar.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir fonksiyondan 3, 4 veya daha fazla farklÄ± tÃ¼rde deÄŸer dÃ¶ndÃ¼rmek gerektiÄŸinde (Ã–rn: ID, Ä°sim, MaaÅŸ, Tarih) geÃ§ici struct tanÄ±mlama zahmetinden kurtarÄ±r.

#### ğŸ” Arka Plan (Under the Hood)
`std::tuple` bir **Variadic Template** (deÄŸiÅŸken sayÄ±da parametre alan ÅŸablon) Ã¶rneÄŸidir. Elemanlara indeks veya tÃ¼r ile eriÅŸilir.

```cpp
#include <tuple>
auto t = std::make_tuple(101, "Ali", 3.14); // tuple<int, const char*, double>

// EriÅŸim yollarÄ±:
int id = std::get<0>(t); // Ä°ndeks ile (0-based)
const char* name = std::get<const char*>(t); // <-- C++14: TÃ¼r ile eriÅŸim (TÃ¼r benzersiz olmalÄ±)

// Structured Binding (C++17):
auto [myId, myName, myPi] = t; // <-- Hoca: En pratik kullanÄ±m budur.
```

### 10. `std::tuple` Fabrika FonksiyonlarÄ± ve KarÅŸÄ±laÅŸtÄ±rma [02:06:20 - 02:17:05]

`std::tuple` nesnelerini oluÅŸturmak ve karÅŸÄ±laÅŸtÄ±rmak iÃ§in kullanÄ±lan yardÄ±mcÄ± araÃ§lar dersin bu bÃ¶lÃ¼mÃ¼nde detaylandÄ±rÄ±lmÄ±ÅŸtÄ±r.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++17 Ã¶ncesinde CTAD (Class Template Argument Deduction) olmadÄ±ÄŸÄ± iÃ§in, template argÃ¼manlarÄ±nÄ± manuel yazmamak adÄ±na `std::make_tuple` gibi fabrika fonksiyonlarÄ±na ihtiyaÃ§ duyuluyordu. AyrÄ±ca, Ã§ok elemanlÄ± verilerin (Ã–rn: VeritabanÄ± satÄ±rÄ±) belirli bir hiyerarÅŸiye gÃ¶re sÄ±ralanmasÄ± karmaÅŸÄ±k bir mantÄ±k gerektirir.

#### ğŸ” Arka Plan (Under the Hood): Lexicographical Comparison
`std::tuple` karÅŸÄ±laÅŸtÄ±rma operatÃ¶rleri (`<`, `>`, `==`), **Lexicographical** (sÃ¶zlÃ¼k sÄ±rasÄ±na gÃ¶re) karÅŸÄ±laÅŸtÄ±rma yapar.
1. Ä°lk elemanlar karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r. KÃ¼Ã§Ã¼kse sonuÃ§ `true` dÃ¶ner.
2. Ä°lk elemanlar eÅŸitse, ikinci elemanlara bakÄ±lÄ±r.
3. Bu sÃ¼reÃ§ tÃ¼m elemanlar tÃ¼kenene veya bir fark bulunana kadar devam eder.

```cpp
auto t1 = std::make_tuple(1, "Ahmet", 1990);
auto t2 = std::make_tuple(1, "Zeynep", 1985);

bool result = t1 < t2; // true dÃ¶ner, Ã§Ã¼nkÃ¼ 1 == 1 ama "Ahmet" < "Zeynep".
```

#### ğŸš© Kritik Nokta: `std::sort` ile KullanÄ±m
Hoca, 10.000 elemanlÄ± bir `std::vector<std::tuple<...>>` Ã¼zerinden Ã¶rnek vererek, `std::sort` algoritmasÄ±nÄ±n tuple'Ä±n doÄŸal karÅŸÄ±laÅŸtÄ±rma mantÄ±ÄŸÄ±nÄ± kullanarak verileri Ã¶nce ID'ye, sonra isme, en son tarihe gÃ¶re otomatik sÄ±raladÄ±ÄŸÄ±nÄ± gÃ¶stermiÅŸtir.

---

### 11. "Poor Man's Spaceship Operator" Ä°diyomu [02:17:06 - 02:20:40]

C++20'deki `<=>` (Spaceship operator) gelmeden Ã¶nce, karmaÅŸÄ±k sÄ±nÄ±flarda karÅŸÄ±laÅŸtÄ±rma operatÃ¶rlerini yazmanÄ±n en ÅŸÄ±k yoludur.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir `Date` (Tarih) sÄ±nÄ±fÄ±nda `operator<` yazarken yÄ±l, ay ve gÃ¼n kontrolÃ¼ yapmak Ã§ok fazla `if-else` bloÄŸu gerektirir. `std::tuple` veya `std::tie` bu karmaÅŸayÄ± tek satÄ±ra indirir.

#### ğŸ” Kod YapÄ±sÄ± (Ä°diyom)
```cpp
struct Date {
    int d, m, y;

    friend bool operator<(const Date& lhs, const Date& rhs) {
        // Hoca: "Fakir adamÄ±n spaceship operatÃ¶rÃ¼"
        return std::tie(lhs.y, lhs.m, lhs.d) < std::tie(rhs.y, rhs.m, rhs.d); // <-- Kritik Ä°diyom
    }
};
```
*   `std::tie`: Verilen deÄŸiÅŸkenlerden referans tutan geÃ§ici bir tuple oluÅŸturur. Kopyalama maliyeti yoktur.

---

### 12. Tuple ArayÃ¼zÃ¼ Meta-FonksiyonlarÄ± [02:20:41 - 02:29:05]

`std::tuple` sadece bir sÄ±nÄ±f deÄŸil, aynÄ± zamanda bir arayÃ¼zdÃ¼r (Tuple Interface). Bu arayÃ¼z 3 temel bileÅŸenden oluÅŸur.

#### ğŸ” Meta-Fonksiyonlar (Compile-Time Tools)
1.  **`std::tuple_size<T>`:** Belirtilen tÃ¼rÃ¼n kaÃ§ elemandan oluÅŸtuÄŸunu derleme zamanÄ±nda verir.
    ```cpp
    using MyType = std::tuple<int, double, char>;
    constexpr size_t sz = std::tuple_size_v<MyType>; // 3
    ```
2.  **`std::tuple_element<Idx, T>`:** Belirtilen indeksteki elemanÄ±n tÃ¼rÃ¼nÃ¼ derleme zamanÄ±nda verir.
    ```cpp
    using SecondType = std::tuple_element_t<1, MyType>; // double
    ```
3.  **`std::get<Idx>(obj)`:** Veriye eriÅŸim saÄŸlayan fonksiyon ÅŸablonu.

#### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
*   `std::pair` ve `std::array` de bu meta-fonksiyonlarÄ± destekler. Yani teknik olarak bu sÄ±nÄ±flar da birer "tuple-like" yapÄ±dÄ±r ve Structured Binding ile kullanÄ±labilirler.

---

### 13. Kendi TÃ¼rÃ¼mÃ¼zÃ¼ Structured Binding'e Uygun Hale Getirmek [02:29:06 - 02:39:45]

Necati Hoca, dersin sonunda ileri dÃ¼zey bir teknik olan "Tuple Interface Implementation" konusuna giriÅŸ yapmÄ±ÅŸtÄ±r.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
SÄ±nÄ±fÄ±mÄ±z bir **Aggregate** deÄŸilse (private Ã¼yeleri varsa, constructor'Ä± varsa), C++17'deki **Structured Binding** (`auto [x, y] = obj`) Ã¶zelliÄŸini doÄŸrudan kullanamayÄ±z. Bunu mÃ¼mkÃ¼n kÄ±lmak iÃ§in sÄ±nÄ±fÄ±mÄ±za tuple arayÃ¼zÃ¼nÃ¼ (size, element, get) giydirmeliyiz.

#### ğŸ” Uygulama: `Date` SÄ±nÄ±fÄ±nÄ± Tuple Yapmak
SÄ±nÄ±fÄ±n dÄ±ÅŸÄ±ndaki bir `get` fonksiyonu ve `std` namespace'i iÃ§indeki meta-fonksiyonlarÄ±n Ã¶zelleÅŸtirilmesi (specialization) gerekir.

```cpp
// 1. AdÄ±m: std::tuple_size Ã¶zelleÅŸtirmesi
template<>
struct std::tuple_size<Date> : std::integral_constant<std::size_t, 3> {};

// 2. AdÄ±m: std::tuple_element Ã¶zelleÅŸtirmesi (TÃ¼m Ã¼yeler int ise)
template<std::size_t N>
struct std::tuple_element<N, Date> {
    using type = int; 
};

// 3. AdÄ±m: get fonksiyonu ÅŸablonu
template<std::size_t N>
auto get(const Date& d) {
    if constexpr (N == 0) return d.getDay();
    else if constexpr (N == 1) return d.getMonth();
    else if constexpr (N == 2) return d.getYear();
}
```

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** Structured Binding hangi mekanizmayÄ± kullanÄ±r?
**Cevap:** EÄŸer tÃ¼r bir dizi (array) deÄŸilse ve bir aggregate (toplu yapÄ±) deÄŸilse, derleyici ADL (Argument Dependent Lookup) yoluyla `get<N>` fonksiyonunu arar ve `std::tuple_size`, `std::tuple_element` meta-fonksiyonlarÄ±na bakar. EÄŸer bunlar doÄŸru implemente edilmiÅŸse, o tÃ¼r iÃ§in structured binding Ã§alÄ±ÅŸÄ±r.

---

