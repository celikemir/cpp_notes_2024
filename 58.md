### C++ Kursu 58. Ders: Modern C++ Chrono KÃ¼tÃ¼phanesi ve Ratio AltyapÄ±sÄ±
**Tarih:** 27 Ocak 2025  
**EÄŸitmen:** Necati Ergin

---

### 1. Modern C++ Chrono KÃ¼tÃ¼phanesine GiriÅŸ [00:00 - 02:28]

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Modern C++ (C++11) Ã¶ncesinde, tarih ve zaman iÅŸlemleri iÃ§in C'den miras kalan `<ctime>` (`time.h`) kÃ¼tÃ¼phanesi kullanÄ±lÄ±yordu. Ancak bu kÃ¼tÃ¼phanenin arayÃ¼zÃ¼ (interface) oldukÃ§a kÄ±sÄ±tlÄ±ydÄ±, tip gÃ¼venliÄŸi (type safety) zayÄ±ftÄ± ve hassas zaman Ã¶lÃ§Ã¼mleri iÃ§in taÅŸÄ±nabilir (portable) bir yapÄ± sunmuyordu. C++11 ile birlikte **Howard Hinnant**'Ä±n bÃ¼yÃ¼k katkÄ±larÄ±yla `std::chrono` kÃ¼tÃ¼phanesi eklendi.

ğŸ” **Arka Plan (Under the Hood):**
Chrono kÃ¼tÃ¼phanesi, "Zero-Cost Abstraction" (sÄ±fÄ±r maliyetli soyutlama) prensibi Ã¼zerine inÅŸa edilmiÅŸtir. Zaman birimleri arasÄ±ndaki dÃ¶nÃ¼ÅŸÃ¼mlerin Ã§oÄŸu Compile-Time'da (derleme zamanÄ±nda) yapÄ±lÄ±r ve Runtime'da (Ã§alÄ±ÅŸma zamanÄ±nda) ek bir overhead (ek yÃ¼k) getirmez.

---

### 2. Standart C Zaman KÃ¼tÃ¼phanesi HatÄ±rlatmalarÄ± [02:28 - 29:00]

Modern kÃ¼tÃ¼phane halen legacy (miras) C kodlarÄ±yla etkileÅŸim halinde olduÄŸu iÃ§in C arayÃ¼zÃ¼nÃ¼ bilmek kritiktir.

âš™ï¸ **Teknik Detay ve Sentaks:**

**A. Temel TÃ¼rler:**
1.  `time_t`: "Calendar Time" (takvim zamanÄ±). Genellikle **Epoch**'tan (Unix sistemlerde 1-1-1970 00:00:00) geÃ§en saniye sayÄ±sÄ±nÄ± tutan bir `long long` eÅŸ ismidir (type alias).
2.  `clock_t`: Ä°ÅŸlemci tik (tick) sayÄ±sÄ±nÄ± temsil eder.
3.  `struct tm`: "Broken-down time" (ayrÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ zaman).

**B. Kritik C FonksiyonlarÄ±:**
Hoca, `std::time` fonksiyonunun `null pointer` kabul etme opsiyonuna dikkat Ã§ekti:

```cpp
#include <ctime>
#include <iostream>

int main() {
    std::time_t sec;
    std::time(&sec); // Alt parametre (out parameter) kullanÄ±mÄ±
    
    // Veya:
    sec = std::time(nullptr); // <-- Hoca buraya dikkat Ã§ekti: Null pointer geÃ§mek legaldir.
}
```

**C. AyrÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ Zaman (Broken-down Time):**
`struct tm` yapÄ±sÄ±ndaki elemanlarÄ±n indekslenmesi mÃ¼lakatlarda sÄ±kÃ§a sorulan bir "tuzak" noktasÄ±dÄ±r.

```cpp
tm* p = std::localtime(&sec);
// p->tm_year + 1900; // <-- Kritik: YÄ±l 1900'den baÅŸlar.
// p->tm_mon + 1;     // <-- Kritik: Aylar 0'dan baÅŸlar (Ocak = 0).
// p->tm_mday;        // AyÄ±n gÃ¼nÃ¼ (1-31).
// p->tm_wday;        // HaftanÄ±n gÃ¼nÃ¼ (0=Pazar, 1=Pazartesi).
```

ğŸš© **Kritik Nokta (Daylight Saving Time):**
`tm_isdst` elemanÄ±:
*   `> 0`: GÃ¼n Ä±ÅŸÄ±ÄŸÄ± tasarrufu aktif.
*   `0`: Aktif deÄŸil.
*   `< 0`: Bilgi yok.

**D. FormatlÄ± YazdÄ±rma (`strftime`):**
Hoca, yerel dile (locale) baÄŸlÄ± Ã§Ä±ktÄ± almayÄ± gÃ¶sterdi:

```cpp
#include <clocale>

char buff[256];
std::strftime(buff, sizeof(buff), "%A %B %Y", p); 
// %A: Tam gÃ¼n ismi, %B: Tam ay ismi, %Y: Tam yÄ±l.

std::setlocale(LC_ALL, "turkish"); // <-- Yerel ayar deÄŸiÅŸtirildi.
// ArtÄ±k Ã§Ä±ktÄ± "Monday" yerine "Pazartesi" olur.
```

---

### 3. Chrono KÃ¼tÃ¼phanesi Makro BakÄ±ÅŸ [29:00 - 36:00]

Chrono Ã¼Ã§ temel sÃ¼tun Ã¼zerine kuruludur. Hoca bu iliÅŸkiyi Pointer AritmetiÄŸine benzetti.

ğŸ–¼ï¸ **GÃ¶rselleÅŸtirme (Zaman Ã‡izgisi):**

```text
Epoch (Orijin/BaÅŸlangÄ±Ã§)
      |
      V
Time Point 1 -------- Duration (SÃ¼re) --------> Time Point 2
      |                                           |
      +-------------------------------------------+
               Ä°ki Time Point farkÄ± = Duration
```

*   **Clock (Saat):** BaÅŸlangÄ±Ã§ noktasÄ±nÄ± (Epoch) ve sÃ¼renin hassasiyetini (period) belirleyen yapÄ±dÄ±r.
*   **Time Point (Zaman NoktasÄ±):** Belirli bir Clock'a gÃ¶re Epoch'tan geÃ§en sÃ¼redir.
*   **Duration (SÃ¼re):** Ä°ki zaman noktasÄ± arasÄ±ndaki farktÄ±r (Ã–rn: 5 saniye).

ğŸ”— **Ã–nceki Derslerle BaÄŸlantÄ±:**
Hoca, `Time Point - Time Point = Duration` iliÅŸkisinin, `Pointer - Pointer = ptrdiff_t` iliÅŸkisine benzediÄŸini belirtti.

---

### 4. Ratio KÃ¼tÃ¼phanesi (`<ratio>`) [36:00 - 58:00]

Chrono'nun kalbinde yer alan, tamamen Compile-Time'da Ã§alÄ±ÅŸan bir kÃ¼tÃ¼phanedir. Rasyonel sayÄ±larÄ± temsil eder.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Zaman birimleri (milisaniye, mikrosaniye, saat) arasÄ±ndaki dÃ¶nÃ¼ÅŸÃ¼mleri hatasÄ±z ve performans kaybÄ± olmadan derleme zamanÄ±nda hesaplamak iÃ§in.

âš™ï¸ **Teknik Detay ve Sentaks:**
`std::ratio<num, den>` template yapÄ±sÄ±dÄ±r. `intmax_t` (genellikle `long long`) tÃ¼rÃ¼nde iki sabit alÄ±r.

```cpp
#include <ratio>

using namespace std;

// 8/12 kesri
using my_ratio = ratio<8, 12>; 

// <-- Hoca'nÄ±n vurgusu: "Ä°htisar etmek" (Simplification/SadeleÅŸtirme)
// Derleyici bunu otomatik olarak 2/3 ÅŸeklinde saklar.
cout << my_ratio::num << "/" << my_ratio::den; // Ã‡Ä±ktÄ±: 2/3
```

**Aritmetik Metafunction'lar (Derleme ZamanÄ± AritmetiÄŸi):**
Ä°ÅŸlemlerin sonucu yine bir `ratio` tÃ¼rÃ¼dÃ¼r.

```cpp
using r1 = ratio<1, 2>;
using r2 = ratio<1, 3>;

using sum = ratio_add<r1, r2>::type; // 5/6
using result = ratio_less_v<r1, r2>; // r1 < r2 mi? (false)
```

**HazÄ±r Prefix'ler (TÃ¼reÅŸ Ä°simleri):**
C++ standart kÃ¼tÃ¼phanesi SI birimlerini hazÄ±r olarak sunar:
*   `std::milli`: `ratio<1, 1000>`
*   `std::kilo`: `ratio<1000, 1>`
*   `std::micro`: `ratio<1, 1000000>`

---

### [00:00 - 58:00] ArasÄ± Kritik Ã–zet

**Bu ilk 58 dakikada Hoca ÅŸu 3 kritik konuya dikkat Ã§ekti:**
1.  **Miras KÃ¼tÃ¼phanenin Riskleri:** `localtime` gibi fonksiyonlarÄ±n statik Ã¶mÃ¼rlÃ¼ nesne adresi dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼, bu yÃ¼zden thread-safe olmadÄ±ÄŸÄ±nÄ± ve verilerin Ã¼zerine yazÄ±labileceÄŸini hatÄ±rlattÄ±.
2.  **Ratio'nun GÃ¼cÃ¼:** `std::ratio`'nun sadece bir tÃ¼r olduÄŸunu, Runtime'da bir nesne oluÅŸturmadÄ±ÄŸÄ±nÄ±, tÃ¼m sadeleÅŸtirme ve aritmetik iÅŸlemlerin derleyici tarafÄ±ndan yapÄ±ldÄ±ÄŸÄ±nÄ± vurguladÄ±.
3.  **Hassasiyet (Precision):** `ratio`'nun paydasÄ±nÄ±n (`den`) her zaman pozitif tutulduÄŸunu, negatiflik durumunda iÅŸaretin paya (`num`) taÅŸÄ±ndÄ±ÄŸÄ±nÄ± belirtti.

### 5. `std::chrono::duration` Åablonu [58:00 - 01:15:00]

Hoca, Chrono kÃ¼tÃ¼phanesinin en temel taÅŸlarÄ±ndan biri olan `duration` (sÃ¼re) tÃ¼rÃ¼nÃ¼ "Zero-cost Abstraction" kavramÄ±nÄ±n ders kitabÄ± Ã¶rneÄŸi olarak tanÄ±mladÄ±.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
SÃ¼releri sadece bir tam sayÄ± (int, long) olarak tutmak, o sayÄ±nÄ±n neyi temsil ettiÄŸinin (saniye mi, milisaniye mi?) kaybolmasÄ±na ve hatalÄ± hesaplamalara yol aÃ§ar. `duration` tÃ¼rÃ¼, bu tam sayÄ±yÄ± (count) ve o sayÄ±nÄ±n birimini (ratio) bir araya getirerek tip gÃ¼venliÄŸi saÄŸlar.

âš™ï¸ **Teknik Detay ve Sentaks:**
`duration` iki template parametresi alÄ±r:
1.  **Rep:** SayÄ±sal deÄŸerin hangi tÃ¼rde tutulacaÄŸÄ± (int, double, long long).
2.  **Period:** Bir saniyenin kaÃ§ta kaÃ§Ä± olduÄŸunu belirten `std::ratio`.

```cpp
template <class Rep, class Period = std::ratio<1>>
class duration;

// Ã–rnek: YarÄ±m saniyelik birimlerden oluÅŸan tÃ¼r
using half_sec = std::chrono::duration<int, std::ratio<1, 2>>; 
// 57 half_sec = 28.5 saniye demektir.
```

ğŸ” **Arka Plan (Memory Layout):**
Hoca bizzat `sizeof` operatÃ¶rÃ¼ ile kanÄ±tladÄ±: `duration` sÄ±nÄ±fÄ± aslÄ±nda sadece `Rep` tÃ¼rÃ¼nden tek bir veri elemanÄ± sarmalar.
```cpp
using ms = std::chrono::duration<int, std::milli>;
std::cout << sizeof(ms);   // 4 (sizeof(int) kaÃ§ ise o)
std::cout << sizeof(double_duration); // 8 (double sarmalÄ±yorsa)
```
**Kritik Kural:** EÄŸer bir `duration` nesnesini default initialize ederseniz, iÃ§indeki deÄŸer "indetermined value" (belirsiz deÄŸer/Ã§Ã¶p deÄŸer) olur. Ã‡Ã¼nkÃ¼ bu bir POD (Plain Old Data) yapÄ±sÄ±ndadÄ±r.

---

### 6. HazÄ±r Duration TÃ¼rleri ve Literal OperatÃ¶rler [01:15:00 - 01:30:00]

âš™ï¸ **Teknik Detay ve Sentaks:**
Standart kÃ¼tÃ¼phane bize en Ã§ok kullanÄ±lan sÃ¼releri hazÄ±r sunar:
*   `std::chrono::nanoseconds`
*   `std::chrono::microseconds`
*   `std::chrono::milliseconds`
*   `std::chrono::seconds`
*   `std::chrono::minutes`
*   `std::chrono::hours`

**Literal Operators (C++14):**
Hoca, `using namespace std::chrono_literals;` kullanarak sÃ¼releri nasÄ±l daha okunaklÄ± yazabileceÄŸimizi gÃ¶sterdi:

```cpp
using namespace std::chrono_literals;
auto s = 12s;    // std::chrono::seconds
auto ms = 345ms; // std::chrono::milliseconds
auto h = 2h;     // std::chrono::hours

// <-- HATA BURADA: 
// std::chrono::seconds sec = 456; // Sentaks hatasÄ±! 
// Hoca'nÄ±n uyarÄ±sÄ±: Ã–rtÃ¼lÃ¼ dÃ¶nÃ¼ÅŸÃ¼m (implicit conversion) yasaktÄ±r.
std::chrono::seconds sec{456}; // DoÄŸru kullanÄ±m
```

---

### 7. Duration AritmetiÄŸi ve Ortak TÃ¼r Bulma [01:20:00 - 01:35:00]

Hoca, farklÄ± birimlerin toplanmasÄ± durumunda derleyicinin "en ince" (finest) birimi otomatik olarak seÃ§tiÄŸini vurguladÄ±.

âš™ï¸ **Teknik Detay ve Sentaks:**
```cpp
auto total = 2h + 23min + 345s; 
// Derleyici bunlarÄ± toplar ve sonucu 'seconds' tÃ¼rÃ¼nde verir. 
// Ã‡Ã¼nkÃ¼ bu ifadeler iÃ§indeki en hassas birim saniyedir.
```

ğŸ“Š **Standart KarÅŸÄ±laÅŸtÄ±rmasÄ± (C++20 I/O):**
Hoca, C++20 Ã¶ncesinde duration'larÄ± doÄŸrudan `cout` ile yazdÄ±ramadÄ±ÄŸÄ±mÄ±zÄ±, `count()` fonksiyonuna ihtiyaÃ§ duyduÄŸumuzu belirtti. C++20 ile inserter operatÃ¶rÃ¼ eklendi:

```cpp
auto ms = 34ms;
// C++17 ve Ã¶ncesi:
std::cout << ms.count() << "ms"; 
// C++20:
std::cout << ms; // Ã‡Ä±ktÄ±: 34ms
```

---

### 8. TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mleri: `duration_cast` [01:35:00 - 01:50:00]

Bu bÃ¶lÃ¼m mÃ¼lakatlarÄ±n vazgeÃ§ilmezidir. Hoca "Coarse" (Kaba) ve "Fine" (Ä°nce) tÃ¼rler arasÄ±ndaki iliÅŸkiyi aÃ§Ä±kladÄ±.

ğŸ§  **DÃ¶nÃ¼ÅŸÃ¼m KurallarÄ±:**
1.  **Kaba tÃ¼rden Ä°nce tÃ¼re (Coarse -> Fine):** Ã–rtÃ¼lÃ¼ (implicit) dÃ¶nÃ¼ÅŸÃ¼m serbesttir. Veri kaybÄ± olmaz. (Ã–rn: Saniyeden milisaniyeye).
2.  **Ä°nce tÃ¼rden Kaba tÃ¼re (Fine -> Coarse):** Ã–rtÃ¼lÃ¼ dÃ¶nÃ¼ÅŸÃ¼m YASAKTIR. Veri kaybÄ± (hassasiyet kaybÄ±) olacaÄŸÄ± iÃ§in `std::chrono::duration_cast` zorunludur.

```cpp
std::chrono::milliseconds ms{5000};
std::chrono::seconds s = ms; // OK: Kaba'dan Ä°nce'ye geÃ§iÅŸ yok, tam tersi. 5000ms = 5s.

std::chrono::milliseconds ms2{5432};
// std::chrono::seconds s2 = ms2; // <-- HATA: Hassasiyet kaybÄ± olur (432ms Ã§Ã¶pe gider).
auto s2 = std::chrono::duration_cast<std::chrono::seconds>(ms2); // 5s (FazlalÄ±k atÄ±lÄ±r)
```

**C++17 Yuvarlama FonksiyonlarÄ±:**
*   `floor`: AÅŸaÄŸÄ± yuvarlar.
*   `ceil`: YukarÄ± yuvarlar.
*   `round`: En yakÄ±n birime yuvarlar.

---

### [00:58:00 - 01:50:00] ArasÄ± Kritik Ã–zet

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **Count vs Duration:** `ms.count()` Ã§aÄŸrÄ±sÄ±nÄ±n bir tam sayÄ± (int/long) dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼, ancak `ms` nesnesinin kendisinin bir `std::chrono::duration` olduÄŸunu ve bu ikisinin karÄ±ÅŸtÄ±rÄ±lmamasÄ± gerektiÄŸini belirtti.
2.  **Implicit Conversion Engeli:** Derleyicinin sÃ¼reler arasÄ±nda sadece veri kaybÄ± olmayacaksa otomatik dÃ¶nÃ¼ÅŸÃ¼m yaptÄ±ÄŸÄ±nÄ±, aksi halde "kodun niyetini" anlamak iÃ§in explicit cast istediÄŸini vurguladÄ±.
3.  **Floating Point AvantajÄ±:** EÄŸer `representation` tÃ¼rÃ¼ `double` olarak seÃ§ilirse (`duration<double>`), her zaman Ã¶rtÃ¼lÃ¼ dÃ¶nÃ¼ÅŸÃ¼m yapÄ±labileceÄŸini gÃ¶sterdi.

### 9. Duration AritmetiÄŸi: ParÃ§alara AyÄ±rma ve Mod OperatÃ¶rÃ¼ [01:50:00 - 01:53:00]

Hoca, bir sÃ¼re deÄŸerini (Ã¶rneÄŸin milisaniye) daha anlamlÄ± parÃ§alara (saat, dakika, saniye) ayÄ±rmanÄ±n en profesyonel yolunu gÃ¶sterdi.

ğŸ§  **Neden Ä°htiyaÃ§ Duyuldu? (Rationale):**
Toplam saniye veya milisaniye cinsinden olan sÃ¼reyi kullanÄ±cÄ±ya "X saat Y dakika" ÅŸeklinde gÃ¶stermek iÃ§in manuel matematiksel hesaplamalar (60'a bÃ¶lmeler vb.) tip gÃ¼venliÄŸini bozar. Chrono'nun modÃ¼lo (`%`) operatÃ¶rÃ¼ desteÄŸi bu iÅŸlemi gÃ¼venli kÄ±lar.

âš™ï¸ **Teknik Detay ve Sentaks:**
```cpp
using namespace std::chrono;
milliseconds ms{2345678}; // Toplam sÃ¼re

// 1. Saat kÄ±smÄ±nÄ± al
hours hh = duration_cast<hours>(ms); 

// 2. Kalan milisaniyeyi bul ve dakikaya Ã§evir
minutes mm = duration_cast<minutes>(ms % hours{1}); 

// 3. Kalan dakikadan saniyeyi al
seconds ss = duration_cast<seconds>(ms % minutes{1});

// 4. En son kalan milisaniye
milliseconds remainder_ms = ms % seconds{1};

// Ã‡Ä±ktÄ±: 0h 39min 5s 678ms
```
ğŸš© **Kritik Nokta:** `ms % hours{1}` ifadesi, toplam sÃ¼renin 1 saate bÃ¶lÃ¼mÃ¼nden kalan *duration* deÄŸerini dÃ¶ndÃ¼rÃ¼r.

---

### 10. Saat TÃ¼rleri (Clocks) [01:58:00 - 02:18:50]

Chrono kÃ¼tÃ¼phanesindeki saatler, `now()` statik fonksiyonu aracÄ±lÄ±ÄŸÄ±yla bize birer `time_point` Ã¼retirler.

ğŸ§  **Neden 3 FarklÄ± Saat Var?**
Her saatin kullanÄ±m amacÄ± farklÄ±dÄ±r. BazÄ±larÄ± ayarlanabilir (duvar saati), bazÄ±larÄ± ise sadece ileri doÄŸru akar (kronometre).

âš™ï¸ **Teknik Detay ve KarÅŸÄ±laÅŸtÄ±rma:**

| Saat TÃ¼rÃ¼ | Monotonik (Steady) mi? | KullanÄ±m AmacÄ± |
| :--- | :--- | :--- |
| `std::chrono::system_clock` | **HayÄ±r** | GerÃ§ek dÃ¼nya zamanÄ± (Takvim). Ayarlanabilir. |
| `std::chrono::steady_clock` | **Evet** | SÃ¼re Ã¶lÃ§Ã¼mÃ¼ (Kronometre). Ayarlanamaz, geriye gitmez. |
| `std::chrono::high_resolution_clock` | DeÄŸiÅŸken | Sistemdeki en hassas saattir. Genelde diÄŸer ikisinden birinin eÅŸ ismidir. |

ğŸ” **Arka Plan (Clock Nested Types):**
Bir saat tÃ¼rÃ¼ (Ã¶rn: `system_clock`) ÅŸu iÃ§ tÃ¼rlere (nested types) sahiptir:
*   `rep`: Temsil tÃ¼rÃ¼ (genelde `long long`).
*   `period`: Saatin tÄ±k (tick) hassasiyeti (Ã¶rn: `std::ratio<1, 1000000000>`).
*   `duration`: `duration<rep, period>`.
*   `time_point`: `time_point<system_clock, duration>`.

ğŸš© **Kritik Nokta (MÃ¼lakat Sorusu):** Hangi saat sÃ¼re Ã¶lÃ§Ã¼mÃ¼ iÃ§in daha uygundur?
**Cevap:** `steady_clock`. Ã‡Ã¼nkÃ¼ `system_clock` kullanÄ±cÄ± tarafÄ±ndan veya sistem saati senkronizasyonu sÄ±rasÄ±nda geri alÄ±nabilir; bu da Ã¶lÃ§Ã¼len sÃ¼renin negatif Ã§Ä±kmasÄ±na neden olur.

---

### 11. Time Point (Zaman NoktasÄ±) KavramÄ± [02:07:00 - 02:15:30]

`time_point`, bir saatin **Epoch** (baÅŸlangÄ±Ã§ noktasÄ±) deÄŸerinden ne kadar sÃ¼re geÃ§tiÄŸini temsil eden bir tÃ¼rdÃ¼r.

âš™ï¸ **Teknik Detay ve Sentaks:**
```cpp
// C++20 Ã¶ncesi uzun yazÄ±m:
std::chrono::time_point<std::chrono::system_clock> tp = std::chrono::system_clock::now();

// Modern yazÄ±m:
auto tp = std::chrono::system_clock::now(); // <-- Necati Hoca'nÄ±n tercihi
```

ğŸ”— **KÃ¼mÃ¼latif BaÄŸlantÄ±lar:**
Hoca, `time_point` aritmetiÄŸinin pointer aritmetiÄŸiyle aynÄ± kÄ±sÄ±tlara sahip olduÄŸunu hatÄ±rlattÄ±:
*   `time_point + duration = time_point` (Ä°leri bir tarih).
*   `time_point - duration = time_point` (GeÃ§miÅŸ bir tarih).
*   `time_point - time_point = duration` (Ä°ki tarih arasÄ±ndaki fark).
*   `time_point + time_point = HATA!` (Ä°ki adresi toplamakla aynÄ± saÃ§malÄ±ktÄ±r).

---

### 12. Legacy C EtkileÅŸimi: `to_time_t` ve `from_time_t` [02:15:30 - 02:27:00]

Sadece `std::chrono::system_clock` bu dÃ¶nÃ¼ÅŸÃ¼m fonksiyonlarÄ±na sahiptir.

âš™ï¸ **Teknik Detay ve Sentaks:**
```cpp
auto tp = system_clock::now();

// 1. time_point -> time_t (Legacy C tÃ¼rÃ¼)
time_t t = system_clock::to_time_t(tp);

// 2. time_t -> Ekrana YazdÄ±rma
std::cout << std::ctime(&t); // Monday Jan 27 22:15:56 2025
```

ğŸš© **Kritik Nokta (Visual Studio Warning):**
Hoca, `std::ctime` kullanÄ±rken oluÅŸan "unsafe" uyarÄ±sÄ± iÃ§in ÅŸu Ã§Ã¶zÃ¼mÃ¼ hatÄ±rlattÄ±:
`#define _CRT_SECURE_NO_WARNINGS` // <-- Visual Studio'nun "salak" uyarÄ±larÄ±nÄ± kapatmak iÃ§in.

---

### 13. Pratik Uygulamalar: Seed Ãœretimi ve Performans [02:27:00 - 02:40:00]

Hoca derste Ã§ok sÄ±k kullanÄ±lan iki Ã¶nemli idiomu (kalÄ±bÄ±) gÃ¶sterdi.

**A. Rastgele SayÄ± Ãœreticisi Ä°Ã§in Seed (Tohum) DeÄŸeri:**
```cpp
auto seed = static_cast<unsigned int>(
    steady_clock::now().time_since_epoch().count() // <-- "En uzun idiomlardan biri"
);
std::mt19937 eng{seed};
```
`time_since_epoch()`: O anki zaman noktasÄ±nÄ±n baÅŸlangÄ±Ã§tan (epoch) ne kadar uzakta olduÄŸunu `duration` olarak verir.

**B. Algoritma Performans Ã–lÃ§Ã¼mÃ¼:**
```cpp
auto start = steady_clock::now();
std::sort(vec.begin(), vec.end()); // Ã–lÃ§Ã¼len iÅŸlem
auto end = steady_clock::now();

auto diff = duration_cast<milliseconds>(end - start);
std::cout << "SÄ±ralama sÃ¼resi: " << diff.count() << "ms\n";
```

---

### 14. KapanÄ±ÅŸ ve Value Kategorileri Ãœzerine [02:40:00 - 02:42:47]

Hoca, gelecek derste **Random** kÃ¼tÃ¼phanesini inceleyeceÄŸimizi, ardÄ±ndan **Concurrency** (eÅŸzamanlÄ±lÄ±k) konularÄ±na geÃ§eceÄŸimizi belirtti. Bir Ã¶ÄŸrencinin "X-value'larÄ± gÃ¶recek miyiz?" sorusu Ã¼zerine:

ğŸš© **MÃ¼lakat Notu (X-values):**
*   `x-value` (expiring value), bir nesnenin Ã¶mrÃ¼nÃ¼n bitmek Ã¼zere olduÄŸunu ve kaynaklarÄ±nÄ±n taÅŸÄ±nabileceÄŸini (move) belirten bir kategori deÄŸeridir.
*   `std::move(obj)` ifadesinin sonucu bir `x-value`'dur.
*   Pratikte `pr-value` ile birleÅŸerek `R-value` kategorisini oluÅŸtururlar. Hoca buna ileride 20-30 dakika ayÄ±racaÄŸÄ±nÄ± belirtti.

---

### [01:50:00 - 02:42:47] ArasÄ± Kritik Ã–zet

**Bu son bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik konuya dikkat Ã§ekti:**
1.  **DoÄŸru Saat SeÃ§imi:** Performans Ã¶lÃ§Ã¼mlerinde `system_clock` deÄŸil, her zaman `steady_clock` kullanÄ±lmalÄ±dÄ±r.
2.  **DÃ¶nÃ¼ÅŸÃ¼m Zinciri:** `time_point`'ten `count()` deÄŸerine (ham sayÄ±ya) ulaÅŸmak iÃ§in Ã¶nce `time_since_epoch()` ile `duration` elde edilmesi gerektiÄŸini vurguladÄ±.
3.  **C++20 KolaylÄ±ÄŸÄ±:** Zaman birimlerini yazdÄ±rmak iÃ§in eskiden `to_time_t` ve `ctime` ile takla atarken, C++20 ile `cout << tp;` demenin yeterli hale geldiÄŸini gÃ¶sterdi.
