C++ Programlama Dili - 9. Ders Teknik NotlarÄ± (18 AralÄ±k 2024)

--- START OF FILE ---

## 1. GENELLEÅTÄ°RÄ°LMÄ°Å ARAMA ALGORÄ°TMALARI (SEARCH ALGORITHMS)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C dilindeki `strstr` fonksiyonu, bir yazÄ± iÃ§inde baÅŸka bir yazÄ±yÄ± arar. Ancak modern C++'ta sadece `char*` tÃ¼rÃ¼ndeki dizilerde deÄŸil, herhangi bir veri tÃ¼rÃ¼nÃ¼ tutan herhangi bir *range* (aralÄ±k) iÃ§inde baÅŸka bir *sub-range* (alt aralÄ±k) arama ihtiyacÄ± doÄŸmuÅŸtur. `std::search` ve `std::find_end` bu ihtiyacÄ± karÅŸÄ±lamak iÃ§in tasarlanmÄ±ÅŸ jenerik algoritmalardÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, bu algoritmalarÄ± C'deki `strstr` fonksiyonunun genelleÅŸtirilmiÅŸ hali olarak tanÄ±mladÄ±:

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>

int main() {
    std::vector<std::string> esvek = {"kaya", "mert", "esra", "nuri", "edis", "sefa", "ayca", "esra", "nuri", "edis"};
    std::initializer_list<std::string> list = {"esra", "nuri", "edis"};

    // std::search: Ä°lk eÅŸleÅŸen alt aralÄ±ÄŸÄ±n baÅŸlangÄ±Ã§ iteratÃ¶rÃ¼nÃ¼ dÃ¶ner.
    auto iter = std::search(esvek.begin(), esvek.end(), list.begin(), list.end());

    if (iter != esvek.end()) {
        auto idx = std::distance(esvek.begin(), iter); // <-- Hoca: Ä°ndeksi bulmak iÃ§in iteratÃ¶r farkÄ± alÄ±nÄ±r.
        std::cout << "Bulundu, indeks: " << idx << " Deger: " << *iter << "\n";
    }

    // std::find_end: Son eÅŸleÅŸen alt aralÄ±ÄŸÄ±n baÅŸlangÄ±Ã§ iteratÃ¶rÃ¼nÃ¼ dÃ¶ner.
    auto iter_last = std::find_end(esvek.begin(), esvek.end(), list.begin(), list.end());
    // <-- Kritik Fark: search 'baÅŸtan', find_end 'sondan' arar.
}
```

### ğŸ” Arka Plan (Under the Hood)
- **Iterator Category:** Bu algoritmalar asgari olarak `Forward Iterator` gerektirir.
- **Return Value:** EÄŸer aranan sekans bulunamazsa, kaynak aralÄ±ÄŸÄ±n sonunu (`end` iterator) dÃ¶nerler.
- **Complexity:** Kabaca `O(N*M)` (N: kaynak boyutu, M: aranan boyutu).

---

## 2. ADET BAZLI ARAMA: `std::search_n`

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bazen bir range iÃ§inde belirli bir deÄŸerden ardÄ±ÅŸÄ±k (contiguous) olarak `n` tane olup olmadÄ±ÄŸÄ±nÄ± kontrol etmemiz gerekir. Ã–rneÄŸin; "3 tane arka arkaya 8 var mÄ±?" sorusunun cevabÄ±dÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, `std::abs` kullanarak mutlak deÄŸer eÅŸitliÄŸine dayalÄ± bir *Binary Predicate* Ã¶rneÄŸi verdi:

```cpp
#include <algorithm>
#include <cmath>

auto f_equal = [](int a, int b) {
    return std::abs(a) == std::abs(b); // <-- Binary Predicate (Ä°ki parametreli sÄ±nayÄ±cÄ±)
};

std::vector<int> ivek = {3, 6, 2, 2, 2, 5, -5, 5, -5, 1, 1, 7, 7, 7};
// 5 deÄŸerinden (mutlak deÄŸerce) ardÄ±ÅŸÄ±k 4 tane arayalÄ±m:
auto iter = std::search_n(ivek.begin(), ivek.end(), 4, 5, f_equal);

if (iter != ivek.end()) {
    // Bulundu...
}
```

---

## 3. SIRALI ARALIK ALGORÄ°TMALARI (SORTED RANGE ALGORITHMS)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
EÄŸer bir aralÄ±k zaten sÄ±ralÄ±ysa (sorted), arama iÅŸlemleri Ã§ok daha hÄ±zlÄ± (`O(log N)`) yapÄ±labilir. AyrÄ±ca kÃ¼meler teorisindeki "kapsama" (inclusion) iliÅŸkisi bu gruptaki algoritmalarla test edilir.

### âš™ï¸ Teknik Detay ve Sentaks: `std::includes`
Hoca, `std::includes` fonksiyonunun elemanlarÄ±n ardÄ±ÅŸÄ±k olmasÄ± gerekmediÄŸini, sadece sÄ±rasÄ±nÄ±n korunmuÅŸ olmasÄ±nÄ±n yettiÄŸini vurguladÄ±:

```cpp
// Kaynak: 2, 7, 9, 12, 23, 45, 87 (SÄ±ralÄ±)
// Aranan: 7, 12, 23
// std::includes sonucu: TRUE (Ã‡Ã¼nkÃ¼ bu Ã¶ÄŸeler kaynakta sÄ±rasÄ±yla mevcut)
```

**Kritik Kural:** EÄŸer veriyi `std::greater` ile sÄ±raladÄ±ysanÄ±z, `binary_search` veya `includes` yaparken de aynÄ± komparatÃ¶rÃ¼ (`comparator`) parametre olarak vermelisiniz. Aksi halde sonuÃ§ hatalÄ±/anlamsÄ±z olur.

---

## 4. `std::bitset` SINIFI (GiriÅŸ ve Mimari)

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bellekte her bir bitin `true/false` deÄŸerini temsil ettiÄŸi, derleme zamanÄ±nda boyutu belirlenmiÅŸ, yÃ¼ksek performanslÄ± ve bit manipÃ¼lasyonu (bitwise operations) yapabilen bir yapÄ±ya ihtiyaÃ§ vardÄ±r. `std::vector<bool>` dinamik iken, `std::bitset` statiktir.

### âš™ï¸ Mimari Ã–zellikler
- **Non-type Template Parameter:** Boyut, bir tÃ¼r deÄŸil, bir tam sayÄ± sabitidir.
  `std::bitset<16> bs;` // <-- 16 bir tam sayÄ± sabitidir (compile-time).
- **Sizeof:** Bellek kullanÄ±mÄ± tipik olarak iÅŸlemci kelime uzunluÄŸunun (word size) katlarÄ± ÅŸeklindedir.
  - `std::bitset<8>` -> Genellikle 4 veya 8 byte (derleyiciye baÄŸlÄ±).
  - `std::bitset<34>` -> 32 biti aÅŸtÄ±ÄŸÄ± iÃ§in bir kelime boyutu daha eklenir (Ã¶rn: 8 byte).

### ğŸ›  KonstruktÃ¶rler ve Hata YÃ¶netimi
Hoca `std::invalid_argument` istisnasÄ±nÄ± (exception) vurguladÄ±:

```cpp
#include <bitset>
#include <string>

try {
    std::bitset<16> bs("01010301"); // <-- HATA: '3' karakteri bitset iÃ§in geÃ§ersizdir.
} catch (const std::invalid_argument& e) {
    std::cerr << e.what(); // "invalid bitset char"
}

// Substring ile baÅŸlatma:
std::string str = "xyxyxyyyyxxxx";
std::bitset<8> bs_custom(str, 0, 8, 'x', 'y'); // x=0, y=1 kabul eder.
```

---

## 5. `std::bitset` ÃœYE FONKSÄ°YONLARI VE PROXY CLASS MANTIÄI

### ğŸš© Kritik Nokta: `operator[]` ve Proxy SÄ±nÄ±fÄ±
`std::bitset` iÃ§indeki bitlerin doÄŸrudan bir adresi yoktur (C++'ta en kÃ¼Ã§Ã¼k adreslenebilir birim byte'dÄ±r). Bu nedenle `operator[]` bize doÄŸrudan bir `bool&` dÃ¶nemez.

**Under the Hood:**
`operator[]` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda derleyici arka planda `std::bitset::reference` isimli bir **Proxy (Vekil)** sÄ±nÄ±f nesnesi dÃ¶ndÃ¼rÃ¼r.

```cpp
std::bitset<32> bs;
auto val = bs[5]; // val'Ä±n tÃ¼rÃ¼ bool deÄŸil, std::bitset<32>::reference'dÄ±r!

// Arka planda olan:
// bs[5] = 1; -> reference::operator=(bool) Ã§aÄŸrÄ±lÄ±r.
// bool b = bs[5]; -> reference::operator bool() (conversion) Ã§aÄŸrÄ±lÄ±r.
```

### ğŸ“Š Ãœye Fonksiyonlar Tablosu

| Fonksiyon | AÃ§Ä±klama |
| :--- | :--- |
| `set()` | TÃ¼m bitleri 1 yapar. (ArgÃ¼man alÄ±rsa sadece o indeksi 1 yapar) |
| `reset()` | TÃ¼m bitleri 0 yapar. (ArgÃ¼man alÄ±rsa sadece o indeksi 0 yapar) |
| `flip()` | Bitleri ters Ã§evirir (Toggle). |
| `all()` | TÃ¼m bitler 1 mi? |
| `any()` | En az bir bit 1 mi? |
| `none()` | HiÃ§bir bit 1 deÄŸil mi? |
| `count()` | Set edilmiÅŸ (1 olan) bit sayÄ±sÄ± (Population count). |
| `test(idx)` | Ä°lgili bitin deÄŸerini dÃ¶ner (SÄ±nÄ±rlar dÄ±ÅŸÄ±ndaysa exception fÄ±rlatÄ±r). |

**Fluent API Ã–rneÄŸi:**
Hoca bu fonksiyonlarÄ±n referans dÃ¶ndÃ¼rerek zincirleme (chaining) yapÄ±labildiÄŸini gÃ¶sterdi:
`bs.set(12).reset(23).flip(24);`

Bu bÃ¶lÃ¼mde Necati Hoca, `std::bitset`'in ileri seviye kullanÄ±m senaryolarÄ±nÄ±, STL konteynerlarÄ± ile olan etkileÅŸimini ve mÃ¼lakatlarda sÄ±kÃ§a sorulan "operatÃ¶r Ã¶nceliÄŸi" tuzaklarÄ±nÄ± detaylandÄ±rdÄ±.

---

## 6. BITSET VE ENUMERATION Ä°LÄ°ÅKÄ°SÄ°

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bitset iÃ§indeki bitlerin ne anlama geldiÄŸini (0. bit, 5. bit vb.) sadece sayÄ±larla takip etmek kodun okunabilirliÄŸini azaltÄ±r. "Magic numbers" yerine anlamlÄ± isimler kullanmak iÃ§in `enum` yapÄ±larÄ± ile bitset indekslerini eÅŸleÅŸtirmek bir C++ idiomudur.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, renklerin bitlerle temsil edildiÄŸi bir senaryoyu Ã¶rneklendirdi:

```cpp
enum Color { White, Gray, Yellow, Blue, Green, Red, Brown, Black, NumberOfColors }; // <-- Ä°diomatik yapÄ±

// NumberOfColors, enum iÃ§indeki eleman sayÄ±sÄ±nÄ± (8) otomatik olarak tutar.
std::bitset<NumberOfColors> my_set; 

my_set[Red] = 1;    // 5. biti set eder. Okunabilirlik Ã§ok yÃ¼ksek!
my_set.reset(Black); // 7. biti sÄ±fÄ±rlar.
```

---

## 7. KONTEYNERLARDA BITSET VE SIRALAMA SORUNSALI

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta: Bitset Neden DoÄŸrudan SÄ±ralanamaz?
**Soru:** Bir `std::vector<std::bitset<8>>` nesnesini `std::sort` ile sÄ±ralayabilir miyiz?
**Cevap:** HayÄ±r, **Syntax Error** (SÃ¶zdizimi hatasÄ±) oluÅŸur.

### ğŸ” Arka Plan (Under the Hood)
- `std::sort` algoritmasÄ±, Ã¶ÄŸeleri karÅŸÄ±laÅŸtÄ±rmak iÃ§in varsayÄ±lan olarak `operator<` (kÃ¼Ã§Ã¼ktÃ¼r operatÃ¶rÃ¼) kullanÄ±r.
- `std::bitset` sÄ±nÄ±fÄ±; `operator==` ve `operator!=` operatÃ¶rlerini aÅŸÄ±rÄ± yÃ¼klemiÅŸ (overload) olsa da, **`operator<` operatÃ¶rÃ¼ne sahip deÄŸildir.**
- Ã‡Ã¼nkÃ¼ "bir bit kÃ¼mesinin diÄŸerinden kÃ¼Ã§Ã¼k olmasÄ±" matematiksel olarak tek bir anlama gelmez (SayÄ±sal deÄŸer mi? Set edilmiÅŸ bit sayÄ±sÄ± mÄ±?).

### ğŸ›  Ã‡Ã¶zÃ¼m: Custom Comparator (Ã–zel KarÅŸÄ±laÅŸtÄ±rÄ±cÄ±)
Hoca, bitset'leri sayÄ±sal deÄŸerlerine gÃ¶re sÄ±ralamak iÃ§in `to_ulong()` fonksiyonunu kullanan bir lambda ifadesi yazdÄ±:

```cpp
#include <vector>
#include <algorithm>

using FileFlags = std::bitset<8>;
std::vector<FileFlags> vec;

// Hoca: Emplace_back ile doÄŸrudan argÃ¼man gÃ¶ndererek de bitset eklenebilir.
vec.emplace_back("01010101");
vec.emplace_back(62);

auto comp = [](const FileFlags& lhs, const FileFlags& rhs) {
    return lhs.to_ulong() < rhs.to_ulong(); // <-- Ã‡Ã–ZÃœM: SayÄ±sal deÄŸere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼p karÅŸÄ±laÅŸtÄ±rÄ±yoruz.
};

std::sort(vec.begin(), vec.end(), comp); // ArtÄ±k legal!
```

---

## 8. LÄ°TERALLER VE DIGIT SEPARATORS (SAYI AYRIÃ‡LARI)

### âš™ï¸ Teknik Detay ve Sentaks
C++14 ile gelen tek tÄ±rnak (`'`) ayracÄ±, bitset'e gÃ¶nderilen tam sayÄ± sabitlerini (literals) gruplandÄ±rmak iÃ§in kullanÄ±labilir. Hoca bunun sadece "insan algÄ±sÄ±" iÃ§in olduÄŸunu belirtti.

```cpp
// Legal KullanÄ±mlar:
auto a = 0b1010'1100'0011'1111; // Binlik (binary) ayraÃ§
auto b = 1'000'000;             // OndalÄ±k ayraÃ§

// HATA (Exception):
// std::bitset<8> bs("0101'0101"); // <-- HATA: String iÃ§indeki tÄ±rnak '0' veya '1' deÄŸildir.
```

---

## 9. BITSET VE OPERATÃ–R Ã–NCELÄ°ÄÄ° (PRECEDENCE PITFALLS)

### ğŸš© Kritik Nokta: "En Komik C++ KodlarÄ±ndan Biri"
Hoca, `std::cout` ile bitset kaydÄ±rma operatÃ¶rleri kullanÄ±lÄ±rken yapÄ±lan Ã§ok kritik bir hataya dikkat Ã§ekti.

```cpp
std::bitset<16> bs(16); // 0000000000010000

// Hoca: "Bu ne yazdÄ±rÄ±r?"
std::cout << bs << 3; 
```

**Analiz:**
1. `std::cout << bs` kÄ±smÄ± Ã¶nce Ã§alÄ±ÅŸÄ±r ve ekrana bitset'i yazdÄ±rÄ±r.
2. `operator<<` fonksiyonu geriye tekrar `std::cout` (ostream&) dÃ¶ndÃ¼rÃ¼r.
3. Kalan ifade ÅŸuna dÃ¶nÃ¼ÅŸÃ¼r: `std::cout << 3;`
4. **SonuÃ§:** Ekranda bitset'in yanÄ±na sadece "3" yazÄ±lÄ±r! KaydÄ±rma iÅŸlemi yapÄ±lmaz.

**DoÄŸru KullanÄ±m (Parantez Åart):**
```cpp
std::cout << (bs << 3); // <-- DoÄŸru: Ã–nce bitset 3 sola kaydÄ±rÄ±lÄ±r, sonra yazdÄ±rÄ±lÄ±r.
```

### âš™ï¸ Bitsel OperatÃ¶r Overloading
`std::bitset` ÅŸu operatÃ¶rleri destekler:
- `&` (Bitwise AND)
- `|` (Bitwise OR)
- `^` (Bitwise XOR)
- `~` (Bitwise NOT / Tilda)
- `<<`, `>>` (Shift)
- `&=`, `|=`, `^=`, `<<=`, `>>=` (AtamalÄ± operatÃ¶rler)

---

## ğŸ’ DERSÄ°N Ã–ZETÄ° (Hoca'nÄ±n VurgularÄ±)
1. **`std::bitset` bir container deÄŸildir;** iteratÃ¶rleri (`begin/end`) yoktur. Bu yÃ¼zden doÄŸrudan `std::sort` gibi iteratÃ¶r bekleyen algoritmalara sokulamaz (ancak bir container iÃ§inde tutulabilir).
2. **Proxy Class:** `bs[i]` ifadesinin bize bir "yalancÄ±" (reference) nesne dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼, bu nesnenin `bool` gibi davrandÄ±ÄŸÄ±nÄ± ama aslÄ±nda bit manipÃ¼lasyonu yapan bir aracÄ± olduÄŸunu unutmayÄ±n.
3. **SÄ±ralÄ± Arama:** EÄŸer veriniz sÄ±ralÄ±ysa `std::find` yerine `std::binary_search` veya `std::includes` kullanmak performans aÃ§Ä±sÄ±ndan "durumdan vazife Ã§Ä±kartmaktÄ±r".


--- 
**Teknik Not:** Bu dokÃ¼man, Necati Ergin'in 18 AralÄ±k 2024 tarihli ders anlatÄ±mÄ±ndaki tÃ¼m teknik detaylar ve kod Ã¶rnekleri Ã¼zerinden, C++ standartlarÄ±na uygun terminoloji ile yeniden inÅŸa edilmiÅŸtir.