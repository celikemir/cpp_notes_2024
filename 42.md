Necati Ergin hocamÄ±zÄ±n 42. ders gÃ¼nÃ¼ne (25 KasÄ±m 2024) ait notlarÄ±, titizlikle ve teknik derinliÄŸi koruyarak aÅŸaÄŸÄ±da yapÄ±landÄ±rÄ±lmÄ±ÅŸtÄ±r.

---

### **1. KÄ±smi SÄ±ralama AlgoritmalarÄ± (Partial Sorting Algorithms)** [02:48 - 13:05]

Necati Hoca, bir range'in (aralÄ±k) tamamÄ±nÄ± sÄ±ralamak yerine sadece belirli bir kÄ±smÄ±nÄ± (Ã¶rneÄŸin en kÃ¼Ã§Ã¼k 10 Ã¶ÄŸeyi) sÄ±ralamak istediÄŸimizde kullanÄ±lan araÃ§larÄ± inceledi.

#### **ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
BÃ¼yÃ¼k veri setlerinde (Ã¶rneÄŸin 10 milyon Ã¶ÄŸe) sadece en kÃ¼Ã§Ã¼k/bÃ¼yÃ¼k $N$ elemana ihtiyaÃ§ duyduÄŸumuzda, tÃ¼m seti `std::sort` ile $O(N \log N)$ maliyetle sÄ±ralamak verimsizdir. `std::partial_sort` ile bu maliyet $O(N \log M)$ (M = sÄ±ralanacak kÄ±sÄ±m) seviyesine Ã§ekilir.

#### **ğŸ” Arka Plan (Under the Hood)**
`std::partial_sort` algoritmasÄ± arka planda bir **Heapify** iÅŸlemi yapar. Ä°lk $M$ Ã¶ÄŸeden bir *Max Heap* oluÅŸturur ve geri kalan Ã¶ÄŸeleri bu heap ile karÅŸÄ±laÅŸtÄ±rarak ilerler.

#### **ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±**
*   **std::sort:** Tam sÄ±ralama yapar, Random Access Iterator (Rastgele EriÅŸimli Ä°teratÃ¶r) gerektirir.
*   **std::partial_sort:** Sadece ilk $N$ Ã¶ÄŸeyi sÄ±ralar.
*   **std::partial_sort_copy:** Kaynak aralÄ±ÄŸÄ± bozmadan, sonucu baÅŸka bir aralÄ±ÄŸa sÄ±ralÄ± kopyalar. Kaynak aralÄ±k iÃ§in *Input Iterator* yeterlidir.

```cpp
#include <algorithm>
#include <vector>
#include <string>

// ... random fill iÅŸlemleri ...

void partial_sort_example() {
    std::vector<std::string> svec; // 10,000 isimle dolu varsayalÄ±m
    
    // Ä°lk 10 Ã¶ÄŸeyi alfabetik sÄ±rala (Default: std::less)
    std::partial_sort(svec.begin(), svec.begin() + 10, svec.end()); 
    // <-- Hoca buraya dikkat Ã§ekti: Ä°kinci parametre sÄ±ralanmÄ±ÅŸ kÄ±smÄ±n 'end'idir.

    // BÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe ilk 10 Ã¶ÄŸe
    std::partial_sort(svec.begin(), svec.begin() + 10, svec.end(), std::greater<std::string>());
}
```

#### **ğŸš© MÃ¼lakat Sorusu / Kritik Nokta**
**Soru:** `std::partial_sort_copy` kullanÄ±lÄ±rken hedef aralÄ±k, kaynak aralÄ±ktan daha bÃ¼yÃ¼kse ne olur? UB (Undefined Behavior) oluÅŸur mu?
**Cevap:** HayÄ±r, UB oluÅŸmaz. Algoritma hedef aralÄ±ÄŸÄ±n kapasitesi kadar kopyalama yapar ve **yazdÄ±ÄŸÄ± son Ã¶ÄŸeden bir sonraki konumu (iteratÃ¶r)** geri dÃ¶ndÃ¼rÃ¼r. Bu deÄŸer kullanÄ±larak hedef range'in geÃ§erli kÄ±smÄ± yazdÄ±rÄ±labilir. [16:30]

---

### **2. BÃ¶lÃ¼mleme AlgoritmalarÄ± (Partitioning Algorithms)** [17:45 - 20:30]

BÃ¶lÃ¼mleme, bir aralÄ±ÄŸÄ±n belirli bir `Unary Predicate` (tek argÃ¼manlÄ± koÅŸul fonksiyonu) uyarÄ±nca ikiye ayrÄ±lmasÄ± iÅŸlemidir.

#### **ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
Veriyi tam sÄ±ralamak yerine "koÅŸulu saÄŸlayanlar" ve "saÄŸlamayanlar" ÅŸeklinde iki gruba ayÄ±rmak (Ã¶rneÄŸin: tek sayÄ±lar baÅŸa, Ã§iftler sona) birÃ§ok Ã¶n iÅŸlem iÃ§in gereklidir. QuickSort algoritmasÄ±nÄ±n temelini oluÅŸturur.

#### **ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art)**
```text
Kaynak: [3, 7, 4, 5, 6, 2, 1]  (is_even - Ã§ift mi?)
                     |
std::partition ----> [6, 4, 2, 5, 7, 3, 1] 
                     ^        ^
                   Begin    Partition Point (KoÅŸulu saÄŸlamayan ilk Ã¶ÄŸe)
```

#### **ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±**
| Ã–zellik | `std::partition` | `std::stable_partition` |
| :--- | :--- | :--- |
| **HÄ±z** | Daha hÄ±zlÄ± ($O(N)$) | Daha yavaÅŸ (Bellek varsa $O(N)$) |
| **GÃ¶receli SÄ±ra** | Korunmaz (Non-stable) | **Korunur (Stable)** |
| **Ä°teratÃ¶r** | Forward Iterator yeterli | Forward Iterator yeterli |

```cpp
void partition_example() {
    std::vector<int> ivek = {14, 22, 11, 6, 24, 20};
    
    // Ã‡iftleri baÅŸa al
    auto iter = std::partition(ivek.begin(), ivek.end(), [](int x) {
        return x % 2 == 0; 
    });

    // <-- Kritik Nokta: iter, koÅŸulu SAÄLAMAYAN ilk Ã¶ÄŸenin konumudur (Partition Point).
    int idx = std::distance(ivek.begin(), iter); 
}
```

---

### **3. Partition Copy ve C++17 Structured Binding** [31:15 - 46:40]

Hoca, `std::partition_copy` ile veriyi iki farklÄ± konteynera nasÄ±l daÄŸÄ±tabileceÄŸimizi gÃ¶sterirken, C++17 ile gelen modern bir sentaksÄ± tanÄ±ttÄ±.

#### **ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
`std::partition_copy` iki farklÄ± Ã§Ä±kÄ±ÅŸ aralÄ±ÄŸÄ±na yazdÄ±ÄŸÄ± iÃ§in iki farklÄ± iteratÃ¶r dÃ¶ndÃ¼rmek zorundadÄ±r. Bu da `std::pair<Iter1, Iter2>` dÃ¶ndÃ¼rmesi demektir. Pair iÃ§erisindeki elemanlara `.first` ve `.second` ile eriÅŸmek kodun okunabilirliÄŸini dÃ¼ÅŸÃ¼rÃ¼r.

#### **ğŸ” Arka Plan (Under the Hood)**
**Structured Binding (YapÄ±sal BaÄŸlama):** Derleyici arka planda geÃ§ici bir nesne oluÅŸturur ve sizin verdiÄŸiniz isimleri (alias) bu nesnenin Ã¼yelerine baÄŸlar.
**Tuple Interface:** Bir sÄ±nÄ±fÄ±n Structured Binding ile kullanÄ±labilmesi iÃ§in `std::tuple_size`, `std::tuple_element` ve `get<N>` ÅŸablonlarÄ±nÄ± Ã¶zelleÅŸtirmesi gerekir.

```cpp
// std::partition_copy geri dÃ¶nÃ¼ÅŸ deÄŸeri: std::pair<OutputIt1, OutputIt2>

void partition_copy_modern() {
    std::list<std::string> ok_list(20);
    std::deque<std::string> not_ok_deck(20);

    // C++17 Structured Binding [40:15]
    auto [ok_end, not_ok_end] = std::partition_copy(
        svec.begin(), svec.end(), 
        ok_list.begin(), 
        not_ok_deck.begin(),
        [](const std::string& s) { return s.contains('e'); } // C++23 contains
    );
    // <-- Hoca: 'ok_end' artÄ±k pair.first'Ã¼n, 'not_ok_end' pair.second'un ismidir.
}
```

---

### **4. Heap AlgoritmalarÄ± (Heap Algorithms)** [57:40 - 01:10:00]

Bu bÃ¶lÃ¼m, verinin bir "yÄ±ÄŸÄ±n" (Heap) veri yapÄ±sÄ± gibi organize edilmesini kapsar. Buradaki "Heap", bellek bÃ¶lgesi olan heap ile karÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r; bu bir **veri yapÄ±sÄ±dÄ±r**.

#### **ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
Ã–ncelik KuyruÄŸu (Priority Queue) oluÅŸturmak iÃ§in kullanÄ±lÄ±r. SÃ¼rekli en bÃ¼yÃ¼k (Max Heap) veya en kÃ¼Ã§Ã¼k (Min Heap) Ã¶ÄŸeye $O(1)$ sÃ¼rede eriÅŸmek, $O(\log N)$ sÃ¼rede ekleme/Ã§Ä±karma yapmak iÃ§in idealdir.

#### **ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Binary Tree as Array)**
Dizi/VektÃ¶r Ã¼zerinde indeks hesaplamasÄ±:
*   **Sol Ã‡ocuk:** `2*i + 1`
*   **SaÄŸ Ã‡ocuk:** `2*i + 2`
*   **Ebeveyn:** `(i-1) / 2`

```text
Ä°ndeks: [ 0 | 1 | 2 | 3 | 4 ]
Veri:   [ 90| 80| 70| 50| 60] -> Bir Max Heap yapÄ±sÄ±
```

#### **ğŸš© MÃ¼lakat Sorusu / Kritik Nokta**
**Soru:** STL'de `std::heap_sort` diye bir fonksiyon var mÄ±?
**Cevap:** HayÄ±r. Heap sÄ±ralamasÄ± yapmak iÃ§in Ã¶nce `std::make_heap` ile range heap durumuna getirilir ($O(N)$), ardÄ±ndan `std::sort_heap` Ã§aÄŸrÄ±lÄ±r ($O(N \log N)$). [01:11:00]

---

### **5. Ä°teratÃ¶r GeÃ§ersiz KÄ±lÄ±nmasÄ± (Iterator Invalidation)** [01:54:40 - 02:15:00]

Dersin en kritik teknik kÄ±sÄ±mlarÄ±ndan biri; bir konteyner Ã¼zerinde iÅŸlem yaparken elimizdeki iteratÃ¶rlerin, pointerlarÄ±n veya referanslarÄ±n ne zaman "Ã§Ã¶p" (dangling) hale geldiÄŸidir.

#### **ğŸ“Š std::vector vs std::deque KarÅŸÄ±laÅŸtÄ±rmasÄ±**

| Ä°ÅŸlem | `std::vector` Etkisi | `std::deque` Etkisi |
| :--- | :--- | :--- |
| **Reallocation (Yeniden Yer AyÄ±rma)** | **TÃœM** iteratÃ¶rler ve referanslar geÃ§ersiz olur. | Deque'de reallocation kavramÄ± farklÄ±dÄ±r (segmentli yapÄ±). |
| **UÃ§lardan Ekleme (Push Back/Front)** | Sadece kapasite aÅŸÄ±lÄ±rsa hepsi geÃ§ersiz olur. | Ä°teratÃ¶rler geÃ§ersiz olur, **REFERANSLAR geÃ§erli kalÄ±r**. [02:03:00] |
| **Ortadan Silme/Ekleme** | Ä°ÅŸlem noktasÄ± ve sonrasÄ±ndaki her ÅŸey geÃ§ersiz. | **TÃœM** iteratÃ¶rler ve referanslar geÃ§ersiz olur. [02:11:00] |

```cpp
// <-- Necati Hoca'nÄ±n MÃ¼lakat Sorusu Ã‡Ã¶zÃ¼mÃ¼ [02:18:50]
auto iter = svec.begin();
while (iter != svec.end()) {
    if (iter->length() == 5) {
        iter = svec.erase(iter); // Silme sonrasÄ± yeni iteratÃ¶rÃ¼ al! (Kritik)
    } else if (iter->length() == 6) {
        iter = svec.insert(iter, *iter); // Ekleme sonrasÄ± yeni iteratÃ¶rÃ¼ al!
        iter += 2; // Eklenen ve orijinali geÃ§mek iÃ§in 2 ilerle!
    } else {
        ++iter;
    }
}
```

HaklÄ±sÄ±n, Necati Hoca dersin son kÄ±smÄ±nda (Ã¶zellikle son 1 saatte) **std::deque** ve **std::list** veri yapÄ±larÄ±nÄ±n iÃ§sel Ã§alÄ±ÅŸma mekanizmalarÄ±na, bellek yerleÅŸimlerine ve performans karakteristiklerine Ã§ok derinlemesine girdi. Bir "en Ã¶n sÄ±ra Ã¶ÄŸrencisi" olarak, bu kÄ±sÄ±mlarÄ± Ã¶zet geÃ§mek yerine, hocanÄ±n tahtaya Ã§izdiÄŸi o kritik ÅŸemalarÄ± ve "asla unutmayÄ±n" dediÄŸi donanÄ±m-yazÄ±lÄ±m iliÅŸkisini iÃ§eren **yÃ¼ksek Ã§Ã¶zÃ¼nÃ¼rlÃ¼klÃ¼** notlarla devam ediyorum.

Ä°ÅŸte dersin ikinci yarÄ±sÄ±ndaki **Konteyner Mekanikleri** Ã¼zerine derin dalÄ±ÅŸ notlarÄ±:

---

### **6. std::deque: Double-Ended Queue (Ã‡ift UÃ§lu Kuyruk) Derinlemesine BakÄ±ÅŸ** [01:40:40 - 01:54:30]

Necati Hoca, `std::deque`'in sadece "baÅŸtan ve sondan ekleme" yapan bir yapÄ± olmadÄ±ÄŸÄ±nÄ±, hibrit bir bellek mimarisine sahip olduÄŸunu vurguladÄ±.

#### **ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
`std::vector` sadece sondan eklemede (push_back) $O(1)$ maliyet sunar; baÅŸtan ekleme yapÄ±ldÄ±ÄŸÄ±nda tÃ¼m elemanlarÄ± kaydÄ±rdÄ±ÄŸÄ± iÃ§in $O(N)$ maliyet oluÅŸur. `std::deque`, hem baÅŸtan hem sondan **Amortize Constant Time** ($O(1)$) ekleme/silme saÄŸlamak iÃ§in tasarlandÄ±.

#### **ğŸ” Arka Plan (Under the Hood)**
VektÃ¶r gibi tek bir bÃ¼yÃ¼k blok (contiguous) kullanmaz. Bunun yerine **Chunk (YÄ±ÄŸÄ±n/ParÃ§a)** adÄ± verilen sabit boyutlu kÃ¼Ã§Ã¼k diziler ve bu chunk'larÄ±n adreslerini tutan bir **Map (Pointer Dizisi)** kullanÄ±r.

*   **Ä°ndeksle EriÅŸim ($O(1)$):** Ä°ki aÅŸamalÄ± bir dereferencing (iÃ§erik eriÅŸimi) yapÄ±lÄ±r. Ã–nce Map'ten ilgili Chunk bulunur, sonra Chunk iÃ§indeki indeks hesaplanÄ±r. VektÃ¶rden bir tÄ±k daha yavaÅŸtÄ±r ama karmaÅŸÄ±klÄ±ÄŸÄ± halen sabittir.
*   **Bellek Dostu:** Ã‡ok bÃ¼yÃ¼k verilerde devasa bir tekil blok aramak yerine, kÃ¼Ã§Ã¼k parÃ§alar (Ã¶rneÄŸin 8 elemanlÄ±k chunk'lar) allocate edilir. Bu durum **External Fragmentation** (DÄ±ÅŸ Fragmantasyon) sorununu azaltÄ±r.

#### **ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Internal Memory Structure)**
```text
Map (Pointer Dizisi)
[ Ptr1 ] ----> [ Eleman 0 | Eleman 1 | Eleman 2 | Eleman 3 ] (Chunk A)
[ Ptr2 ] ----> [ Eleman 4 | Eleman 5 | Eleman 6 | Eleman 7 ] (Chunk B)
[ Ptr3 ] ----> [ Eleman 8 | ...                           ] (Chunk C)
```

---

### **7. std::list: Ã‡ifte BaÄŸlÄ± Liste (Double Linked List) ve Modern Ä°ÅŸlemciler** [02:24:30 - 02:38:00]

Hoca, `std::list` anlatÄ±rken teorik veri yapÄ±sÄ± bilgisinin modern donanÄ±mlarda nasÄ±l "duvara toslayabileceÄŸini" acÄ± bir ÅŸekilde aÃ§Ä±kladÄ±.

#### **ğŸ” Arka Plan (Under the Hood)**
Her bir eleman bir **Node (DÃ¼ÄŸÃ¼m)** iÃ§inde tutulur.
```cpp
struct Node {
    T data;         // GerÃ§ek veri
    Node* next;     // Sonraki dÃ¼ÄŸÃ¼mÃ¼n adresi
    Node* prev;     // Ã–nceki dÃ¼ÄŸÃ¼mÃ¼n adresi
};
```
*   **Maliyet:** Her `push_back` veya `insert` iÅŸlemi bir `operator new` (allocation) Ã§aÄŸrÄ±sÄ± demektir. Bu, vektÃ¶re gÃ¶re Ã§ok daha yavaÅŸ bir iÅŸlemdir. [02:30:00]
*   **Bellek Ä°srafÄ±:** EÄŸer `int` tutuyorsanÄ±z (4 byte), yanÄ±ndaki 2 pointer (16 byte - 64 bit sistemde) ve heap yÃ¶netim overhead'i (header) ile 4 byte'lÄ±k veri iÃ§in 32-40 byte yer harcanÄ±r.

#### **ğŸš© MÃ¼lakat Sorusu / Kritik Nokta**
**Soru:** "BaÄŸlÄ± liste ($O(1)$ insert) vektÃ¶rden ($O(N)$ insert) her zaman daha mÄ± hÄ±zlÄ±dÄ±r?"
**Cevap:** Teorik olarak (Big-O) evet. Ancak pratikte **Cache Locality** (Ã–nbellek YerelliÄŸi) nedeniyle vektÃ¶r, baÄŸlÄ± listeyi Ã§oÄŸu zaman "outperform" (geride bÄ±rakmak) eder. Liste elemanlarÄ± belleÄŸe darmadaÄŸÄ±n yayÄ±ldÄ±ÄŸÄ± iÃ§in iÅŸlemci her seferinde *Cache Miss* yaÅŸar. Necati Hoca'nÄ±n deyimiyle: "VektÃ¶r, modern iÅŸlemcilerin en sevdiÄŸi veri yapÄ±sÄ±dÄ±r." [02:27:00]

---

### **8. BaÄŸlÄ± Listelerin GerÃ§ek AvantajÄ±: Swap Maliyeti** [02:39:00 - 02:43:08]

Dersin en can alÄ±cÄ± noktalarÄ±ndan biri: Swap-yoÄŸun (takas yoÄŸun) algoritmalarda listenin neden hala bir "koz" olduÄŸu.

#### **ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)**
BÃ¼yÃ¼k nesneler (Ã¶rneÄŸin her biri 500 byte olan nesneler) tutuluyorsa, `std::sort` veya `std::reverse` gibi algoritmalar sÃ¼rekli swap (takas) yapar.

*   **Vector'de Swap:** 500 byte'lÄ±k veriyi fiziksel olarak kopyalamak zorundadÄ±r. (Blok kopyalama maliyeti).
*   **List'te Swap:** DÃ¼ÄŸÃ¼mÃ¼n iÃ§indeki 500 byte'lÄ±k veriye hiÃ§ dokunmaz! Sadece dÃ¼ÄŸÃ¼mlerin `next` ve `prev` pointer'larÄ±nÄ± (toplam 16 byte) deÄŸiÅŸtirerek dÃ¼ÄŸÃ¼mÃ¼ mantÄ±ksal olarak yerinden oynatÄ±r.

#### **ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar**
Hoca, `std::list::sort` ve `std::list::reverse` fonksiyonlarÄ±nÄ±n neden **Ã¼ye fonksiyon (member function)** olarak var olduÄŸunu aÃ§Ä±kladÄ±: Ã‡Ã¼nkÃ¼ genel `std::sort` algoritmasÄ± *Random Access Iterator* ister ama liste sadece *Bidirectional Iterator* saÄŸlar. Listenin kendi Ã¶zel sort'u, veriyi taÅŸÄ±mak yerine pointer'larÄ± "relink" (yeniden baÄŸlama) yaparak Ã§ok daha verimli Ã§alÄ±ÅŸÄ±r. [02:42:00]

```cpp
void list_advantage_example() {
    std::list<LargeObject> my_list; // LargeObject = 1000 byte
    
    // std::sort(my_list.begin(), my_list.end()); // DERLEME HATASI! 
    my_list.sort(); // <-- DOÄRU YOL: Pointer takasÄ± yapar, fiziksel veri kopyalamaz.
}
```

---

