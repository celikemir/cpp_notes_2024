Bu dokÃ¼man, Necati Ergin'in C++ dersindeki anlatÄ±mlarÄ±nÄ± titizlikle takip eden, teknik derinliÄŸi yÃ¼ksek bir mÃ¼hendislik notu formatÄ±nda hazÄ±rlanmÄ±ÅŸtÄ±r.

---

# C++ Standart KÃ¼tÃ¼phanesi: Dosya Ä°ÅŸlemleri (File Operations) - Ders NotlarÄ±

## 1. GiriÅŸ ve Temel SÄ±nÄ±flar [00:00 - 05:00]

Hoca, `iostream` kÃ¼tÃ¼phanesinin dosya iÅŸlemleriyle ilgili arayÃ¼zÃ¼nÃ¼ incelemeye baÅŸlÄ±yor. C++'da dosya iÅŸlemleri iÃ§in kullanÄ±lan sÄ±nÄ±flar `<fstream>` baÅŸlÄ±k dosyasÄ±nda tanÄ±mlÄ±dÄ±r.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C dilindeki `FILE*` ve `fopen`/`fclose` tabanlÄ± yapÄ±sal yaklaÅŸÄ±m, tip gÃ¼venliÄŸi (type safety) saÄŸlamÄ±yordu ve hata kontrolÃ¼ manuel yapÄ±lÄ±yordu. C++'da RAII (Resource Acquisition Is Initialization - Kaynak Edinimi BaÅŸlatmadÄ±r) prensibiyle Ã§alÄ±ÅŸan, nesne yÃ¶nelimli bir stream (akÄ±ÅŸ) yapÄ±sÄ±na ihtiyaÃ§ duyuldu.

### âš™ï¸ Teknik Detay ve Sentaks
Dosya iÅŸlemleri iÃ§in Ã¼Ã§ temel sÄ±nÄ±f (aslÄ±nda `type alias` / tÃ¼r eÅŸ ismi) mevcuttur:
1.  **`ifstream`**: YalnÄ±zca okuma (input) amaÃ§lÄ±.
2.  **`ofstream`**: YalnÄ±zca yazma (output) amaÃ§lÄ±.
3.  **`fstream`**: Hem okuma hem yazma (input/output) amaÃ§lÄ±.

```cpp
#include <fstream>

int main() {
    std::ifstream ifs; // Okuma amaÃ§lÄ± stream nesnesi
    std::ofstream ofs; // Yazma amaÃ§lÄ± stream nesnesi
    std::fstream fs;   // Hem okuma hem yazma amaÃ§lÄ±
}
```

### ğŸ” Arka Plan (Under the Hood)
Bu sÄ±nÄ±flar aslÄ±nda `std::basic_ifstream<char>` gibi sÄ±nÄ±f ÅŸablonlarÄ±nÄ±n `char` aÃ§Ä±lÄ±mlarÄ±dÄ±r. Hoca, bunlarÄ±n `type alias` (tÃ¼r eÅŸ ismi) olduÄŸunu hatÄ±rlattÄ±.

---

## 2. Dosya AÃ§Ä±ÅŸ ModlarÄ± (Open Modes) [05:00 - 15:00]

Hoca, C'deki `fopen` modlarÄ±nÄ± hatÄ±rlatarak C++'daki karÅŸÄ±lÄ±klarÄ±nÄ± aÃ§Ä±kladÄ±. Bir dosya aÃ§Ä±lÄ±rken iki soru kritiktir:
1. Hangi iÅŸlemleri yapmaya hakkÄ±m var?
2. Dosya varsa/yoksa ne olacak?

### ğŸš© Kritik Nokta: Truncate (KÄ±rpma)
Yazma modunda aÃ§Ä±lan bir dosya mevcutsa, eski iÃ§eriÄŸi silinir. Buna **truncate** (kÄ±rpma/budama) deniyor. `append` modunda ise iÃ§erik korunur ve sona ekleme yapÄ±lÄ±r.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: SÄ±nÄ±f HiyerarÅŸisi (ASCII Art)
```text
       [ios_base] (Taban SÄ±nÄ±f - Bitmask TÃ¼rleri)
           |
      [basic_ios]
      /         \
[basic_istream] [basic_ostream]
      \         /      |
     [basic_iostream] [basic_ofstream]
           |
     [basic_fstream]
```

### ğŸš© MÃ¼lakat Sorusu: Windows vs Unix FarkÄ±
**Soru:** DosyayÄ± `text` veya `binary` modda aÃ§mak Windows'ta neden kritiktir?
**Cevap:** Windows'ta `text` modunda `\n` (newline) karakteri yazÄ±ldÄ±ÄŸÄ±nda, arka planda 2 byte (`13-10` / `CR-LF`) olarak kaydedilir. Okurken de `13-10` Ã§ifti `10` (`\n`) olarak okunur. `binary` modda ise karakterler olduÄŸu gibi (transparan) iÅŸlenir. AyrÄ±ca Windows'ta `26` nolu karakter (`Ctrl-Z`), `text` modunda dosya sonu (EOF) kabul edilir; `binary` modda bu bir veri byte'Ä±dÄ±r.

---

## 3. `ios_base::openmode` ve Bayraklar [15:00 - 25:00]

DosyayÄ± aÃ§arken kullanÄ±lan bayraklar `std::ios_base::openmode` tÃ¼rÃ¼ndendir ve bitsel veya (`bitwise OR`) operatÃ¶rÃ¼yle birleÅŸtirilirler.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca aÅŸaÄŸÄ±daki bayraklarÄ± detaylandÄ±rdÄ±:
*   `ios::in`: Okuma (Input).
*   `ios::out`: Yazma (Output).
*   `ios::app`: Sona ekleme (Append). Her yazma iÅŸleminden Ã¶nce konum gÃ¶stericisi sona gider.
*   `ios::ate`: AÃ§Ä±lÄ±ÅŸta sona git (At End). `app`'ten farkÄ±; sadece aÃ§Ä±lÄ±ÅŸta sona gider, sonra yer deÄŸiÅŸtirebilirsiniz.
*   `ios::trunc`: DosyayÄ± silerek aÃ§ (Truncate).
*   `ios::binary`: Ä°kili modda aÃ§.

```cpp
// Hoca'nÄ±n vurguladÄ±ÄŸÄ± kullanÄ±m:
std::ofstream ofs("deneme.bin", std::ios::out | std::ios::binary); 
// <-- Kritik: Binary modda aÃ§mazsanÄ±z Windows'ta \n karakterleri 2 byte yazÄ±lÄ±r!
```

### ğŸ”— Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
| Ã–zellik | C++ StandartÄ± | AÃ§Ä±klama |
| :--- | :--- | :--- |
| `noreplace` | C++23 | Dosya zaten varsa aÃ§ma iÅŸlemini baÅŸarÄ±sÄ±z kÄ±lar. |

---

## 4. DosyayÄ± AÃ§ma ve RAII Ä°diomu [25:00 - 35:00]

Hoca, dosyanÄ±n iki ÅŸekilde aÃ§Ä±labileceÄŸini belirtti:
1. Constructor (Kurucu fonksiyon) argÃ¼manÄ± ile.
2. `open()` Ã¼ye fonksiyonu ile.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
RAII idiomu sayesinde, nesnenin Ã¶mrÃ¼ bittiÄŸinde (scope dÄ±ÅŸÄ±na Ã§Ä±ktÄ±ÄŸÄ±nda) `destructor` otomatik olarak dosyayÄ± kapatÄ±r (`close()`). Bu, kaynak sÄ±zÄ±ntÄ±sÄ±nÄ± (resource leak) engeller.

```cpp
{
    std::ifstream ifs("veri.txt"); // RAII: Constructor dosyayÄ± aÃ§ar.
    if (!ifs) { // <-- Hoca'nÄ±n sevdiÄŸi kontrol yÃ¶ntemi: operator!
        // Hata iÅŸlemleri
    }
} // <-- Destructor burada ifs.close() fonksiyonunu otomatik Ã§aÄŸÄ±rÄ±r.
```

### âš™ï¸ VarsayÄ±lan Modlar (Default Modes)
Hoca buraya Ã§ok dikkat Ã§ekti:
*   `ifstream` iÃ§in varsayÄ±lan: `ios::in`
*   `ofstream` iÃ§in varsayÄ±lan: `ios::out`
*   `fstream` iÃ§in varsayÄ±lan: `ios::in | ios::out`

```cpp
std::ofstream ofs("necati.txt"); // AslÄ±nda std::ios::out flag'ini gizlice (default) alÄ±r.
std::ofstream ofs2("necati.txt", std::ios::binary); // out default geldiÄŸi iÃ§in sadece binary eklemek yeterli.
```

---

## 5. AkÄ±ÅŸ Durum KontrolÃ¼ ve `is_open` [35:00 - 45:00]

Bir dosya nesnesinin hayatta olmasÄ±, bir dosyanÄ±n aÃ§Ä±k olduÄŸu anlamÄ±na gelmez.

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** `is_open()` ile `fail()` arasÄ±ndaki fark nedir?
**Cevap:** `is_open()`, nesneye baÄŸlÄ± fiziksel bir dosya olup olmadÄ±ÄŸÄ±nÄ± sÃ¶yler. `fail()` veya `operator bool`, yapÄ±lan son iÅŸlemin (aÃ§ma dahil) baÅŸarÄ±lÄ± olup olmadÄ±ÄŸÄ±nÄ± sÃ¶yler.

```cpp
std::ifstream ifs; // Default construct edildi, aÃ§Ä±k dosya yok.
// ifs.is_open() -> false
// ifs.fail() -> false (HenÃ¼z bir iÅŸlem yapÄ±lmadÄ±)

ifs.open("olmayan_dosya.txt");
// ifs.is_open() -> false
// ifs.fail() -> true (AÃ§ma giriÅŸimi baÅŸarÄ±sÄ±z)
```

### ğŸ” Arka Plan (Under the Hood): Exceptions
Dosya iÅŸlemleri varsayÄ±lan olarak `exception` (istisna) fÄ±rlatmaz. Ancak `exceptions()` fonksiyonu ile hangi hata durumunda (`badbit`, `failbit`, `eofbit`) fÄ±rlatÄ±lacaÄŸÄ± set edilebilir.

```cpp
std::ifstream ifs;
ifs.exceptions(std::ios::failbit); // ArtÄ±k aÃ§Ä±lmazsa exception fÄ±rlatÄ±r.
```

---

## 6. FormatlÄ± ve FormatsÄ±z I/O [45:00 - 60:00]

Hoca, `iostream`'den gelen tÃ¼m manipÃ¼latÃ¶rlerin ve operatÃ¶rlerin dosyalarda da aynen kullanÄ±labileceÄŸini gÃ¶sterdi.

### âš™ï¸ Teknik Detay ve Sentaks
*   **FormatlÄ±:** `operator<<` ve `operator>>` (Karakter kodlarÄ± Ã¼zerinden).
*   **FormatsÄ±z:** `get()`, `put()`, `read()`, `write()`.

```cpp
// FormatsÄ±z okuma Ã¶rneÄŸi (Byte-by-byte)
char c;
while (ifs.get(c)) { // <-- Necati Hoca'nÄ±n "Idiom" kullanÄ±mÄ±: operator bool Ã¼zerinden kontrol
    std::cout.put(c);
}

// FormatsÄ±z Blok Yazma (Binary)
int x = 12345;
ofs.write(reinterpret_cast<const char*>(&x), sizeof(x)); 
// <-- HATA RÄ°SKÄ°: Hoca belirtti, void* olmadÄ±ÄŸÄ± iÃ§in reinterpret_cast zorunludur!
```

### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar
"Bunu 12. derste formatlama konusunda gÃ¶rmÃ¼ÅŸtÃ¼k; `setw`, `setfill`, `left` gibi manipÃ¼latÃ¶rler dosya stream'lerinde de `std::cout` gibi Ã§alÄ±ÅŸÄ±r."

---

### Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:
1.  **Binary Mod Ä°hmali:** Windows'ta binary veri yazarken `ios::binary` eklememek veriyi bozar.
2.  **State Resetleme:** Bir hata (Ã¶rneÄŸin EOF) oluÅŸtuktan sonra aynÄ± nesneyle baÅŸka dosya aÃ§Ä±lacaksa `clear()` Ã§aÄŸrÄ±lmalÄ±dÄ±r.
3.  **Cast ZorunluluÄŸu:** `read` ve `write` fonksiyonlarÄ± `char*` bekler, `int*` veya baÅŸka tÃ¼rden adresler geÃ§erken `reinterpret_cast` ÅŸarttÄ±r.


HaklÄ±sÄ±n, Necati Hoca'nÄ±n her bir cÃ¼mlesi altÄ±n deÄŸerinde. Tempoyu dÃ¼ÅŸÃ¼rÃ¼p teknik derinliÄŸi artÄ±rarak, her bir fonksiyonun neden var olduÄŸunu ve arka planda neyi temsil ettiÄŸini ilmik ilmik iÅŸleyelim.

---

## 7. Dosya AÃ§ma Kontrolleri ve "Stream State" [01:00:00 - 01:10:00]

Hoca, bir dosyanÄ±n aÃ§Ä±lÄ±p aÃ§Ä±lmadÄ±ÄŸÄ±nÄ± kontrol etmenin modern C++'daki "best practice" (en iyi uygulama) yÃ¶ntemlerini detaylandÄ±rÄ±yor.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C'de `fopen` baÅŸarÄ±sÄ±z olduÄŸunda `NULL` dÃ¶nerdi. C++'da ise bir nesne her zaman oluÅŸur, ancak nesne "hata durumuna" (`fail state`) geÃ§er. ProgramcÄ±nÄ±n bu durumu nesne Ã¼zerinden sorgulamasÄ± gerekir.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, dosya aÃ§ma kontrolÃ¼ iÃ§in Ã¼Ã§ farklÄ± sentaks gÃ¶sterdi ve bunlarÄ±n arka planda aynÄ± kapÄ±ya Ã§Ä±ktÄ±ÄŸÄ±nÄ± vurguladÄ±:

```cpp
std::ifstream ifs("olmayan_dosya.txt");

// 1. YÃ¶ntem: operator! (Hoca'nÄ±n favorisi)
if (!ifs) { 
    // <-- Kritik: Bu yÃ¶ntem aslÄ±nda ifs.fail() fonksiyonunu Ã§aÄŸÄ±rÄ±r.
    std::cerr << "Dosya acilamadi!" << std::endl; 
}

// 2. YÃ¶ntem: Explicit fail() Ã§aÄŸrÄ±sÄ±
if (ifs.fail()) { 
    // State kontrolÃ¼ yapar
}

// 3. YÃ¶ntem: operator bool (L-value to bool dÃ¶nÃ¼ÅŸÃ¼mÃ¼)
if (ifs) { 
    // Dosya baÅŸarÄ±yla aÃ§Ä±ldÄ±ysa buraya girer
}
```

### ğŸ” Arka Plan (Under the Hood): Kopyalama vs. TaÅŸÄ±ma
Hoca burada Ã§ok kritik bir mimari kuralÄ± hatÄ±rlattÄ±: **Stream sÄ±nÄ±flarÄ± kopyalanamaz (Copy Disabled), ancak taÅŸÄ±nabilir (Move Enabled).**

*   **Neden kopyalanamaz?** Ä°ki farklÄ± nesnenin aynÄ± dosya handle'Ä±na (dosya iÅŸleyicisi) sahip olmasÄ±, destructor'lar Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda "double close" (Ã§ifte kapatma) hatasÄ±na ve senkronizasyon felaketine yol aÃ§ar.
*   **Neden taÅŸÄ±nabilir?** Bir fonksiyonun iÃ§inde aÃ§tÄ±ÄŸÄ±mÄ±z dosyayÄ± (local object), sahipliÄŸini dÄ±ÅŸarÄ±daki bir nesneye devrederek (move) verimli bir ÅŸekilde dÃ¶ndÃ¼rebilmek iÃ§in.

```cpp
std::ifstream ifs1("a.txt");
// std::ifstream ifs2 = ifs1; // <-- HATA: Copy Constructor silinmiÅŸ (deleted).
std::ifstream ifs3 = std::move(ifs1); // <-- GEÃ‡ERLÄ°: Move Semantics.
```

---

## 8. FormatsÄ±z Okuma: `get()` ve `gcount()` [01:10:00 - 01:20:00]

Hoca, karakter tabanlÄ± okuma iÅŸlemlerinde (unformatted input) kullanÄ±lan `get` fonksiyonunun overload'larÄ±nÄ± (aÅŸÄ±rÄ± yÃ¼klemelerini) inceledi.

### âš™ï¸ Teknik Detay ve Sentaks
`get()` fonksiyonunun iki temel kullanÄ±mÄ± vardÄ±r:

1.  **Parametresiz `get()`:** Okunan karakteri `int` olarak dÃ¶ndÃ¼rÃ¼r. EOF (End of File) durumunda `EOF` sabiti (genelde -1) dÃ¶ner.
2.  **Referans Parametreli `get(char&)`:** Okunan karakteri referansa yazar ve fonksiyonun kendisi stream nesnesini (`*this`) dÃ¶ndÃ¼rÃ¼r.

```cpp
char c;
// Necati Hoca Ä°diomu: Stream nesnesinin kendisi bool baÄŸlamda test ediliyor.
while (ifs.get(c)) { 
    // ifs.get(c) Ã§aÄŸrÄ±sÄ± ifs nesnesini dÃ¶ner, o da operator bool() ile test edilir.
    std::cout.put(c); 
}
```

### ğŸš© Kritik Nokta: `gcount()` (The Ghost Counter)
**Soru:** Madem `get(char&)` fonksiyonu stream nesnesini dÃ¶ndÃ¼rÃ¼yor, kaÃ§ karakter okuduÄŸumuzu nasÄ±l anlarÄ±z?
**Cevap:** `gcount()` (Get Count) fonksiyonu ile.

### ğŸ” Arka Plan (Under the Hood)
`gcount()`, yapÄ±lan **son formatsÄ±z okuma iÅŸleminde** kaÃ§ byte transfer edildiÄŸini dÃ¶ndÃ¼ren bir iÃ§ sayacÄ± okur.

```cpp
ifs.get(c);
auto n = ifs.gcount(); // n burada 1 olacaktÄ±r (eÄŸer okuma baÅŸarÄ±lÄ±ysa).
```

---

## 9. Pratik Dosya Yazma: "Asal SayÄ±lar" Ã–rneÄŸi [01:20:00 - 01:30:00]

Hoca, Ã¶ÄŸrendiÄŸimiz her ÅŸeyi bir araya getiren "ilk N asal sayÄ±yÄ± dosyaya yazma" Ã¶rneÄŸini kodladÄ±.

### âš™ï¸ Teknik Detay ve Sentaks
Bu bÃ¶lÃ¼mde Hoca, dosya isimlerini dinamik olarak oluÅŸturmak iÃ§in `std::ostringstream` kullandÄ±:

```cpp
#include <sstream>
#include <fstream>
#include <iomanip>

int n = 1000;
std::ostringstream oss;
oss << "primes_" << n << ".txt"; // "primes_1000.txt" yazÄ±sÄ±nÄ± oluÅŸturduk.
std::string filename = oss.str(); // string'i aldÄ±k.

std::ofstream ofs(filename); // <-- Dosya aÃ§Ä±ldÄ±.
if (!ofs) { /* Hata kontrolÃ¼ */ }

int prime_count = 0;
int x = 2;
while (prime_count < n) {
    if (is_prime(x)) {
        ofs << std::setw(10) << x << (prime_count % 10 == 9 ? "\n" : " ");
        // <-- Kritik: setw(10) ile formatlama yapÄ±ldÄ±.
        prime_count++;
    }
    x++;
} // <-- RAII: ofs nesnesi burada Ã¶lÃ¼rken dosyayÄ± otomatik kapatacak.
```

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Hoca, dosya isimlerini manuel olarak "string birleÅŸtirme" (plus operator) ile yapmak yerine `ostringstream` kullanmanÄ±n Ã§ok daha esnek ve gÃ¼venli (formatlama yeteneÄŸinden dolayÄ±) olduÄŸunu gÃ¶sterdi.

---

## 10. Dosya Ä°Ã§eriÄŸini Tek Seferde Basma: `rdbuf()` Sihri [01:20:00 civarÄ±]

Hoca, dosyanÄ±n tamamÄ±nÄ± ekrana basmanÄ±n "en havalÄ±" ve en hÄ±zlÄ± yolunu gÃ¶sterdi.

### ğŸ” Arka Plan (Under the Hood)
Her stream nesnesinin arka planÄ±nda dÃ¼ÅŸÃ¼k seviyeli bir **`streambuf`** (akÄ±ÅŸ tamponu) nesnesi bulunur. `rdbuf()` bu tamponun adresini dÃ¶ner. `std::ostream` sÄ±nÄ±fÄ±nÄ±n (`cout` gibi) `streambuf*` alan bir `operator<<` overload'u vardÄ±r.

```cpp
std::ifstream ifs("primes.txt");
std::cout << ifs.rdbuf(); 
// <-- KRÄ°TÄ°K: Hoca "tek bir statement ile dosyanÄ±n tamamÄ±nÄ± yazdÄ±k" dedi.
// Bu iÅŸlem karakter karakter dÃ¶ngÃ¼ kurmaktan Ã§ok daha hÄ±zlÄ±dÄ±r.
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Bir dosyanÄ±n boyutunu aÃ§ar aÃ§maz nasÄ±l anlarÄ±z?
**Cevap:** `std::ios::ate` (At the end) bayraÄŸÄ±yla aÃ§Ä±p `tellg()` fonksiyonunu Ã§aÄŸÄ±rarak.

---

### Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:
1.  **`ostringstream` TemizliÄŸi:** DÃ¶ngÃ¼ iÃ§inde `oss` kullanÄ±lÄ±yorsa, her turda iÃ§eriÄŸin `oss.str("")` ile boÅŸaltÄ±lmasÄ± gerektiÄŸini hatÄ±rlattÄ± (farklÄ± bir Ã¶rnek baÄŸlamÄ±nda).
2.  **`std::endl` vs `\n`:** Dosyalara Ã§ok fazla veri yazarken `std::endl` kullanmanÄ±n (her seferinde fiziksel diski flush ettiÄŸi iÃ§in) performansÄ± Ã§ok dÃ¼ÅŸÃ¼receÄŸini, `\n` tercih edilmesi gerektiÄŸini vurguladÄ±.
3.  **HatalÄ± Dosya UzantÄ±sÄ±:** `binary` modda yazÄ±lan dosyalarÄ±n `.txt` uzantÄ±sÄ±yla kaydedilmesinin programcÄ±yÄ± yanÄ±ltabileceÄŸini, `.dat` veya `.bin` gibi uzantÄ±larÄ±n teknik olarak daha doÄŸru bir "niyet beyanÄ±" olduÄŸunu belirtti.


Necati Hoca, dersin bu bÃ¶lÃ¼mÃ¼nde formatlÄ± okumadan baÅŸlayarak, standart kÃ¼tÃ¼phane kaplarÄ±nÄ± (containers) dosya iÅŸlemleriyle nasÄ±l entegre edeceÄŸimizi ve ardÄ±ndan "Binary I/O" (Ä°kili GiriÅŸ/Ã‡Ä±kÄ±ÅŸ) dÃ¼nyasÄ±na neden girmemiz gerektiÄŸini derinlemesine iÅŸliyor.

---

## 11. Dosyadan FormatlÄ± Okuma ve `operator>>` [01:30:00 - 01:33:00]

Hoca, daha Ã¶nce oluÅŸturulan `primes_100.txt` dosyasÄ±ndaki sayÄ±larÄ± tek tek Ã§ekmeyi gÃ¶steriyor.

### âš™ï¸ Teknik Detay ve Sentaks
FormatlÄ± okumada en kritik nokta, whitespace (boÅŸluk, tab, yeni satÄ±r) karakterlerinin otomatik olarak atlanmasÄ±dÄ±r.

```cpp
std::ifstream ifs("primes_100.txt"); // Default mode: std::ios::in
int x;

// Necati Hoca'nÄ±n "Condition State" KontrolÃ¼
while (ifs >> x) { 
    // ifs >> x iÅŸlemi baÅŸarÄ±lÄ± olduÄŸu sÃ¼rece (failbit set edilmediÄŸi sÃ¼rece) dÃ¶ner.
    std::cout << "Okunan asal sayi: " << x << "\n";
    // _getch(); // Hoca, akÄ±ÅŸÄ± yavaÅŸlatÄ±p gÃ¶rmek iÃ§in Windows'un getch'ini kullandÄ±.
}
```

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
DÃ¼z metin (plain text) olarak kaydedilmiÅŸ sayÄ±sal verileri, bellekteki uygun tÃ¼rlere (`int`, `double` vb.) dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in manuel parse (Ã§Ã¶zÃ¼mleme) iÅŸlemi zahmetlidir. `operator>>` bu iÅŸlemi `locale` kurallarÄ±na gÃ¶re otomatik yapar.

---

## 12. Pratik Uygulama: Dosya Karakter FrekansÄ± [01:33:00 - 01:41:00]

Hoca, bir dosyanÄ±n iÃ§indeki harflerin kaÃ§ar kez geÃ§tiÄŸini bulan ve en Ã§ok geÃ§enden en az geÃ§ene doÄŸru sÄ±ralayan teknik bir Ã¶rnek kodluyor.

### âš™ï¸ Teknik Detay ve Sentaks
Bu Ã¶rnekte `std::map`, `std::vector`, `std::pair` ve `lambda` ifadeleri bir araya getiriliyor.

```cpp
#include <map>
#include <vector>
#include <algorithm>
#include <cctype>

std::string filename;
std::cin >> filename;
std::ifstream ifs(filename); 

if (!ifs) { /* Hata KontrolÃ¼ */ }

std::map<char, int> char_map;
char c;

while (ifs.get(c)) { // FormatsÄ±z okuma: Her byte'Ä± al
    if (std::isalpha(c)) {
        char_map[std::toupper(c)]++; // BÃ¼yÃ¼k harfe Ã§evirip sayacÄ± artÄ±r
    }
}

// Map'i deÄŸere (count) gÃ¶re sÄ±ralamak iÃ§in vektÃ¶re taÅŸÄ±yoruz
std::vector<std::pair<char, int>> vec(char_map.begin(), char_map.end());

std::sort(vec.begin(), vec.end(), [](const auto& p1, const auto& p2) {
    return p1.second > p2.second; // BÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe sÄ±ralama (Descending)
});

for (const auto& [ch, count] : vec) { // C++17 Structured Binding
    std::cout << ch << " : " << count << "\n";
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Neden `std::map` iÃ§indeyken sÄ±ralama yapamadÄ±k?
**Cevap:** `std::map`, elemanlarÄ±nÄ± her zaman **Key** (anahtar) kÄ±smÄ±na gÃ¶re sÄ±ralÄ± tutar. Verilen Ã¶rnekte harflere gÃ¶re sÄ±ralÄ±dÄ±r. Adede (Value) gÃ¶re sÄ±ralamak iÃ§in veriyi bir `std::vector`'e kopyalayÄ±p orada `std::sort` Ã§alÄ±ÅŸtÄ±rmak zorundayÄ±z.

---

## 13. Fonksiyonlardan Stream Nesnesi DÃ¶ndÃ¼rme ve Move Semantics [01:41:00 - 01:49:00]

Hoca, "Stream nesneleri kopyalanamaz ama taÅŸÄ±nabilir" kuralÄ±nÄ±n pratik faydasÄ±nÄ± gÃ¶steriyor.

### âš™ï¸ Teknik Detay ve Sentaks
DosyayÄ± aÃ§an, hata kontrolÃ¼ yapan ve nesneyi dÄ±ÅŸarÄ±ya veren bir "Fabrika Fonksiyonu" (Factory Function) Ã¶rneÄŸi:

```cpp
std::ifstream open_text_file(const std::string& fname) {
    std::ifstream ifs(fname);
    if (!ifs) {
        throw std::runtime_error("Dosya acilamadi: " + fname);
    }
    return ifs; // <-- KRÄ°TÄ°K: Burada Copy deÄŸil, Move Semantics devreye girer.
}

int main() {
    // x-value (expiring value) Ã¼zerinden sahiplik devralÄ±nÄ±r.
    auto my_file = open_text_file("data.txt"); 
}
```

### ğŸ” Arka Plan (Under the Hood)
Hoca burada **`L-value to X-value Transformation`** terimini kullandÄ±. Fonksiyon iÃ§indeki yerel `ifs` nesnesi, `return` satÄ±rÄ±nda bir `x-value`'ya dÃ¶nÃ¼ÅŸÃ¼r ve dÄ±ÅŸarÄ±daki nesneye "taÅŸÄ±nÄ±r" (move). Bellek adresi ve dosya handle'Ä± deÄŸiÅŸmez, sadece sahiplik el deÄŸiÅŸtirir.

---

## 14. Binary (Ä°kili) Dosya Ä°ÅŸlemleri: `read` ve `write` [01:49:00 - 02:11:00]

Hoca, dosya iÅŸlemlerinin en "ham" ve en gÃ¼Ã§lÃ¼ kÄ±smÄ±na giriÅŸ yapÄ±yor.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
FormatlÄ± yazÄ±mda (`operator<<`), `12345` sayÄ±sÄ± dosyaya 5 karakter (5 byte) olarak yazÄ±lÄ±r. Oysa bu sayÄ± bellekte (`int`) 4 byte yer kaplar. Binary modda bellekteki 4 byte olduÄŸu gibi dosyaya kopyalanÄ±r. Bu hem hÄ±z hem de dosya boyutu aÃ§Ä±sÄ±ndan devasa avantaj saÄŸlar.

### âš™ï¸ Teknik Detay ve Sentaks: `reinterpret_cast` ZorunluluÄŸu
`write()` ve `read()` fonksiyonlarÄ± `const char*` tÃ¼rÃ¼nden parametre bekler. Elimizde `int*` veya `double*` varsa, derleyiciyi susturmak ve "bu adresteki byte'lara char gibi bak" demek iÃ§in `reinterpret_cast` kullanmak **zorunludur**.

```cpp
std::ofstream ofs("data.bin", std::ios::binary); // <-- Binary flag ÅART!
int x = 1000000;

// HATA: ofs.write(&x, sizeof(x)); // <-- Derleme hatasÄ±!
ofs.write(reinterpret_cast<const char*>(&x), sizeof(int)); 
// <-- "Bu adresten baÅŸla ve sizeof(int) kadar byte'Ä± olduÄŸu gibi transfer et"
```

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: Bellekten Dosyaya Transfer (ASCII Art)
```text
RAM (int x)          Physical Disk (data.bin)
[00001111] (byte 1) ----\     [00001111]
[10101010] (byte 2) -----\---> [10101010]
[11001100] (byte 3) -----/---> [11001100]
[00110011] (byte 4) ----/     [00110011]
      (4 Byte)                      (4 Byte)
```

### ğŸš© Kritik Nokta: VektÃ¶rÃ¼ Blok Halinde Yazmak
Bir vektÃ¶rdeki binlerce elemanÄ± dÃ¶ngÃ¼yle tek tek yazmak yerine, bellekte ardÄ±ÅŸÄ±k durduklarÄ± gerÃ§eÄŸini kullanarak tek seferde yazabiliriz:

```cpp
std::vector<int> ivek(10000, 5); // 10 bin tane 5 deÄŸeri
ofs.write(reinterpret_cast<const char*>(ivek.data()), ivek.size() * sizeof(int));
// <-- Hoca buraya yÄ±ldÄ±z koydu: ivek.data() bellekteki ilk elemanÄ±n adresini verir.
```

---

### Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik noktaya parmak bastÄ±:
1.  **Structured Binding:** C++17 ile gelen `for (const auto& [ch, count] : vec)` sentaksÄ±nÄ±n kod okunabilirliÄŸini nasÄ±l artÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶sterdi.
2.  **Map'ten VektÃ¶re GeÃ§iÅŸ:** Ä°statistiksel verileri (frekans gibi) toplarken `map`'in, bunlarÄ± sÄ±ralarken `vector`'Ã¼n avantajlÄ± olduÄŸunu ispatladÄ±.
3.  **Endianness UyarÄ±sÄ±:** Binary I/O'da verinin bellekteki haliyle yazÄ±ldÄ±ÄŸÄ±nÄ±, farklÄ± mimariler (Big Endian vs Little Endian) arasÄ±nda veri taÅŸÄ±nÄ±rken bu byte sÄ±rasÄ±nÄ±n problem yaratabileceÄŸini (ÅŸimdilik detayÄ±na girmeden) hatÄ±rlattÄ±.

Necati Hoca, dersin son bÃ¶lÃ¼mÃ¼nde binary (ikili) okuma iÅŸlemlerini tamamlÄ±yor ve gerÃ§ek hayat senaryosu olan "File Splitter" (Dosya ParÃ§alayÄ±cÄ±) projesini adÄ±m adÄ±m kodlayarak komut satÄ±rÄ± argÃ¼manlarÄ± ile dosya akÄ±ÅŸlarÄ±nÄ± birleÅŸtiriyor.

---

## 15. Binary Okuma: `read()` ve Blok Transfer [02:11:00 - 02:18:00]

Hoca, binary olarak yazÄ±lmÄ±ÅŸ veriyi tekrar belleÄŸe almanÄ±n en verimli yollarÄ±nÄ± gÃ¶steriyor.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
FormatlÄ± okuma (`operator>>`), boÅŸluklarÄ± (whitespace) atlar ve karakterleri parse etmeye Ã§alÄ±ÅŸÄ±r. Oysa binary veride her bir byte bir "deÄŸerdir". `read()` fonksiyonu, veriye hiÃ§ dokunmadan (transparan bir ÅŸekilde) diskteki byte dizilimini RAM'e kopyalar.

### âš™ï¸ Teknik Detay ve Sentaks
`read()` fonksiyonu da `write()` gibi `char*` beklediÄŸi iÃ§in `reinterpret_cast` kullanÄ±mÄ± burada da kaÃ§Ä±nÄ±lmazdÄ±r.

```cpp
std::ifstream ifs("primes.dat", std::ios::binary);
int x;

// Tek tek okuma
while (ifs.read(reinterpret_cast<char*>(&x), sizeof(int))) {
    // Okuma baÅŸarÄ±lÄ± olduÄŸu sÃ¼rece dÃ¶ngÃ¼ dÃ¶ner.
    std::cout << x << " ";
}

// Blok halinde (VektÃ¶re) okuma
std::vector<int> my_vec(100); // 100 elemanlÄ±k yer ayÄ±rdÄ±k
ifs.read(reinterpret_cast<char*>(my_vec.data()), 100 * sizeof(int));
// <-- Kritik: data() fonksiyonu L-value bir adres dÃ¶ner, bu yÃ¼zden cast edilebilir.
```

### ğŸ” Arka Plan (Under the Hood): `gcount()` HatÄ±rlatmasÄ±
Hoca, `read()` fonksiyonu Ã§aÄŸrÄ±ldÄ±ktan sonra diskte istenen miktar kadar veri kalmamÄ±ÅŸ olabileceÄŸini hatÄ±rlattÄ±. `ifs.gcount()` Ã§aÄŸrÄ±sÄ±, **gerÃ§ekte kaÃ§ byte okunduÄŸunu** verir. Bu, Ã¶zellikle dosyanÄ±n son parÃ§asÄ±nÄ± okurken hayati Ã¶nem taÅŸÄ±r.

---

## 16. BÃ¼yÃ¼k Proje: Dosya ParÃ§alayÄ±cÄ± (File Splitter) [02:18:00 - 02:30:00]

Hoca, dosyayÄ± belirtilen byte boyutlarÄ±nda parÃ§alara bÃ¶len bir komut satÄ±rÄ± aracÄ± tasarlÄ±yor.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ã‡ok bÃ¼yÃ¼k dosyalarÄ± (Ã¶rneÄŸin bir log dosyasÄ± veya bÃ¼yÃ¼k bir binary veri) network Ã¼zerinden gÃ¶ndermek veya saklamak zor olabilir. BunlarÄ± "chunk" (yÄ±ÄŸÄ±n/parÃ§a) adÄ± verilen daha kÃ¼Ã§Ã¼k dosyalara bÃ¶lmek yÃ¶netimi kolaylaÅŸtÄ±rÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks: Command Line Arguments
ProgramÄ±n `int main(int argc, char* argv[])` yapÄ±sÄ±nÄ± kullanmasÄ± gerektiÄŸini vurguladÄ±.

```cpp
int main(int argc, char* argv[]) {
    // argv[0]: ProgramÄ±n adÄ±
    // argv[1]: BÃ¶lÃ¼necek dosya yolu (string)
    // argv[2]: ParÃ§a boyutu (chunk size - string olarak gelir)

    if (argc != 3) {
        std::cerr << "Kullanim: bol_dosya <dosya_ismi> <byte_sayisi>\n";
        return 1;
    }

    // std::atoi (C fonksiyonu) veya std::stoi (C++) ile string -> int dÃ¶nÃ¼ÅŸÃ¼mÃ¼
    int chunk_size = std::atoi(argv[2]); 
}
```

---

## 17. Dosya Ä°simlerini Dinamik OluÅŸturma ve Kontrol DÃ¶ngÃ¼sÃ¼ [02:30:00 - 02:40:00]

ParÃ§a dosyalarÄ±nÄ±n `parca001.par`, `parca002.par` ÅŸeklinde otomatik isimlendirilmesi gerekiyor.

### âš™ï¸ Teknik Detay ve Sentaks: `ostringstream` ve `setfill`
Hoca, dosya isimlerini formatlamak iÃ§in `iomanip` manipÃ¼latÃ¶rlerini bir `string stream` Ã¼zerinde kullandÄ±:

```cpp
std::ostringstream oss;
int file_count = 0;

// ... dÃ¶ngÃ¼ iÃ§inde her yeni parÃ§a dosyasÄ± iÃ§in ...
oss << "parca" << std::setw(3) << std::setfill('0') << (file_count + 1) << ".par";
std::string new_filename = oss.str(); 
// "parca001.par" sonucunu verir.

std::ofstream ofs(new_filename, std::ios::binary);
```

### ğŸ” Arka Plan (Under the Hood): Stream Resetleme
Hoca dÃ¶ngÃ¼ iÃ§inde `ostringstream` kullanÄ±rken Ã§ok kritik bir noktaya deÄŸindi: `oss.str("")` Ã§aÄŸrÄ±sÄ± yapÄ±lmazsa, bir sonraki isim eskisinin Ã¼zerine eklenir (`parca001.parparca002.par` gibi). Bu yÃ¼zden her dosya deÄŸiÅŸiminde tampon temizlenmelidir.

### ğŸš© Kritik Nokta: ParÃ§alÄ± Yazma AlgoritmasÄ±
Hoca algoritmanÄ±n ana hatlarÄ±nÄ± ÅŸÃ¶yle Ã§izdi:
1. Kaynak dosyayÄ± binary okuma modunda aÃ§.
2. Hedef `ofstream` nesnesini oluÅŸtur ama henÃ¼z bir dosya aÃ§ma.
3. Her byte'Ä± oku:
    *   EÄŸer `ofs` ÅŸu an bir dosya aÃ§Ä±k tutmuyorsa (`is_open()`), yeni bir isim oluÅŸtur ve `open()` yap.
    *   Byte'Ä± `put()` ile yaz.
    *   YazÄ±lan byte sayÄ±sÄ± `chunk_size`'a ulaÅŸtÄ±ysa `ofs.close()` yap ve isim sayacÄ±nÄ± artÄ±r.

```cpp
char c;
long byte_counter = 0;
while (ifs.get(c)) { // Kaynaktan oku
    if (!ofs.is_open()) {
        // Yeni dosya ismini oluÅŸtur ve ofs.open(...) yap
    }
    ofs.put(c);
    byte_counter++;
    
    if (byte_counter % chunk_size == 0) {
        ofs.close(); // ParÃ§a bitti, kapat.
    }
}
```

---

## 18. KapanÄ±ÅŸ ve Gelecek Ders NotlarÄ± [02:40:00 - 02:41:53]

Hoca, bir sonraki derste bu parÃ§alarÄ± birleÅŸtirecek olan "Joiner" programÄ±nÄ± yazacaÄŸÄ±mÄ±zÄ± ve ardÄ±ndan **Concurrency** (EÅŸzamanlÄ±lÄ±k/Ã‡oklu Ä°ÅŸ ParÃ§acÄ±ÄŸÄ±) konularÄ±na giriÅŸ yapacaÄŸÄ±mÄ±zÄ± belirtti.

### ğŸš© Bu BÃ¶lÃ¼mÃ¼n 3 Kritik MÃ¼hendislik Notu:
1.  **`std::atoi` GÃ¼venliÄŸi:** Hoca pratiklik iÃ§in `atoi` kullandÄ± ancak gerÃ§ek projelerde hata kontrolÃ¼ iÃ§in `std::stoi` (exception fÄ±rlatÄ±r) veya `std::from_chars` (C++17) daha gÃ¼venlidir.
2.  **`is_open()` Fonksiyonu:** DÃ¶ngÃ¼ iÃ§inde stream nesnesinin bir dosyaya baÄŸlÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol etmenin en saÄŸlam yolu `ofs.is_open()` metodudur.
3.  **Performance Tip:** Byte-byte okumak (`get/put`) bÃ¼yÃ¼k dosyalarda yavaÅŸtÄ±r. Hoca eÄŸitim amaÃ§lÄ± bunu gÃ¶sterdi; gerÃ§ekte `read()` ve `write()` ile blok transferi yapÄ±lmalÄ±dÄ±r.

---
**Necati Hoca'nÄ±n Notu:** "GeÃ§en hafta acil bir iÅŸten dolayÄ± yapamadÄ±ÄŸÄ±mÄ±z dersi telafi edeceÄŸiz. Eksik konularÄ± gerekirse ek videolarla tamamlayÄ±p kurs sistemine yÃ¼kleyeceÄŸim."

ğŸ“Œ **Transkript sona erdi.** Dosya Ä°ÅŸlemleri ve Command Line Tools bÃ¶lÃ¼mleri tamamlanmÄ±ÅŸtÄ±r. Devam edecek bir transkript bulunmamaktadÄ±r.