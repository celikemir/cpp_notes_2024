Merhaba deÄŸerli hocam, en Ã¶n sÄ±radaki yerimi aldÄ±m. NotlarÄ±mÄ± sizin anlatÄ±m tarzÄ±nÄ±zla, teknik derinliÄŸi ve nÃ¼anslarÄ± kaÃ§Ä±rmadan "yeniden inÅŸa ederek" tutmaya baÅŸlÄ±yorum. 54. dersin (8 Ocak 2025) ilk teknik incelemesi aÅŸaÄŸÄ±dadÄ±r.

---

# Ders 54: Literal Operators (User-Defined Literals) ve I/O Stream GiriÅŸ

Bu dersin odak noktasÄ±, C++11 ile hayatÄ±mÄ±za giren ve Modern C++ kÃ¼tÃ¼phanelerinde (string, chrono, complex) yoÄŸun olarak kullanÄ±lan **Literal Operators** (ProgramcÄ± tarafÄ±ndan oluÅŸturulan sabitler) ve ardÄ±ndan C++'Ä±n en kapsamlÄ± kÃ¼tÃ¼phanelerinden biri olan **I/O Stream** yapÄ±sÄ±dÄ±r.

---

## 1. Sabitler (Literals) ve Suffix (Son Ek) KavramÄ± [02:20 - 05:32]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C ve C++ dillerinde, derleyici bir sabit gÃ¶rdÃ¼ÄŸÃ¼nde (Ã¶rneÄŸin `35`), bu sabitin tÃ¼rÃ¼ne varsayÄ±lan kurallarla karar verir. Ancak bazen derleyiciye bu sabitin tÃ¼rÃ¼nÃ¼ (Ã¶rneÄŸin `unsigned int` veya `long double`) aÃ§Ä±kÃ§a sÃ¶ylememiz gerekir. Bu durum Ã¶zellikle **Function Overloading Resolution** (Fonksiyon yÃ¼kleme Ã§Ã¶zÃ¼mlenmesi) aÅŸamasÄ±nda hayati Ã¶nem taÅŸÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
*   **C Terminolojisi:** Constant (Sabit).
*   **C++ Terminolojisi:** Literal (Sabit).

**Tam SayÄ± Sabitleri (Integer Literals):**
```cpp
auto a = 35;     // int
auto b = 35U;    // unsigned int
auto c = 35L;    // long int
auto d = 35ULL;  // unsigned long long
auto e = 0b101;  // binary literal (C++14 ile standart oldu) <-- Hoca: Eskiden extension idi.
```

**GerÃ§ek SayÄ± Sabitleri (Floating Point Literals):**
```cpp
auto f = 3.14;   // double (nokta iÃ§eriyorsa varsayÄ±lan budur)
auto g = 3.14f;  // float
auto h = 3.14L;  // long double
```

---

## 2. Literal Operators: GiriÅŸ [05:32 - 11:12]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
`std::string s = "ahmet";` yazdÄ±ÄŸÄ±mÄ±zda, saÄŸ taraf aslÄ±nda bir `const char*`dÄ±r (C string). Buradan bir `std::string` nesnesi oluÅŸturmak iÃ§in bir **Conversion Constructor** (DÃ¶nÃ¼ÅŸtÃ¼rme kurucusu) Ã§aÄŸrÄ±lÄ±r. Ancak bazen bir ifadeyi doÄŸrudan bir sÄ±nÄ±f tÃ¼rÃ¼nden "sabitmiÅŸ gibi" kullanmak isteriz.

### âš™ï¸ Teknik Detay ve Sentaks
Standart kÃ¼tÃ¼phane, `std::literals` namespace'i altÄ±nda birÃ§ok operatÃ¶r sunar:

```cpp
using namespace std::literals; // Gerekli namespace bildirimi

auto s = "ahmet"s;     // operator""s Ã§aÄŸrÄ±lÄ±r, tÃ¼rÃ¼ std::string
auto sv = "ahmet"sv;   // operator""sv Ã§aÄŸrÄ±lÄ±r, tÃ¼rÃ¼ std::string_view
auto ms = 100ms;       // operator""ms Ã§aÄŸrÄ±lÄ±r (chrono kÃ¼tÃ¼phanesi)
```

### ğŸ” Arka Plan (Under the Hood)
Derleyici `"ahmet"s` ifadesini gÃ¶rdÃ¼ÄŸÃ¼nde bunu ÅŸu fonksiyon Ã§aÄŸrÄ±sÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r:
`operator""s("ahmet", 5);` // <-- Arka planda bir fonksiyon Ã§aÄŸrÄ±sÄ±dÄ±r.

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Bir Literal Operator fonksiyonu `constexpr` olabilir mi?
**Cevap:** Evet, olabilir veya olmayabilir. EÄŸer fonksiyon `constexpr` tanÄ±mlanmÄ±ÅŸsa (string literal operatÃ¶rlerinde olduÄŸu gibi), bu ifadeden elde edilen sonuÃ§ `constexpr` bir deÄŸiÅŸkene ilk deÄŸer (initializer) olarak verilebilir.

---

## 3. Kendi Literal OperatÃ¶rlerimizi TanÄ±mlama (Cooked Literals) [11:12 - 19:42]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Kendi sÄ±nÄ±flarÄ±mÄ±z iÃ§in (Ã¶rneÄŸin bir `Date` veya `Distance` sÄ±nÄ±fÄ±) okunabilirliÄŸi artÄ±rmak amacÄ±yla `10.5_km` veya `10_05_1987_dt` gibi yazÄ±mlarÄ± desteklemek isteriz.

### âš™ï¸ Teknik Detay ve Sentaks
Kendi operatÃ¶rlerimizi yazarken uymamÄ±z gereken **en kritik kural**:
*   **Suffix (Son ek) mutlaka `_` (underscore) ile baÅŸlamalÄ±dÄ±r!** [14:46]
*   `_` ile baÅŸlamayan son ekler standart kÃ¼tÃ¼phane iÃ§in rezerve edilmiÅŸtir.

**Cooked (PiÅŸmiÅŸ) Literal:** Derleyicinin sabiti doÄŸrudan ilgili tÃ¼re dÃ¶nÃ¼ÅŸtÃ¼rÃ¼p argÃ¼man olarak geÃ§tiÄŸi operatÃ¶rlerdir.

```cpp
// Metre cinsinden mesafe hesaplayan cooked literal operatÃ¶rÃ¼
constexpr double operator""_m(long double val) {
    return static_cast<double>(val); // <-- Hoca: Narrowing conversion'dan kaÃ§Ä±nmak iÃ§in cast kullanÄ±n.
}

constexpr double operator""_cm(long double val) {
    return static_cast<double>(val) / 100.0;
}

constexpr double operator""_km(long double val) {
    return static_cast<double>(val) * 1000.0;
}

// KullanÄ±m:
auto dist = 1.0_km + 500.0_m + 250.0_cm; // Hepsi metreye dÃ¶nÃ¼ÅŸÃ¼r, sonuÃ§ double olur. [27:53]
```

### ğŸ” Arka Plan (Cooked vs Uncooked) [15:59 - 19:42]
1.  **Cooked (PiÅŸmiÅŸ):** ArgÃ¼man olarak `long double`, `unsigned long long`, `char`, veya `const char*, size_t` (stringler iÃ§in) alÄ±r. DeÄŸer Ã¶nceden parse edilmiÅŸtir.
2.  **Uncooked (PiÅŸmemiÅŸ):** ArgÃ¼man olarak sadece `const char*` alÄ±r. SayÄ±sal ifade `"1234"` gibi bir yazÄ± olarak fonksiyona gelir. Fonksiyonun iÃ§inde bu yazÄ±yÄ± biz parse ederiz.

---

## 4. Pratik Ã–rnekler: Bellek Birimleri ve Date SÄ±nÄ±fÄ± [29:10 - 55:00]

Hoca bu bÃ¶lÃ¼mde Literal operatÃ¶rlerin sadece matematiksel dÃ¶nÃ¼ÅŸÃ¼m deÄŸil, karmaÅŸÄ±k nesne inÅŸasÄ± iÃ§in de kullanÄ±labileceÄŸini gÃ¶sterdi.

```cpp
// Kilobayt/Megabayt hesaplamasÄ±
constexpr size_t operator""_KB(unsigned long long val) {
    return val * 1024;
}

constexpr size_t operator""_MB(unsigned long long val) {
    return val * 1024 * 1024;
}

// KullanÄ±m Ã¶rneÄŸi (Buffer oluÅŸturma):
std::array<unsigned char, 16_KB> myBuffer; // <-- Hoca: Ne kadar okunabilir deÄŸil mi? [39:10]
```

**Date Ã–rneÄŸi (String ArgÃ¼manlÄ± UDL):**
```cpp
// "23-05-1987"_dt yazÄ±mÄ± iÃ§in
Date operator""_dt(const char* str, size_t len) {
    return Date(str); // Date sÄ±nÄ±fÄ±nÄ±n string parametreli kurucusunu Ã§aÄŸÄ±rÄ±r. [43:26]
}

// MÃ¼lakat Sorusu: Bu fonksiyonu ismiyle nasÄ±l Ã§aÄŸÄ±rÄ±rÄ±z? [47:04]
auto d = operator""_dt("12-12-1987", 10); // <-- Explicit Ã§aÄŸrÄ±. UzunluÄŸu elle geÃ§mek zorunlu.
```

---

## 5. Uncooked Literals: Binary Parser Ã–rneÄŸi [55:00 - 01:09:00]

### âš™ï¸ Teknik Detay ve Sentaks
Uncooked literallarda, sayÄ±sal bir sabit yazsak bile derleyici bunu bize bir `const char*` olarak iletir. Bu, dile olmayan sayÄ± sistemlerini (Ã¶rneÄŸin Custom Binary) eklemek iÃ§in harikadÄ±r.

```cpp
// Uncooked Literal: Bir yazÄ±yÄ± sayÄ±ya dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.
unsigned int operator""_b(const char* p) {
    unsigned int val = 0;
    while (*p) {
        if (*p != '0' && *p != '1') 
            throw std::runtime_error("Invalid binary character!"); // <-- Hata yakalama [59:40]
        val = val * 2 + (*p - '0');
        ++p;
    }
    return val;
}

auto x = 1011_b; // operator""_b("1011") Ã§aÄŸrÄ±lÄ±r. SonuÃ§ 11 olur.
```

---

### ğŸ•’ [00:00 - 01:10] ArasÄ± Kritik Ã–zet:
1.  **Literal vs Constant:** C++ terminolojisinde "Literal" tercih edilir.
2.  **Naming:** KullanÄ±cÄ± tanÄ±mlÄ± operatÃ¶rlerin `_` (alt tire) ile baÅŸlamasÄ± zorunludur. `operator""s` gibi isimler standart kÃ¼tÃ¼phaneye aittir.
3.  **Parameter Rules:** Cooked floatlar iÃ§in `long double`, tam sayÄ±lar iÃ§in `unsigned long long` parametre tÃ¼rleri zorunludur. FarklÄ± tÃ¼rler (Ã¶rn: `int` veya `float`) derleme hatasÄ±na yol aÃ§ar. [13:00]
4.  **Flexible Return Type:** OperatÃ¶rÃ¼n geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ programcÄ±ya baÄŸlÄ±dÄ±r; `int`, `double` veya bir sÄ±nÄ±f nesnesi (Ã¶rn: `Date`) dÃ¶nebilir.

---

## 6. I/O Stream KÃ¼tÃ¼phanesine GiriÅŸ [01:10:00 - 01:25:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C'deki `printf/scanf` ailesi **Type Safety** (TÃ¼r gÃ¼venliÄŸi) sunmaz ve geniÅŸletilemez (extensible deÄŸildir). `iostream`, nesne yÃ¶nelimli ve generic bir yapÄ± sunarak her tÃ¼r iÃ§in giriÅŸ-Ã§Ä±kÄ±ÅŸ iÅŸlemlerini standartlaÅŸtÄ±rÄ±r.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme: Stream Analojisi [01:12:00]
Hoca stream'i bir "boruya" benzetti:
```text
DÄ±ÅŸ DÃ¼nya (Klavye/Dosya) ----> [ Buffer ] ----> Program (Input Stream)
Program (Output Stream) ----> [ Buffer ] ----> DÄ±ÅŸ DÃ¼nya (Ekran/Dosya)
```

### ğŸ” Arka Plan (Under the Hood)
C++ stream yapÄ±sÄ± aslÄ±nda bir **Template Specialization** (Åablon Ã¶zelleÅŸmesi) grubudur:
*   `std::ostream` aslÄ±nda `std::basic_ostream<char>`'dÄ±r.
*   `std::istream` aslÄ±nda `std::basic_istream<char>`'dÄ±r.

---

### ğŸ”— [01:25:00 - 01:33:00] KÃ¼mÃ¼latif BaÄŸlantÄ±: KalÄ±tÄ±m HiyerarÅŸisi
I/O Stream hiyerarÅŸisi, C++'Ä±n karmaÅŸÄ±k kalÄ±tÄ±m Ã¶zelliklerini (Multiple Inheritance ve Virtual Inheritance) bir arada kullanan nadir yapÄ±lardan biridir.

**SÄ±nÄ±f HiyerarÅŸisi (ASCII Art):**
```text
          ios_base (En tepedeki taban sÄ±nÄ±f - Template deÄŸil)
              |
          basic_ios<char> (Template sÄ±nÄ±f)
          /             \
  basic_istream      basic_ostream
        \               /
         basic_iostream (Multiple Inheritance + Virtual Inheritance)
```
*   **Virtual Inheritance:** `basic_iostream` nesnesinde sadece bir tane `ios_base` nesnesi olmasÄ± iÃ§in kullanÄ±lÄ±r (Diamond Problem Ã§Ã¶zÃ¼mÃ¼). [01:32:50]

---

HaklÄ±sÄ±nÄ±z hocam, hÄ±zÄ± dÃ¼ÅŸÃ¼rÃ¼yor ve her bir detayÄ± adeta bir nakÄ±ÅŸ gibi iÅŸleyerek "yeniden inÅŸa etmeye" devam ediyorum. I/O Stream kÃ¼tÃ¼phanesinin o devasa mimarisini, Necati Hoca'nÄ±n deyimiyle "hantal ama gÃ¼Ã§lÃ¼" yapÄ±sÄ±nÄ± incelemeye kaldÄ±ÄŸÄ±mÄ±z yerden devam ediyoruz.

---

## 7. Stream SÄ±nÄ±flarÄ± ve "Perde Gerisindeki Kahraman": Streambuf [01:34:00 - 01:41:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
GiriÅŸ-Ã§Ä±kÄ±ÅŸ iÅŸlemleri sadece ekrana yazÄ± basmak deÄŸildir. Verinin kaynaÄŸÄ± (Source) veya hedefi (Sink) bir dosya, bellek alanÄ± (string) veya bir network soketi olabilir. TÃ¼m bu farklÄ± donanÄ±mlarÄ± tek bir arayÃ¼zle (Interface) yÃ¶netebilmek iÃ§in hiyerarÅŸik bir yapÄ± ÅŸarttÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, stream hiyerarÅŸisindeki sÄ±nÄ±flarÄ±n gÃ¶revlerini netleÅŸtirdi:

*   **`std::basic_ostream`:** Ã‡Ä±kÄ±ÅŸ (Output) iÅŸlemlerinin tepesindeki sÄ±nÄ±ftÄ±r.
*   **`std::basic_ostringstream`:** Ã‡Ä±kÄ±ÅŸÄ± belleÄŸe (bir stringe) yapmak iÃ§in kullanÄ±lÄ±r (**In-Memory I/O**). [01:34:36]
*   **`std::basic_ofstream`:** Ã‡Ä±kÄ±ÅŸÄ± bir dosyaya (File) yapmak iÃ§in kullanÄ±lÄ±r.
*   **`std::basic_iostream`:** Hem okuma hem yazma yeteneÄŸine sahip olan, **Multiple Inheritance** (Ã‡oklu KalÄ±tÄ±m) ile hem `istream` hem `ostream` olan sÄ±nÄ±ftÄ±r. [01:35:36]

### ğŸ” Arka Plan (Under the Hood)
Hoca burada Ã§ok kritik bir noktaya parmak bastÄ±: **Buffer SÄ±nÄ±flarÄ±**. [01:36:30]
Stream sÄ±nÄ±flarÄ± (cin, cout vb.) aslÄ±nda sadece birer arayÃ¼zdÃ¼r. Ä°ÅŸlemleri asÄ±l yÃ¼rÃ¼ten, veriyi tamponlayan "perde gerisindeki gerÃ§ek kahraman" **`std::streambuf`** (veya `std::basic_streambuf`) sÄ±nÄ±fÄ±dÄ±r.
*   Her stream nesnesi, iÃ§inde bir `streambuf` nesnesine iÅŸaret eden bir pointer tutar.

---

## 8. Nesnenin "Durumu": Stream State ve Formatting State [01:41:00 - 01:54:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir `std::cout` nesnesi programÄ±n baÅŸÄ±ndan sonuna kadar aynÄ±dÄ±r ancak davranÄ±ÅŸlarÄ± deÄŸiÅŸebilir. Ã–rneÄŸin, bir yerde sayÄ±larÄ± 10'luk sistemde basarken, baÅŸka bir yerde 16'lÄ±k (hex) sistemde basmasÄ±nÄ± isteyebiliriz. Bu davranÄ±ÅŸlarÄ± yÃ¶neten ÅŸey nesnenin **State**'idir (Durum). [01:41:50]

### âš™ï¸ Teknik Detay ve Sentaks
Stream nesnesinin durumu iki ana kategoriye ayrÄ±lÄ±r:
1.  **Condition State (Hata Durumu):** AkÄ±m aÃ§Ä±k mÄ±, hata var mÄ± (eof, fail, bad)? (Bu konuya sonra girilecek).
2.  **Formatting State (Formatlama Durumu):** Verinin nasÄ±l "yazÄ± haline" getirileceÄŸini belirleyen durum. [01:42:00]

**On-Off BayraklarÄ± (On-Off Flags):**
Hoca, bu bayraklarÄ±n sadece iki seÃ§eneÄŸi (True/False) olduÄŸunu belirtti.

| Bayrak Ä°smi | GÃ¶revi |
| :--- | :--- |
| `boolalpha` | `true/false` deÄŸerlerini `1/0` yerine yazÄ± olarak basar. |
| `uppercase` | Hexadecimal sayÄ±larda `0x` ve harfleri bÃ¼yÃ¼k basar. |
| `showpos` | Pozitif sayÄ±larÄ±n baÅŸÄ±na `+` iÅŸareti koyar. |
| `showbase` | SayÄ± sisteminin Ã¶nekini (`0x`, `0`) gÃ¶sterir. |
| `showpoint` | OndalÄ±k kÄ±sÄ±m `0` olsa bile noktayÄ± basar (Ã¶rn: `3.0`). |
| `skipws` | GiriÅŸ iÅŸlemlerinde beyaz boÅŸluk (whitespace) karakterlerini atlar. |

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu [01:44:40]
**Soru:** Stream formatlama Ã¶zellikleri kalÄ±cÄ± mÄ±dÄ±r?
**Cevap:** **Evet**, `std::setw` (width) hariÃ§ tÃ¼m formatlama Ã¶zellikleri nesnenin state'inde saklanÄ±r ve siz deÄŸiÅŸtirene kadar kalÄ±cÄ±dÄ±r. Bir kez `boolalpha` yaptÄ±ysanÄ±z, akÄ±m sonlanana kadar tÃ¼m booleanlar yazÄ± olarak basÄ±lÄ±r.

---

## 9. Bitsel Maskeler ve `std::ios_base::fmtflags` [01:54:00 - 02:04:00]

### ğŸ” Arka Plan (Under the Hood)
Necati Hoca, bu formatlama bilgilerinin bellekte nasÄ±l tutulduÄŸunu bir mÃ¼hendislik perspektifiyle aÃ§Ä±kladÄ±. [01:55:40]

*   HiyerarÅŸinin en tepesindeki `std::ios_base` sÄ±nÄ±fÄ± iÃ§inde `fmtflags` adÄ±nda bir **Type Alias** (tÃ¼reÅŸ isim) tanÄ±mlÄ±dÄ±r.
*   Bu genellikle bir tam sayÄ± tÃ¼rÃ¼dÃ¼r (Ã¶rn: `int`).
*   Her bir formatlama Ã¶zelliÄŸi (boolalpha, hex, vb.) bu tam sayÄ±nÄ±n **tek bir bitine** karÅŸÄ±lÄ±k gelen bir **Maske**'dir.

**HocanÄ±n ASCII Art ile AnlattÄ±ÄŸÄ± KayÄ±t (Register) MantÄ±ÄŸÄ±:**
```text
Bit No:  [7] [6] [5] [4] [3] [2] [1] [0]
AnlamÄ±:  ... [Uppercase] [Showpos] [Boolalpha] ...
DeÄŸer:    0     1         0          1   (Ã–rn: Uppercase ve Boolalpha aktif)
```

**Maskelerin Bitsel Ä°ncelemesi (Hoca TarafÄ±ndan GÃ¶sterilen Kod):** [01:58:30]
```cpp
#include <iostream>
#include <bitset>

void bit_inceleme() {
    // Hoca: std::ios_base::boolalpha bir maskedir.
    std::cout << std::bitset<32>(std::ios_base::boolalpha) << std::endl;
    // Ã‡Ä±ktÄ±da sadece tek bir bitin 1 olduÄŸunu gÃ¶rÃ¼rÃ¼z.
}
```

---

## 10. BayraklarÄ± YÃ¶netmek: `setf` ve `unsetf` [02:00:00 - 02:10:00]

### âš™ï¸ Teknik Detay ve Sentaks
BayraklarÄ± manuel olarak (manipÃ¼latÃ¶r kullanmadan) deÄŸiÅŸtirmek iÃ§in `setf` (set flags) ve `unsetf` (unset flags) fonksiyonlarÄ± kullanÄ±lÄ±r.

```cpp
bool b = true;
std::cout << b << "\n"; // Ã‡Ä±ktÄ±: 1 (Default durum)

// <-- Hoca: BayraÄŸÄ± set ediyoruz.
std::cout.setf(std::ios_base::boolalpha); // Bitwise OR iÅŸlemi yapar.
std::cout << b << "\n"; // Ã‡Ä±ktÄ±: true

// <-- Hoca: BayraÄŸÄ± reset ediyoruz.
std::cout.unsetf(std::ios_base::boolalpha); // Bitwise AND NOT iÅŸlemi yapar.
std::cout << b << "\n"; // Ã‡Ä±ktÄ±: 1
```

### ğŸ” Arka Plan (Under the Hood)
Hoca, `setf` ve `unsetf` fonksiyonlarÄ±nÄ±n iÃ§sel olarak ne yaptÄ±ÄŸÄ±nÄ± matematiksel olarak aÃ§Ä±kladÄ±: [02:08:00]

*   `setf(mask)` $\rightarrow$ `current_flags |= mask;` (Ä°lgili biti 1 yapar)
*   `unsetf(mask)` $\rightarrow$ `current_flags &= ~mask;` (Ä°lgili biti 0 yapar)

**Kritik Fonksiyon: `flags()`**
Stream nesnesinin o anki tÃ¼m formatlama durumunu bir bÃ¼tÃ¼n olarak almak veya tamamen yeni bir deÄŸer atamak iÃ§in kullanÄ±lÄ±r:
```cpp
auto old_flags = std::cout.flags(); // Mevcut durumu yedekle. [02:05:30]
std::cout.flags(std::ios_base::hex | std::ios_base::showbase); // TÃ¼m bitleri ez ve yenilerini yaz.
// ... iÅŸlemler ...
std::cout.flags(old_flags); // Eski haline geri dÃ¶ndÃ¼r. <-- Hoca: GÃ¼venli yol budur!
```

---

## 11. Ã‡ok SeÃ§enekli Bayraklar ve "Field" KavramÄ± [02:10:00 - 02:24:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
SayÄ± sistemleri (Dec, Hex, Oct) gibi Ã¶zellikler birbirini dÄ±ÅŸlayan (mutually exclusive) Ã¶zelliklerdir. Bir sayÄ± aynÄ± anda hem 10'luk hem 16'lÄ±k basÄ±lamaz. EÄŸer sadece `setf(hex)` yaparsak ve Ã¶nceden `dec` bit'i de 1 ise, "iki bit birden 1" olur ve bu karmaÅŸaya yol aÃ§ar. [02:14:00]

### âš™ï¸ Teknik Detay ve Sentaks
Bu sorunu Ã§Ã¶zmek iÃ§in `setf` fonksiyonunun **iki parametreli** overload'u kullanÄ±lÄ±r. [02:16:00]

*   **1. Parametre:** Set edilecek bayrak (mask).
*   **2. Parametre:** Temizlenecek alan (**Field**).

**Standart Field GruplarÄ±:**
1.  `std::ios_base::basefield`: `hex`, `dec` ve `oct` bayraklarÄ±nÄ± kapsar.
2.  `std::ios_base::adjustfield`: `left`, `right` ve `internal` bayraklarÄ±nÄ± kapsar.
3.  `std::ios_base::floatfield`: `scientific` ve `fixed` bayraklarÄ±nÄ± kapsar.

**Ã–rnek Uygulama (DoÄŸru KullanÄ±m):**
```cpp
int val = 100;
// YanlÄ±ÅŸ: std::cout.setf(std::ios_base::hex); // <-- Hoca: Ã–nceki bitler temizlenmeyebilir!

// DoÄŸru (Hoca buraya vurgu yaptÄ±): [02:16:40]
std::cout.setf(std::ios_base::hex, std::ios_base::basefield); 
// Arka plan: basefield alanÄ±ndaki tÃ¼m bitleri (dec, oct, hex) sÄ±fÄ±rla, sonra hex'i birle.
std::cout << val; // Ã‡Ä±ktÄ±: 64
```

### ğŸš© Kritik Nokta: HatalÄ± MantÄ±k ve UB [02:20:46]
Hoca, Alihan'Ä±n sorusu Ã¼zerine: EÄŸer `basefield` kullanmadan hem `dec` hem `hex` bitlerini 1 yaparsanÄ±z, standart genellikle `dec` (10'luk) sistemin Ã¶ncelikli olduÄŸunu ve onu basacaÄŸÄ±nÄ± sÃ¶yler. Ancak bu taÅŸÄ±nabilir ve temiz bir kod deÄŸildir.

---

## 12. Alan GeniÅŸliÄŸi ve Hizalama (Width, Fill, Alignment) [02:24:00 - 02:39:04]

### âš™ï¸ Teknik Detay ve Sentaks
Stream'de verilerin tablolaÅŸtÄ±rÄ±lmasÄ± iÃ§in kullanÄ±lan 3 temel ayar vardÄ±r:

**1. `width()` (GeniÅŸlik):** [02:24:40]
*   YazÄ±lacak verinin minimum kaÃ§ karakterlik alan kaplayacaÄŸÄ±nÄ± belirler.
*   **Ã–NEMLÄ°:** Sadece bir sonraki yazma iÅŸlemi iÃ§in geÃ§erlidir, sonra sÄ±fÄ±rlanÄ±r! (Tek istisna budur).
```cpp
std::cout.width(10);
std::cout << 123; // "       123" (Ã–nÃ¼nde 7 boÅŸluk var)
std::cout << 456; // "456" (Width sÄ±fÄ±rlandÄ±!)
```

**2. `fill()` (Doldurma Karakteri):** [02:26:40]
*   GeniÅŸlikten artan boÅŸluklara ne yazÄ±lacaÄŸÄ±nÄ± belirler. VarsayÄ±lan boÅŸluktur.
```cpp
std::cout.fill('*');
std::cout.width(10);
std::cout << 123; // "*******123"
```

**3. Alignment (Hizalama):** [02:27:52]
*   `std::ios_base::left`: Sola dayalÄ±.
*   `std::ios_base::right`: SaÄŸa dayalÄ± (Default).
*   `std::ios_base::internal`: Ä°ÅŸaret (`+`/`-`) veya Ã¶nek (`0x`) baÅŸta, sayÄ± sonda, boÅŸluklar ortada. [02:30:18]

**Hoca'nÄ±n "AyÄ±p" Olarak NitelediÄŸi Eksiklik:** [02:28:34]
Standart `iostream` kÃ¼tÃ¼phanesinde **ortalama (center alignment)** Ã¶zelliÄŸi yoktur! Bu ancak C++20 `std::format` ile gelmiÅŸtir.

**Internal Hizalama Ã–rneÄŸi:** [02:32:00]
```cpp
std::cout.setf(std::ios_base::internal, std::ios_base::adjustfield);
std::cout.setf(std::ios_base::showpos);
std::cout.width(10);
std::cout << 123; // Ã‡Ä±ktÄ±: "+      123" (Hoca: Ä°ÅŸaret en baÅŸta, sayÄ± en sonda!)
```

---

### ğŸ•’ [01:34:00 - 02:39:04] ArasÄ± Kritik Ã–zet:
1.  **HiyerarÅŸi:** `ios_base` (Genel ayarlar) $\rightarrow$ `basic_ios` (AkÄ±m ayarlarÄ±) $\rightarrow$ `ostream/istream`.
2.  **State YÃ¶netimi:** `setf(mask)` on-off bayraklarÄ± iÃ§in, `setf(mask, field)` grup bayraklarÄ± iÃ§in kullanÄ±lÄ±r.
3.  **KalÄ±cÄ±lÄ±k:** `width()` tek atÄ±mlÄ±ktÄ±r, diÄŸer tÃ¼m ayarlar (`fill`, `hex`, `boolalpha` vb.) kalÄ±cÄ±dÄ±r.
4.  **Hizalama:** `left`, `right` ve egzotik bir seÃ§enek olan `internal` mevcuttur. Ortalama yoktur.

---

ğŸ“Œ **Dersin Sonu.** Transkriptin sonuna kadar ([02:39:04]) tÃ¼m teknik detaylar Necati Ergin hocamÄ±zÄ±n anlatÄ±m Ã¼slubu ve derinliÄŸiyle notlandÄ±rÄ±lmÄ±ÅŸtÄ±r. Hoca dersi iyi akÅŸamlar dileyerek bitirmiÅŸtir. BaÅŸka bir transkriptiniz veya sorunuz varsa hazÄ±r bekliyorum hocam. 

**Not:** Hoca dersi bitirirken "Bir dahaki hafta dosya iÅŸlemlerine kadar gelmeyi planlÄ±yorum" demiÅŸtir. [02:38:40]

