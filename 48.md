Merhaba, Necati Hoca'nÄ±n 48. dersini en Ã¶n sÄ±radan, her zamanki titizliÄŸimle not aldÄ±m. HocamÄ±zÄ±n "Ã–zetleme, yeniden inÅŸa et!" prensibiyle, dersteki tÃ¼m teknik nÃ¼anslarÄ±, derleyici hatalarÄ±nÄ± ve o meÅŸhur "buraya dikkat" uyarÄ±larÄ±nÄ± dokÃ¼mante ettim.

---

# ğŸ“‘ C++ Ders NotlarÄ±: Genel Fonksiyon AdaptÃ¶rleri ve `std::bind` Derinlemesi
**Tarih:** 16 AralÄ±k 2024  
**Ders:** 48  
**Konu:** `std::bind`, `std::mem_fn`, `std::function` ve STL AlgoritmalarÄ±  
**Zaman DamgasÄ±:** [00:00.000 --> 31:34.000]

## 1. Modern C++ Ã–ncesi ve SonrasÄ± AdaptÃ¶r YapÄ±sÄ±
Hoca sÃ¶ze modern C++'tan Ã¶nce hayatÄ±mÄ±zÄ±n ne kadar zor olduÄŸunu hatÄ±rlatarak baÅŸladÄ±. Eskiden `bind1st`, `bind2nd` gibi 6-7 tane hantal adaptÃ¶r vardÄ±. Bunlar Ã¶nce *deprecated* (artÄ±k kullanÄ±lmÄ±yor) edildi, sonra tamamen kaldÄ±rÄ±ldÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
FarklÄ± parametre sayÄ±larÄ±na veya tÃ¼rlerine sahip *Callable* (Ã§aÄŸrÄ±labilir) varlÄ±klarÄ±, belirli bir arayÃ¼z bekleyen (Ã¶rneÄŸin tek parametre bekleyen bir STL algoritmasÄ±) yapÄ±lara uyumlu hale getirmek iÃ§in bir "ara katman" gerekiyordu.

### ğŸ” Arka Plan (Under the Hood)
`std::bind` genel bir fonksiyon adaptÃ¶rÃ¼dÃ¼r. Bir *Callable* varlÄ±ÄŸÄ± sarmalar ve bize bir *Function Object* (fonksiyon nesnesi) dÃ¶ndÃ¼rÃ¼r. Bu dÃ¶nen nesnenin `operator()` fonksiyonunu Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±zda, aslÄ±nda sarmaladÄ±ÄŸÄ±mÄ±z asÄ±l fonksiyonu bizim yerimize "adapte edilmiÅŸ" argÃ¼manlarla Ã§aÄŸÄ±rÄ±r.

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
| Ã–zellik | C++98 / 03 | C++11 / 14 / 17 |
| :--- | :--- | :--- |
| AdaptÃ¶rler | `bind1st`, `bind2nd` | `std::bind`, `std::not_fn` (C++17), `std::mem_fn` |
| Esneklik | Ã‡ok kÄ±sÄ±tlÄ±, sadece binary | SÄ±nÄ±rsÄ±z parametre, Placeholder desteÄŸi |
| Modern Alternatif | Yok | Lambda Ä°fadeleri (Genelde `bind` yerine tercih edilir) |

---

## 2. `std::bind` ve Placeholders (Yer Tutucular) [02:20]
Hoca, `_1`, `_2` gibi sabitlerin `std::placeholders` isim alanÄ± iÃ§inde olduÄŸunu vurguladÄ±.

```cpp
#include <functional>
#include <iostream>

using namespace std;
using namespace std::placeholders; // <-- Hoca zaman kazanmak iÃ§in bunu kullandÄ± ama Ã¼retimde dikkat!

auto f_add = [](int a, int b, int c) { return a + b + c; };

int main() {
    // 3 parametreli bir lambda'yÄ± 2 parametreliye adapte ediyoruz
    auto f = bind(f_add, _1, _2, 0); 
    // _1: f'in birinci parametresi f_add'in a'sÄ±na
    // _2: f'in ikinci parametresi f_add'in b'sine
    // 0: f_add'in c'sine sabit olarak baÄŸlanÄ±r.

    cout << f(10, 20) << endl; // Ã‡Ä±ktÄ±: 30
}
```

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::bind` argÃ¼manlarÄ± nasÄ±l tutar?  
**Cevap:** Hoca burayÄ± defalarca vurguladÄ±: `std::bind`, kendisine geÃ§ilen argÃ¼manlarÄ± **copy** (kopyalama) yoluyla kendi iÃ§inde saklar! EÄŸer nesnenin kendisini kullanmasÄ±nÄ± istiyorsak `std::ref` kullanmalÄ±yÄ±z.

---

## 3. Algoritmalarda Fonksiyon Adaptasyonu [11:10]
Hoca, YiÄŸit Bey'in "Neden doÄŸrudan Ã§aÄŸÄ±rmÄ±yoruz?" sorusu Ã¼zerine muazzam bir Ã¶rnek verdi: "Durumdan vazife Ã§Ä±kartmak."

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
`std::transform` gibi algoritmalar *Unary Operation* (tek parametreli iÅŸlem) bekler. Elimizde `std::plus` (iki parametreli) varsa, bunu `bind` ile "kÃ¶reltmemiz" gerekir.

```cpp
#include <vector>
#include <algorithm>
#include <functional>

void ornek() {
    vector<int> ivek(10);
    // ... random fill ...
    int n;
    cin >> n;

    // std::plus<int> 2 parametre bekler. transform tek parametre gÃ¶nderir.
    // std::bind ile plus'Ä±n bir parametresini 'n'e baÄŸlÄ±yoruz.
    transform(ivek.begin(), ivek.end(), ivek.begin(), 
              bind(plus<int>(), _1, n)); // <-- Hoca buradaki adaptasyona dikkat Ã§ekti.
}
```

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Adaptasyon MantÄ±ÄŸÄ±)
```text
Algoritma (Tek ArgÃ¼man SalÄ±yor) ---> [ AdaptÃ¶r (Bind) ] ---> AsÄ±l Fonksiyon (Ä°ki ArgÃ¼man Bekliyor)
          [x]                ---> [ _1 (x) , n ]   ---> plus(x, n)
```

---

## 4. Ãœye FonksiyonlarÄ±n (Member Functions) Bind Edilmesi [18:20]
Ãœye fonksiyonlar gizli bir `this` pointer parametresine sahiptir. Hoca bu kÄ±smÄ±n mÃ¼lakatlarda Ã§ok can yaktÄ±ÄŸÄ±nÄ± belirtti.

```cpp
class MyClass {
public:
    void bar(int x) { cout << "bar x: " << x << endl; }
};

int main() {
    MyClass m;
    // Ãœye fonksiyonu sarmalamak iÃ§in:
    // 1. Fonksiyonun adresi (&MyClass::bar)
    // 2. Birinci placeholder (_1) veya nesnenin kendisi nesne iÃ§in ayrÄ±lmalÄ±.
    auto f = bind(&MyClass::bar, _1, _2); 
    f(m, 10); // m nesnesi _1'e, 10 deÄŸeri _2'ye gider.

    // Alternatif: Nesneyi doÄŸrudan baÄŸlamak
    auto f2 = bind(&MyClass::bar, m, _1);
    f2(20); // Nesne zaten m olarak baÄŸlandÄ±, 20 deÄŸeri bar'a gider.
}
```

---

## 5. Referans SemantiÄŸi ve `std::ref` Kritik HatasÄ± [25:20]
Hoca, `std::bind`'Ä±n en tehlikeli tarafÄ±nÄ±n "sessizce kopyalamasÄ±" olduÄŸunu sÃ¶yledi.

```cpp
void func(int& a) { a++; }

int main() {
    int x = 5;
    auto f = bind(func, x); // <-- KRÄ°TÄ°K HATA: x buraya kopyalanÄ±r!
    f(); 
    cout << x; // Ã‡Ä±ktÄ± halÃ¢ 5!

    auto f_correct = bind(func, ref(x)); // <-- DoÄŸru kullanÄ±m
    f_correct();
    cout << x; // Ã‡Ä±ktÄ±: 6
}
```

### ğŸ” Arka Plan (Under the Hood)
`std::bind` sarmaladÄ±ÄŸÄ± argÃ¼manlarÄ± *internal data member* (iÃ§ veri elemanÄ±) olarak saklar. `std::ref` kullanÄ±ldÄ±ÄŸÄ±nda, kopyalanan ÅŸey nesnenin kendisi deÄŸil, `reference_wrapper` nesnesidir. Bu nesne de iÃ§inde asÄ±l nesnenin adresini tutar.

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::cout` gibi kopyalamaya kapalÄ± (*Non-copyable*) nesneler `bind` ile nasÄ±l kullanÄ±lÄ±r?  
**Cevap:** DoÄŸrudan geÃ§ilemez, derleyici hatasÄ± verir. Mutlaka `std::ref(cout)` ÅŸeklinde geÃ§ilmelidir. Ã‡Ã¼nkÃ¼ `std::ostream` sÄ±nÄ±fÄ±nÄ±n *Copy Constructor*'Ä± silinmiÅŸtir (`delete`).

---

## 6. `std::mem_fn` AdaptÃ¶rÃ¼ (GiriÅŸ) [31:34]
Hoca, `mem_fn`'in (Member Function) `bind`'a gÃ¶re daha spesifik ve bazen daha okunabilir bir alternatif olduÄŸunu sÃ¶yleyerek konuya giriÅŸ yaptÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ãœye fonksiyonlarÄ± bir fonksiyon nesnesi gibi Ã§aÄŸÄ±rabilmek iÃ§in `std::bind`'Ä±n hantal sÃ¶zdiziminden (placeholder yazma zorunluluÄŸu vb.) kurtulmak ve daha *polymorphic* (hem pointer hem nesne kabul eden) bir yapÄ± kurmak.


Necati Hocaâ€™nÄ±n dersindeki o meÅŸhur "tahtayÄ± temizleyip yeni konuya geÃ§me" ritmiyle devam ediyoruz. `std::mem_fn` ve ardÄ±ndan gelen `std::function` devrimi ile C++'Ä±n "Callable" (Ã§aÄŸrÄ±labilir) varlÄ±klara bakÄ±ÅŸ aÃ§Ä±sÄ± tamamen deÄŸiÅŸiyor.

---

# ğŸ“‘ C++ Ders NotlarÄ±: `std::mem_fn` ve `std::function` GiriÅŸ
**Konu:** Ãœye Fonksiyon AdaptÃ¶rleri ve Polimorfik SarmalayÄ±cÄ±lar  
**Zaman DamgasÄ±:** [31:34.000 --> 01:00.000]

## 7. `std::mem_fn` (Member Function Adapter) [31:34]
Hoca, `mem_fn` isminin "Member Function"dan geldiÄŸini belirterek sÃ¶ze baÅŸladÄ±. Bu adaptÃ¶r, bir sÄ±nÄ±fÄ±n Ã¼ye fonksiyonunu alÄ±r ve onu sanki bir serbest fonksiyonmuÅŸ (*Free Function*) gibi Ã§aÄŸÄ±rmamÄ±za olanak saÄŸlayan bir sarmalayÄ±cÄ± dÃ¶ner.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ãœye fonksiyonlarÄ± doÄŸrudan bir STL algoritmasÄ±na veya bir *Callable* bekleyen yapÄ±ya gÃ¶nderemeyiz; Ã§Ã¼nkÃ¼ Ã¼ye fonksiyonlar gizli bir `this` parametresine ihtiyaÃ§ duyar. `std::bind` ile bunu yapabilirdik (`_1` kullanarak), ancak `std::mem_fn` daha temiz, daha spesifik ve "polimorfik" bir Ã§Ã¶zÃ¼m sunar.

### ğŸ” Arka Plan (Under the Hood)
`std::mem_fn`, sarmaladÄ±ÄŸÄ± Ã¼ye fonksiyonu Ã§aÄŸÄ±rÄ±rken akÄ±llÄ± bir mekanizma kullanÄ±r. EÄŸer argÃ¼man olarak bir nesne (`obj`), referans (`&obj`) veya pointer (`*obj`) gÃ¶nderilirse, derleyici arka planda uygun Ã§aÄŸrÄ±yÄ± (`.` veya `->`) otomatik seÃ§er.

```cpp
class MyClass {
public:
    void who() { cout << "MyClass::who()" << endl; } // <-- Hoca burada isim Ã§akÄ±ÅŸmasÄ± hatasÄ± yaptÄ±, dÃ¼zelttik.
    void bar(int x) { cout << "x: " << x << endl; }
};

int main() {
    auto f = mem_fn(&MyClass::who); // Ãœye fonksiyonun adresi alÄ±nÄ±r.
    
    MyClass m;
    MyClass* ptr = &m;

    f(m);   // Nesnenin kendisiyle Ã§aÄŸrÄ± (m.who())
    f(ptr); // Pointer ile Ã§aÄŸrÄ± (ptr->who()) <-- Hoca: "BakÄ±n, kendi ayarlÄ±yor!"
}
```

### ğŸš© Derleyici GÃ¶zÃ¼ (Hata Analizi) [35:36]
Hoca kod yazarken iki fonksiyona da `who` ismini verdiÄŸi iÃ§in derleyici kÄ±zdÄ±:
*   **Hata Nedeni:** *Ambiguity* (Belirsizlik). AynÄ± isimli ve aynÄ± imzalÄ± (parametresiz) iki fonksiyonun overload edilmesi mÃ¼mkÃ¼n deÄŸildir. Hoca durumu fark edip birini `foo` veya `bar` olarak gÃ¼ncelledi.

---

## 8. STL AlgoritmalarÄ±nda `std::mem_fn` KullanÄ±mÄ± [39:30]
Bu bÃ¶lÃ¼mÃ¼n en vurucu kÄ±smÄ± burasÄ±ydÄ±. Hoca, "Neden lambda varken bunu kullanalÄ±m?" sorusunun cevabÄ±nÄ± *Trade-off* (Ã¶dÃ¼nleÅŸim) Ã¼zerinden anlattÄ±.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Algoritma Entegrasyonu)
```text
[ vector<Net> ]  --->  [ for_each ]  ---> [ mem_fn(&Net::print) ]
      |                      |                      |
   (Nesne) ----------> (Callable) ----------> calls obj.print()
```

### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar: Lambda vs `mem_fn` [43:40]
Hoca, aynÄ± iÅŸi yapan iki kodu karÅŸÄ±laÅŸtÄ±rdÄ±:

```cpp
// 1. Lambda ile:
for_each(myvec.begin(), myvec.end(), [](const Net& n) { n.print(); });

// 2. mem_fn ile:
for_each(myvec.begin(), myvec.end(), mem_fn(&Net::print)); // <-- Hoca: "Daha kompakt ve niyeti belli ediyor."
```
*   **Hoca'nÄ±n Yorumu:** "BazÄ± durumlarda okunabilirlik aÃ§Ä±sÄ±ndan `mem_fn` daha ÅŸÄ±ktÄ±r, ancak lambda daha esnektir."

---

## 9. `std::function` - GenelleÅŸtirilmiÅŸ Callback YapÄ±sÄ± [53:00]
Emirhan Bey'in "mem_fn ile farkÄ± ne?" sorusu Ã¼zerine Hoca muazzam bir derinliÄŸe daldÄ±.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
SÄ±radan fonksiyon pointer'larÄ± (`void (*f)(int)`) sadece serbest fonksiyonlarÄ±n adresini tutabilir. Lambda, `std::bind` Ã§Ä±ktÄ±sÄ± veya *Functor* nesnelerini aynÄ± tip altÄ±nda tutamazlar. `std::function`, tipi silinmiÅŸ (*Type Erasure*) bir polimorfik sarmalayÄ±cÄ±dÄ±r.

### ğŸ” Arka Plan (Under the Hood)
`std::function` bir **Function Type** (fonksiyon tÃ¼rÃ¼) bekler, **Function Pointer Type** deÄŸil!
*   `int(int, int)` bir Fonksiyon TÃ¼rÃ¼dÃ¼r.
*   `int(*)(int, int)` bir Fonksiyon Pointer TÃ¼rÃ¼dÃ¼r.

```cpp
int foo(int a) { return a * a; }

int main() {
    // C++17 CTAD sayesinde tipi belirtmeye gerek kalmayabilir ama hoca aÃ§Ä±k yazdÄ±:
    function<int(int)> f = foo; // f artÄ±k foo'yu sarmalÄ±yor.
    
    // BoÅŸ bir function nesnesi Ã§aÄŸÄ±rmak tehlikelidir!
    function<int(int)> f_empty;
    // f_empty(5); // <-- KRÄ°TÄ°K: std::bad_function_call fÄ±rlatÄ±r!
}
```

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±: CTAD (C++17) [59:20]
Hoca, C++17 ile gelen **CTAD** (*Class Template Argument Deduction*) Ã¶zelliÄŸinin `std::function` kullanÄ±mÄ±nÄ± nasÄ±l kolaylaÅŸtÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶sterdi.

| Standart | SÃ¶zdizimi | Ã‡Ä±karÄ±m |
| :--- | :--- | :--- |
| C++11 | `function<int(int)> f = foo;` | Manuel belirtim zorunlu |
| C++17 | `function f = foo;` | ArgÃ¼mandan otomatik Ã§Ä±karÄ±m (**CTAD**) |

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta [01:02:20]
**Soru:** Bir `std::function` nesnesinin dolu olup olmadÄ±ÄŸÄ±nÄ± nasÄ±l kontrol ederiz?  
**Cevap:** Hoca `operator bool` fonksiyonunu iÅŸaret etti. `if (f)` ÅŸeklinde kontrol edilmeden Ã§aÄŸrÄ±lan boÅŸ bir `std::function`, doÄŸrudan **UB** (*Undefined Behavior*) deÄŸil, standart bir **Exception** fÄ±rlatÄ±r.

---

## Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:
1.  **Ãœye Fonksiyon Adresi:** Ãœye fonksiyon adresi alÄ±nÄ±rken `&` operatÃ¶rÃ¼ zorunludur ve sÄ±nÄ±f ismiyle *qualify* edilmelidir (`&MyClass::func`).
2.  **`std::function` Maliyeti:** Hoca henÃ¼z rakam vermedi ama "bedava deÄŸil" dedi (Gelecek 10 dakikada 40 byte detayÄ±na girecek).
3.  **Naming Conflict:** `mem_fn` kullanÄ±rken sÄ±nÄ±f iÃ§indeki fonksiyon isimlerinin Ã§akÄ±ÅŸmamasÄ±na dikkat edilmeli, aksi halde derleyici hangi overload'un sarmalanacaÄŸÄ±nÄ± bilemez.


Necati Hoca'nÄ±n dersinde vites yÃ¼kseltiyoruz. `std::function`â€™Ä±n polimorfik yapÄ±sÄ±ndan, C++17â€™nin hayat kurtaran `std::invoke` fonksiyonuna ve oradan STL'in en kritik algoritma gruplarÄ±na geÃ§iyoruz. ArkanÄ±za yaslanÄ±n, Ã§Ã¼nkÃ¼ "Type Erasure" ve "Sorted Range" konularÄ± mÃ¼lakatlarÄ±n baÅŸ tacÄ±dÄ±r.

---

# ğŸ“‘ C++ Ders NotlarÄ±: `std::function` Derinlemesi, `std::invoke` ve STL AlgoritmalarÄ±
**Konu:** Polimorfik SarmalayÄ±cÄ±lar ve Algoritma VerimliliÄŸi  
**Zaman DamgasÄ±:** [01:00:00 --> 02:39:24]

## 10. `std::function` ve CTAD MekanizmasÄ± [01:00:00]
Hoca, C++17 ile gelen **CTAD** (*Class Template Argument Deduction*) Ã¶zelliÄŸinin `std::function` ile nasÄ±l birleÅŸtiÄŸini gÃ¶sterdi.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Eskiden (C++11/14), `std::function` tanÄ±mlarken fonksiyonun imzasÄ±nÄ± (Ã¶rneÄŸin `int(int)`) aÃ§Ä±kÃ§a yazmak zorundaydÄ±k. CTAD ile derleyici, constructor'a gÃ¶nderilen argÃ¼mandan bu imzayÄ± kendisi Ã§Ä±kartabiliyor.

### ğŸ” Arka Plan (Under the Hood)
Derleyici, constructor'a geÃ§ilen *Callable* varlÄ±ÄŸÄ±n `operator()` fonksiyonuna veya adresine bakarak `std::function` ÅŸablonunu *instantiate* (somutlaÅŸtÄ±rma) eder.

```cpp
int cube(int x) { return x * x * x; }

int main() {
    // C++17 Ã–ncesi: Signature (imza) zorunlu
    std::function<int(int)> f1 = cube;

    // C++17 ve SonrasÄ±: CTAD devrede
    std::function f2 = cube; // <-- Hoca: "Derleyici Ã§Ä±karÄ±mÄ± kendisi yapÄ±yor."
}
```

---

## 11. `std::function`â€™Ä±n Maliyeti ve Boyutu [01:38:00]
Hoca buraya "KRÄ°TÄ°K" notunu dÃ¼ÅŸtÃ¼. `std::function` bedava deÄŸildir!

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ± (Size Analysis)
Hoca kendi derleyicisinde (muhtemelen MSVC) bir test yaptÄ±:
*   **SÄ±radan Fonksiyon Pointer:** 4 veya 8 byte (mimariye baÄŸlÄ±).
*   **`std::function<int(int)>`:** **40 byte!**

### ğŸ” Arka Plan (Under the Hood)
`std::function`, **Type Erasure** (tip silme) tekniÄŸini kullanÄ±r. Ä°Ã§inde sanal fonksiyon tablosu benzeri bir yapÄ± ve "Small Object Optimization" (kÃ¼Ã§Ã¼k nesne optimizasyonu) iÃ§in bir alan tutar. EÄŸer sarmalanan nesne (Ã¶rneÄŸin bÃ¼yÃ¼k bir lambda capture listesi) bu alana sÄ±ÄŸmazsa, **dynamic allocation** (heap bellek kullanÄ±mÄ±) yapar. 

**Hoca'nÄ±n Ä°diomu:** *"Zorunlu olmadÄ±kÃ§a kullanmayÄ±n, overhead'i (ek yÃ¼kÃ¼) vardÄ±r."*

---

## 12. `std::invoke` (C++17) [01:43:50]
Hoca, `std::invoke`'un "Unified Calling Syntax" (birleÅŸtirilmiÅŸ Ã§aÄŸÄ±rma sÃ¶zdizimi) olduÄŸunu belirtti.

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++'ta bir serbest fonksiyonu `f()` diye Ã§aÄŸÄ±rÄ±rken, Ã¼ye fonksiyon pointer'Ä±nÄ± `(obj.*f)()` diye Ã§aÄŸÄ±rmak gerekir. Jenerik (template) kod yazarken bu fark baÅŸ belasÄ±dÄ±r. `std::invoke` her ikisini de aynÄ± ÅŸekilde Ã§aÄŸÄ±rÄ±r.

```cpp
struct Functor {
    int operator()(int x) { return x * 10; }
};

void demo() {
    Functor fn;
    // std::invoke her tÃ¼rlÃ¼ callable'Ä± tek potada eritir.
    int res = std::invoke(fn, 5); // Functor Ã§aÄŸrÄ±sÄ±
    int res2 = std::invoke(cube, 3); // Serbest fonksiyon Ã§aÄŸrÄ±sÄ±
}
```

---

## 13. STL AlgoritmalarÄ±: `generate` ve `fill` Serisi [01:55:00]
Hoca, "Ham dÃ¶ngÃ¼lerden (raw loops) kaÃ§Ä±nÄ±n!" diyerek bu algoritmalarÄ± tanÄ±ttÄ±.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (Generate MantÄ±ÄŸÄ±)
```text
[ ? ] [ ? ] [ ? ]  <--- generate(begin, end, generator)
  |     |     |
[ 2 ] [ 4 ] [ 6 ]  <--- Her adÄ±mda generator() Ã§aÄŸrÄ±lÄ±r.
```

### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta: `mutable` Lambda [02:01:00]
Hoca, `std::generate` ile artan sayÄ±lar Ã¼retmek iÃ§in lambda iÃ§inde `mutable` kullanÄ±mÄ±nÄ± gÃ¶sterdi:

```cpp
vector<int> ivek(10);
// x'i 0'dan baÅŸlatÄ±p her Ã§aÄŸrÄ±da 2 artÄ±rmak istiyoruz.
generate(ivek.begin(), ivek.end(), [x = 0]() mutable { 
    return x += 2; // <-- HATA BURADA: mutable olmazsa x deÄŸiÅŸtirilemez!
});
```
**Derleyici ÅŸu sebeple kÄ±zÄ±yor:** Lambda'nÄ±n `operator()` fonksiyonu varsayÄ±lan olarak `const`'tur. `mutable` anahtar sÃ¶zcÃ¼ÄŸÃ¼ bu kÄ±sÄ±tlamayÄ± kaldÄ±rÄ±r.

---

## 14. Sorted Range AlgoritmalarÄ± (Set Operations) [02:16:00]
Hoca, bu algoritmalarÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in range'lerin **mutlaka sÄ±ralÄ±** (*sorted*) olmasÄ± gerektiÄŸini, yoksa **UB** (*Undefined Behavior*) oluÅŸacaÄŸÄ±nÄ± vurguladÄ±.

### ğŸ“Š Set AlgoritmalarÄ± Tablosu
| Algoritma | AÃ§Ä±klama |
| :--- | :--- |
| `set_union` | $A \cup B$ (BirleÅŸim) |
| `set_intersection` | $A \cap B$ (KesiÅŸim) |
| `set_difference` | $A \setminus B$ (Fark) |
| `set_symmetric_difference` | $(A \setminus B) \cup (B \setminus A)$ |

### ğŸ”— KÃ¼mÃ¼latif BaÄŸlantÄ±lar
Hoca, bu algoritmalarÄ±n 5 parametre aldÄ±ÄŸÄ±nÄ±; ilk 4'Ã¼nÃ¼n iki adet input range'i, 5.'sinin ise `std::back_inserter` gibi bir *output iterator* olduÄŸunu hatÄ±rlattÄ±.

```cpp
set_intersection(ivek.begin(), ivek.end(), 
                 ilist.begin(), ilist.end(), 
                 back_inserter(destvek)); // <-- Hoca: "SÄ±ralÄ± olmalarÄ± ÅŸart!"
```

---

## 15. `std::search` AlgoritmasÄ± [02:30:50]
Hoca dersi bitirirken bu isimlendirmenin kafa karÄ±ÅŸtÄ±rÄ±cÄ± olduÄŸunu sÃ¶yledi: "Find ile karÄ±ÅŸtÄ±rmayÄ±n!"

### ğŸš© Kritik Nokta
`std::search`, bir range iÃ§inde bir **Sub-range** (alt aralÄ±k) arar. Hoca dersin sonunda `std::search_n` konusuna bir sonraki derste gireceÄŸini belirterek dersi noktaladÄ±.

---

## Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:
1.  **`std::function` BoÅŸluk KontrolÃ¼:** BoÅŸ bir `std::function` nesnesini Ã§aÄŸÄ±rmak `std::bad_function_call` fÄ±rlatÄ±r. Mutlaka `if (f)` kontrolÃ¼ yapÄ±lmalÄ±.
2.  **Sorted Range Ä°hlali:** `set_union` gibi fonksiyonlara sÄ±rasÄ±z veri gÃ¶nderilirse algoritma mantÄ±ÄŸÄ± Ã§Ã¶ker.
3.  **Lambda Init-Capture:** Lambda iÃ§inde durum saklamak (state) istiyorsak `mutable` anahtar kelimesini unutmamalÄ±yÄ±z.

