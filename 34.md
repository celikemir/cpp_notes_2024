# C++ Programlama Dili - Ders NotlarÄ± (34. GÃ¼n)

**Tarih:** 23 Ekim 2024  
**Konu:** Perfect Forwarding (MÃ¼kemmel GÃ¶nderim), Type Traits (TÃ¼r Sorgulama AraÃ§larÄ±) ve Variadic Templates GiriÅŸ  
**EÄŸitmen:** Necati Ergin

---

## 1. Perfect Forwarding (MÃ¼kemmel GÃ¶nderim) GiriÅŸ [00:00 - 05:25]

Modern C++'Ä±n en kritik araÃ§larÄ±ndan biri olan "Perfect Forwarding", saÄŸ taraf referanslarÄ±nÄ±n (R-value references) dile eklenmesinin en temel iki gerekÃ§esinden biridir. TaÅŸÄ±ma SemantiÄŸi (Move Semantics) ile doÄŸrudan iliÅŸkili olmasa da, her iki mekanizma da implementasyon aÅŸamasÄ±nda saÄŸ taraf referanslarÄ±nÄ± kullanÄ±r.

### Problemin TanÄ±mÄ±
Bir fonksiyonu (Ã¶rneÄŸin `CallFoo`), kendisine gelen argÃ¼manlarla baÅŸka bir fonksiyonu (Ã¶rneÄŸin `Foo`) Ã§aÄŸÄ±racak ÅŸekilde tasarladÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. "MÃ¼kemmel GÃ¶nderim", bizim `Foo` fonksiyonunu doÄŸrudan Ã§aÄŸÄ±rmamÄ±z ile `CallFoo` Ã¼zerinden Ã§aÄŸÄ±rmamÄ±z arasÄ±nda; nesne Ã¶mrÃ¼, kopyalama maliyeti, `const` yeterliliÄŸi ve **Value Category (DeÄŸer Kategorisi)** aÃ§Ä±sÄ±ndan hiÃ§bir fark olmamasÄ± durumudur.

### Overload Ã‡Ä±kmazÄ±
EÄŸer bu iÅŸi otomatik bir mekanizma (Perfect Forwarding) olmadan yapmaya kalksaydÄ±k, her parametre kombinasyonu iÃ§in ayrÄ± overload'lar yazmamÄ±z gerekirdi:
*   1 parametreli bir fonksiyon iÃ§in: 4 overload (L-value, Const L-value, R-value, Const R-value).
*   2 parametreli bir fonksiyon iÃ§in: $4^2 = 16$ overload.
*   3 parametreli bir fonksiyon iÃ§in: $4^3 = 64$ overload.

Bu durum sÃ¼rdÃ¼rÃ¼lemez bir kod karmaÅŸasÄ±na (combinatorial explosion) yol aÃ§ar. Perfect Forwarding mekanizmasÄ± bu problemi tek bir template fonksiyonu ile Ã§Ã¶zer.

### MekanizmanÄ±n Temeli: Forwarding Reference
MÃ¼kemmel gÃ¶nderimin gerÃ§ekleÅŸmesi iÃ§in fonksiyon parametresinin Ã¶zel bir yapÄ±da olmasÄ± gerekir:
```cpp
template <typename T>
void CallFoo(T&& arg); // Buradaki T&& bir "Forwarding Reference"dÄ±r.
```
Bu yapÄ± dÄ±ÅŸarÄ±dan bakÄ±ldÄ±ÄŸÄ±nda bir R-value referans gibi gÃ¶rÃ¼nse de, bir template parametresine baÄŸlÄ± olduÄŸu ve tÃ¼r Ã§Ä±karÄ±mÄ± (type deduction) yapÄ±ldÄ±ÄŸÄ± iÃ§in **Universal Reference** (Scott Meyers'Ä±n terimi) veya **Forwarding Reference** (Standart terimi) olarak adlandÄ±rÄ±lÄ±r.

---

## 2. Forwarding Reference vs. R-Value Reference [05:26 - 09:48]

Her `&&` gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z yer "Forwarding Reference" deÄŸildir. Bir referansÄ±n bu kategoriye girmesi iÃ§in tÃ¼r Ã§Ä±karÄ±mÄ±nÄ±n olmasÄ± ÅŸarttÄ±r.

### Universal Reference Olmayan Durumlar
1.  **Const veya Volatile Belirleyicisi:** EÄŸer `const T&&` ÅŸeklinde bir bildirim varsa, bu artÄ±k bir forwarding reference deÄŸildir, sadece `const` bir saÄŸ taraf referansÄ±dÄ±r.
2.  **TÃ¼r Ã‡Ä±karÄ±mÄ± Olmayan Åablonlar:** SÄ±nÄ±f ÅŸablonlarÄ±nÄ±n Ã¼ye fonksiyonlarÄ±nda durum karÄ±ÅŸtÄ±rÄ±labilir.
    ```cpp
    template <typename T>
    class MyClass {
        void func(T&& arg); // Bu bir R-VALUE referanstÄ±r! TÃ¼r Ã§Ä±karÄ±mÄ± yoktur.
    };
    ```
    Burada `MyClass<int>` oluÅŸturulduÄŸunda fonksiyon `func(int&&)` haline gelir. TÃ¼r zaten bellidir, Ã§Ä±karÄ±m yapÄ±lmaz.

### Member Template Durumu
EÄŸer sÄ±nÄ±fÄ±n iÃ§indeki fonksiyon kendi baÅŸÄ±na bir template ise, o zaman forwarding reference oluÅŸur:
```cpp
template <typename T>
class MyClass {
    template <typename U>
    void emplace_back(U&& arg); // Bu bir FORWARDING REFERENCE'dÄ±r.
};
```

ğŸ’¡ **Ã–ÄŸrenci Notu:** Standart kÃ¼tÃ¼phanedeki `std::vector::push_back` fonksiyonunun iki overload'u vardÄ±r: biri `const T&`, diÄŸeri `T&&`. Ancak `emplace_back` fonksiyonu bir variadic member template olarak `Args&&...` kullanÄ±r, bu da onun neden mÃ¼kemmel gÃ¶nderim yapabildiÄŸini aÃ§Ä±klar.

---

## 3. std::forward ve KoÅŸullu DeÄŸer Kategorisi DÃ¶nÃ¼ÅŸÃ¼mÃ¼ [09:49 - 18:42]

MÃ¼kemmel gÃ¶nderimin kalbi `std::forward` fonksiyonudur. Bu fonksiyon `<utility>` baÅŸlÄ±k dosyasÄ±nda bulunur ve tamamen derleme zamanÄ±nda (compile-time) etkili olan bir `constexpr` fonksiyonudur.

### std::forward Ne Yapar?
Fonksiyonun parametresi olan `x`, ismi olan bir varlÄ±k olduÄŸu iÃ§in her zaman bir **L-value**'dur. EÄŸer biz `x`'i doÄŸrudan iÃ§teki fonksiyona gÃ¶nderirsek, orijinalinde R-value gelse bile iÃ§teki fonksiyon bunu L-value olarak karÅŸÄ±lar. Bu da taÅŸÄ±ma yerine kopyalamaya neden olur.

`std::forward`, kendisine gelen argÃ¼manÄ±n orijinal deÄŸer kategorisini korur:
*   EÄŸer `CallFoo`'ya bir **L-value** gelmiÅŸse: `std::forward` bunu tekrar **L-value** olarak dÃ¶ndÃ¼rÃ¼r.
*   EÄŸer `CallFoo`'ya bir **R-value** gelmiÅŸse: `std::forward` bunu tekrar **R-value**'ya cast eder.

### std::move ile FarkÄ±
*   `std::move`: Gelen ne olursa olsun kayÄ±tsÄ±z ÅŸartsÄ±z saÄŸ taraf referansÄ±na (R-value) cast eder.
*   `std::forward`: Sadece orijinalinde R-value gelmiÅŸse cast eder. Bu yÃ¼zden "Conditional Cast" (KoÅŸullu DÃ¶nÃ¼ÅŸtÃ¼rme) olarak bilinir.

```cpp
template <typename T>
void wrapper(T&& arg) {
    foo(std::forward<T>(arg)); // T'nin tÃ¼rÃ¼ne gÃ¶re deÄŸer kategorisini korur
}
```

---

## 4. GerÃ§ek DÃ¼nya Ã–rneÄŸi: Emplace FonksiyonlarÄ± [18:43 - 26:50]

STL konteynerlarÄ±ndaki `push_back` ve `emplace_back` arasÄ±ndaki fark, Perfect Forwarding'in en somut Ã¶rneÄŸidir.

### push_back Senaryosu
`push_back` bir nesne bekler. EÄŸer geÃ§ici bir nesne gÃ¶nderirseniz (`vector.push_back(Date{1,1,2024})`), Ã¶nce geÃ§ici nesne oluÅŸturulur, sonra bu nesne taÅŸÄ±ma (move) veya kopyalama (copy) ile konteynerin belleÄŸine aktarÄ±lÄ±r. Burada en az bir taÅŸÄ±ma/kopyalama maliyeti vardÄ±r.

### emplace_back ve Perfect Forwarding
`emplace_back` ise nesnenin kendisini deÄŸil, nesnenin **constructor'Ä±na gÃ¶nderilecek argÃ¼manlarÄ±** alÄ±r.
1.  Konteyner, nesne iÃ§in gerekli belleÄŸi ayÄ±rÄ±r.
2.  `std::forward` kullanarak aldÄ±ÄŸÄ± argÃ¼manlarÄ±, bu bellek alanÄ±nda Ã§aÄŸrÄ±lan constructor'a mÃ¼kemmel bir ÅŸekilde iletir.
3.  Nesne doÄŸrudan konteynerin iÃ§inde inÅŸa edilir.

**SonuÃ§:** HiÃ§bir geÃ§ici nesne oluÅŸmaz, kopyalama veya taÅŸÄ±ma maliyeti sÄ±fÄ±ra iner.

---

## 5. std::make_unique ve Variadic Perfect Forwarding [26:51 - 36:20]

Perfect Forwarding sadece tek parametre ile sÄ±nÄ±rlÄ± deÄŸildir. `std::make_unique` gibi fabrika fonksiyonlarÄ±, belirsiz sayÄ±da argÃ¼manÄ± (Variadic Templates) hedef constructor'a iletmek iÃ§in bu mekanizmayÄ± kullanÄ±r.

### make_unique TasarÄ±mÄ± (BasitleÅŸtirilmiÅŸ)
```cpp
template <typename T, typename... Args>
std::unique_ptr<T> MakeUnique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```
Burada `args...` bir parametre paketidir. `std::forward<Args>(args)...` ifadesi ise paketi aÃ§ar (expansion) ve her bir argÃ¼manÄ± kendi orijinal deÄŸer kategorisiyle constructor'a gÃ¶nderir.

âš ï¸ **UyarÄ±:** `std::make_unique` Ã§aÄŸrÄ±lÄ±rken oluÅŸturulacak tÃ¼r (T) Ã§Ä±karÄ±lamaz, Ã§Ã¼nkÃ¼ parametre paketinde T'ye dair bir ipucu yoktur. Bu yÃ¼zden T her zaman **explicit** (aÃ§Ä±kÃ§a) belirtilmelidir: `std::make_unique<MyClass>(arg1, arg2)`.

---

## 6. Master Kod Ã–rneÄŸi (MÃ¼kemmel GÃ¶nderim KatmanlarÄ±) [36:21 - 47:00]

AÅŸaÄŸÄ±daki kod, Perfect Forwarding'in bir fonksiyon zinciri boyunca deÄŸer kategorisini ve `const` bilgisini nasÄ±l bozmadan ilettiÄŸini Ã¶zetler:

```cpp
#include <iostream>
#include <utility>

struct MyClass {};

void target(MyClass& x)       { std::cout << "L-value ref\n"; }
void target(const MyClass& x) { std::cout << "Const L-value ref\n"; }
void target(MyClass&& x)      { std::cout << "R-value ref\n"; }

// Perfect Forwarding Zinciri
template <typename T>
void layer3(T&& arg) {
    target(std::forward<T>(arg));
}

template <typename T>
void layer2(T&& arg) {
    layer3(std::forward<T>(arg));
}

template <typename T>
void layer1(T&& arg) {
    layer2(std::forward<T>(arg));
}

int main() {
    MyClass m;
    const MyClass cm;

    layer1(m);                     // Ã‡Ä±ktÄ±: L-value ref
    layer1(cm);                    // Ã‡Ä±ktÄ±: Const L-value ref
    layer1(std::move(m));          // Ã‡Ä±ktÄ±: R-value ref
    layer1(MyClass{});             // Ã‡Ä±ktÄ±: R-value ref
}
```

---

## 7. Type Traits KÃ¼tÃ¼phanesi ve Meta-Function KavramÄ± [47:01 - 01:10:00]

Type Traits, C++ standart kÃ¼tÃ¼phanesinin `<type_traits>` baÅŸlÄ±ÄŸÄ± altÄ±nda sunduÄŸu, tÃ¼rler hakkÄ±nda **compile-time**'da bilgi edinmemizi veya tÃ¼rleri dÃ¶nÃ¼ÅŸtÃ¼rmemizi saÄŸlayan bir araÃ§ setidir.

### Meta-Function Nedir?
C++'taki normal fonksiyonlar deÄŸerler Ã¼zerinde iÅŸlem yaparken, meta-function'lar tÃ¼rler (types) ve sabitler (constants) Ã¼zerinde iÅŸlem yapar.
1.  **TÃ¼r Sorgulayanlar:** Bir tÃ¼rÃ¼n Ã¶zelliÄŸini (`bool`) dÃ¶ndÃ¼rÃ¼r. (Ã–rn: `is_pointer`)
2.  **TÃ¼r DÃ¶nÃ¼ÅŸtÃ¼renler:** Bir tÃ¼rden baÅŸka bir tÃ¼r elde eder. (Ã–rn: `remove_const`)

### Integral Constant: Temel YapÄ± TaÅŸÄ±
TÃ¼m tÃ¼r sorgulama araÃ§larÄ± `std::integral_constant` ÅŸablonundan tÃ¼retilir.
```cpp
template<typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    typedef T value_type;
    typedef integral_constant type;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

// En sÄ±k kullanÄ±lan eÅŸ isimler:
using true_type  = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;
```

ğŸ’¡ **Ã–ÄŸrenci Notu:** `true_type` ve `false_type` sÄ±nÄ±flarÄ±, derleme zamanÄ±nda "Evet" ve "HayÄ±r" cevaplarÄ±nÄ± temsil eden nesneleÅŸmiÅŸ tÃ¼rlerdir. Bir meta-function'Ä± bu sÄ±nÄ±flardan kalÄ±tÄ±m yoluyla elde etmek, o function'Ä±n `value` Ã¼yesine otomatik olarak `true` veya `false` atanmasÄ±nÄ± saÄŸlar.

## 8. Meta-FunctionlarÄ±n Ä°mzasÄ±: value, type ve _v/_t Sonekleri [01:10:00 - 01:25:00]

Bir Type Trait (meta-function) tasarlanÄ±rken standart bir arayÃ¼z takip edilir. Bu arayÃ¼z, ÅŸablon metaprogramlama (TMP) sÃ¼reÃ§lerinde kodun okunabilirliÄŸini ve taÅŸÄ±nabilirliÄŸini saÄŸlar.

### Ãœye ElemanlarÄ±n RolÃ¼
*   **`value`:** Sorgulama sonucunu (`true/false`) tutan `static constexpr` Ã¼yedir.
*   **`value_type`:** `value` Ã¼yesinin tÃ¼rÃ¼dÃ¼r (genelde `bool`).
*   **`type`:** Meta-function'Ä±n kendisini (tÃ¼rÃ¼nÃ¼) dÃ¶ndÃ¼rÃ¼r.
*   **TÃ¼r DÃ¶nÃ¼ÅŸtÃ¼rme OperatÃ¶rÃ¼:** `integral_constant` iÃ§indeki `operator value_type()` sayesinde, sÄ±nÄ±fÄ±n bir nesnesi doÄŸrudan `true` veya `false` gibi kullanÄ±labilir.

### `is_pointer` Ä°mplementasyonu (Sorgulama MantÄ±ÄŸÄ±)
Bir tÃ¼rÃ¼n pointer olup olmadÄ±ÄŸÄ±nÄ± anlamak iÃ§in **Partial Specialization (KÄ±smi Ã–zelleÅŸtirme)** tekniÄŸi kullanÄ±lÄ±r:
```cpp
// 1. Primary Template: VarsayÄ±lan olarak her ÅŸey "false"
template <typename T>
struct IsPointer : std::false_type {};

// 2. Partial Specialization: Sadece T* formatÄ±ndaki tÃ¼rler iÃ§in "true"
template <typename T>
struct IsPointer<T*> : std::true_type {};

// KullanÄ±m:
bool b = IsPointer<int*>::value; // true
bool c = IsPointer<int>::value;  // false
```

### DeÄŸiÅŸken ÅablonlarÄ± (Variable Templates) ve `_v` Soneki
C++17 ile gelen `_v` soneki (Ã–rn: `is_pointer_v<T>`), arka planda `is_pointer<T>::value` ifadesine karÅŸÄ±lÄ±k gelen bir `variable template`'dir. Kodun kalabalÄ±ÄŸÄ±nÄ± azaltÄ±r.
```cpp
template <typename T>
constexpr bool is_pointer_v = IsPointer<T>::value;
```

---

## 9. TÃ¼r Sorgulama Ã–rnekleri: is_const ve is_same [01:25:01 - 01:34:00]

### `is_const` NasÄ±l Ã‡alÄ±ÅŸÄ±r?
Derleyiciye "eÄŸer bu tÃ¼r `const` ise ÅŸu uzmanlaÅŸmÄ±ÅŸ ÅŸablonu kullan" demenin yoludur.
```cpp
template <typename T>
struct IsConst : std::false_type {};

template <typename T>
struct IsConst<const T> : std::true_type {};
```
ğŸ’¡ **Ã–ÄŸrenci Notu:** `is_const_v<const int*>` sonucu `false` dÃ¶ner. Ã‡Ã¼nkÃ¼ buradaki `const`, pointer'Ä±n gÃ¶sterdiÄŸi yere aittir (low-level const). Pointer'Ä±n kendisinin const olmasÄ± iÃ§in `int* const` olmasÄ± gerekir.

### `is_same` Ä°mplementasyonu
Ä°ki tÃ¼rÃ¼n tÄ±patÄ±p aynÄ± olup olmadÄ±ÄŸÄ±nÄ± sÄ±nar.
```cpp
template <typename T, typename U>
struct IsSame : std::false_type {};

template <typename T>
struct IsSame<T, T> : std::true_type {}; // T ve U aynÄ± olduÄŸunda bu Ã§alÄ±ÅŸÄ±r
```

---

## 10. TÃ¼r DÃ¶nÃ¼ÅŸtÃ¼ren Meta-Functionlar: remove_const ve remove_reference [01:34:01 - 01:45:00]

Bu kategorideki araÃ§lar bir deÄŸer dÃ¶ndÃ¼rmez, yeni bir **tÃ¼r** elde ederler. SonuÃ§ her zaman iÃ§teki `type` isimli bir `typedef/using` bildirimindedir.

### `remove_const` MekanizmasÄ±
```cpp
template <typename T>
struct RemoveConst { using type = T; };

template <typename T>
struct RemoveConst<const T> { using type = T; };

// KullanÄ±m:
using CleanType = RemoveConst<const int>::type; // CleanType = int
```

### `_t` Soneki ve Alias Templates
TÃ¼r dÃ¶nÃ¼ÅŸtÃ¼rme araÃ§larÄ±nda `::type` yazmaktan kurtulmak iÃ§in `_t` eki kullanÄ±lÄ±r:
```cpp
template <typename T>
using remove_const_t = typename RemoveConst<T>::type;
```

---

## 11. std::type_identity ve TÃ¼r Ã‡Ä±karÄ±mÄ±nÄ± Kapatmak [01:45:01 - 02:00:00]

C++20 ile standartlaÅŸan `std::type_identity`, en basit ama en zekice araÃ§lardan biridir. Sadece aldÄ±ÄŸÄ± tÃ¼rÃ¼ geri verir.

### Neden Ä°htiyaÃ§ Duyulur?
Bazen ÅŸablon fonksiyonlarda belirli bir parametre iÃ§in **Type Deduction (TÃ¼r Ã‡Ä±karÄ±mÄ±)** yapÄ±lmasÄ±nÄ± istemeyiz. ArgÃ¼manÄ±n, baÅŸka bir parametreden Ã§Ä±karÄ±lan tÃ¼re uymasÄ±nÄ± zorunlu kÄ±lmak isteriz.

```cpp
template <typename T>
struct type_identity { using type = T; };

template <typename T>
void func(T a, typename type_identity<T>::type b) { }

int main() {
    func(10.5, 5); // T = double olarak Ã§Ä±karÄ±lÄ±r. 
                   // Ä°kinci parametre iÃ§in Ã§Ä±karÄ±m YAPILMAZ, doÄŸrudan double beklenir.
}
```
âš ï¸ **UyarÄ±:** `typename type_identity<T>::type` yazÄ±lan bir yerde derleyici tÃ¼r Ã§Ä±karÄ±mÄ± yapamaz, Ã§Ã¼nkÃ¼ bu tÃ¼r "Non-deduced context" (Ã§Ä±karÄ±m yapÄ±lamayan baÄŸlam) iÃ§indedir.

---

## 12. Modern C++'ta Derleme ZamanÄ± KontrolÃ¼: if constexpr [02:00:01 - 02:11:59]

`if constexpr`, geleneksel `if` yapÄ±sÄ±nÄ±n derleme zamanÄ±nda Ã§alÄ±ÅŸan versiyonudur. Derleyici, ÅŸartÄ±n saÄŸlanmadÄ±ÄŸÄ± bloklarÄ± koddan tamamen atar.

*   **Runtime If:** Program Ã§alÄ±ÅŸÄ±rken karar verir, her iki blok da derlenmiÅŸ koda dahil edilir.
*   **Compile-time If (`if constexpr`):** Åart derleme zamanÄ±nda deÄŸerlendirilir. YanlÄ±ÅŸ olan blok "instantiate" edilmez (ÅŸablonun o parÃ§asÄ± Ã¼retilmez).

### Type Traits ile KullanÄ±mÄ±
```cpp
template <typename T>
void process(T val) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "Pointer islemi: " << *val << "\n";
    } else {
        std::cout << "Deger islemi: " << val << "\n";
    }
}
```

---

## 13. Variadic Templates (DeÄŸiÅŸken SayÄ±da Åablon Parametreleri) GiriÅŸ [02:12:00 - 02:30:00]

Modern C++ (C++11) Ã¶ncesinde, farklÄ± sayÄ±da parametre alan ÅŸablonlar iÃ§in her sayÄ±ya Ã¶zel overload yazÄ±lÄ±rdÄ±. Variadic Templates bu sorunu kÃ¶kten Ã§Ã¶zer.

### Temel Kavramlar:
1.  **Template Parameter Pack:** `typename... Args` -> SÄ±fÄ±r veya daha fazla tÃ¼rÃ¼ temsil eden paket.
2.  **Function Parameter Pack:** `Args... args` -> Bu tÃ¼rlerden oluÅŸan nesne paketi.
3.  **Ellipsis (`...`) Token:** ÃœÃ§ nokta, paketin nerede olduÄŸunu veya nerede aÃ§Ä±lacaÄŸÄ±nÄ± (expansion) belirtir.

```cpp
template <typename... Args> // Template Parameter Pack
void logger(Args... args)   // Function Parameter Pack
{
    // ...
}
```

### `sizeof...` OperatÃ¶rÃ¼
Bir paket iÃ§erisindeki eleman sayÄ±sÄ±nÄ± derleme zamanÄ±nda Ã¶ÄŸrenmek iÃ§in kullanÄ±lÄ±r. Normal `sizeof` ile karÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r; `sizeof...` doÄŸrudan paketi hedef alÄ±r.
```cpp
template <typename... Args>
void countArgs(Args... args) {
    constexpr size_t n = sizeof...(Args); // TÃ¼r sayÄ±sÄ±nÄ± verir
    constexpr size_t m = sizeof...(args); // ArgÃ¼man sayÄ±sÄ±nÄ± verir
}
```

---

## 14. Pack Expansion (Paket GeniÅŸletme) [02:30:01 - 02:46:17]

Paketleri tek baÅŸlarÄ±na kullanamayÄ±z; onlarÄ± bir "Pattern" (Ã–rÃ¼ntÃ¼) eÅŸliÄŸinde aÃ§mamÄ±z gerekir.

### Base Class Expansion (Taban SÄ±nÄ±f GeniÅŸletme)
Bir sÄ±nÄ±fÄ±n, belirsiz sayÄ±da sÄ±nÄ±ftan aynÄ± anda kalÄ±tÄ±m almasÄ±nÄ± saÄŸlar.
```cpp
template <typename... Bases>
class MultiDerived : public Bases... {}; // TÃ¼m tÃ¼rlerden kalÄ±tÄ±m alÄ±r

// Ã–rnek: MultiDerived<A, B, C> -> class MultiDerived : public A, public B, public C
```

### Using Declaration Expansion
Taban sÄ±nÄ±flardaki aynÄ± isimli fonksiyonlarÄ± (overload Ã§Ã¶zÃ¼mlemesi iÃ§in) tÃ¼remiÅŸ sÄ±nÄ±fa topluca Ã§ekmek iÃ§in kullanÄ±lÄ±r:
```cpp
template <typename... Bases>
struct Overloader : Bases... {
    using Bases::foo...; // TÃ¼m taban sÄ±nÄ±flardaki foo'larÄ± gÃ¶rÃ¼nÃ¼r kÄ±lar
};
```

---

## Master Kod Ã–rneÄŸi (Type Traits ve Variadic GiriÅŸ)

AÅŸaÄŸÄ±daki kod, derleme zamanÄ±nda tÃ¼r sorgulayan, `if constexpr` ile yol ayrÄ±mÄ± yapan ve variadic bir yapÄ±ya sahip temel bir sistemi Ã¶zetler:

```cpp
#include <iostream>
#include <type_traits>

// Meta-function: Sadece tam sayÄ± ve gerÃ§ek sayÄ± tÃ¼rlerini kabul et
template <typename T>
void smart_print(T val) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Tam sayi: " << val << "\n";
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Gercek sayi: " << val << "\n";
    } else {
        std::cout << "Diger tur\n";
    }
}

// Variadic ÅŸablon: Paketi aÃ§madan eleman sayÄ±sÄ±nÄ± gÃ¶steren bir yapÄ±
template <typename... Args>
struct PacketInfo {
    static void printCount() {
        std::cout << "Paketteki eleman sayisi: " << sizeof...(Args) << std::endl;
    }
};

int main() {
    smart_print(10);      // Tam sayi
    smart_print(5.5);     // Gercek sayi
    smart_print("Merhaba"); // Diger tur

    PacketInfo<int, double, char, long>::printCount(); // Ã‡Ä±ktÄ±: 4
}
```

---
