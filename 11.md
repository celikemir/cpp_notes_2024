Harika bir istek! İşte 5 Ağustos 2024 tarihli 11. C++ dersinin detaylı notları:

**DERS NOTLARI: C++ Özel Üye Fonksiyonları - Copy Constructor ve Copy Assignment**

**BÖLÜM 1: ÖNCEKİ DERSİN TEKRARI VE GİRİŞ (00:00.000 - 00:59.140)**

*   **Giriş:**
    *   Ders Tarihi: 5 Ağustos 2024 Pazartesi
    *   Ders Saati: 19.31
    *   Konu: Kaldığımız yerden devam (Constructor ve Destructor ana başlığı altında Özel Üye Fonksiyonları).
*   **Önceki Dersin Kısa Tekrarı (00:19.620 - 00:54.680):**
    *   **C'den Bilinmesi Gerekenler:** `Complete type` ve `incomplete type` kavramları ve bunların C++ için önemi.
        *   **Complete Type:** Derleyicinin boyutunu ve yapısını tam olarak bildiği tiptir. Örneğin, `int`, `double` veya tanımı tam olarak yapılmış bir `struct` ya da `class`.
        *   **Incomplete Type:** Derleyicinin boyutunu veya yapısını henüz bilmediği tiptir. Genellikle bir `class` veya `struct`'ın sadece bildiriminin yapıldığı (forward declaration) durumlarda karşımıza çıkar. Örneğin, `class MyClass;`
        *   **Önemi:** Özellikle başlık dosyalarında (`.h`, `.hpp`), `incomplete type` kullanımı (genellikle pointer veya referanslar aracılığıyla) gereksiz bağımlılıkları azaltır ve derleme sürelerini kısaltır. `Complete type`'a ihtiyaç duyulmayan yerlerde (örneğin, bir sınıfın içinde başka bir sınıf türünden sadece pointer veya referans tutuluyorsa) `incomplete type` kullanmak tercih edilir.
    *   **Amaç:** Gereksiz bağımlılıkları ortadan kaldırmak ve derleme sürelerini iyileştirmek.

**BÖLÜM 2: CONSTRUCTOR, DESTRUCTOR VE İLGİLİ KAVRAMLARIN HATIRLATILMASI (01:00.000 - 03:14.520)**

*   **Ana Konu:** Constructor ve Destructor.
*   **Öğrenilen Terimler (01:03.080 - 01:29.660):**
    *   **Default Constructor:** Parametresiz çağrılabilen constructor. Derleyici, programcı hiç constructor yazmazsa bazı durumlarda bunu kendisi oluşturur.
    *   **Member Initializer List (MIL) / Constructor Initializer List:** Bir sınıfın non-static veri elemanlarını constructor gövdesine girmeden önce initialize etmek için kullanılan syntax.
        *   **Faydaları:**
            *   Performans: Özellikle sınıf türünden üyeler için gereksiz default constructor + atama yerine doğrudan copy/move constructor çağrılmasını sağlar.
            *   Zorunluluk: Referans türünden üyeler, `const` üyeler ve base class alt nesnelerinin initialize edilmesi için zorunludur.
        *   **Syntax:** `ClassName(params) : member1(val1), member2(val2) { /* constructor body */ }`
*   **Önemli Kural (Derleyicinin SMF Davranışı) (01:29.660 - 02:28.460):**
    *   Derleyici bir sınıfın bir "Special Member Function"ını (Özel Üye Fonksiyonu - SMF) örtülü olarak bildirip (`implicitly declare`) onu `default` ettiğinde (yani tanımını yaptığında), eğer bu tanım dil kurallarını çiğneyen bir durum oluşturursa (örneğin, bir üyenin ilgili SMF'sinin olmaması, `private` olması veya `delete` edilmiş olması, `default initialize` edilemeyen bir üyenin `default initialize` edilmeye çalışılması), derleyici syntax hatası vermek yerine o SMF'yi örtülü olarak `delete` eder.
    *   Bu, Modern C++ (C++11 ve sonrası) ile gelen bir kuraldır. Eskiden bu durumlar syntax hatasına yol açabilirdi.
*   **In-class Initializer / Default Member Initializer (02:29.800 - 03:14.520):**
    *   Modern C++ ile gelen bir özelliktir.
    *   Sınıf tanımı içinde non-static veri elemanlarına doğrudan ilk değer atanmasını sağlar.
        ```cpp
        class MyData {
            int x = 10; // In-class initializer
            std::string s = "hello"; // In-class initializer
        public:
            MyData() {} // x ve s zaten initialize edildi
        };
        ```
    *   Eğer bir constructor, MIL kullanarak bir üyeyi initialize etmezse ve o üyenin in-class initializer'ı varsa, o değer kullanılır. Yoksa, üye default initialize edilir.

**BÖLÜM 3: SINIFLARIN ÖZEL ÜYE FONKSİYONLARI (SMF) - GENEL BAKIŞ (03:14.520 - 05:16.040)**

*   **Tanışma Zamanı:** Sınıfın diğer özel üye fonksiyonları.
*   **Kaç Tane SMF Var? (03:46.860):** 6 tane.
    1.  **Default Constructor:** Parametresiz kurucu.
    2.  **Destructor:** Yıkıcı fonksiyon, nesne ömrü bittiğinde çağrılır.
    3.  **Copy Constructor:** Kopyalayan kurucu.
    4.  **Move Constructor:** Taşıyan kurucu (C++11).
    5.  **Copy Assignment Operator:** Kopyalayarak atama operatörü.
    6.  **Move Assignment Operator:** Taşıyarak atama operatörü (C++11).
*   **SMF'lerin İşlevleri (Kısa Tanıtım):**
    *   **Hayata Gelme/Bitme:** Default Constructor, Destructor.
    *   **Kopyalama Yoluyla Hayata Gelme:** Copy Constructor (Bir nesnenin değerini, aynı türden başka bir nesneden alarak hayata gelmesi).
    *   **Taşıma Yoluyla Hayata Gelme:** Move Constructor (Bir nesnenin kaynağını, "çalınabilir" (movable) durumdaki başka bir nesneden alarak hayata gelmesi, genellikle geçici nesnelerden).
    *   **Kopyalama Yoluyla Atama:** Copy Assignment (Var olan bir nesneye, aynı türden başka bir nesnenin değerinin atanması).
    *   **Taşıma Yoluyla Atama:** Move Assignment (Var olan bir nesneye, "çalınabilir" durumdaki başka bir nesnenin kaynağının atanması).
*   Bugünkü dersin ana odağı: **Copy Constructor**.

**BÖLÜM 4: COPY CONSTRUCTOR (05:18.000 - Devam Ediyor)**

*   **Temel Kavram (05:18.000 - 05:39.620):**
    *   C++ dilinde, bir sınıf nesnesi değerini aynı türden başka bir sınıf nesnesinden alarak hayata geldiğinde, sınıfın `Copy Constructor` (kopyalayan kurucu) denilen özel üye fonksiyonu çağrılır.
    *   Bu da bir SMF olduğu için, belirli şartlar sağlandığında derleyici bunu örtülü olarak (`implicitly`) bildirip kodunu yazabilir (`default` edebilir).
*   **Kopyalama Semantiği (07:36.140 - 12:21.760):**
    *   Bir nesne başka bir nesnenin değeriyle hayata getirildiğinde veya bir nesneye başka bir nesnenin değeri atandığında ne beklenir?
    1.  **Bağımsızlık (Independent State):**
        *   Kopyalama veya atama işleminden sonra, kaynak ve hedef nesneler birbirinden tamamen bağımsız olmalıdır.
        *   Bir nesne üzerinde yapılan değişiklikler diğerini etkilememelidir. Buna "değer semantiği" (value semantics) denir.
        *   **Örnek:** `Ahmet` ve `Yusuf` adında iki `Kisi` nesnesi olsun. `Kisi Ahmet = Yusuf;` yapıldıktan sonra `Ahmet`'in yaşını değiştirmek `Yusuf`'un yaşını etkilememelidir.
    2.  **Eşitlik (Equality):**
        *   Kopyalama veya atama işleminden hemen sonra, eğer nesneler eşitlik karşılaştırmasına (`==`) tabi tutulabiliyorsa, bu karşılaştırma `true` değerini vermelidir.
        *   **Örnek:** `Date d1(5, 8, 2024); Date d2 = d1;` işleminden sonra `(d1 == d2)` ifadesi `true` olmalıdır. Daha sonra `d1`'in tarihi değiştirilirse `d2`'nin tarihi aynı kalmalı ve eşitlik bozulmalıdır.
    *   **Not:** Bu beklentiler "çoğunluk senaryosu" içindir. Marjinal veya özel durumlar farklı davranışlar gerektirebilir.
*   **Copy Constructor Çağrılma Durumları (Sintaks) (12:24.600 - 15:37.080):**
    *   Bir nesne, hayata gelirken değerini aynı türden başka bir nesneden aldığında `Copy Constructor` çağrılır.
    *   **Örnekler:**
        ```cpp
        MyClass m1; // Default constructor (varsa)

        MyClass m2(m1);          // Direct initialization -> Copy Constructor for m2
        MyClass m3 = m1;         // Copy initialization -> Copy Constructor for m3
        MyClass m4{m1};          // Direct list initialization (C++11) -> Copy Constructor for m4
        auto m5 = m1;            // Type deduction -> Copy Constructor for m5
        ```
    *   Bu sentaksların hepsi `m1`'i kullanarak yeni bir nesne (m2, m3, m4, m5) oluşturur ve bu sırada `MyClass`'ın `Copy Constructor`'ı çağrılır.
*   **Derleyicinin Yazdığı Copy Constructor'ın Yapısı (17:11.380 - 27:27.560):**
    *   Eğer programcı bir `Copy Constructor` bildirmezse (ve bazı özel durumlar yoksa), derleyici bir tane `implicitly declare` edip `default` eder.
    *   **Bildirimi:**
        *   `public` erişim belirleyicisine sahiptir.
        *   `non-static` bir üye fonksiyonudur.
        *   `inline` olarak tanımlanır.
        *   Geri dönüş değeri yoktur (çünkü bir constructor'dır).
        *   Parametresi, sınıfın kendisi türünden bir `const L-value reference`'dır.
        *   **Örnek (`MyClass` için):** `public: inline MyClass(const MyClass& other);`
    *   **İşlevi (Ne Yapar?):**
        *   "Member-wise copy" (üye bazlı kopyalama) yapar.
        *   Yeni oluşturulan nesnenin (`this` ile erişilen) her bir non-static veri elemanını, parametre olarak gelen `other` nesnesinin karşılık gelen veri elemanının değeriyle initialize eder.
        *   **Örnek (`MyClass`'ın `ax`, `bx`, `cx` üyeleri varsa):**
            ```cpp
            // Derleyicinin yazdığı kodun mantıksal eşdeğeri
            MyClass::MyClass(const MyClass& other)
                : ax(other.ax)  // other.ax'i kullanarak ax'i initialize et
                , bx(other.bx)  // other.bx'i kullanarak bx'i initialize et
                , cx(other.cx)  // other.cx'i kullanarak cx'i initialize et
            {
                // Gövde genellikle boştur
            }
            ```
        *   Eğer `ax`, `bx`, `cx` gibi üyeler temel türler (int, double, pointer) ise, değerleri doğrudan kopyalanır.
        *   Eğer bu üyeler başka sınıf türlerinden nesneler ise, o sınıfların kendi `Copy Constructor`'ları çağrılarak bu üyeler initialize edilir.

*   **Rule of Zero / Rule of Three / Rule of Five (17:52.780 - 20:49.640):**
    *   **Rule of Zero:**
        *   İdeal durumdur. Eğer bir sınıf kaynak yönetimi yapmıyorsa (örneğin, ham pointer ile dinamik bellek yönetimi, dosya tanıtıcısı vb. tutmuyorsa) veya üyeleri zaten RAII prensibine uygun sınıflar ise (`std::string`, `std::vector` gibi), o zaman genellikle hiçbir özel üye fonksiyonunu (Destructor, Copy Constructor, Copy Assignment, Move Constructor, Move Assignment) elle yazmaya veya `default`/`delete` etmeye gerek yoktur. Derleyicinin ürettikleri yeterli olacaktır.
    *   **Rule of Three (Eski C++ - C++98/03):**
        *   Eğer bir sınıf için şu üçünden birini (Destructor, Copy Constructor, Copy Assignment Operator) elle yazma ihtiyacı doğuyorsa, muhtemelen diğer ikisini de yazmak gerekir. Bu genellikle sınıfın bir tür kaynak yönetimi (örn: dinamik bellek) yaptığı anlamına gelir.
    *   **Rule of Five (Modern C++ - C++11 ve sonrası):**
        *   Rule of Three'ye Move Constructor ve Move Assignment Operator'ın eklenmiş halidir. Eğer bir sınıf için bu beş fonksiyondan birini yazma ihtiyacı varsa, diğer dördünün de durumu gözden geçirilmelidir (ya elle yazılmalı, ya `default` edilmeli ya da `delete` edilmelidir).
*   **Kod Örneği: `Date` Sınıfı ile Copy Constructor Gösterimi (27:54.380 - 38:03.540):**
    *   Basit bir `Date` sınıfı (üyeleri `int m_day, m_month, m_year`).
    *   Parametreli constructor (`Date(int d, int m, int y)`).
    *   Destructor (`~Date()`).
    *   Bu fonksiyonlara `std::cout` ile çağrıldıklarını belirten mesajlar eklendi.
    *   **Senaryo 1 (Derleyicinin Yazdığı CC):**
        ```cpp
        Date d1(5, 8, 2024); // Parametreli constructor çağrılır
        Date d2 = d1;       // Date'in Copy Constructor'ı çağrılır (d2 için)
                            // Eğer biz yazmadıysak, derleyici yazar.
        // d1 ve d2 için destructor'lar çağrılır (kapsam sonunda)
        ```
        Bu durumda, `d2` için `Copy Constructor` çağrıldığını görmek için `std::cout` mesajı olmaz (çünkü derleyici yazar).
    *   **Senaryo 2 (Kullanıcının Yazdığı CC):**
        ```cpp
        // Date sınıfı içinde
        public:
            Date(const Date& other)
                : m_day(other.m_day), m_month(other.m_month), m_year(other.m_year) {
                std::cout << "Date Copy Constructor called for object at " << this
                          << " from object at " << &other << std::endl;
            }
        ```
        Bu durumda `Date d2 = d1;` satırında yukarıdaki `Copy Constructor` çağrılır ve mesaj ekrana basılır. `this` pointer'ı `d2`'yi, `&other` ise `d1`'in adresini gösterir.
    *   `print()` fonksiyonu eklenerek `d1` ve `d2`'nin değerlerinin aynı olduğu, ancak bağımsız nesneler olduğu gösterildi.
*   **Overloading ve SMF'ler (Rasul'un Sorusu Üzerine Açıklama) (39:54.520 - 42:23.880):**
    *   Tüm constructor'lar (default, parametreli, copy, move) aynı isme (`ClassName`) sahip oldukları için birbirlerinin **overload**'larıdır. Derleyici, hangi constructor'ın çağrılacağına argümanlara bakarak `Function Overload Resolution` kurallarıyla karar verir.
    *   Benzer şekilde, `Copy Assignment Operator` (`operator=`) ve `Move Assignment Operator` (`operator=`) da birbirlerinin overload'larıdır.
    *   Ancak, bir `Copy Constructor` ile bir `Copy Assignment Operator` birbirinin overload'u *değildir*. Birincisi bir constructor iken, ikincisi `operator=` isimli bir fonksiyondur.
*   **`this` Pointer'ın Doğası (42:25.820 - 43:36.820):**
    *   `this` pointer, non-static üye fonksiyonlarına derleyici tarafından örtülü olarak geçirilen, çağrıyı yapan nesnenin adresini tutan bir pointer'dır. Fonksiyonun gizli bir parametresi gibi düşünülebilir.
*   **Copy Constructor'ın Çağrıldığı Diğer Tipik Durumlar (43:37.860 - 55:57.500):**
    1.  **Doğrudan İlk Değer Verme (Tekrar):** `MyClass m2 = m1;`
    2.  **Fonksiyona Değer Yoluyla Argüman Geçme (Pass by Value):**
        *   Bir fonksiyona bir nesne değer yoluyla (referans veya pointer değil) argüman olarak geçirildiğinde, fonksiyonun parametre değişkeni için `Copy Constructor` çağrılır.
        ```cpp
        void processDate(Date d_param) { // d_param için Date'in Copy Constructor'ı çağrılır
            d_param.print();
        }
        Date my_date(5, 8, 2024);
        processDate(my_date); // my_date'i kopyalayarak d_param oluşturulur
        ```
    3.  **Fonksiyondan Değer Yoluyla Nesne Döndürme (Return by Value):**
        *   Bir fonksiyon bir nesneyi değer yoluyla döndürdüğünde, geri dönüş değeri için geçici bir nesne oluşturulurken `Copy Constructor` çağrılabilir.
        ```cpp
        Date createDate() {
            Date temp_date(1, 1, 2000);
            return temp_date; // temp_date'i kopyalayarak bir geri dönüş nesnesi oluşturulabilir
        }
        Date new_d = createDate();
        ```
        *   **ÖNEMLİ NOT (Copy Elision):** Modern C++ derleyicileri bu durumda sıklıkla **Copy Elision** (Kopyalamadan Kaçınma) optimizasyonu yaparlar. RVO (Return Value Optimization) veya NRVO (Named Return Value Optimization) gibi tekniklerle gereksiz kopyalamalar engellenir. C++17 ile bazı durumlarda kopyalamanın yapılmaması garanti altına alınmıştır (Guaranteed Copy Elision). Bu nedenle, bu senaryoda `Copy Constructor`'ın *her zaman* çağrılacağı düşünülmemelidir.
*   **`const T&` Parametresinin Esnekliği (49:01.580 - 53:39.820):**
    *   `Copy Constructor`'ın parametresinin `const MyClass&` olması önemlidir:
        *   `const`: Kaynak nesnenin `Copy Constructor` içinde değiştirilmeyeceğini garanti eder.
        *   `&` (L-value referans): Gereksiz bir kopyalama daha yapılmasını engeller (parametre geçerken).
        *   `const L-value reference`'ın en büyük avantajı hem L-value'lara (örn: `m1`) hem de R-value'lara (örn: `MyClass(1,2,3)` gibi geçici bir nesne) bağlanabilmesidir. Bu, `Move Constructor` olmadığı veya uygun olmadığı durumlarda R-value'ların da kopyalanabilmesini sağlar.
*   **Copy Constructor'ı `default` ve `delete` Etme (58:11.180 - 01:02:47.960):**
    *   **`= default;`**
        *   Programcı, derleyicinin üreteceği varsayılan davranışı istediğini açıkça belirtmek için kullanır.
        *   `MyClass(const MyClass&) = default;`
        *   Bu, SMF'nin `public`, `private` veya `protected` bölümde bildirilmesine ve hatta tanımının `.cpp` dosyasına ertelenmesine olanak tanır.
    *   **`= delete;`**
        *   Programcı, bu SMF'nin kullanılmasını engellemek istediğinde kullanır.
        *   `MyClass(const MyClass&) = delete;`
        *   Bu durumda, bu sınıf türünden bir nesneyi kopyalamaya çalışmak derleme zamanı hatasına yol açar.
        *   **Örtülü `delete`:** Eğer derleyicinin `default` edeceği bir `Copy Constructor`'ın tanımı (örneğin bir üyenin `Copy Constructor`'ı `delete` edilmişse veya erişilemiyorsa) geçerli bir kod oluşturmuyorsa, derleyici bu `Copy Constructor`'ı örtülü olarak `delete` eder.

**BÖLÜM 5: NEDEN COPY CONSTRUCTOR YAZMALIYIZ? SHALLOW COPY vs. DEEP COPY (01:02:53.080 - 01:29:01.680)**

*   **Temel Soru:** Derleyici zaten bir `Copy Constructor` yazıyorsa, biz neden yazalım?
*   **Cevap:** Sınıf **kaynak yönetimi** yapıyorsa (resource-owning class).
    *   **Kaynaklar:** Dinamik olarak ayrılmış bellek (ham pointer ile yönetilen), dosya tanıtıcıları, ağ bağlantıları, mutex'ler vb.
    *   Bu tür sınıflar genellikle kaynağa bir "handle" (işaretçi, tanıtıcı) aracılığıyla erişir.
*   **Örnek: Basit `String` Sınıfı (Ham Pointer ile):**
    *   Üyeler: `char* mp_data;` (dinamik bellekteki karakter dizisini gösterir), `size_t m_length;`
    *   Constructor (`String(const char* s)`): `m_length`'i hesaplar, `malloc` ile bellek ayırır, `strcpy` ile `s`'i bu belleğe kopyalar.
    *   Destructor (`~String()`): `free(mp_data);` ile ayrılan belleği iade eder.
*   **Derleyicinin Yazdığı Copy Constructor'ın Sorunu (Shallow Copy):**
    *   `String s1("hello");`
    *   `String s2 = s1;` // Derleyicinin yazdığı CC çağrılır.
    *   Derleyici ne yapar?
        *   `s2.m_length = s1.m_length;` (Bu sorunsuz)
        *   `s2.mp_data = s1.mp_data;` (İŞTE SORUN BURADA!)
    *   Bu duruma **Shallow Copy (Sığ Kopyalama)** denir. Sadece pointer'ın değeri (adres) kopyalanır, gösterdiği veri (kaynak) kopyalanmaz.
    *   **Shallow Copy'nin Yol Açtığı Problemler:**
        1.  **Dangling Pointer:** `s1` veya `s2`'den biri (örneğin `s2`) kapsam dışı kaldığında destructor'ı `mp_data`'nın gösterdiği belleği `free` eder. Şimdi `s1.mp_data` artık serbest bırakılmış, geçersiz bir bellek alanını gösteren bir **dangling pointer** haline gelir. `s1` üzerinden bu veriye erişmeye çalışmak tanımsız davranışa (undefined behavior - UB) yol açar.
        2.  **Double Free:** Kapsam sonunda `s1`'in destructor'ı da çağrıldığında, aynı bellek alanını ikinci kez `free` etmeye çalışır. Bu da tanımsız bir davranıştır ve genellikle programın çökmesine neden olur.
        3.  **Value Semantics Kaybı:** Eğer `s1`'in içeriği bir şekilde değiştirilebilseydi (örneğin bir `append` fonksiyonu ile), `s2`'nin içeriği de değişirdi çünkü ikisi de aynı veriyi paylaşıyor. Bu, kopyalamanın temel amacı olan bağımsızlığı ihlal eder.
*   **Çözüm: Deep Copy (Derin Kopyalama) (01:11:22.540):**
    *   Programcı, `Copy Constructor`'ı kendisi yazmalıdır.
    *   `Copy Constructor` içinde:
        1.  Yeni nesne (`this`) için kendi bağımsız kaynağını (örneğin, yeni bir bellek alanı) allocate etmelidir.
        2.  Kaynak nesnenin (`other`) gösterdiği veriyi, yeni allocate edilen bu kaynağa kopyalamalıdır.
        ```cpp
        // String sınıfı içinde Deep Copy Constructor
        String::String(const String& other) : m_length(other.m_length) {
            if (other.mp_data) {
                mp_data = static_cast<char*>(malloc(m_length + 1)); // 1. Yeni bellek ayır
                if (mp_data) {
                    strcpy(mp_data, other.mp_data); // 2. Veriyi kopyala
                } else {
                    // Hata yönetimi, örn: exception fırlat veya m_length = 0, mp_data = nullptr yap
                    m_length = 0;
                    mp_data = nullptr; // Güvenli durum
                }
            } else {
                mp_data = nullptr;
                m_length = 0;
            }
            std::cout << "String Deep Copy Constructor called for " << this << std::endl;
        }
        ```
    *   Bu sayede her `String` nesnesi kendi bellek alanına sahip olur, yukarıdaki sorunlar ortadan kalkar.
*   **RAII (Resource Acquisition Is Initialization) Prensibi (01:14:03.700 - 01:18:26.980):**
    *   Açılımı: "Kaynak Edinimi İlk Değer Vermedir."
    *   Bjarne Stroustrup tarafından isimlendirilmiştir. Hoca, "kötü uydurulmuş bir akronim" olduğunu, çünkü ismin tam olarak felsefeyi yansıtmadığını belirtir. Asıl vurgu kaynağın destructor'da serbest bırakılması üzerinedir.
    *   **Felsefesi:** Bir kaynağın ömrü, o kaynağı yöneten bir nesnenin ömrüne bağlanır.
        *   Kaynak, nesnenin constructor'ında edinilir (acquire).
        *   Kaynak, nesnenin destructor'ında serbest bırakılır (release).
    *   **Avantajları:**
        *   Kaynak sızıntılarını (memory leak, file handle leak vb.) büyük ölçüde engeller, çünkü nesne kapsam dışına çıktığında destructor otomatik olarak çağrılır (exception durumlarında bile stack unwinding sayesinde).
        *   Kodu daha temiz ve güvenli hale getirir.
    *   Örnek `String` sınıfımız RAII prensibine uyar: Constructor `malloc` yapar, Destructor `free` yapar.
*   **Shallow Copy Probleminin Fonksiyon Çağrısı ile Gösterimi (01:20:45.500 - 01:26:25.240):**
    *   `void func(String s_param)` gibi bir fonksiyona `String main_str("test"); func(main_str);` şeklinde çağrı yapıldığında:
        *   Eğer `String`'in `Copy Constructor`'ı shallow copy yapıyorsa: `s_param.mp_data` ve `main_str.mp_data` aynı yeri gösterir.
        *   `func` bittiğinde `s_param`'ın destructor'ı belleği `free` eder.
        *   `func`'tan sonra `main_str.mp_data` dangling pointer olur. `main_str`'ı kullanmak UB'dir.
*   **Kod Örneği: `String` Sınıfı ile Shallow ve Deep Copy Constructor Uygulaması (01:29:10.060 - 01:44:16.380):**
    *   Dersin bu bölümünde hoca, `String` sınıfını (constructor, destructor, print, length) implemente etti.
    *   **Shallow Copy Senaryosu:**
        *   `Copy Constructor` programcı tarafından yazılmadığında (derleyici varsayılan olarak shallow copy yapar).
        *   `void processString(String str_val) { ... }` fonksiyonuna bir `String` nesnesi geçildiğinde, `processString` bittikten sonra ana fonksiyondaki orijinal `String` nesnesinin işaretçisi dangling hale geldi ve program çöktü (veya UB sergiledi).
    *   **Deep Copy ile Çözüm:**
        *   Yukarıda gösterilen `String Deep Copy Constructor` implementasyonu eklendi.
        *   Aynı `processString` senaryosu tekrar çalıştırıldığında, her nesne kendi belleğine sahip olduğu için sorun yaşanmadı.
    *   **Önemli Detay:** Bir `Copy Constructor` yazıyorsanız, sadece sorunlu olan pointer üyesini değil, *tüm* üyeleri (örn: `m_length`) doğru şekilde kaynak nesneden kopyalamak/initialize etmek sizin sorumluluğunuzdadır. Unutulan üyeler ya default initialize edilir ya da tanımsız değerler alabilir.

*   **`Copy Constructor` Yazma Sıklığı ve Rule of Zero'ya Dönüş (01:44:16.380 - 01:51:04.240):**
    *   **Soru:** Pratikte ne kadar sıklıkla `Copy Constructor` (ve diğer SMF'leri) elle yazmak gerekir?
    *   **Cevap:** Çok nadiren! Tahminler: %1-2, en fazla %5.
    *   **Neden?**
        *   Çoğu modern C++ sınıfı, doğrudan ham pointer'lar veya işletim sistemi tanıtıcıları gibi düşük seviye kaynakları yönetmez.
        *   Bunun yerine, zaten RAII prensiplerine göre düzgün kaynak yönetimi yapan standart kütüphane sınıflarını (`std::string`, `std::vector`, `std::unique_ptr`, `std::shared_ptr` vb.) üye olarak kullanırlar.
        *   **Örnek:**
            ```cpp
            class Student {
                std::string m_name;
                std::vector<int> m_grades;
                int m_studentID;
            public:
                // ... constructor'lar ...
                // Hiçbir SMF'yi elle yazmaya gerek yok!
            };
            ```
            Bu `Student` sınıfı için derleyicinin yazdığı `Copy Constructor` yeterlidir:
            *   `m_name` için `std::string`'in `Copy Constructor`'ı çağrılır (bu zaten deep copy yapar).
            *   `m_grades` için `std::vector`'un `Copy Constructor`'ı çağrılır (bu da deep copy yapar).
            *   `m_studentID` için basit bir tamsayı kopyalaması yapılır.
        *   Bu durum, **Rule of Zero**'nun etkinliğini gösterir. İyi tasarlanmış temel bileşenler kullanıldığında, karmaşık sınıflar için SMF yazma ihtiyacı azalır veya ortadan kalkar.
        *   Ham kaynak yönetimi yapan sınıflar (derste yazılan `String` gibi) genellikle daha temel, kütüphane seviyesindeki sınıflardır. Uygulama geliştiricileri bunları doğrudan yazmak yerine, hazır çözümleri kullanır.

**(Devam edecek: Copy Assignment Operator...)**

Harika, `Copy Assignment Operator` ile devam edelim:

**BÖLÜM 6: COPY ASSIGNMENT OPERATOR (01:51:04.240 - 02:40:59.420)**

*   **Giriş (01:51:04.240 - 01:57:35.260):**
    *   `Copy Constructor`'dan sonra ele alınacak diğer önemli SMF, `Copy Assignment Operator`'dır.
    *   **Senaryo:** Var olan iki nesne arasında atama.
        ```cpp
        String s1("Merhaba");
        String s2("Dunya");
        // s1 ve s2 zaten hayatta

        s1 = s2; // Burada s1 için String::operator=(const String&) çağrılır.
        ```
    *   **Temel Fark:** `Copy Constructor` yeni bir nesne oluştururken çağrılırken, `Copy Assignment Operator` zaten var olan bir nesnenin değerini değiştirmek için çağrılır.
*   **Operator Overloading ile İlişkisi (01:55:17.660 - 01:59:20.700):**
    *   C++'da operatörlerin sınıf türleri için davranışları özelleştirilebilir. Bu mekanizmaya **Operator Overloading (Operatör Yüklemesi)** denir.
    *   Bir operatör (örn: `=`, `+`, `[]`) sınıf nesneleriyle kullanıldığında, derleyici bu ifadeyi özel bir fonksiyona yapılan çağrıya dönüştürür.
    *   Bu özel fonksiyonların isimleri standartlaşmıştır: `operator` anahtar kelimesi takip eden operatör sembolü.
        *   Örnekler: `operator=`, `operator+`, `operator[]`, `operator<<`.
    *   `s1 = s2;` ifadesi, aslında `s1.operator=(s2);` şeklinde bir fonksiyon çağrısına dönüşür (eğer `operator=` bir üye fonksiyonu ise).
*   **Copy Assignment Operator'ın Adı ve SMF Olması (01:59:05.420 - 02:02:46.060):**
    *   Kopyalama yoluyla atama yapan operatör fonksiyonunun adı `operator=`'dır.
    *   Bu da bir SMF'dir. Yani:
        *   Belirli şartlarda derleyici tarafından örtülü olarak bildirilir ve `default` edilir.
        *   Programcı tarafından `default` edilebilir.
        *   Programcı tarafından `delete` edilebilir.
        *   Programcı tarafından özel bir implementasyonla yazılabilir.
    *   Eski C++'da genellikle "Assignment Operator Function" denirken, Modern C++'da `Move Assignment` da olduğu için spesifik olarak `Copy Assignment` ve `Move Assignment` terimleri kullanılır.
*   **Derleyicinin Yazdığı Copy Assignment Operator'ın Yapısı (02:07:07.340 - 02:15:16.500):**
    *   Eğer programcı bir `Copy Assignment Operator` bildirmezse (ve bazı özel durumlar yoksa), derleyici bir tane `implicitly declare` edip `default` eder.
    *   **Bildirimi (`MyClass` için):**
        ```cpp
        public:
            MyClass& operator=(const MyClass& other);
        ```
        *   `public` erişim belirleyicisine sahiptir.
        *   `non-static` bir üye fonksiyonudur.
        *   `inline` olarak tanımlanır.
        *   **Geri Dönüş Değeri:** Sınıfın kendisi türünden bir **L-value referans** (`MyClass&`). Bu, zincirleme atamalara (`a = b = c;`) ve atama ifadesinin sonucunun başka bir ifadede kullanılmasına olanak tanır.
        *   **Parametresi:** Sınıfın kendisi türünden bir `const L-value reference` (`const MyClass& other`). Kaynak nesnenin değiştirilmemesi ve gereksiz kopyalamanın önlenmesi için.
    *   **İşlevi (Ne Yapar?):**
        *   "Member-wise assignment" (üye bazlı atama) yapar.
        *   Sol taraftaki nesnenin (`this` ile erişilen) her bir non-static veri elemanına, parametre olarak gelen `other` nesnesinin karşılık gelen veri elemanının değerini atar.
        *   **Örnek (`MyClass`'ın `ax`, `bx`, `cx` üyeleri varsa):**
            ```cpp
            // Derleyicinin yazdığı kodun mantıksal eşdeğeri
            MyClass& MyClass::operator=(const MyClass& other) {
                if (this != &other) { // Self-assignment check (derleyici bunu her zaman eklemeyebilir)
                    ax = other.ax;  // other.ax'in değerini ax'e ata
                    bx = other.bx;  // other.bx'in değerini bx'e ata
                    cx = other.cx;  // other.cx'in değerini cx'e ata
                }
                return *this; // Kendisine atama yapılan nesneye referans döndür
            }
            ```
        *   Eğer `ax`, `bx`, `cx` gibi üyeler temel türler (int, double, pointer) ise, basit atama yapılır.
        *   Eğer bu üyeler başka sınıf türlerinden nesneler ise, o sınıfların kendi `Copy Assignment Operator`'ları çağrılarak atama gerçekleştirilir.
    *   **Geri Dönüş Değeri `*this`:** Fonksiyon, atama yapılan nesnenin kendisine bir L-value referans döndürür. Bu, C'den gelen `a = b = c;` gibi zincirleme atama deyimlerinin C++ sınıfları için de doğal bir şekilde çalışmasını sağlar.
        *   `x = y = z;` ifadesi `x = (y = z);` şeklinde yorumlanır. `(y = z)` işlemi `y`'ye bir referans döndürür, bu da `x`'e atanır.
*   **Derleyicinin Yazdığı Copy Assignment'ın Sorunları (Shallow Copy Tekrarı) (02:24:25.360 - 02:27:18.680):**
    *   Eğer sınıf kaynak yönetimi yapıyorsa (dersimizdeki `String` sınıfı gibi ham pointer ile bellek yönetiyorsa), derleyicinin yazdığı `Copy Assignment` da `Copy Constructor`'daki gibi **Shallow Copy** sorunlarına yol açar.
    *   `String s1("eski"); String s2("yeni"); s1 = s2;`
    *   Derleyici `s1.mp_data = s2.mp_data;` yapar.
    *   **Ekstra Problem (Copy Constructor'a Göre): Memory Leak!**
        *   `Copy Constructor`'da nesne yeni oluştuğu için henüz bir kaynağı yoktur.
        *   `Copy Assignment`'da ise `s1`'in zaten `mp_data` ile gösterdiği bir bellek alanı ("eski" yazısı) vardı. Bu adresin üzerine `s2.mp_data`'nın adresi yazıldığında, `s1`'in eski bellek alanına olan tek referans kaybolur. Bu bellek alanı artık `free` edilemez ve **memory leak** oluşur.
    *   Diğer sorunlar (`dangling pointer`, `double free`, `value semantics kaybı`) `Copy Constructor`'daki shallow copy ile aynıdır.
*   **Çözüm: Programcının Yazdığı Deep Copy Assignment (02:27:18.680 - 02:33:16.980):**
    *   Programcı, kaynak yöneten sınıflar için `Copy Assignment Operator`'ı kendisi yazmalıdır.
    *   **Tipik Adımlar:**
        1.  **Self-Assignment Check (Kendi Kendine Atama Kontrolü):**
            *   Atama operatörünün sol ve sağ tarafındaki nesnelerin aynı olup olmadığı kontrol edilir (`if (this == &other)`).
            *   Eğer aynı nesne ise, hiçbir şey yapmadan `*this` döndürülür. Bu, gereksiz işlemleri ve potansiyel hataları (özellikle kendi kaynağını free edip sonra o kaynaktan kopyalamaya çalışmak gibi) önler.
        2.  **Release Old Resources (Eski Kaynakları Serbest Bırak):**
            *   `this` nesnesinin mevcut olarak tuttuğu kaynaklar serbest bırakılır (örn: `free(this->mp_data);`). Bu, memory leak'i önler.
        3.  **Allocate New Resources and Copy (Yeni Kaynakları Ayır ve Kopyala - Deep Copy):**
            *   `other` nesnesinin kaynağının boyutuna göre `this` nesnesi için yeni kaynaklar allocate edilir.
            *   `other` nesnesinin verileri, `this` nesnesinin yeni allocate edilmiş kaynağına kopyalanır (tıpkı deep copy constructor'da olduğu gibi).
        4.  **Return `*this`:** Atama yapılan nesneye L-value referans döndürülür.
    *   **Kod Örneği (`String` sınıfı için):**
        ```cpp
        String& String::operator=(const String& other) {
            std::cout << "String Copy Assignment called for " << this << " from " << &other << std::endl;

            // 1. Self-Assignment Check
            if (this == &other) {
                return *this;
            }

            // 2. Release Old Resources
            free(this->mp_data); // Önceki mp_data'yı serbest bırak
            this->mp_data = nullptr; // Dangling pointer bırakmamak için
            this->m_length = 0;

            // 3. Allocate New Resources and Copy Data (other'dan)
            if (other.mp_data) {
                this->m_length = other.m_length;
                this->mp_data = static_cast<char*>(malloc(this->m_length + 1));
                if (this->mp_data) {
                    strcpy(this->mp_data, other.mp_data);
                } else {
                    // Hata yönetimi
                    this->m_length = 0; // Güvenli durum
                }
            } else {
                // other.mp_data null ise, this de null olmalı
                this->mp_data = nullptr;
                this->m_length = 0;
            }

            // 4. Return *this
            return *this;
        }
        ```
*   **Copy Constructor, Destructor ve Copy Assignment İlişkisi (02:28:05.520 - 02:29:52.640):**
    *   Kaynak yöneten sınıflarda bu üç fonksiyon arasında güçlü bir ilişki vardır (Rule of Three/Five'ın temeli):
        *   **Destructor:** Kaynakları serbest bırakır (`Release Resources`).
        *   **Copy Constructor:** Yeni kaynaklar ayırır ve veriyi kopyalar (`Deep Copy`).
        *   **Copy Assignment:** Önce eski kaynakları serbest bırakır (`Release Resources`), sonra yeni kaynaklar ayırır ve veriyi kopyalar (`Deep Copy`).
    *   Bu, `Copy Assignment`'ın işlevsel olarak "Destructor + Copy Constructor" gibi davrandığı anlamına gelir (mantıksal olarak, birebir kod tekrarı olmasa da).
    *   Kod tekrarını önlemek için `Release Resources` ve `Deep Copy` işlemleri ayrı private helper fonksiyonlara taşınabilir.
*   **Self-Assignment Neden Önemli? (02:33:17.740 - 02:40:23.640):**
    *   **Soru:** `x = x;` gibi bariz bir kendi kendine atamayı kim yapar ki? Neden bunun için önlem alalım?
    *   **Cevap:** Kendi kendine atama her zaman `obj = obj;` şeklinde açıkça görünmeyebilir.
        *   **Pointer Aliasing:** `*p1 = *p2;` gibi bir ifadede, `p1` ve `p2` farklı pointer değişkenleri olsalar bile, aynı nesneyi gösteriyor olabilirler. Bu durumda dolaylı bir self-assignment gerçekleşir.
            ```cpp
            MyClass a;
            MyClass* p1 = &a;
            MyClass* p2 = &a;
            *p1 = *p2; // Self-assignment!
            ```
        *   **Referans Aliasing:** Benzer şekilde referanslarla da olabilir.
            `MyClass& ref1 = a; MyClass& ref2 = a; ref1 = ref2;`
        *   **Dizilerde veya Konteynerlerde:** `arr[i] = arr[j];` Eğer `i == j` ise bu bir self-assignment'tır.
        *   Karmaşık fonksiyon çağrıları veya genel (generic) kod içinde, iki nesne referansının veya pointer'ının aynı varlığa işaret edip etmediği compile-time'da her zaman bilinemeyebilir.
    *   Bu yüzden, `Copy Assignment Operator` içinde self-assignment kontrolü yapmak, sınıfı daha sağlam (robust) hale getirir.
    *   **Not (İleri Seviye):** "Copy-and-Swap Idiom" adı verilen bir teknik, `Copy Assignment Operator`'ı implemente etmek için kullanılır ve genellikle self-assignment kontrolüne doğal olarak ihtiyaç duymaz, ayrıca güçlü exception garantisi sağlar. Bu dersin konusu değildi.
*   **Restrict Keyword'ü (02:40:23.640 - 02:40:59.420):**
    *   Bir öğrencinin sorusu üzerine: `restrict` anahtar kelimesi C++ standardında yoktur. Bu, C99 standardıyla C diline eklenmiş bir özelliktir ve derleyiciye belirli pointer'ların aynı bellek bölgesine (aliasing) işaret etmediği bilgisini vererek optimizasyonlara yardımcı olur. C++ derleyicileri bunu bir extension olarak destekleyebilir, ancak standart bir özellik değildir.

**BÖLÜM 7: DERSİN SONU VE ÖZET**

*   Bu ders, C++'ın özel üye fonksiyonlarından `Copy Constructor` ve `Copy Assignment Operator`'ın ne zaman çağrıldığını, derleyicinin varsayılan olarak nasıl implemente ettiğini (shallow copy) ve kaynak yöneten sınıflar için neden programcı tarafından özel olarak (deep copy) implemente edilmeleri gerektiğini detaylı bir şekilde ele aldı.
*   RAII prensibi ve self-assignment gibi önemli kavramlara değinildi.
*   Rule of Zero/Three/Five'ın mantığı açıklandı.

**KAPSAMLI KOD ÖRNEĞİ (Tüm Anlatılanları Bir Araya Getiren Basit String Sınıfı):**

```cpp
#include <iostream>
#include <cstring> // For strlen, strcpy
#include <cstdlib>  // For malloc, free

class SimpleString {
private:
    char* m_data;
    size_t m_length;

    // Private helper for deep copy logic (to avoid code duplication)
    void deep_copy_from(const char* str, size_t len) {
        m_length = len;
        if (str) {
            m_data = static_cast<char*>(malloc(m_length + 1));
            if (m_data) {
                strcpy(m_data, str);
            } else {
                std::cerr << "Error: Malloc failed in deep_copy_from!" << std::endl;
                m_length = 0; // Consistent state on failure
            }
        } else {
            m_data = nullptr; // Handle null source string
            m_length = 0;
        }
    }

public:
    // 1. Parametreli Constructor
    SimpleString(const char* str = "") { // Default argüman ile Default Constructor da olur
        std::cout << "Parametrized Constructor called for: " << (str ? str : "nullptr") << " at " << this << std::endl;
        deep_copy_from(str, str ? strlen(str) : 0);
    }

    // 2. Destructor (RAII)
    ~SimpleString() {
        std::cout << "Destructor called for: " << (m_data ? m_data : "nullptr") << " at " << this << std::endl;
        free(m_data);
        m_data = nullptr; // Good practice
        m_length = 0;
    }

    // 3. Copy Constructor (Deep Copy)
    SimpleString(const SimpleString& other) {
        std::cout << "Copy Constructor called to copy from " << &other << " to " << this << std::endl;
        deep_copy_from(other.m_data, other.m_length);
    }

    // 4. Copy Assignment Operator (Deep Copy with Self-Assignment Check)
    SimpleString& operator=(const SimpleString& other) {
        std::cout << "Copy Assignment Operator called to assign from " << &other << " to " << this << std::endl;
        
        if (this == &other) { // Self-assignment check
            std::cout << "Self-assignment detected. No action taken." << std::endl;
            return *this;
        }

        // Release old resource
        free(m_data);
        m_data = nullptr; // Önemli: deep_copy_from yeni atama yapacak

        // Deep copy new resource
        deep_copy_from(other.m_data, other.m_length);
        
        return *this;
    }

    // Utility functions
    void print() const {
        if (m_data) {
            std::cout << "[" << m_data << "] (Length: " << m_length << ", Addr: " << static_cast<void*>(m_data) << ")" << std::endl;
        } else {
            std::cout << "[nullptr] (Length: 0)" << std::endl;
        }
    }

    size_t getLength() const {
        return m_length;
    }

    // Basit bir değiştirme fonksiyonu (value semantics'i test etmek için)
    void append_char(char c) {
        if (!m_data && c == '\0') return; // Boş string'e null ekleme

        size_t new_length = m_length + 1;
        char* new_data = static_cast<char*>(malloc(new_length + 1));
        if (!new_data) {
            std::cerr << "Error: Malloc failed in append_char!" << std::endl;
            return;
        }

        if (m_data) {
            strcpy(new_data, m_data);
        }
        new_data[m_length] = c;
        new_data[new_length] = '\0';

        free(m_data);
        m_data = new_data;
        m_length = new_length;
    }
};

// Fonksiyona değer yoluyla argüman geçme testi
void displayString(SimpleString s_param) { // Copy constructor çağrılacak
    std::cout << "Inside displayString (param): ";
    s_param.print();
} // s_param'ın destructor'ı burada çağrılacak

// Fonksiyondan değer yoluyla nesne döndürme testi (RVO/NRVO olabilir)
SimpleString createGreeting(const char* name) {
    char buffer[100];
    strcpy(buffer, "Hello, ");
    strcat(buffer, name);
    SimpleString greeting(buffer); // Parametreli constructor
    std::cout << "Inside createGreeting, returning: ";
    greeting.print();
    return greeting; // Copy constructor çağrılabilir (ama RVO muhtemel)
}


int main() {
    std::cout << "--- Test 1: Constructors and Destructor ---" << std::endl;
    SimpleString s1("Apple");
    s1.print();

    std::cout << "\n--- Test 2: Copy Constructor ---" << std::endl;
    SimpleString s2 = s1; // Copy constructor
    s2.print();
    s1.append_char('s'); // s1'i değiştir
    std::cout << "s1 after append: "; s1.print();
    std::cout << "s2 (should be unchanged): "; s2.print(); // s2 değişmemeli (deep copy)

    std::cout << "\n--- Test 3: Copy Assignment Operator ---" << std::endl;
    SimpleString s3("Banana");
    s3.print();
    s3 = s1; // Copy assignment
    std::cout << "s3 after assignment from s1: "; s3.print();
    s1.append_char('!'); // s1'i tekrar değiştir
    std::cout << "s1 after another append: "; s1.print();
    std::cout << "s3 (should reflect s1 at time of assignment): "; s3.print();

    std::cout << "\n--- Test 4: Self-Assignment ---" << std::endl;
    s2.print();
    s2 = s2; // Self-assignment
    std::cout << "s2 after self-assignment: "; s2.print();

    std::cout << "\n--- Test 5: Pass by Value ---" << std::endl;
    SimpleString s4("Orange");
    displayString(s4);
    std::cout << "s4 after displayString call: "; s4.print(); // s4 hala geçerli olmalı

    std::cout << "\n--- Test 6: Return by Value ---" << std::endl;
    SimpleString s5 = createGreeting("World"); // createGreeting + copy/move
    std::cout << "s5 after createGreeting: "; s5.print();
    
    std::cout << "\n--- Test 7: Pointer Aliasing for Assignment ---" << std::endl;
    SimpleString s_alias_test("Initial");
    SimpleString* ptr1 = &s_alias_test;
    SimpleString* ptr2 = &s_alias_test;
    std::cout << "Before alias assignment: "; s_alias_test.print();
    *ptr1 = *ptr2; // Self-assignment via pointers
    std::cout << "After alias assignment: "; s_alias_test.print();

    std::cout << "\n--- End of main ---" << std::endl;
    return 0;
} // s5, s4, s3, s2, s1 destructor'ları çağrılacak (ters sırada)

```
