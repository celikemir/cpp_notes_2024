Harika bir istek! İşte bir C++ dersinin çalışkan bir öğrenci tarafından tutulmuş gibi olabilecek ayrıntılı notları.

---

**DERS NOTLARI: C++ İleri Seviye Kavramlar (17. Ders)**
**Tarih:** 26 Ağustos 2024 Pazartesi
**Saat:** 19.31

**ANA KONULAR:**
1.  Operatör Yüklemesi (Devam)
    *   Tür Dönüştürme Operatör Fonksiyonları (Recap ve `explicit`)
    *   `operator bool` Yüklemesi ve Davranışları
    *   Enumeration (Numaralandırma) Türleri için Operatör Yüklemesi
2.  Dinamik Ömürlü Nesnelere Giriş
    *   `new` İfadesi ve `operator new` Fonksiyonu
    *   `delete` İfadesi ve `operator delete` Fonksiyonu
    *   Bellek Sızıntıları (Memory Leak) ve Kaynak Sızıntıları (Resource Leak)
    *   Dizi (`array new`/`delete[]`) ve Yerleşim (`placement new`) `new` Kullanımları
3.  Sınıfların Statik Üyeleri
    *   Statik Veri Elemanları
    *   Statik Üye Fonksiyonları

---

**BÖLÜM 1: OPERATÖR YÜKLEMESİ (Devam)**

**1.1. Tür Dönüştürme Operatör Fonksiyonları (Typecast Operator Functions) (00:24 - 02:28)**

*   **Hatırlatma ve Tanım:**
    *   Bir sınıf türünden nesneyi başka bir türe (hedef tür) dönüştürmek için kullanılır.
    *   Bildirimi: `operator hedef_tür();`
    *   `operator` anahtar kelimesini hedef türün ismi izler.
    *   Geri dönüş değeri türü ayrıca yazılmaz; çünkü operatörün ismi zaten geri dönüş türünü belirtir.
    *   Hedef tür: Temel aritmetik türler (int, double), sınıf türleri, işaretçi (pointer) türleri, referans türleri olabilir.
    *   **Örnek:** `MyClass` sınıfından `int` türüne dönüşüm için:
        ```cpp
        class MyClass {
        public:
            // ...
            operator int() const {
                // MyClass nesnesini int'e dönüştürecek mantık
                return some_internal_value;
            }
        };
        ```

*   **`explicit` Anahtar Sözcüğü ile Kullanımı (Modern C++):**
    *   Modern C++ öncesinde tür dönüştürme operatör fonksiyonları `explicit` ile nitelenemiyordu.
    *   Modern C++ ile (`C++11` ve sonrası), `converting constructor`'larda olduğu gibi, tür dönüştürme operatör fonksiyonları da `explicit` anahtar sözcüğü ile nitelenebilir.
        ```cpp
        class MyClass {
        public:
            // ...
            explicit operator int() const {
                return some_internal_value;
            }
        };
        ```
    *   **Etkisi:** `explicit` nitelemesi, örtülü (implicit) tür dönüşümünü engeller.
    *   Dönüşümün hala mümkün olduğu yollar:
        *   Açık (explicit) tür dönüştürme operatörleri: `static_cast<hedef_tür>(nesne)`
        *   C-tarzı tür dönüştürme: `(hedef_tür)nesne`
        *   Doğrudan fonksiyon çağrısı: `nesne.operator hedef_tür()`

**1.2. `operator bool` Yüklemesi (02:36 - 17:40)**

*   **Önemi ve Kullanım Alanları:**
    *   Standart kütüphanede ve 3. parti kütüphanelerde en sık karşılaşılan tür dönüştürme operatörlerinden biridir.
    *   Bir nesnenin mantıksal (lojik) bir bağlamda (context) `bool` değere (doğru/yanlış, var/yok) dönüşmesini sağlar.
    *   **Pointer-like Türler:** Akıllı işaretçiler (smart pointers), iteratörler gibi "işaretçi benzeri" türler için yaygın kullanılır. Bu tür nesnelerin `null pointer` semantiğine benzer şekilde (geçerli bir kaynağı işaret edip etmediğini) kontrol etmek için kullanılır.
        *   Örnek: `std::unique_ptr`, `std::shared_ptr` gibi akıllı işaretçiler, içlerinde geçerli bir adres tutup tutmadıklarını belirtmek için `operator bool`'u yüklerler.
            ```cpp
            std::unique_ptr<int> ptr = std::make_unique<int>(10);
            if (ptr) { // ptr.operator bool() çağrılır
                std::cout << "Pointer is valid." << std::endl;
            }
            ```
    *   **Sayısal Tür Alternatifleri:** `Mint` gibi özel sayı sınıflarının `if (mint_nesnesi)` şeklinde kullanılabilmesi için. Tıpkı C'de `if (sayi)` (sayı 0 ise false, değilse true) gibi.

*   **`operator bool` ve Örtülü Dönüşüm Sorunları (explicit öncesi):**
    *   Eğer `operator bool` `explicit` değilse, beklenmedik örtülü dönüşümlere yol açabilir.
    *   **Örnek Sorun 1: `int`'e istenmeyen dönüşüm:**
        ```cpp
        struct Nech {
            operator bool() const { return true; } // explicit DEĞİL
        };

        Nech myNech;
        int x = myNech; // Geçerli! myNech -> bool (true) -> int (1)
                        // Derleyici: myNech.operator bool() -> bool_değer
                        //            static_cast<int>(bool_değer)
        ```
        Bu genellikle istenmeyen bir durumdur çünkü `Nech` nesnesinin doğrudan bir `int` gibi davranması anlamsız olabilir.

    *   **Örnek Sorun 2: Aritmetik işlemlerde istenmeyen davranış (Puzzle Sorusu):**
        ```cpp
        struct Nech {
            operator bool() const { return true; } // explicit DEĞİL
        };

        Nech n1, n2;
        auto x = n1 + n2; // Geçerli! x'in türü int, değeri 2 olur.
        // Adımlar:
        // 1. n1.operator bool() -> true
        // 2. n2.operator bool() -> true
        // 3. true + true  -> bool operandlar int'e yükseltilir (integral promotion)
        // 4. 1 + 1 -> 2 (int)
        ```

*   **`explicit operator bool` ve Mantıksal Bağlamlar:**
    *   `operator bool` fonksiyonu `explicit` olarak nitelense dahi, **mantıksal ifade beklenen bağlamlarda** (contextual conversion to bool) örtülü dönüşüme izin verir. Bu, `explicit operator bool`'un özel bir davranışıdır.
    *   **Mantıksal Bağlamlar (Contextually Converted to bool):**
        *   `if` ifadesinin koşulu: `if (nesne)`
        *   `while`, `do-while` döngülerinin koşulu: `while (nesne)`
        *   `for` döngüsünün koşul kısmı: `for (...; nesne; ...)`
        *   Mantıksal operatörlerin (`&&`, `||`, `!`) operandları: `!nesne`, `nesne1 && nesne2`
        *   Koşul operatörünün (`?:`) birinci operandı: `nesne ? deger1 : deger2`
    *   **`explicit` ile Davranış Farkı:**
        ```cpp
        struct Nech {
            explicit operator bool() const { return true; }
        };

        Nech n1, n2;
        // int x = n1; // HATA! explicit olduğu için örtülü dönüşüm yok.
        // auto y = n1 + n2; // HATA!

        if (n1) { // GEÇERLİ! Mantıksal bağlam.
            std::cout << "n1 is true-like" << std::endl;
        }
        if (n1 && n2) { // GEÇERLİ!
             std::cout << "n1 and n2 are true-like" << std::endl;
        }
        bool b = !n1; // GEÇERLİ!
        // bool b_direct = n1; // HATA! (C++20 öncesi, C++20'de bazı durumlarda izin verilir)
                               // Genellikle static_cast<bool>(n1) gerekir.
        ```

*   **Örnek: Standart Giriş/Çıkış Kütüphanesi (`iostream`) ve `operator bool` (12:07 - 17:40)**
    *   `std::cin` (ve genel olarak `std::istream` nesneleri) `operator bool`'u yükler.
    *   Bu, `while (std::cin >> x)` gibi yapıların çalışmasını sağlar.
    *   **Açıklama:**
        1.  `std::cin >> x` ifadesi, bir "extractor" (operatör `>>`) yüklemesidir.
        2.  Bu operatör, sol operandı olan `std::cin` nesnesine bir referans döndürür (`std::istream&`).
        3.  Dolayısıyla `while` döngüsünün koşulu `std::cin` nesnesinin kendisi olur.
        4.  `std::cin` (bir `std::istream` nesnesi), `explicit operator bool()` fonksiyonuna sahiptir.
        5.  Bu fonksiyon, stream'in durumu (condition state) iyi (good) ise `true`, hata durumunda (fail, bad, eof) ise `false` döndürür.
        ```cpp
        #include <iostream>
        #include <string>

        int main() {
            int x;
            // std::cin >> x ifadesi std::cin'e referans döndürür.
            // while ( (std::cin.operator>>(x)).operator bool() ) gibi çalışır.
            while (std::cin >> x) {
                std::cout << "Okunan değer: " << x << std::endl;
            }
            // Döngüden çıkış: std::cin.operator bool() false döndürdüğünde
            // (Örn: Geçersiz giriş yapıldığında veya dosya sonuna gelindiğinde)
            std::cout << "Giriş sonlandı." << std::endl;
            return 0;
        }
        ```

**1.3. Enumeration (Numaralandırma) Türleri için Operatör Yüklemesi (17:52 - 36:28)**

*   **Genel Bilgi:**
    *   `enum` türleri `class` türü olmadığından üye operatör fonksiyonlarına sahip olamazlar.
    *   Ancak, `enum` türleri için global (free function) operatör fonksiyonları yazılabilir.
    *   Bu, `scoped enum` (`enum class`) veya `unscoped enum` (`enum`) için geçerlidir.

*   **Kullanım Senaryoları:**
    *   **Artırma/Azaltma Operatörleri (`++`, `--`):** Bir `enum` değerini mantıksal olarak bir sonraki veya bir önceki değere geçirmek için.
        *   Örnek: Haftanın günleri, bir sayaç durumu vb.
    *   **Giriş/Çıkış Operatörleri (`<<`, `>>`):** `enum` değerlerini okunabilir metin olarak yazdırmak veya metinden okumak için.

*   **Örnek: `Weekday` Enum'ı için Operatör Yüklemesi:**
    *   **Enum Tanımı:**
        ```cpp
        #include <iostream>
        #include <string>
        #include <vector> // Opsiyonel, isimleri saklamak için

        // Scoped enum kullanmak daha güvenlidir.
        enum class Weekday {
            Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
        };
        ```

    *   **Çıkış Operatörü (`operator<<`) Yüklemesi:**
        ```cpp
        // Haftanın günlerini string olarak saklamak için bir dizi
        // const char* veya std::string kullanılabilir.
        // constexpr olması derleme zamanı optimizasyonlarına olanak tanır.
        constexpr const char* weekday_names[] = {
            "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
        };

        std::ostream& operator<<(std::ostream& os, Weekday day) {
            // Weekday enum'ını int'e dönüştürüp dizide indeks olarak kullan.
            // static_cast zorunlu çünkü scoped enum'lar örtülü olarak int'e dönüşmez.
            os << weekday_names[static_cast<int>(day)];
            return os; // Zincirleme (chaining) için os döndürülmeli.
        }
        ```

    *   **Artırma Operatörü (`operator++`) Yüklemesi (Prefix ve Postfix):**
        *   **Prefix `++day`:**
            ```cpp
            Weekday& operator++(Weekday& day) { // Referans döndürür ve alır
                if (day == Weekday::Saturday) {
                    day = Weekday::Sunday;
                } else {
                    day = static_cast<Weekday>(static_cast<int>(day) + 1);
                }
                return day; // Değiştirilmiş nesneyi döndür
            }
            ```
        *   **Postfix `day++`:**
            ```cpp
            Weekday operator++(Weekday& day, int) { // Değer döndürür, dummy int parametresi alır
                Weekday old_day = day;  // Eski değeri sakla
                ++day;                  // Prefix versiyonunu çağırarak artır
                return old_day;         // Eski değeri döndür
            }
            ```
        *   **Benzer şekilde `operator--` de yüklenebilir.**

    *   **Kullanım Örneği:**
        ```cpp
        int main() {
            Weekday current_day = Weekday::Monday;
            std::cout << "Bugün: " << current_day << std::endl; // Çıktı: Bugün: Monday

            ++current_day;
            std::cout << "Yarın (prefix ++): " << current_day << std::endl; // Çıktı: Yarın (prefix ++): Tuesday

            Weekday next_day = current_day++;
            std::cout << "Sonraki gün (postfix ++, eski değer): " << next_day << std::endl; // Çıktı: Sonraki gün...: Tuesday
            std::cout << "current_day (postfix sonrası): " << current_day << std::endl; // Çıktı: current_day...: Wednesday
            return 0;
        }
        ```
    *   **Not:** Stroustrup'un kitabında benzer bir örnek olduğu belirtildi. Hoca ayrıca `constexpr const char*` dizi kullanarak isimleri sakladı.

---

**BÖLÜM 2: DİNAMİK ÖMÜRLÜ NESNELERE GİRİŞ (Tanışma) (36:38 - 01:41:16)**

**2.1. Dinamik Ömür Kavramı ve C ile Karşılaştırma (37:22 - 42:50)**

*   **Dinamik Ömür (Dynamic Lifetime):** Programın çalışma zamanında (runtime) istenilen bir noktada hayatı başlatılabilen ve istenilen bir noktada sonlandırılabilen nesneler. Ömürleri bir blokla sınırlı değildir (otomatik ömürlü nesneler gibi) veya programın sonuna kadar sürmez (statik ömürlü nesneler gibi).
*   **Bellek Alanı (Storage) ve Nesne Oluşturma Farkı:**
    *   **C'de `malloc`:**
        *   `void* malloc(size_t size);`
        *   Sadece belirtilen boyutta ham bellek alanı ayırır (allocate).
        *   Nesne oluşturmaz; ayrılan bellek bloğu tanımsız (indeterminate) değerler içerir.
        *   Başarısız olursa `NULL` (null pointer) döndürür.
        *   Programcı, bu ham bellek alanında bir nesneyi "anlamlı" hale getirmek için ek adımlar atmalıdır (değer atama vb.).
        *   Örnek:
            ```c
            struct Date { int d, m, y; };
            struct Date *p_date = (struct Date*)malloc(sizeof(struct Date));
            if (p_date) {
                p_date->d = 26; p_date->m = 8; p_date->y = 2024; // Manuel initialization
            }
            // ...
            free(p_date); // Belleği serbest bırakma
            ```
    *   C++'da ise bellek ayırma ve nesne oluşturma (constructor çağırma) genellikle bir arada ele alınır.

**2.2. C++'da `new` İfadesi ve `operator new` Fonksiyonu (43:30 - 54:48)**

*   **`new` İfadesi (New Expression):**
    *   Dinamik ömürlü nesneler oluşturmak için kullanılır.
    *   Standart, "new expression" terimini kullanır, "new operator" de yaygındır.
    *   **Temel Sentaks (Tek Nesne):** `new TürAdı;` veya `new TürAdı(argümanlar);` veya `new TürAdı{argümanlar};`
    *   **Geri Dönüş Değeri:** Oluşturulan nesnenin adresini (işaretçi) döndürür.
        *   `new Date;` -> `Date*` türünde bir ifade.
        *   `new int;` -> `int*` türünde bir ifade.
    *   **Arka Planda Olanlar (İki Adım):**
        1.  **Bellek Ayırma (Allocation):**
            *   Derleyici, `operator new` **fonksiyonuna** bir çağrı üretir.
            *   `operator new` fonksiyonu, `malloc` benzeri bir bellek ayırma fonksiyonudur.
            *   **`operator new` Fonksiyonunun Tipik Bildirimi:**
                ```cpp
                // Global operator new (birçok overload'u vardır)
                void* operator new(std::size_t size);
                ```
            *   Parametre olarak oluşturulacak nesnenin `sizeof` değerini alır.
            *   Başarılı olursa, ayrılan ham bellek bloğunun adresini (`void*`) döndürür.
            *   **ÖNEMLİ FARK:** Başarısız olursa (`malloc` gibi `NULL` döndürmek yerine) `std::bad_alloc` türünden bir **exception fırlatır**.
        2.  **Nesne Oluşturma (Construction):**
            *   Eğer `operator new` başarılı olup bir adres döndürdüyse (exception fırlatmadıysa), derleyici bu adreste nesneyi oluşturmak için sınıfın uygun **constructor**'ını çağırır.
            *   `operator new`'den dönen adres, constructor'a `this` işaretçisi olarak geçirilir.
    *   **`operator new` Fonksiyonu vs. `new` İfadesi:**
        *   `new Date;` (ifade)
        *   `::operator new(sizeof(Date));` (fonksiyon çağrısı - doğrudan da yapılabilir ama genellikle `new` ifadesi kullanılır)
        *   `new` ifadesi, `operator new` fonksiyon çağrısını ve ardından constructor çağrısını kapsar.

*   **Örnek:**
    ```cpp
    class MyClass {
    public:
        int val;
        MyClass(int v) : val(v) {
            std::cout << "MyClass constructor called with " << v << " at " << this << std::endl;
        }
        ~MyClass() {
            std::cout << "MyClass destructor called for " << this << std::endl;
        }
    };

    // new MyClass(123); ifadesinin adımları:
    // 1. void* raw_memory = ::operator new(sizeof(MyClass)); // Bellek ayır
    //    Eğer başarısızsa std::bad_alloc fırlatılır.
    // 2. MyClass* ptr_obj = static_cast<MyClass*>(raw_memory);
    // 3. ptr_obj->MyClass::MyClass(123); // Constructor'ı çağır (bu sentaks semboliktir)
    //    Daha doğrusu: new (raw_memory) MyClass(123); // Placement new ile constructor çağrılır

    MyClass* p_obj = new MyClass(123);
    if (p_obj) {
        std::cout << "Object value: " << p_obj->val << std::endl;
    }
    // ... Nesneyle iş bittiğinde delete çağrılmalı
    ```

**2.3. C++'da `delete` İfadesi ve `operator delete` Fonksiyonu (01:00:44 - 01:09:00)**

*   **`delete` İfadesi (Delete Expression):**
    *   `new` ile oluşturulmuş dinamik ömürlü nesnelerin hayatını sonlandırmak ve belleklerini iade etmek için kullanılır.
    *   **Temel Sentaks (Tek Nesne):** `delete işaretçi;`
    *   **Arka Planda Olanlar (İki Adım):**
        1.  **Nesnenin Hayatını Sonlandırma (Destruction):**
            *   Derleyici, işaretçinin gösterdiği nesne için sınıfın **destructor**'ını (`~SınıfAdı()`) çağırır.
            *   Destructor, nesnenin sahip olduğu kaynakları (dinamik bellek, dosya tanıtıcıları vb.) serbest bırakmak için kullanılır.
        2.  **Belleği İade Etme (Deallocation):**
            *   Destructor çağrısından sonra, derleyici `operator delete` **fonksiyonuna** bir çağrı üretir.
            *   `operator delete` fonksiyonu, `free` benzeri bir bellek iade fonksiyonudur.
            *   **`operator delete` Fonksiyonunun Tipik Bildirimi:**
                ```cpp
                // Global operator delete (birçok overload'u vardır)
                void operator delete(void* ptr);
                void operator delete(void* ptr, std::size_t size); // C++14 ile gelen boyutlu versiyon
                ```
            *   Parametre olarak `new` ile ayrılan bellek bloğunun adresini alır.
    *   **`operator delete` Fonksiyonu vs. `delete` İfadesi:**
        *   `delete p_obj;` (ifade)
        *   `::operator delete(p_obj);` (fonksiyon çağrısı - doğrudan da yapılabilir ama `delete` ifadesi destructor'ı da çağırır)
        *   `delete` ifadesi, destructor çağrısını ve ardından `operator delete` fonksiyon çağrısını kapsar.

*   **`delete` Kullanılmazsa Ne Olur? (01:17:11 - 01:24:41)**
    *   **Memory Leak (Bellek Sızıntısı):** `operator delete` çağrılmadığı için `new` ile ayrılan bellek bloğu sisteme geri verilmez. Program çalıştığı sürece bu bellek kullanılamaz hale gelir. Bu, `sizeof(Nesne)` kadar belleğin sızmasıdır.
    *   **Resource Leak (Kaynak Sızıntısı):** `delete` ifadesi kullanılmadığında **destructor çağrılmaz**. Eğer destructor önemli kaynakları (dinamik olarak ayrılmış başka bellek blokları, dosyalar, ağ bağlantıları, mutex'ler vb.) serbest bırakıyorsa, bu kaynaklar da serbest bırakılmaz. Bu, nesnenin kendi belleğinden daha büyük veya farklı türde sızıntılara yol açabilir.
        *   **Örnek:**
            ```cpp
            std::string* str_ptr = new std::string(10000, 'A'); // 10000 'A' karakteri
            // delete str_ptr; YAZILMAZSA:
            // 1. Memory Leak: sizeof(std::string) kadar bellek sızar (string nesnesinin kendisi için).
            // 2. Resource Leak (bu da bir memory leak'tir): std::string'in destructor'ı
            //    10000 'A' karakterini tutan dahili bellek bloğunu serbest bırakmayacağı için
            //    10000 byte'lık bir bellek sızıntısı daha olur.
            ```
    *   **Özet:** `delete` etmemek hem nesnenin kapladığı alanın (memory leak) hem de nesnenin yönettiği diğer kaynakların (resource leak, ki bu da memory leak olabilir) sızmasına neden olur.

**2.4. `operator new` ve `operator delete` Fonksiyonlarını Yüklemek (Overload) (01:09:00 - 01:32:07)**

*   Programcılar, global `operator new` ve `operator delete` fonksiyonlarını veya sınıfa özel versiyonlarını yükleyebilirler. Bu, özel bellek yönetimi stratejileri uygulamak için kullanılır.
*   Ders sırasında bu fonksiyonlar, `new` ve `delete` ifadelerinin arka planda nasıl çalıştığını göstermek amacıyla (içlerine `std::cout` eklenerek) yüklendi.
*   **Global Yükleme Örneği (Gösterim Amaçlı):**
    ```cpp
    #include <iostream>
    #include <cstdlib> // malloc, free için
    #include <new>     // std::bad_alloc için

    void* operator new(std::size_t size) {
        std::cout << "Global operator new called for size: " << size << std::endl;
        void* ptr = std::malloc(size);
        if (!ptr) {
            throw std::bad_alloc(); // Malloc başarısız olursa exception fırlat
        }
        std::cout << "Allocated block at: " << ptr << std::endl;
        return ptr;
    }

    void operator delete(void* ptr) noexcept { // noexcept önemli
        std::cout << "Global operator delete called for ptr: " << ptr << std::endl;
        std::free(ptr);
    }
    // Boyutlu delete C++14
    void operator delete(void* ptr, std::size_t size) noexcept {
        std::cout << "Global operator delete (sized) called for ptr: " << ptr << " size: " << size << std::endl;
        std::free(ptr);
    }
    // ... MyClass tanımı (constructor/destructor ile) ...
    class MyClass {
    public:
        int data[16]; // sizeof(MyClass) ~64 byte olsun diye
        MyClass() { std::cout << "MyClass constructor at " << this << std::endl; }
        ~MyClass() { std::cout << "MyClass destructor at " << this << std::endl; }
    };

    int main() {
        std::cout << "sizeof(MyClass) = " << sizeof(MyClass) << std::endl;
        MyClass* obj = new MyClass; // Önce operator new, sonra constructor çağrılır
        // ...
        delete obj; // Önce destructor, sonra operator delete çağrılır
        return 0;
    }
    ```
    *   **Çıktı Sırası (Sembolik):**
        1.  `sizeof(MyClass) = 64`
        2.  `Global operator new called for size: 64`
        3.  `Allocated block at: 0xAdres1`
        4.  `MyClass constructor at 0xAdres1`
        5.  (Program çalışır)
        6.  `MyClass destructor at 0xAdres1`
        7.  `Global operator delete (sized) called for ptr: 0xAdres1 size: 64` (veya boyutsuz olan)
*   **Önemli Not:** `malloc` ile ayrılan yer `free` ile, `operator new` ile (dolaylı olarak `new` ifadesiyle) ayrılan yer `operator delete` ile (dolaylı olarak `delete` ifadesiyle) serbest bırakılmalıdır. Karıştırmak tanımsız davranışa (undefined behavior) yol açar.

**2.5. `new` ve `delete` İfadelerinin Farklı Biçimleri (01:32:07 - 01:41:16)**

*   **Dizi için `new[]` ve `delete[]` (Array new/delete) (01:32:23 - 01:36:47):**
    *   Dinamik ömürlü bir dizi oluşturmak için kullanılır.
    *   **Sentaks:**
        *   `TürAdı* p_array = new TürAdı[boyut];`
        *   `delete[] p_array;` (Köşeli parantezler (`[]`) **zorunludur!**)
    *   **Arka Plan:**
        *   `new TürAdı[boyut]` çağrıldığında:
            1.  `operator new[]` (veya `operator new`) çağrılarak tüm dizi için yeterli bellek ayrılır (genellikle `boyut * sizeof(TürAdı)` + biraz ek yer (metadata için)).
            2.  Dizinin her bir elemanı için sırayla default constructor çağrılır.
        *   `delete[] p_array` çağrıldığında:
            1.  Dizinin her bir elemanı için **ters sırada** destructor çağrılır.
            2.  `operator delete[]` (veya `operator delete`) çağrılarak ayrılan tüm bellek bloğu iade edilir.
    *   **Hata:** `new[]` ile oluşturulan bir diziyi `delete` (köşeli parantezsiz) ile veya `new` ile oluşturulan tek bir nesneyi `delete[]` ile silmek tanımsız davranıştır.
    *   **Örnek:**
        ```cpp
        // ... MyClass (constructor/destructor'lı) ...
        int n = 3;
        MyClass* arr = new MyClass[n]; // n tane MyClass nesnesi için constructor çağrılır
        // ...
        delete[] arr; // n tane MyClass nesnesi için ters sırada destructor çağrılır
        ```

*   **Yerleşim `new` (Placement new) (01:36:55 - 01:40:43):**
    *   Önceden var olan, programcının yönettiği bir bellek alanında nesne oluşturmak (constructor çağırmak) için kullanılır.
    *   Bellek ayırma yapmaz; sadece constructor çağırır.
    *   **Başlık Dosyası:** `<new>`
    *   **Sentaks:** `new (adres) TürAdı(argümanlar);`
    *   **Kullanım:**
        ```cpp
        #include <new> // Placement new için
        // ... MyClass (constructor/destructor'lı) ...

        // 1. Bellek alanını kendimiz ayıralım (stack'te veya malloc ile heap'te olabilir)
        alignas(MyClass) unsigned char buffer[sizeof(MyClass)]; // Yeterli ve hizalı bellek

        // 2. Placement new ile buffer üzerinde nesne oluştur
        MyClass* p_obj_placed = new (buffer) MyClass(); // Constructor çağrılır

        // 3. Nesnenin hayatını sonlandırmak için destructor'ı AÇIKÇA ÇAĞIRMALIYIZ
        //    delete p_obj_placed; KULLANILMAZ! Çünkü bellek 'new' ile ayrılmadı.
        if (p_obj_placed) { // Adres geçerliyse
             p_obj_placed->~MyClass(); // Destructor'ı manuel çağır
        }
        // 4. Eğer buffer malloc ile ayrıldıysa, free(buffer) çağrılmalı. Stack'te ise gerek yok.
        ```
    *   Destructor'ın açıkça (`nesne_ptr->~SınıfAdı();`) çağrılması gereken nadir durumlardan biridir.
    *   `delete` operatörü kullanılmaz çünkü bellek `operator new` ile değil, başka bir yolla (örn: `malloc` veya stack) elde edilmiştir. `delete` kullanmak, `operator new` ile ayrılmamış bir belleği `operator delete` ile serbest bırakmaya çalışmak anlamına gelir (tanımsız davranış).

*   **Diğer `new` Türleri (Kısaca Bahsedilen):**
    *   **`nothrow new`:** Exception fırlatmayan `new`. Başarısız olursa `std::bad_alloc` yerine `nullptr` döndürür.
        *   `#include <new>`
        *   `MyClass* p = new (std::nothrow) MyClass; if (!p) { /* hata yönetimi */ }`

---

Tamamdır, "BÖLÜM 3: SINIFLARIN STATİK ÜYELERİ" kısmından devam ediyorum:

---

**BÖLÜM 3: SINIFLARIN STATİK ÜYELERİ (01:41:27 - Ders Sonu)**

**3.1. Genel Bakış (01:41:30 - 01:43:54)**

*   Sınıf üyeleri (data members, member functions, member types) genel olarak ikiye ayrılır:
    *   **Non-static (Statik Olmayan) Üyeler:**
        *   Her bir sınıf nesnesine (instance) aittir.
        *   Non-static veri elemanları, her nesnenin kendi kopyasına sahip olduğu verilerdir ve nesnenin bellekteki boyutunu etkiler.
        *   Örnek: `Date` sınıfındaki `m_day`, `m_month`, `m_year` her `Date` nesnesi için ayrıdır.
    *   **Static (Statik) Üyeler:**
        *   Sınıfın kendisine aittir, belirli bir nesneye değil.
        *   Sınıfın tüm nesneleri tarafından paylaşılır.
        *   Statik veri elemanları, sınıfın nesnelerinden bağımsız, tek bir kopya olarak bellekte tutulur ve nesne boyutunu etkilemez.

**3.2. Statik Veri Elemanları (Static Data Members) (01:43:54 - 02:16:34)**

*   **Bildirim (Declaration):**
    *   Sınıf tanımı içinde `static` anahtar sözcüğü ile bildirilirler.
    *   `static TürAdı veri_elemanı_adı;`
    *   Bu sadece bir bildirimdir, tanım (definition) değildir (C++17 öncesi `inline` olmayanlar için). Tanım, bellekte yer ayrılmasını sağlar.
    *   Örnek:
        ```cpp
        class MyClass {
        public:
            static int count; // Bildirim (declaration)
            int id;           // Non-static
        };
        ```

*   **Tanım (Definition) (C++17 öncesi ve `inline` olmayanlar için):**
    *   Statik veri elemanlarının bellekte yerinin ayrılması için sınıf tanımının dışında (genellikle `.cpp` dosyasında) tanımlanmaları gerekir.
    *   Tanımda `static` anahtar sözcüğü **tekrarlanmaz**.
    *   Sınıf ismi ve scope resolution operatörü (`::`) ile nitelenir.
    *   Tanım sırasında ilk değer (initializer) verilebilir.
    *   Eğer ilk değer verilmezse ve temel türdense, statik ömürlü oldukları için sıfır ile ilklendirilirler (zero-initialization).
    *   **Örnek:**
        ```cpp
        // MyClass.h içinde bildirim vardı.
        // MyClass.cpp içinde tanım:
        #include "MyClass.h" // Varsayımsal başlık dosyası

        int MyClass::count = 0; // Tanım ve ilk değer atama
        // int MyClass::count; // Sadece tanım, ilk değer 0 olur (int için)
        ```
    *   **ODR (One Definition Rule):** Bu tanım, programda sadece bir kaynak dosyasında yapılmalıdır, aksi halde linker hatası alınır. Bu yüzden genellikle `.cpp` dosyasına konulur.

*   **Özellikleri ve Davranışları:**
    *   **Sınıfa Ait Olma:** Belirli bir nesneye değil, sınıfa aittirler. `MyClass::count` gibi erişilir.
    *   **Tek Kopya:** Sınıfın kaç tane nesnesi oluşturulursa oluşturulsun, statik veri elemanından bellekte sadece bir tane bulunur.
    *   **Paylaşım:** Tüm nesneler aynı statik veri elemanını paylaşır. Bir nesne üzerinden (izin verilirse) yapılan değişiklik diğerlerini de etkiler.
    *   **Nesne Boyutuna Etkisi Yok:** `sizeof(MyClass)` değerini artırmazlar çünkü nesnenin içinde yer almazlar.
    *   **Statik Ömür:** Programın çalışma süresi boyunca hayattadırlar (global değişkenler gibi). `main` başlamadan önce oluşturulur, program bitince yok edilirler.
    *   **Erişim Kontrolü:** `public`, `private`, `protected` erişim belirleyicilerine tabidirler.
    *   **Nesne Olmadan Erişim:** Sınıf ismiyle erişilebildikleri için, o sınıftan hiç nesne oluşturulmamış olsa bile statik veri elemanlarına erişilebilir (eğer `public` ise).
        ```cpp
        // MyClass::count = 10; // Eğer count public ise ve MyClass.cpp'de tanımlıysa
        ```
    *   **Nesne Üzerinden Erişim (Dikkat Edilmesi Gereken Durum):**
        *   Bir nesne veya nesne işaretçisi üzerinden de (eğer `public` ise) statik veri elemanına erişilebilir: `myObject.count` veya `p_myObject->count`.
        *   Bu durumda derleyici, ifadenin `MyClass::count` anlamına geldiğini anlar. Nesnenin kendisiyle doğrudan bir ilişkisi yoktur.
        *   Bu kullanım kafa karıştırıcı olabilir çünkü non-static bir üyeye erişiliyormuş gibi görünür. Genellikle sınıf ismiyle (`MyClass::count`) erişim tercih edilir.
            ```cpp
            MyClass obj1, obj2;
            MyClass::count = 5;
            obj1.count = 10; // Aslında MyClass::count = 10 demek
            std::cout << obj2.count; // 10 yazar
            std::cout << MyClass::count; // 10 yazar
            ```

*   **`const static` Veri Elemanları ve Sınıf İçi İlk Değer Verme (C++17 öncesi özel durum):**
    *   C++17 öncesinde, eğer bir statik veri elemanı `const` ise ve **integral türde** (int, char, bool vb. veya enum) ya da **numaralandırma türünde** ise, sınıf tanımı içinde doğrudan ilk değer verilebilirdi.
        ```cpp
        class Constants {
        public:
            const static int MaxUsers = 100;       // GEÇERLİ (const + integral)
            const static bool IsEnabled = true;    // GEÇERLİ
            // const static double PI = 3.14159;   // HATA! (C++17 öncesi, double integral değil)
                                                 // PI için .cpp'de tanım gerekirdi.
        };
        // std::cout << Constants::MaxUsers;
        ```
    *   Bu durumda bile, eğer bu `const static` elemanın adresi alınacaksa veya ODR ihlali riski varsa (nadiren), `.cpp` dosyasında ayrıca bir tanım (ilk değersiz) gerekebilirdi: `int Constants::MaxUsers;` (Bu duruma "in-class initialization with out-of-class definition for ODR-use" denir).

*   **C++17 ve `inline static` Veri Elemanları (02:04:21 - 02:10:03):**
    *   C++17 ile `inline` anahtar sözcüğü değişkenler için de kullanılabilir hale geldi.
    *   Statik veri elemanları `inline` olarak bildirilirse, sınıf tanımı içinde doğrudan tanımlanabilir ve ilk değer verilebilirler. Tür kısıtlaması (`const` ve integral olma) kalkar.
    *   Bu, ODR kuralını ihlal etmez. Başlık dosyasını include eden her kaynak dosyası aynı tanımı görse de, linker tek bir örneğini oluşturur.
    *   `.cpp` dosyasında ayrı bir tanıma ihtiyaç kalmaz. Bu, "header-only" kütüphaneler için çok kullanışlıdır.
        ```cpp
        // C++17 ve sonrası
        class MySettings {
        public:
            inline static int DefaultTimeout = 1000;         // GEÇERLİ
            inline static double Gravity = 9.81;             // GEÇERLİ
            inline static std::string DefaultUserName = "guest"; // GEÇERLİ (constructor çağrılır)

            // const static double PI_LEGACY = 3.14; // Hata! inline değilse cpp'de tanım lazım
                                                  // VEYA inline const static double PI_NEW = 3.14;
            inline const static double PI = 3.1415926535; // inline const static de yaygın
        };
        // Kullanım:
        // int timeout = MySettings::DefaultTimeout;
        // std::string user = MySettings::DefaultUserName;
        ```
    *   Hoca, C++17 öncesinde `inline` anahtar sözcüğünün değişkenler için kullanılamadığını, ancak fonksiyonlar için ODR kuralını esnetmek amacıyla kullanıldığını hatırlattı. `inline` değişkenler de benzer bir mantıkla çalışır.

*   **Kullanım Senaryoları:**
    *   **Sayaçlar:** Sınıftan kaç tane nesne oluşturulduğunu saymak. (Constructor'da artır, destructor'da azalt).
    *   **Paylaşılan Kaynaklar/Ayarlar:** Tüm nesneler için ortak olan bir yapılandırma değeri, bir look-up tablosu.
        *   Örnek (02:14:27):
            ```cpp
            #include <vector>
            #include <string>

            class Config {
            public:
                // inline static std::vector<std::string> AllowedIPs = {"192.168.1.1", "10.0.0.5"};
                // Veya C++17 öncesi:
                // static std::vector<std::string> AllowedIPs;
                // Config.cpp:
                // std::vector<std::string> Config::AllowedIPs = {"192.168.1.1", "10.0.0.5"};

                // Constexpr daha iyi olabilir eğer derleme zamanında biliniyorsa
                inline static constexpr int MaxConnections = 10;
            };
            ```
    *   **Singleton Tasarım Deseni:** Bir sınıftan sadece bir nesne oluşturulmasını garantilemek için (statik bir işaretçi veya referans ile).
    *   Sınıfın kendi türünden statik veri elemanı olabilir (incomplete type sorunu olmaz çünkü sadece bildirimdir, tanım daha sonra yapılır). `static MyClass instance;` gibi.

*   **Statik Veri Elemanlarına İlk Değer Verirken İsim Arama (02:36:06 - 02:37:44):**
    *   Statik bir veri elemanının tanımı yapılırken (`.cpp` dosyasında veya `inline` olarak) kullanılan ilk değer ifadesindeki nitelenmemiş (unqualified) isimler, **önce sınıfın kendi scope'unda (class scope) aranır**, sonra global scope'ta.
    *   **Örnek:**
        ```cpp
        // MyClass.h
        class MyClass {
        public:
            static int getValue();     // Statik üye fonksiyon
            inline static int data = getValue(); // getValue() MyClass::getValue()'ı çağırır
        };

        // MyClass.cpp
        // int MyClass::data = getValue(); // Eğer inline olmasaydı, bu da MyClass::getValue() çağırırdı.
        int MyClass::getValue() { return 42; }

        int getValue() { return 100; } // Global fonksiyon

        // main.cpp
        // MyClass::data'nın değeri 42 olur, 100 değil.
        // Eğer global getValue() kastediliyorsa ::getValue() kullanılmalıydı.
        ```

**3.3. Statik Üye Fonksiyonları (Static Member Functions) (02:16:34 - Ders Sonu)**

*   **Bildirim (Declaration):**
    *   Sınıf tanımı içinde `static` anahtar sözcüğü ile bildirilirler.
    *   `static geri_dönüş_türü fonksiyon_adı(parametreler);`
    *   Örnek:
        ```cpp
        class Utils {
        public:
            static int generateID();
            static void logMessage(const std::string& msg);
        };
        ```

*   **Tanım (Definition):**
    *   Statik veri elemanlarında olduğu gibi, tanımda `static` anahtar sözcüğü **tekrarlanmaz**.
    *   Sınıf ismi ve scope resolution operatörü (`::`) ile nitelenir.
    *   `.cpp` dosyasında veya sınıf tanımı içinde `inline` olarak tanımlanabilirler (sınıf içinde tanımlananlar örtülü olarak `inline` olur).
    *   Örnek:
        ```cpp
        // Utils.cpp
        #include "Utils.h" // Varsayımsal
        #include <iostream>
        #include <cstdlib> // rand

        int Utils::generateID() {
            return std::rand();
        }
        void Utils::logMessage(const std::string& msg) {
            std::cout << "[LOG] " << msg << std::endl;
        }
        ```

*   **Özellikleri ve Davranışları:**
    *   **`this` İşaretçisine Sahip Değiller (02:23:35):**
        *   En önemli farkları budur. Statik üye fonksiyonlar belirli bir nesne üzerinden çağrılmazlar, bu yüzden gizli bir `this` parametreleri yoktur.
    *   **Nesne Olmadan Çağrılabilme:** Sınıf ismiyle doğrudan çağrılabilirler: `Utils::generateID();`
    *   **`const` veya Volatile Olamazlar (02:23:17):** `this` işaretçileri olmadığı için, `const` veya `volatile` ile nitelenemezler (bu niteleyiciler `this` işaretçisinin türünü etkiler).
        ```cpp
        // class MyClass {
        // public:
        //    static void func() const; // HATA! Statik fonksiyon const olamaz.
        // };
        ```
    *   **Non-static Üyelere Doğrudan Erişemezler (02:26:31):**
        *   `this` işaretçileri olmadığı için, sınıfın non-static veri elemanlarına veya non-static üye fonksiyonlarına doğrudan (nesne belirtmeden) erişemezler. Hangi nesnenin üyesine erişecekleri belirsizdir.
        *   Erişmek için ya parametre olarak bir nesne/referans/işaretçi almaları ya da fonksiyon içinde bir nesne oluşturmaları/elde etmeleri gerekir.
            ```cpp
            class DataHolder {
            public:
                int value;
                static void printValue(DataHolder& obj) { // Nesne referansı alır
                    std::cout << obj.value << std::endl;  // GEÇERLİ
                }
                static void tryAccess() {
                    // std::cout << value; // HATA! Hangi nesnenin 'value'su?
                }
            };
            ```
    *   **Statik Üyelere Doğrudan Erişebilirler (02:28:41):**
        *   Sınıfın diğer statik veri elemanlarına ve statik üye fonksiyonlarına doğrudan erişebilirler (isim arama kuralları dahilinde).
            ```cpp
            class Counter {
            public:
                static int count;
                static void increment() {
                    count++; // GEÇERLİ
                }
                static void reset() {
                    count = 0; // GEÇERLİ
                    print();   // GEÇERLİ (eğer print statikse)
                }
                static void print() {
                    std::cout << "Count: " << count << std::endl;
                }
            };
            int Counter::count = 0; // Tanım
            ```
    *   **Sınıfın `private`/`protected` Bölümlerine Erişim (02:31:22):**
        *   Statik üye fonksiyonlar da sınıfın bir parçasıdır. Dolayısıyla, (örneğin parametre olarak aldıkları) bir sınıf nesnesinin `private` veya `protected` üyelerine erişebilirler. Bu, onları global fonksiyonlardan ayıran önemli bir özelliktir (friend olmadıkça global fonksiyonlar erişemez).
            ```cpp
            class SecretKeeper {
            private:
                int secret_code;
                SecretKeeper(int code) : secret_code(code) {}

            public:
                static SecretKeeper createInstance(int initial_code) {
                    // Statik üye fonksiyon private constructor'a erişebilir
                    return SecretKeeper(initial_code);
                }
                void reveal(const SecretKeeper& other) const {
                    std::cout << "My secret: " << this->secret_code << std::endl;
                    // std::cout << "Other's secret: " << other.secret_code << std::endl; // Hata: 'other' bir non-static üye fonksiyon değil,
                                                                                        // this->secret_code ve other.secret_code (eğer other bir nesne ise)
                                                                                        // non-static üye fonksiyonlar içinde erişilebilir.
                                                                                        // Statik üye fonksiyon 'other' gibi bir nesnenin
                                                                                        // private üyesine erişebilir.
                }
                static void compareSecrets(const SecretKeeper& sk1, const SecretKeeper& sk2) {
                     std::cout << "SK1's secret: " << sk1.secret_code << std::endl; // GEÇERLİ
                     std::cout << "SK2's secret: " << sk2.secret_code << std::endl; // GEÇERLİ
                     if (sk1.secret_code == sk2.secret_code) {
                         std::cout << "Secrets are the same!" << std::endl;
                     }
                }
            };
            // SecretKeeper s1 = SecretKeeper::createInstance(123);
            // SecretKeeper s2 = SecretKeeper::createInstance(456);
            // SecretKeeper::compareSecrets(s1,s2);
            ```

*   **Kullanım Senaryoları:**
    *   **Yardımcı (Utility) Fonksiyonlar:** Belirli bir nesneye bağlı olmayan, ancak sınıfla mantıksal olarak ilişkili işlevler sunmak için (örn: `Utils::logMessage`). Global namespace'i kirletmek yerine sınıf scope'unda gruplanırlar.
    *   **Fabrika (Factory) Fonksiyonları:** Sınıf nesnelerini oluşturup döndüren fonksiyonlar. Özellikle constructor'lar `private` ise veya nesne oluşturma karmaşıksa kullanışlıdır. (Yukarıdaki `SecretKeeper::createInstance` örneği gibi).
    *   **Statik Veri Elemanlarını Yönetmek:** `private` statik veri elemanlarına kontrollü erişim sağlamak (getter/setter benzeri).
    *   **Sınıf Düzeyinde İşlemler:** Belirli bir nesne durumu gerektirmeyen, sınıfın geneliyle ilgili işlemler.

*   **Tanımda `static`, `public`, `private` gibi niteleyiciler (02:18:21 - 02:22:14):**
    *   Hoca, `.cpp` dosyasındaki fonksiyon tanımına bakarak bir fonksiyonun `static` olup olmadığını veya erişim seviyesini (`public`/`private`) anlamanın zor olduğunu belirtti.
    *   Bazı programcıların, okunabilirliği artırmak için `.cpp` dosyasında `#define static` (boş bir makroya) gibi teknikler kullandığını, böylece tanımda `static int MyClass::func()` gibi yazabildiklerini, ancak bunun derleyici için bir anlamı olmadığını, ön işlemcinin `static` kelimesini kaldıracağını söyledi. Bu bir konvansiyondur, standart bir pratik değildir.
        ```cpp
        // MyClass.cpp (okunabilirlik için bir konvansiyon)
        // #define static // Bu makro, aşağıdaki 'static' kelimesini kaldırır.
        // #define public
        // #define private

        // public static int MyClass::getCounter() { /* ... */ }
        // // Derleyiciye giden kod: int MyClass::getCounter() { /* ... */ }

        // Bu yaklaşım, kafa karıştırıcı olabileceği için genellikle tavsiye edilmez.
        // Modern IDE'ler bu bilgiyi zaten sağlar.
        ```

---

**TÜM ANLATILANLARI KAPSAYAN GENEL KOD ÖRNEĞİ (Sembolik ve Birleştirilmiş):**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <new>     // std::bad_alloc, std::nothrow, placement new
#include <cstdlib> // malloc, free, rand

// Forward declaration for a class Necati might use
class NecatiLogger;

// Enumeration with overloaded operators
enum class LogLevel { INFO, WARNING, ERROR };
const char* logLevelToString(LogLevel level) {
    switch (level) {
        case LogLevel::INFO: return "INFO";
        case LogLevel::WARNING: return "WARNING";
        case LogLevel::ERROR: return "ERROR";
        default: return "UNKNOWN";
    }
}
std::ostream& operator<<(std::ostream& os, LogLevel level) {
    os << logLevelToString(level);
    return os;
}

// Global operator new/delete (ders gösterimi için)
void* operator new(std::size_t size) {
    std::cout << "[GLOBAL] operator new called for size: " << size << std::endl;
    void* ptr = std::malloc(size);
    if (!ptr) throw std::bad_alloc();
    std::cout << "[GLOBAL] Allocated block at: " << ptr << std::endl;
    return ptr;
}
void operator delete(void* ptr) noexcept {
    std::cout << "[GLOBAL] operator delete called for ptr: " << ptr << std::endl;
    std::free(ptr);
}
void operator delete(void* ptr, std::size_t size) noexcept { // C++14
    std::cout << "[GLOBAL] operator delete (sized) called for ptr: " << ptr << " size: " << size << std::endl;
    std::free(ptr);
}


class ExampleSystem {
private:
    int instance_id_;
    std::string instance_name_;

    // Static data member (private)
    inline static int object_count_ = 0; // C++17 inline static
    inline static LogLevel current_log_level_ = LogLevel::INFO;
    // inline static std::vector<std::string> message_log_ // Sınıf içi tanım (C++17)
    //     = {"System Initialized"}; // Bu şekilde de olabilirdi.
    static std::vector<std::string> message_log_; // C++17 öncesi veya tercih

public:
    // Non-static data member
    double some_value_per_instance_;

    // Constructor
    ExampleSystem(int id, const std::string& name, double val)
        : instance_id_(id), instance_name_(name), some_value_per_instance_(val) {
        object_count_++;
        logMessage(LogLevel::INFO, "Instance " + name + " (ID: " + std::to_string(id) + ") created. Total: " + std::to_string(object_count_));
    }

    // Destructor
    ~ExampleSystem() {
        object_count_--;
        logMessage(LogLevel::INFO, "Instance " + instance_name_ + " (ID: " + std::to_string(instance_id_) + ") destroyed. Total: " + std::to_string(object_count_));
    }

    // Non-static member function
    void displayInfo() const { // const member function
        std::cout << "Instance ID: " << instance_id_
                  << ", Name: " << instance_name_
                  << ", Value: " << some_value_per_instance_ << std::endl;
        // Statik olmayan fonksiyon, statik üyeye erişebilir
        std::cout << "  Current log level for all instances: " << current_log_level_ << std::endl;
        // Statik olmayan fonksiyon, statik fonksiyonu çağırabilir
        // printObjectCount(); // MyClass::printObjectCount() çağrılır
    }

    // Tür dönüştürme operatörü (explicit)
    explicit operator bool() const {
        return instance_id_ != 0; // Örnek bir mantık
    }

    // Statik üye fonksiyon
    static int getObjectCount() {
        return object_count_;
    }

    static void setLogLevel(LogLevel new_level) {
        current_log_level_ = new_level;
        // Statik fonksiyon, başka bir statik fonksiyona erişebilir.
        logMessage(LogLevel::INFO, "Log level changed to: " + std::string(logLevelToString(new_level)));
    }

    static void logMessage(LogLevel level, const std::string& message) {
        if (static_cast<int>(level) >= static_cast<int>(current_log_level_)) {
            std::string full_message = "[" + std::string(logLevelToString(level)) + "] " + message;
            std::cout << full_message << std::endl;
            message_log_.push_back(full_message);
        }
    }

    static void printMessageLog() {
        std::cout << "\n--- Message Log ---" << std::endl;
        for (const auto& msg : message_log_) {
            std::cout << msg << std::endl;
        }
        std::cout << "-------------------" << std::endl;
    }

    // Statik veri elemanı için tanım (Eğer C++17 inline static kullanılmıyorsa .cpp'de olmalı)
    // Bu satır normalde .cpp dosyasında olur, ama örnek bütünlüğü için burada
    // static std::vector<std::string> message_log_ = {"System Initialized"}; // (Eğer yukarıda inline değilse)
};

// Statik veri elemanının tanımı (Eğer C++17 inline değilse ve sınıf içinde ilklendirilmediyse)
std::vector<std::string> ExampleSystem::message_log_ = {"System Initialized (via cpp-style def)"};


int main() {
    ExampleSystem::setLogLevel(LogLevel::INFO);

    ExampleSystem sys1(1, "Alpha", 10.5);
    sys1.displayInfo();

    // Dinamik ömürlü nesne
    ExampleSystem* sys_ptr = new ExampleSystem(2, "Beta", 20.7);
    if (sys_ptr) { // operator bool() çağrılmaz, pointer kontrolü
        sys_ptr->displayInfo();
    }
     // explicit operator bool kullanımı
    if (static_cast<bool>(*sys_ptr)) {
        std::cout << "sys_ptr (dereferenced) is considered 'true-like'" << std::endl;
    }


    ExampleSystem::logMessage(LogLevel::WARNING, "A sample warning.");
    std::cout << "Current object count: " << ExampleSystem::getObjectCount() << std::endl;

    // Dinamik ömürlü dizi
    int array_size = 2;
    ExampleSystem* sys_array = new ExampleSystem[array_size]{
        {3, "Gamma", 30.1}, {4, "Delta", 40.2} // C++11 aggregate initialization for array
    };

    for (int i = 0; i < array_size; ++i) {
        sys_array[i].displayInfo();
    }

    delete sys_ptr;    // Tek nesne için delete
    delete[] sys_array; // Dizi için delete[]

    std::cout << "Final object count: " << ExampleSystem::getObjectCount() << std::endl;
    ExampleSystem::printMessageLog();

    // Placement new örneği
    alignas(ExampleSystem) unsigned char buffer[sizeof(ExampleSystem)];
    ExampleSystem* placed_sys = new (buffer) ExampleSystem(5, "Epsilon (Placed)", 50.3);
    placed_sys->displayInfo();
    placed_sys->~ExampleSystem(); // Destructor'ı manuel çağır

    return 0;
}

```

---

Harika bir istek! `operator new`/`delete` yüklemeleri ve `placement new` konuları C++'ın bellek yönetimiyle ilgili güçlü ama dikkatli kullanılması gereken özellikleridir. Daha derinlemesine inceleyelim:

---

**BÖLÜM 2 (DEVAM): DİNAMİK ÖMÜRLÜ NESNELER (Detaylı İnceleme)**

**2.4. `operator new` ve `operator delete` Fonksiyonlarını Yüklemek (Overload) (Detaylı)**

Bu fonksiyonları yüklemek, C++'ın varsayılan bellek ayırma ve iade etme mekanizmalarını özelleştirmenize olanak tanır.

*   **Neden Yüklenir?**
    1.  **Özel Bellek Yönetimi (Custom Memory Management):**
        *   **Bellek Havuzları (Memory Pools):** Sık sık aynı boyutta küçük nesneler oluşturulup siliniyorsa, genel amaçlı `malloc`/`free` (veya varsayılan `operator new`/`delete`) yavaş olabilir ve bellek parçalanmasına (fragmentation) yol açabilir. Bir bellek havuzu, büyük bir bellek bloğunu önceden ayırır ve bu bloktan hızlıca küçük parçalar dağıtır/toplar.
        *   **Performans Optimizasyonu:** Belirli nesne türleri için daha hızlı ayırma/iade etme stratejileri.
        *   **Hizalama (Alignment) Kontrolü:** Varsayılanın ötesinde özel hizalama gereksinimleri olan nesneler için.
    2.  **Hata Ayıklama ve İzleme (Debugging and Tracking):**
        *   Bellek sızıntılarını tespit etmek için yapılan ayırmaları ve iadeleri kaydetmek.
        *   Bellek taşmalarını (buffer overflows/underflows) tespit etmek için ayrılan blokların başına/sonuna koruyucu baytlar (guard bytes) eklemek.
        *   Kim ne kadar bellek kullanıyor istatistiklerini tutmak.
    3.  **Sınırlı Bellek Ortamları:** Gömülü sistemler gibi bellek kaynaklarının kısıtlı olduğu yerlerde daha sıkı kontrol sağlamak.

*   **Yükleme Kapsamları:**
    1.  **Global `operator new`/`delete`:**
        *   Bu fonksiyonları global scope'ta yüklediğinizde, programdaki **tüm** `new` ve `delete` ifadeleri (eğer sınıfa özel bir versiyon yoksa) sizin yüklediğiniz versiyonları kullanır.
        *   Bu, çok dikkatli yapılmalıdır çünkü tüm sistemi etkiler.
        *   `::operator new` ve `::operator delete` şeklinde çağrılarak her zaman global versiyonlara (varsayılan veya sizin yüklediğiniz) erişilebilir.
    2.  **Sınıfa Özel (Class-Specific) `operator new`/`delete`:**
        *   Bir sınıfın üyesi olarak `operator new` ve `operator delete` yüklerseniz, **sadece o sınıfa ait nesneler** için yapılan `new` ve `delete` işlemleri bu özel versiyonları kullanır. Diğer türler için global versiyonlar kullanılır.
        *   Sınıfa özel `operator new`/`delete` fonksiyonları **örtülü olarak statik üye fonksiyonlardır**. `this` işaretçileri yoktur (çünkü nesne henüz oluşturulmamış veya zaten yok edilmiş olabilir).
        *   Bu fonksiyonlar sanal (virtual) olamazlar.

*   **Temel İmzalar:**
    *   **Tekil Nesneler İçin:**
        ```cpp
        // Ayırma
        void* operator new(std::size_t size); // Temel, exception fırlatan
        void* operator new(std::size_t size, const std::nothrow_t&) noexcept; // Exception fırlatmayan

        // İade
        void operator delete(void* ptr) noexcept;
        void operator delete(void* ptr, std::size_t size) noexcept; // C++14: Boyutlu iade
        void operator delete(void* ptr, const std::nothrow_t&) noexcept; // nothrow new ile eşleşen
        void operator delete(void* ptr, std::size_t size, const std::nothrow_t&) noexcept; // C++14, nothrow
        ```
    *   **Diziler İçin:**
        ```cpp
        // Ayırma
        void* operator new[](std::size_t size);
        void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;

        // İade
        void operator delete[](void* ptr) noexcept;
        void operator delete[](void* ptr, std::size_t size) noexcept; // C++14
        void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
        void operator delete[](void* ptr, std::size_t size, const std::nothrow_t&) noexcept; // C++14
        ```
    *   **`std::size_t size`:** Ayrılması istenen bellek miktarı (bayt cinsinden). Derleyici bu değeri otomatik olarak `sizeof(Tür)` veya dizi için gereken toplam boyut olarak hesaplar.
    *   **`void* ptr`:** `operator new` tarafından döndürülen ve iade edilecek bellek bloğunun adresi.
    *   **`const std::nothrow_t&`:** Bu parametre, `new (std::nothrow) Tür` şeklinde kullanılan `nothrow` versiyonunu çağırmak için bir etiket görevi görür. `std::nothrow` `<new>` başlığında tanımlı boş bir struct nesnesidir.
    *   **`noexcept`:** `operator delete` fonksiyonları (ve `nothrow new` versiyonları) exception fırlatmamalıdır. Eğer fırlatırlarsa, program genellikle `std::terminate` ile sonlanır.

*   **Sınıfa Özel Yükleme Örneği:**
    ```cpp
    #include <iostream>
    #include <cstdlib> // malloc, free
    #include <new>     // std::bad_alloc, std::nothrow_t

    class Tracked {
    public:
        int id;
        static int allocations;

        Tracked(int i) : id(i) {
            std::cout << "Tracked(" << id << ") constructor. this=" << this << std::endl;
        }
        ~Tracked() {
            std::cout << "Tracked(" << id << ") destructor. this=" << this << std::endl;
        }

        // Sınıfa özel operator new
        static void* operator new(std::size_t size) {
            allocations++;
            std::cout << "Tracked::operator new called. Size: " << size
                      << ". Allocation count: " << allocations << std::endl;
            void* p = std::malloc(size);
            if (!p) throw std::bad_alloc();
            return p;
        }

        // Sınıfa özel operator delete
        static void operator delete(void* ptr) noexcept {
            allocations--; // Aslında bu tehlikeli, eğer malloc başarısız olursa delete çağrılmaz
                           // Daha iyi bir izleme için sayaçlar new'de artırılıp delete'de azaltılmalı
                           // veya başarılı ayırmadan sonra artırılmalı.
            std::cout << "Tracked::operator delete called. Ptr: " << ptr
                      << ". Allocation count now: " << allocations << std::endl;
            std::free(ptr);
        }

        // Sınıfa özel operator new[] (Dizi için)
        static void* operator new[](std::size_t size) {
             std::cout << "Tracked::operator new[] called. Size: " << size << std::endl;
             void* p = std::malloc(size);
             if (!p) throw std::bad_alloc();
             return p;
        }

        // Sınıfa özel operator delete[] (Dizi için)
        static void operator delete[](void* ptr) noexcept {
            std::cout << "Tracked::operator delete[] called. Ptr: " << ptr << std::endl;
            std::free(ptr);
        }
    };
    int Tracked::allocations = 0;

    int main() {
        std::cout << "--- Single Object ---" << std::endl;
        Tracked* t1 = new Tracked(1); // Tracked::operator new çağrılır
        delete t1;                   // Tracked::operator delete çağrılır

        std::cout << "\n--- Array of Objects ---" << std::endl;
        Tracked* t_array = new Tracked[2]{{2}, {3}}; // Tracked::operator new[] çağrılır
        delete[] t_array;                            // Tracked::operator delete[] çağrılır

        std::cout << "\nFinal allocation count for Tracked: " << Tracked::allocations << std::endl;
        return 0;
    }
    ```

*   **Önemli Hususlar:**
    1.  **Exception Güvenliği:** Kendi `operator new` fonksiyonunuz bellek ayıramazsa `std::bad_alloc` fırlatmalıdır (veya `nothrow` versiyonu ise `nullptr` döndürmelidir).
    2.  **`delete` ve `noexcept`:** `operator delete` fonksiyonları her zaman `noexcept` olmalıdır. Destructor'lar da genellikle `noexcept` olmalıdır.
    3.  **Sıfır Baytlık İstekler:** `operator new(0)` çağrısı geçerlidir. Standart, bu durumda geçerli, benzersiz bir işaretçi döndürülmesini gerektirir (genellikle 1 bayt ayırır gibi davranır).
    4.  **Hizalama (Alignment):** `operator new` döndürdüğü adresin, oluşturulacak nesne türü için uygun şekilde hizalanmış olmasını sağlamalıdır. `std::malloc` genellikle yeterli hizalamayı sağlar, ancak `std::aligned_alloc` (C++11) gibi fonksiyonlar daha fazla kontrol sunar.
    5.  **Boyutlu İade (Sized Deallocation - C++14):** `operator delete(void* ptr, std::size_t size)` versiyonu, derleyici tarafından iade edilecek bloğun boyutunu da geçirir. Bu, bazı bellek yöneticileri için performansı artırabilir çünkü boyutu ayrıca saklamak veya hesaplamak zorunda kalmazlar. Derleyici, eğer uygun bir boyutlu `delete` varsa onu, yoksa boyutsuz olanı çağırır.
    6.  **Eşleşme:** Eğer `operator new` bir strateji kullanıyorsa (örn: özel bir havuz), `operator delete` de aynı stratejiye uygun olmalıdır. Global `::operator new` çağrılıp, iade için özel bir `operator delete` kullanmak (veya tam tersi) genellikle hatadır.
    7.  **Kalıtım:** Taban sınıfta yüklenmiş `operator new`/`delete`, türemiş sınıflar için de kullanılır (eğer türemiş sınıf kendisi yüklemezse).

---

**2.5. Yerleşim `new` (Placement new) (Detaylı)**

`Placement new`, nesneleri önceden ayrılmış belirli bir bellek adresinde "oluşturmak" (yani constructor'larını çağırmak) için kullanılan özel bir `new` ifadesi biçimidir. Kendisi bellek ayırmaz.

*   **Temel Kullanım ve Standart Yerleşim `operator new`:**
    *   En yaygın kullanımı, `<new>` başlığında tanımlı olan standart yerleşim `operator new` fonksiyonunu çağırmaktır:
        ```cpp
        void* operator new(std::size_t size, void* where) noexcept {
            (void)size; // Boyut kullanılmaz, sadece imza uyumu için
            return where; // Aldığı adresi doğrudan döndürür
        }
        ```
    *   Bu fonksiyon `new (adres) Tür(argümanlar);` sentaksıyla çağrılır.
    *   **Örnek:**
        ```cpp
        #include <iostream>
        #include <string>
        #include <new> // Placement new için

        class MyData {
        public:
            int x; std::string s;
            MyData(int val, const std::string& str) : x(val), s(str) {
                std::cout << "MyData constructor: x=" << x << ", s='" << s << "' at " << this << std::endl;
            }
            ~MyData() {
                std::cout << "MyData destructor: x=" << x << ", s='" << s << "' at " << this << std::endl;
            }
            void print() { std::cout << "Data: " << x << ", " << s << std::endl; }
        };

        int main() {
            // 1. Bellek bloğunu ayır (örneğin stack'te veya malloc ile)
            // alignas C++11 ile hizalamayı garanti eder.
            alignas(MyData) unsigned char buffer[sizeof(MyData) * 2]; // İki MyData nesnesi için yer

            std::cout << "Buffer starts at: " << static_cast<void*>(buffer) << std::endl;

            // 2. İlk nesneyi buffer'ın başına yerleştir
            MyData* obj1 = new (buffer) MyData(10, "Hello");

            // 3. İkinci nesneyi buffer'da ilk nesneden sonraya yerleştir
            MyData* obj2 = new (buffer + sizeof(MyData)) MyData(20, "World");

            obj1->print();
            obj2->print();

            // 4. Nesnelerin hayatını sonlandırmak için destructor'ları AÇIKÇA ÇAĞIR
            // delete obj1; YANLIŞ! Bu, ::operator delete(buffer) çağırır, tanımsız davranış.
            obj2->~MyData(); // Ters sırada çağırmak genellikle iyi bir pratiktir.
            obj1->~MyData();

            // 5. Eğer buffer malloc ile ayrıldıysa: std::free(buffer);
            return 0;
        }
        ```

*   **Özel Yerleşim Argümanları (Custom Placement Arguments):**
    *   `operator new` fonksiyonunu, `std::size_t` ve standart `void*` dışında ek parametreler alacak şekilde yükleyebilirsiniz.
    *   Bu, yerleşim `new` ifadesine ek argümanlar geçirmenizi sağlar.
    *   **Sentaks:**
        ```cpp
        // Özel placement operator new
        void* operator new(std::size_t size, EkParam1 p1, EkParam2 p2, ...);

        // Kullanımı
        // Nesne* ptr = new (arg1_for_p1, arg2_for_p2, ...) Tür(constructor_argümanları);
        ```
    *   **Örnek: Bellek Havuzundan Yer Ayırma (Basit Gösterim):**
        ```cpp
        // Basit bir bellek havuzu (sadece konsept için)
        class MemoryPool {
        public:
            void* allocate(std::size_t size) {
                std::cout << "MemoryPool allocating " << size << " bytes." << std::endl;
                return std::malloc(size); // Gerçek bir havuz daha karmaşık olurdu
            }
            void deallocate(void* p) {
                std::cout << "MemoryPool deallocating." << std::endl;
                std::free(p);
            }
        };

        class PooledObject {
        public:
            int data;
            PooledObject(int d) : data(d) {
                std::cout << "PooledObject(" << data << ") constructor at " << this << std::endl;
            }
            ~PooledObject() {
                std::cout << "PooledObject(" << data << ") destructor at " << this << std::endl;
            }

            // Özel placement new: Bellek havuzunu argüman olarak alır
            static void* operator new(std::size_t size, MemoryPool& pool) {
                std::cout << "PooledObject::operator new (placement) with pool. Size: " << size << std::endl;
                return pool.allocate(size);
            }

            // Özel placement new için eşleşen delete (constructor exception fırlatırsa çağrılır)
            // Bu delete, pool.deallocate'i çağırmalıdır.
            static void operator delete(void* ptr, MemoryPool& pool) noexcept {
                std::cout << "PooledObject::operator delete (placement) with pool for ptr: " << ptr << std::endl;
                pool.deallocate(ptr);
            }

            // Normal delete için (eğer delete ptr; çağrılırsa, ki bu durumda mantıksız olurdu)
            // Eğer placement new ile oluşturulan nesne için delete çağrılmamalıysa
            // bu delete'i private yapabilir veya silebilirsiniz.
            // Ancak, constructor exception'ı için placement delete'in olması gerekir.
             static void operator delete(void* ptr) noexcept {
                 std::cout << "PooledObject::operator delete (normal) - Should not be typically called for placement new" << std::endl;
                 // Bu durumda hangi havuzdan deallocate edileceği bilinemez,
                 // bu yüzden bu genellikle tanımsızdır veya global free çağrılır.
                 // Ya da bu fonksiyon private yapılır veya hiç tanımlanmaz.
                 std::free(ptr); // Veya bir hata logla
             }
        };

        int main() {
            MemoryPool my_pool;
            PooledObject* p_obj = new (my_pool) PooledObject(100); // Özel placement new çağrılır

            // ... p_obj ile çalış ...

            // Önce destructor çağrılmalı
            p_obj->~PooledObject();
            // Sonra bellek havuza iade edilmeli (placement delete ile değil, havuzun kendi mekanizmasıyla)
            // Eğer operator delete(void*, MemoryPool&) çağrılacaksa, bu durum constructor exception'ı içindir.
            // Manuel iade için genellikle şöyle yapılır:
            my_pool.deallocate(p_obj); // Veya PooledObject::operator delete(p_obj, my_pool);

            return 0;
        }
        ```
        **Not:** Yukarıdaki `PooledObject::operator delete(void* ptr)` normal `delete obj;` içindir. Eğer nesneler *sadece* `new (pool) PooledObject` ile oluşturuluyorsa ve `delete obj;` ile *asla* silinmeyecekse, bu normal `operator delete` kaldırılabilir veya `private` yapılabilir. Ancak, constructor bir exception fırlatırsa, derleyici `operator delete(void* ptr, MemoryPool& pool)` (yani placement `new` ile eşleşen `delete`) fonksiyonunu arar.

*   **Yerleşim `new` için `operator delete` (Constructor Exception Durumu):**
    *   Eğer `new (placement_args) Tür(constructor_args);` ifadesinde, `operator new(size, placement_args)` başarılı olduktan sonra `Tür`'ün constructor'ı bir **exception fırlatırsa**, C++ çalışma zamanı sistemi, bu durumu temizlemek için özel bir `operator delete` arar.
    *   Bu `operator delete`'in imzası, çağrılan `operator new`'in imzasıyla eşleşmelidir (ilk `std::size_t` parametresi yerine `void*` ve aynı ek yerleşim argümanları).
    *   **İmzalar:**
        ```cpp
        // Standart placement new (new (adres) Type) için:
        void operator delete(void* ptr_allocated, void* placement_arg_address) noexcept;

        // Özel placement new (new (ek_args...) Type) için:
        void operator delete(void* ptr_allocated, EkParam1 p1, EkParam2 p2, ...) noexcept;
        ```
    *   Bu `operator delete`'in amacı, `operator new` (yerleşim versiyonu) tarafından yapılmış olabilecek (bellek ayırmanın ötesinde) herhangi bir kurulumu geri almaktır. Standart `new (adres) Type` için, `operator delete(void*, void*)` genellikle boştur çünkü `operator new(size, void*)` sadece adresi döndürür, ek bir şey yapmaz.
    *   Eğer eşleşen bir yerleşim `delete` bulunamazsa, hiçbir `delete` çağrılmaz (kaynak sızıntısı olabilir eğer yerleşim `new` bir şey yapmışsa).

*   **Kullanım Alanları:**
    1.  **Bellek Havuzları:** Belirli bir havuzdan bellek tahsis edip orada nesne oluşturmak.
    2.  **Donanım Kayıtları (Memory-Mapped I/O):** Belirli bir donanım adresinde bir C++ nesnesine karşılık gelen yapıyı oluşturmak.
    3.  **Paylaşımlı Bellek (Shared Memory):** Farklı prosesler arasında paylaşılan bir bellek bölgesinde nesne oluşturmak.
    4.  **Konteyner Uygulamaları:** `std::vector` gibi konteynerler, elemanlar için ham bellek ayırır ve sonra bu bellekte "yerleşim `new`" kullanarak nesneleri oluşturur. Bu, gereksiz kopyalamaları önler ve performansı artırır.
    5.  **Nesneleri Yeniden Kullanma/Başlatma:** Bir nesnenin belleğini serbest bırakmadan, önce destructor'ını çağırıp sonra aynı adreste `placement new` ile yeni bir nesne (veya aynı türden yeniden başlatılmış bir nesne) oluşturmak. (Çok dikkatli kullanılmalıdır!)

---

