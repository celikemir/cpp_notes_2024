
**Ders Notları: C++ 8. Ders (24 Temmuz 2024)**

**Genel Konular:**
*   Function Overloading (Tekrar ve Mülakat Sorusu)
*   `extern "C"` ile C ve C++ Kodlarının Birlikte Kullanımı
*   Sınıflara Giriş (Classes)
    *   Data Abstraction Kavramı
    *   Sınıf Bildirimi ve Tanımı
    *   Sınıf Üyeleri (Class Members)
    *   Erişim Belirteçleri (Access Specifiers: public, private, protected)
    *   `struct` ve `class` Farkı
    *   Data Hiding (Veri Gizleme)
*   Üye Fonksiyonlar (Member Functions)
    *   Non-static Üye Fonksiyonlar
    *   `this` Göstericisi (İmalı Kullanım)
    *   Üye Fonksiyonların Tanımlanması (Sınıf İçinde ve Dışında)
    *   Üye Fonksiyonlar İçinde İsim Arama (Name Lookup)

---

**Bölüm 1: Function Overloading Tekrarı ve Önemli Bir Mülakat Sorusu (00:20 - 05:05)**

*   **Temel Kavramlar:**
    *   **Function Overloading Nedir?** Aynı isimde, farklı parametre listelerine (imzalara) sahip birden fazla fonksiyon tanımlayabilme yeteneğidir.
    *   **Function Overload Resolution Nedir?** Bir fonksiyon çağrısı yapıldığında, derleyicinin hangi overload edilmiş fonksiyonun çağrılacağına karar verme sürecidir. Aşamaları vardır (exact match, promotion, conversion vb.).
*   **Data Type vs. Value Category (01:09 - 03:12):**
    *   Bu iki kavramın farklı olduğu vurgulandı. Bir ifadenin "value category"si olur (L-value, R-value, X-value), bir değişkenin veya ifadenin "data type"ı (türü) olur.
    *   Örnek Yanlış Kullanım: "X'in value kategorisi ne?" -> Doğrusu: "X ifadesinin value kategorisi ne?"
    *   `int& ref = x;` `ref`'in data type'ı `int&` (int referans). `ref` ifadesi bir L-value'dur.
*   **Mülakat Sorusu (Referans Semantiği ve İsimler) (03:12 - 05:05):**
    *   **Temel Kural:** Bir ifadenin *ismi* varsa, o ifade bir L-value expression'dır. Bu, değişkenin türünün R-value referans olması durumunda bile geçerlidir.
    *   **Örnek Kod:**
        ```cpp
        #include <iostream>

        void foo(int& x) {
            std::cout << "foo(int&)" << std::endl;
        }

        void foo(int&& x) {
            std::cout << "foo(int&&)" << std::endl;
        }

        void call_foo(int&& r) { // r'nin türü int&& (R-value referans)
            std::cout << "call_foo'da r'nin adresi: " << &r << std::endl;
            foo(r); // 'r' burada bir İSİM olduğu için L-value expression'dır.
                    // Dolayısıyla foo(int&) çağrılır.
        }

        int main() {
            call_foo(10); // 10 bir R-value, call_foo(int&&) çağrılır.
            return 0;
        }
        ```
    *   **Çıktı:**
        ```
        call_foo'da r'nin adresi: <bir adres>
        foo(int&)
        ```
    *   **Açıklama:** `call_foo` fonksiyonuna `10` (bir R-value) ile çağrı yapılır, `r` parametresi bu R-value'ya bağlanır. Ancak `call_foo` *içinde* `r` artık bir isimdir. İsimli olan her şey bir L-value expression oluşturur. Bu nedenle `foo(r)` çağrısı, `foo(int&)` overload'unu seçer. `r`'nin *data type*'ı `int&&` olmasına rağmen, `r` *ifadesinin value category*'si L-value'dur.

---

**Bölüm 2: `extern "C"` ile C ve C++ Kodlarının Birlikte Kullanımı (Linkage Uyuşmazlığı) (05:05 - 22:55)**

*   **Problem (Name Mangling / Decoration):**
    *   C++ derleyicileri, function overloading'i desteklemek için fonksiyon isimlerini "dekore eder" (name mangling). Bu dekorasyon, fonksiyonun parametre türlerini ve bazen geri dönüş türünü de isme dahil eder.
        *   Örn: `sum(int, int)` -> `_sum_int_int` gibi bir şey olabilir.
    *   C derleyicileri ise name mangling yapmaz. `sum` fonksiyonu C'de sadece `_sum` (veya benzeri basit bir dekorasyon) olarak kalır.
    *   Bir C++ projesinde, C ile derlenmiş bir kütüphanedeki fonksiyonu çağırmaya çalıştığımızda, C++ derleyicisi C fonksiyonu için C++ tarzı dekore edilmiş bir isim arar. Ancak C kütüphanesinde bu isim C tarzı (dekore edilmemiş) olduğundan linker hatası (`unresolved external symbol`) alınır.
*   **Çözüm: `extern "C"` Linkage Belirleyicisi:**
    *   `extern "C"` ifadesi, C++ derleyicisine takip eden bildirimlerin C linkage kurallarına göre (yani name mangling yapmadan) ele alınması gerektiğini söyler.
    *   Bu, C++'a özgü bir yapıdır, C'de bulunmaz.
    *   **Tek Fonksiyon İçin:**
        ```cpp
        // main.cpp (C++ kodu)
        extern "C" int sum(int x, int y); // C'de derlenmiş sum fonksiyonu

        int main() {
            int result = sum(10, 20);
            // ...
            return 0;
        }
        ```
        ```c
        // zeki.c (C kodu)
        int sum(int x, int y) {
            return x + y;
        }
        ```
    *   **Birden Fazla Fonksiyon İçin (Blok Kullanımı):**
        ```cpp
        extern "C" {
            int sum(int x, int y);
            void print_hello(void);
            // Diğer C fonksiyon bildirimleri
        }
        ```
*   **Başlık Dosyalarında (`.h`) `extern "C"` Kullanımı (Conditional Compiling):**
    *   Bir başlık dosyasının hem C hem de C++ kaynak dosyaları tarafından include edilebilmesi için koşullu derleme kullanılır.
    *   C++ derleyicileri `__cplusplus` adında bir ön tanımlı makro tanımlar. C derleyicilerinde bu makro tanımsızdır.
    *   **Örnek Başlık Dosyası (`samet.h`):**
        ```cpp
        // samet.h
        #ifndef SAMET_H
        #define SAMET_H

        // Eğer C++ derleyicisi ile derleniyorsa
        #ifdef __cplusplus
        extern "C" {
        #endif

        // C ve C++ tarafından ortak kullanılacak fonksiyon bildirimleri
        int c_compatible_sum(int a, int b);
        void c_compatible_print(const char* msg);

        // Eğer C++ derleyicisi ile derleniyorsa extern "C" bloğunu kapat
        #ifdef __cplusplus
        } // extern "C"
        #endif

        #endif // SAMET_H
        ```
    *   Bu sayede, C++ kodu bu başlığı include ettiğinde fonksiyonlar `extern "C"` ile sarmalanır, C kodu include ettiğinde ise normal C bildirimi gibi görünür.
    *   `__cplusplus` makrosunun değeri, kullanılan C++ standardını da belirtebilir (örn: `199711L` C++98 için, `201103L` C++11 için, `201402L` C++14 için, `201703L` C++17 için, `202002L` C++20 için).

---

**Bölüm 3: Sınıflara Giriş (Classes) (23:11 - 32:36)**

*   **Sınıf (Class) ve Nesne Yönelimli Programlama (OOP) İlişkisi (23:55 - 25:22):**
    *   **Yanlış Anlama:** Class demek doğrudan OOP demek değildir.
    *   **Doğrusu:** C++, nesne yönelimli programlamaya *da* destek veren çok paradigmalı (multi-paradigm) bir dildir. Sınıflar, OOP'nin temel araçlarından biri olsa da, C++'da sınıflar öncelikle **Data Abstraction (Veri Soyutlama)** için kullanılır.
*   **Data Abstraction (Veri Soyutlama) (25:22 - 29:35):**
    *   **Tanım (Hocanın Tercihi):** Problem domenindeki varlıkların yazılımsal olarak temsil edilmesi.
    *   **Amaç:** Gerçek hayattaki veya bir çözüm uzayındaki kavramları (örneğin `Tarih`, `Savaşçı`, `Silah`, `FiyatVerisi`, `VeritabanıBağlantısı`, `Emir`) programlama dilinde bir tür (type) olarak modellemek.
    *   Bu sayede, bu türlerden değişkenler (nesneler) oluşturarak programlarımızı daha anlaşılır ve yönetilebilir hale getiririz.
    *   C dilinde bu `struct`'lar ile kısıtlı bir şekilde yapılırken, C++ sınıflarla bu konuda çok daha güçlü araçlar sunar.
*   **Sınıfların Kullanım Alanları:**
    *   Data Abstraction (Temel amaç)
    *   Object Oriented Programming (Kalıtım, Polimorfizm vb.)
    *   Generic Programming (Şablonlar ile birlikte)
    *   Fonksiyonel Programlama (Fonktörler vb.)
*   C++'da dilin sentaksının en yoğun olduğu yerlerden biri sınıflardır.

---

**Bölüm 4: Sınıf Bildirimi ve Tanımı (32:36 - 38:04)**

*   **C'deki `struct`'lar C++'da Sınıftır (32:36):**
    *   C++'da `struct` anahtar sözcüğü ile tanımlanan yapılar da birer sınıftır (`class type`). `class` anahtar sözcüğü ile tanımlananlar da öyledir. Aralarında temel farklar vardır (varsayılan erişim seviyesi gibi).
*   **Sınıf Bildirimi (Forward Declaration) (34:06 - 35:57):**
    *   Sadece sınıfın varlığını derleyiciye bildirir, detaylarını vermez. Bu durumda sınıf "incomplete type" (tamamlanmamış tür) olur.
    *   **Sentaks:** `class SinifAdi;` veya `struct YapiAdi;`
    *   Kullanım Alanları:
        *   Pointer veya referans olarak kullanmak için: `SinifAdi* ptr;`
        *   Fonksiyon parametresi veya geri dönüş türü olarak (pointer/referans ise): `void func(SinifAdi&);`
        *   Dairesel bağımlılıkları (circular dependencies) kırmak için.
*   **Sınıf Tanımı (Definition) (34:06 - 38:04):**
    *   Sınıfın üyelerini (veri ve fonksiyonlar) ve yapısını detaylandırır. Tanım yapıldığında tür "complete type" (tamamlanmış tür) olur.
    *   **Sentaks:**
        ```cpp
        class SinifAdi { // class tag: SinifAdi
            // Üye bildirimleri (members)
        }; // Noktalı virgül (terminator) unutulmamalı!

        struct YapiAdi {
            // Üye bildirimleri
        };
        ```
    *   **Boş Sınıf (Empty Class) (37:42):** C++'da bir sınıfın hiç üyesi olmayabilir. Bu geçerlidir.
        ```cpp
        class EmptyClass {};
        struct EmptyStruct {};
        ```
        *   `sizeof(EmptyClass)` genellikle 1 byte'tır (adreslenebilir olması için), 0 değildir. Bu, C'deki "struct en az bir üyeye sahip olmalı" kuralından farklıdır.

---

**Bölüm 5: Sınıf Üyeleri (Class Members) (39:26 - 50:08)**

*   Sınıf tanımı içindeki `{}` parantezler arası "declarative region" (bildirimsel bölge) olup, burada bildirilen varlıklara **sınıfın üyeleri (class members)** denir.
*   **Üye Kategorileri:**
    1.  **Data Members (Veri Üyeleri):** Sınıf nesnelerinin durumunu (state) tutan değişkenlerdir.
        *   Örnek: `int m_id; double m_value; char m_name[50];`
    2.  **Member Functions (Üye Fonksiyonlar / Metotlar):** Sınıf nesneleri üzerinde işlem yapan veya onların durumunu değiştiren fonksiyonlardır.
        *   Örnek: `void display(); int getValue() const; void setValue(int val);`
        *   **Not:** Hoca "metot" terimini C++ jargonunda çok kullanmasa da, üye fonksiyonlar için kullanılabileceğini belirtti. Global fonksiyonlara "metot" denmesi ise daha yaygın bir yanılgı.
    3.  **Type Members (Tür Üyeleri) / Nested Types (İç İçe Türler):** Sınıf içinde tanımlanan türlerdir.
        *   **Nested Class:** `class Nested { /*...*/ };`
        *   **Nested Struct:** `struct InnerStruct { /*...*/ };`
        *   **Nested Enum:** `enum Color { RED, GREEN, BLUE };` veya `enum class Flags : unsigned char { FLAG_A = 1, FLAG_B = 2 };`
        *   **Type Alias (using / typedef):** `using IdType = int;` veya `typedef double PriceType;`

---

**Bölüm 6: Kapsam (Scope) Türleri ve Class Scope (50:16 - 52:20)**

*   C++'da çeşitli kapsam (scope) kategorileri vardır. Bir ismin nerede geçerli (görünür) olduğunu belirler.
*   **C++ Kapsam Kategorileri:**
    1.  **Namespace Scope:** Global kapsamı ve kullanıcı tanımlı namespace'leri içerir. C'deki "file scope" yerine geçer.
    2.  **Block Scope (Yerel Kapsam):** `{}` parantezleri ile tanımlanan bloklar içindeki kapsam (fonksiyon gövdesi, `if`, `for` blokları vb.).
    3.  **Function Prototype Scope:** Fonksiyon bildirimindeki parametre isimlerinin geçerli olduğu kapsam (sadece bildirim içinde).
    4.  **Function Scope:** Sadece `goto` etiketleri (labels) için geçerlidir, fonksiyonun tamamında görünürler.
    5.  **Class Scope:** Sınıf tanımı içinde bildirilen üyelerin geçerli olduğu kapsam.
*   C'de `namespace scope` ve `class scope` yoktur. C'de `file scope` vardır.

---

**Bölüm 7: İsim Arama (Name Lookup) ve Class Scope (52:24 - 01:06:11)**

*   **Class Scope'taki İsimler:** Sınıf üyeleri (data members, member functions, nested types) class scope'tadır.
*   **Qualified Name Lookup (Nitelikli İsim Arama):**
    *   Sınıf dışından veya ilişkisiz bir kapsamdan sınıf üyelerine erişmek için isimlerin nitelenmesi gerekir.
    *   **Nokta Operatörü (`.`):** Nesneler üzerinden üyelere erişim.
        ```cpp
        MyClass obj;
        obj.dataMember = 10;
        obj.memberFunction();
        ```
    *   **Ok Operatörü (`->`):** Nesne göstericileri (pointer) üzerinden üyelere erişim.
        ```cpp
        MyClass* ptr = new MyClass();
        ptr->dataMember = 20;
        ptr->memberFunction();
        delete ptr;
        ```
    *   **Scope Resolution Operatörü (`::`):** Sınıf ismi ile statik üyelere veya nested type'lara erişim.
        ```cpp
        MyClass::staticMember = 5;
        MyClass::NestedType nestedObj;
        ```
    *   Eğer bir isim bu operatörlerin sağ tarafında kullanılıyorsa, o isim ilgili sınıfın tanımı içinde aranır.
*   **Unqualified Name Lookup (Niteliksiz İsim Arama):**
    *   Bir sınıfın üye fonksiyonu *içinde*, başka bir üyeye nitelenmemiş bir isimle (doğrudan `m_x` gibi) erişilebilir. Bu durumda isim arama önce yerel bloklarda, sonra class scope'ta yapılır. (Detayları üye fonksiyonlar bölümünde).
*   **İsim Arama, Bağlam Kontrolü ve Erişim Kontrolü Sıralaması (57:55):**
    Derleyicinin bir ifadeyi işleme sırası:
    1.  **Name Lookup (İsim Arama):** İlgili ismin hangi varlığa (değişken, fonksiyon, tür vb.) karşılık geldiği bulunur. Bulunamazsa hata. Bulunursa bir daha arama yapılmaz.
        *   **Altın Kural 1:** İsim arama belirli bir *sırayla* yapılır (yerel blok -> kapsayan bloklar -> class scope (eğer üye fonk. içindeyse) -> namespace scope).
        *   **Altın Kural 2:** İsim bulunduğunda arama *sona erer*. Bulunan isim bağlama uymasa bile tekrar arama yapılmaz.
    2.  **Context Control (Bağlam Kontrolü):** Bulunan ismin kullanıldığı bağlamın geçerli olup olmadığı kontrol edilir.
        *   Örn: `int x = 5; x(10);` -> `x` bulunur (int). `x(10)` (fonksiyon çağrısı) bağlamı `int` için geçersizdir. Hata.
    3.  **Access Control (Erişim Kontrolü):** Bulunan isme (eğer bir sınıf üyesiyse) erişim yetkisinin olup olmadığı kontrol edilir (public, private, protected).

    ```cpp
    // Global
    int my_var = 10;

    class Test {
    private:
        int my_var = 20; // Class scope'taki my_var
    public:
        void func(int my_var) { // Parameter, block scope'taki my_var
            my_var = 5;         // 1. Name lookup: Parameter 'my_var' found.
                                // 2. Context: Assigning int to int, OK.
                                // 3. Access: Not a class member access, OK.

            this->my_var = my_var; // 1. Name lookup for 'this->my_var': Class member 'my_var' found.
                                   // 2. Context: OK.
                                   // 3. Access: Inside member func, private member access OK.
                                   // 1. Name lookup for right-hand 'my_var': Parameter 'my_var' found.

            ::my_var = my_var;   // 1. Name lookup for '::my_var': Global 'my_var' found.
                                 // 2. Context: OK.
                                 // 3. Access: Global, OK.
        }
    };
    ```

---

Tamamdır, notlara devam ediyorum:

---

**Bölüm 8: Üyelerin Statik ve Non-Statik Olarak Ayrılması ve Erişim Belirteçleri (Access Specifiers) Detayları (01:06:12 - 01:15:39)**

*   **Üye Kategorilerinin Alt Düzeyde Ayrımı (01:11:47 - 01:15:39):**
    *   **Data Members (Veri Üyeleri):**
        1.  **Non-static Data Members:** Her sınıf nesnesi için ayrı bir kopyası bulunur. Nesnenin bir parçasıdırlar. `sizeof`'u etkilerler. *Şimdilik "data member" dendiğinde bu anlaşılacak.*
        2.  **Static Data Members:** Sınıfın kendisine aittir, tüm nesneler tarafından paylaşılır. Nesnelerin içinde yer almazlar. `sizeof`'u (genellikle) etkilemezler. *Bu konu daha sonra detaylı işlenecek.*
    *   **Member Functions (Üye Fonksiyonlar):**
        1.  **Non-static Member Functions:** Belirli bir nesne üzerinde çalışırlar. Gizli bir `this` pointer'ı alırlar. *Şimdilik "member function" dendiğinde bu anlaşılacak.*
        2.  **Static Member Functions:** Belirli bir nesneye bağlı değillerdir. `this` pointer'ı almazlar. Sınıf ismiyle çağrılabilirler. *Bu konu daha sonra detaylı işlenecek.*
    *   **Nested Types (İç İçe Türler):**
        *   Bunlar için "static" veya "non-static" ayrımı **yoktur**. Nested type'lar her zaman sınıfın bir parçasıdır.

*   **`static` Anahtar Sözcüğü ile Belirleme (01:13:23):**
    *   Bir data member veya member function bildiriminin başına `static` anahtar sözcüğü eklenirse, o üye "static" olur.
    *   Eklenmezse, "non-static" olur (varsayılan).
    ```cpp
    class MyData {
    public:
        int non_static_data;         // Non-static data member
        static int static_data;      // Static data member

        void non_static_func();      // Non-static member function
        static void static_func();   // Static member function
    };
    ```
    *   **Önemli Not:** Şimdilik derslerde "data member" veya "member function" dendiğinde, aksi belirtilmedikçe **non-static** olanlar kastedilecektir. Statik üyeler ilerleyen haftalarda detaylıca ele alınacak.

---

**Bölüm 9: Non-Static Data Members ve Sınıf Boyutu (`sizeof`) (01:16:23 - 01:21:52)**

*   **Non-static Data Members ve Nesne Yerleşimi:**
    *   Sınıfların non-static veri elemanları, C'deki yapıların elemanları gibi, doğrudan sınıf nesnesinin (instance) içinde yer alır.
    *   Her sınıf nesnesi, bu non-static veri üyeleri için kendi belleğine sahip olur.
    *   Örnek:
        ```cpp
        class Point {
        public:
            int x; // 4 byte (genellikle)
            int y; // 4 byte (genellikle)
        };
        // sizeof(Point) genellikle 8 byte olur (padding hariç).
        // Point p1, p2;
        // p1.x ve p2.x farklı bellek konumlarındadır.
        ```
*   **`sizeof` Operatörü ve Sınıflar:**
    *   Bir sınıfın `sizeof` değeri, non-static veri üyelerinin kapladığı toplam alan (ve derleyicinin ekleyebileceği hizalama/padding baytları) kadardır.
    *   **Üye fonksiyonlar (non-static veya static) sınıfın `sizeof` değerini doğrudan artırmaz.** (Sanal fonksiyonlar ileride bir istisna olarak görülecek).
        ```cpp
        #include <iostream>

        class MyClass {
        public:
            int a;        // 4 bytes
            double b;     // 8 bytes
            char c[10];   // 10 bytes

            void func1() { /*...*/ } // sizeof'u etkilemez
            void func2(int) { /*...*/ } // sizeof'u etkilemez
        };

        int main() {
            // sizeof(MyClass) = sizeof(int) + sizeof(double) + sizeof(char[10]) + padding
            // Genellikle 4 + 8 + 10 = 22 byte + padding.
            // Örneğin, double'dan sonra int için padding gerekebilir, veya char[10]'dan sonra.
            // Tipik bir sistemde 24 veya 32 byte olabilir.
            std::cout << "sizeof(MyClass): " << sizeof(MyClass) << std::endl;
        }
        ```
*   **Boş Sınıfın Boyutu (Empty Class `sizeof`) (01:20:50):**
    *   Bir sınıfın hiç non-static data member'ı olmasa bile (`class Empty {};`), `sizeof(Empty)` genellikle **1 byte** olur.
    *   Sebebi: C++'da her nesnenin benzersiz bir adresi olmalıdır. 0 byte'lık bir nesne adreslenemezdi. Bu 1 byte'lık "dummy" alan, farklı boş sınıf nesnelerinin farklı adreslere sahip olmasını sağlar.
*   **Aynı İsimli Data Member Tanımlanamaz (01:21:57):**
    *   Aynı class scope içinde (aynı sınıf tanımında) aynı isimde birden fazla data member (türleri farklı olsa bile) tanımlanamaz. Bu bir "redeclaration" (yeniden bildirim) hatasıdır.
    ```cpp
    class BadExample {
    public:
        int x;
        // double x; // HATA: 'x' yeniden tanımlanıyor
    };
    ```

---

**Bölüm 10: Üye Fonksiyonlar (Member Functions) ve Overloading (01:22:40 - 01:26:06)**

*   **Aynı İsimli Üye Fonksiyon ve Data Member (01:22:47):**
    *   Aynı class scope içinde, bir data member ile aynı isimde bir member function tanımlanamaz. Bu da bir "redeclaration" hatasıdır.
    ```cpp
    class BadExample2 {
    public:
        int foo;
        // void foo(int); // HATA: 'foo' hem data member hem member function olamaz
    };
    ```
*   **Member Function Overloading (01:24:28):**
    *   Sınıf içinde üye fonksiyonlar overload edilebilir. Yani aynı isimde, farklı parametre listelerine (imzalara) sahip birden fazla üye fonksiyon tanımlanabilir.
    *   Bu, global fonksiyonların overload edilmesiyle aynı prensibe dayanır: Aynı scope, aynı isim, farklı imzalar.
    ```cpp
    class Calculator {
    public:
        int add(int a, int b) { return a + b; }
        double add(double a, double b) { return a + b; } // OK: Overload
        // void add(int a, int b) {} // HATA: Sadece geri dönüş türü farklı, imza aynı
    };
    ```
*   **Global Fonksiyon vs. Member Function (Overloading Değil) (01:23:35):**
    *   Bir global fonksiyon ile aynı isimde bir member function tanımlanması function overloading **değildir**, çünkü kapsamları (scope) farklıdır.
    ```cpp
    void func(int); // Global scope

    class MyStuff {
    public:
        void func(double); // MyStuff class scope (Overloading değil, farklı scope'lar)
    };
    ```
*   **Member Function'ların Yeniden Bildirimi (Redeclaration) Yoktur (01:25:12):**
    *   Global fonksiyonların aksine, sınıfın üye fonksiyonları (bildirimleri birebir aynı olsa bile) sınıf tanımı içinde **tekrar bildirilemez**. Bu bir sentaks hatasıdır.
    ```cpp
    class NoRedecl {
    public:
        void doSomething(int x);
        // void doSomething(int x); // HATA: Member function yeniden bildirilemez
    };
    ```
    *   Global fonksiyonlar farklı çeviri birimlerinde (translation units) birden çok kez bildirilebilir (ama sadece bir kez tanımlanabilir), ancak member function'lar için bu geçerli değildir. Tanımları sınıf tanımının bir parçasıdır veya sınıf dışında nitelikli olarak yapılır.

---

**Bölüm 11: Erişim Belirteçleri (Access Specifiers): `public`, `private`, `protected` (01:26:06 - 01:44:42)**

*   **Temel Amaç:** Sınıf üyelerine erişimi kontrol etmek, Data Hiding/Information Hiding sağlamak.
*   **Erişim Belirteçleri (Access Specifiers / Access Modifiers):**
    1.  `public`: Her yerden erişilebilir. Sınıfın dış dünyaya açılan arayüzünü oluşturur.
    2.  `private`: Sadece sınıfın kendi üye fonksiyonları (ve `friend` olarak bildirilen fonksiyon/sınıflar) tarafından erişilebilir. Varsayılan olarak client kodların erişimi engellenir.
    3.  `protected`: Sınıfın kendi üye fonksiyonları, `friend`'leri VE bu sınıftan kalıtım (inheritance) yoluyla türetilmiş sınıfların üye fonksiyonları tarafından erişilebilir. *Kalıtım konusu işlenene kadar `private` ile benzer davranır.*
*   **Bölge Tanımlama (01:28:37):**
    *   C++'da `public`, `private`, `protected` anahtar sözcükleri, Java veya C# gibi dillerdeki gibi tek tek üyeleri nitelemez. Bunun yerine, sınıf tanımı içinde **bölgeler (sections)** tanımlarlar.
    *   Bir erişim belirteci yazıldıktan sonra (örn: `public:`), o belirteçten bir sonraki erişim belirtecine kadar veya sınıf tanımının sonuna kadar olan tüm üyeler o erişim seviyesine sahip olur.
    ```cpp
    class Demo {
    // Hiçbir şey belirtilmediyse, 'class' için varsayılan 'private' olur
        int x; // private

    public:     // Buradan sonrası public
        int y;
        void func1();

    private:    // Buradan sonrası private
        int z;
        void helperFunc();

    public:     // Tekrar public olabilir
        double k;
    };
    ```
*   **`class` vs. `struct` Varsayılan Erişim Seviyesi (01:30:13):**
    *   **`class`:** Eğer hiçbir erişim belirteci kullanılmazsa, üyeler varsayılan olarak **`private`** olur.
    *   **`struct`:** Eğer hiçbir erişim belirteci kullanılmazsa, üyeler varsayılan olarak **`public`** olur.
    *   Bu, `struct` ile `class` arasındaki temel farklardan biridir. C'deki `struct`'ların tüm üyeleri doğal olarak public olduğundan, C++'daki `struct` bu davranışı sürdürür.
    ```cpp
    class MyClass {
        int data; // private (varsayılan)
    };

    struct MyStruct {
        int data; // public (varsayılan)
    };
    ```
*   **Erişim Kontrolünün Kapsamı (01:36:35):**
    *   Erişim kontrolü, **tüm üye türleri** için geçerlidir:
        *   Data members
        *   Member functions
        *   Nested types
    *   Örnek:
        ```cpp
        class AccessExample {
        private:
            int private_data;
            void private_func() {}
            class PrivateNested {}; // private nested class

        public:
            int public_data;
            void public_func() {}
            class PublicNested {};  // public nested class
        };

        int main() {
            AccessExample obj;
            obj.public_data = 10;  // OK
            obj.public_func();     // OK
            AccessExample::PublicNested pn; // OK

            // obj.private_data = 20; // HATA: private
            // obj.private_func();    // HATA: private
            // AccessExample::PrivateNested pvn; // HATA: private
            return 0;
        }
        ```
*   **Farklı Erişim Bölgelerinde Function Overloading (01:38:28):**
    *   Bir fonksiyonun overload'ları sınıfın farklı erişim bölgelerinde (`public`, `private` vb.) bulunabilir.
    *   **Önemli:** `public`, `private` gibi belirteçler scope (kapsam) oluşturmaz. Sınıfın tüm üyeleri aynı **class scope** içindedir. Bu nedenle, farklı erişim bölgelerindeki aynı isimli fonksiyonlar (imzaları farklıysa) overload oluşturur. Aynı isim ve aynı imzaya sahipse, erişim seviyesi ne olursa olsun hata verir (redeclaration).
    ```cpp
    class OverloadAccess {
    public:
        void print(int i) { /*...*/ }

    private:
        // Bu, public'teki print ile overload olur, çünkü imzaları farklı
        void print(double d) { /*...*/ }
        // int x; // public veya private, herhangi bir x burada olsaydı

    public:
        // void print(int val) { /*...*/ } // HATA: public'teki print(int) ile imza aynı

        // Bu OK, farklı isim
        void display(int i) {
            print(i);     // Kendi içinden public print(int)'i çağırır
            print(3.14);  // Kendi içinden private print(double)'ı çağırır
            // x = 10;    // Eğer x tanımlı olsaydı, erişilebilirdi
        }
    };
    ```
*   **`protected`'ın Detayı (Kalıtım ile İlişkisi) (01:41:33):**
    *   `protected` üyeler, temel sınıfın (`base class`) kendi üyeleri ve `friend`'leri tarafından erişilebilir.
    *   Ek olarak, bu temel sınıftan kalıtım yoluyla türetilen sınıfların (`derived class`) üye fonksiyonları da temel sınıfın `protected` üyelerine erişebilir.
    *   Kalıtım konusu işlenene kadar, `protected` üyeler client kodlar açısından `private` üyeler gibi davranır (yani dışarıdan erişilemezler).
    *   Eğer kalıtım kullanılmayacaksa, `protected` kullanmanın `private`'a göre bir avantajı olmaz.
*   **Data Hiding / Information Hiding Felsefesi (01:44:42 - 01:55:35):**
    *   **Amaç:** Sınıfın iç çalışma detaylarını (implementasyonunu) dış dünyadan (client kodlardan) gizlemek ve sadece iyi tanımlanmış bir arayüz (`public` üyeler) sunmak.
    *   **Tipik Yaklaşım:**
        *   Veri üyeleri (`data members`) genellikle `private` yapılır.
        *   Bu verilere erişmek ve onları değiştirmek için `public` üye fonksiyonlar (getter/setter veya daha anlamlı işlemler yapan fonksiyonlar) sağlanır.
    *   **Avantajları:**
        1.  **Azaltılmış Karmaşıklık (Reduced Complexity):** Client kod yazanlar, sınıfın iç yapısını bilmek zorunda kalmaz, sadece `public` arayüzü öğrenirler. Bu, öğrenme yükünü azaltır.
        2.  **Artırılmış Esneklik ve Bakım Kolaylığı (Increased Flexibility & Maintainability):** Sınıfın iç implementasyonu (örn: `private` veri üyelerinin türü veya sayısı) `public` arayüzü sabit kaldığı sürece değiştirilebilir. Bu değişiklikler client kodları etkilemez (kırmaz). C'de `struct` elemanları değişirse, tüm client kodlar güncellenmek zorunda kalabilir.
        3.  **Gelişmiş Sağlamlık (Improved Robustness):** `private` verilere sadece sınıfın kendi kontrolündeki `public` fonksiyonlar aracılığıyla erişilebildiğinden, verilerin geçerli (valid) bir durumda kalması sağlanabilir (invariant'lar korunabilir). Doğrudan erişimde, client kodlar verileri geçersiz bir duruma sokabilir.
            *   Örnek (`Triangle` sınıfı): Kenar uzunlukları `private` ise, `public setEdge` fonksiyonu bir üçgen oluşturma koşulunu (iki kenarın toplamı üçüncüden büyük olmalı) kontrol edebilir. Alan (`area`) gibi bağımlı bir veri varsa, kenar değiştiğinde alanın da otomatik güncellenmesi sağlanabilir.
        4.  **Kontrollü Erişim:** Sınıf, verilerine nasıl erişileceği ve nasıl değiştirileceği konusunda tam kontrol sahibi olur.
    *   **C'deki Benzer Yaklaşım (Dosya Bazında) (01:55:40):**
        *   C'de `public` arayüz, başlık dosyasında (`.h`) bildirilen global fonksiyonlar ve `extern` değişkenler ile sağlanır.
        *   `private` implementasyon detayları ise kaynak dosyasında (`.c`) `static` anahtar sözcüğü ile tanımlanan (internal linkage'a sahip) fonksiyonlar ve değişkenler ile gizlenir. Bunlar sadece tanımlandıkları dosya içinden erişilebilir.
    *   **Information Hiding Bir Dogma Değildir (01:53:30):**
        *   Veri gizleme her zaman ve her koşulda "en iyi" yaklaşım olmayabilir. Bazen, özellikle basit veri taşıyıcı yapılar (POD - Plain Old Data benzeri) için tüm üyeleri `public` yapmak (genellikle `struct` kullanarak) daha pratik olabilir.
        *   Sırf "hiding" olsun diye tüm `private` üyelere basit `get` ve `set` fonksiyonları eklemek, gereksiz kod karmaşasına yol açabilir ve doğrudan `public` erişimden pek farklı olmayabilir. Duruma göre karar verilmelidir.

---
Harika, C++ ders notlarına devam ediyoruz!

---

**Bölüm 12: Üye Fonksiyonların Detayları: `this` Göstericisi ve Çağrılma Mekanizması (01:59:55 - 02:30:17)**

*   **Non-Static Üye Fonksiyonların Temel Prensibi (01:59:55):**
    *   Hoca, üye fonksiyonların aslında dil seviyesinde bir "uydurma" olduğunu, yani derleyicinin daha okunabilir ve nesne yönelimli bir sentaks sağlamak için yaptığı bir dönüşüm olduğunu belirtti. Assembly seviyesinde, global fonksiyonlardan temelde farkları yoktur.
    *   Amaçları, kodu daha yüksek seviyede soyutlamak, okunabilirliği artırmak ve belirli bir nesneyle doğrudan ilişkilendirilmiş eylemler tanımlamaktır.
*   **C'deki Explicit Pointer Parametresiyle Karşılaştırma (02:01:20):**
    *   C dilinde, bir yapı (struct) üzerinde işlem yapacak fonksiyonlar genellikle o yapının bir göstericisini (pointer) ilk parametre olarak alırlar.
        ```c
        // C Kodu
        typedef struct {
            int id;
            double wage;
        } Employee;

        void print_employee(const Employee* emp) {
            // emp->id, emp->wage kullanarak işlem yap
        }

        void set_employee_wage(Employee* emp, double new_wage) {
            emp->wage = new_wage;
        }

        // Kullanım:
        // Employee e1;
        // set_employee_wage(&e1, 5000.0);
        // print_employee(&e1);
        ```
    *   Bu yaklaşımda:
        *   Fonksiyon çağrılarında nesnenin adresini (`&e1`) açıkça geçmek gerekir.
        *   Eğer bir fonksiyon birden fazla nesne üzerinde çalışıyorsa (örn: `attack(Fighter* attacker, Fighter* attacked)`), hangi parametrenin "ana" nesne olduğu belirsiz olabilir ve kodun okunabilirliği düşer.
*   **C++ Non-Static Üye Fonksiyonlarının Avantajı: Örtülü (Implicit) `this` Göstericisi (02:09:10):**
    *   C++'da non-static bir üye fonksiyonu çağırdığımızda, sanki fonksiyonun gizli bir ilk parametresi varmış gibi davranılır. Bu gizli parametre, fonksiyonun çağrıldığı nesnenin adresini tutan bir göstericidir ve adına **`this` göstericisi** denir.
    *   **Sentaks Dönüşümü:**
        *   Client Kod: `myObject.memberFunc(arg1, arg2);`
        *   Derleyicinin Yaptığı (Kavramsal Olarak): `ClassName::memberFunc(&myObject, arg1, arg2);` (Eğer `memberFunc` global olsaydı ve ilk parametresi `ClassName* this_ptr` olsaydı)
        *   Client Kod: `myPointer->memberFunc(arg1, arg2);`
        *   Derleyicinin Yaptığı (Kavramsal Olarak): `ClassName::memberFunc(myPointer, arg1, arg2);`
    *   **`this` Göstericisinin Türü:** Eğer üye fonksiyon `MyClass` sınıfına aitse, `this` göstericisinin türü `MyClass* const` olur (const olmayan üye fonksiyonlar için). `const` üye fonksiyonlar için `const MyClass* const` olur. `this` göstericisinin kendisi değiştirilemez (sağdaki `const`), gösterdiği nesne ise fonksiyonun const olup olmamasına göre değiştirilebilir.
*   **Non-Static Üye Fonksiyonların Parametre Sayısı (02:13:05):**
    *   Bir non-static üye fonksiyonun bildiriminde `N` tane parametre görünüyorsa, aslında `N+1` tane parametresi vardır. Bu ek parametre, `this` göstericisidir.
    ```cpp
    class Example {
    public:
        void func1() {}           // Görünürde 0 parametre, gerçekte 1 (this)
        void func2(int a) {}      // Görünürde 1 parametre, gerçekte 2 (this, a)
        void func3(int a, double b) {} // Görünürde 2 parametre, gerçekte 3 (this, a, b)
    };
    ```
*   **`this` Göstericisinin Kullanımı (Implicit ve Explicit) (02:36:05):**
    *   Bir non-static üye fonksiyonu *içinde*, sınıfın diğer üyelerine (data members veya diğer member functions) erişirken `this->` önekini kullanmak **opsiyoneldir**.
    *   Eğer nitelenmemiş bir isim kullanılırsa (örn: `m_data` gibi), derleyici bu ismin `this->m_data` anlamına geldiğini varsayar (eğer yerel bir değişken veya parametre bu ismi maskelemiyorsa).
    ```cpp
    class Point {
    private:
        int x, y;
    public:
        void set(int new_x, int new_y) {
            x = new_x;         // Örtülü olarak this->x = new_x;
            this->y = new_y;   // Açıkça this->y = new_y;
        }
        void print() const {
            // this->x ve this->y kullanılabilir.
        }
    };
    ```
*   **Global Fonksiyonlar vs. Member Fonksiyonlar (İhtiyaç Devam Ediyor) (02:19:54):**
    *   Üye fonksiyonların varlığı, global (free) fonksiyonlara olan ihtiyacı ortadan **kaldırmaz**.
    *   C++ Standart Kütüphanesi'nde bile birçok sınıf hem üye fonksiyonlara hem de o sınıflarla çalışan global fonksiyonlara sahiptir.
        *   Örnek: `std::vector` sınıfının `push_back()` gibi üye fonksiyonları varken, `std::erase()` (C++20) gibi global fonksiyonlar da vektörlerle çalışabilir.
    *   Hangi işlevselliğin üye fonksiyon, hangisinin global fonksiyon olacağı bir tasarım kararıdır ve ileride tartışılacaktır.

---

**Bölüm 13: Üye Fonksiyonların Tanımlanması (Definition) (02:24:40 - 02:40:00)**

*   **Tanım Yöntemleri:**
    1.  **Sınıf Tanımı İçinde (Implicitly Inline - Örtülü Olarak Satır İçi):**
        *   Eğer bir üye fonksiyonun gövdesi doğrudan sınıf tanımı içinde verilirse, bu fonksiyon derleyici tarafından örtülü olarak `inline` kabul edilir. Bu, derleyicinin optimizasyon amacıyla fonksiyon çağrısını fonksiyonun koduyla değiştirebileceği anlamına gelir (bir tavsiyedir, garanti değil).
        *   Genellikle kısa ve basit fonksiyonlar için tercih edilir.
        ```cpp
        class MyInline {
        public:
            int getValue() const { return data; } // Sınıf içinde tanımlı, implicitly inline
        private:
            int data = 0;
        };
        ```
    2.  **Sınıf Tanımı Dışında (Explicitly Qualified - Açıkça Nitelikli):**
        *   Sınıf tanımında sadece fonksiyonun bildirimi yapılır.
        *   Fonksiyonun tanımı (gövdesi) ise sınıf tanımının dışında, genellikle bir `.cpp` kaynak dosyasında yapılır.
        *   Bu durumda, fonksiyonun hangi sınıfa ait olduğunu belirtmek için **sınıf ismi ve scope resolution operatörü (`::`)** ile nitelenmesi gerekir.
        *   Bu yöntem, daha uzun ve karmaşık fonksiyonlar için veya implementasyonu başlık dosyasından ayırmak için kullanılır.
        ```cpp
        // MyClass.h (Başlık Dosyası)
        #ifndef MYCLASS_H
        #define MYCLASS_H

        class MyClass {
        public:
            void setData(int val); // Bildirim
            int getData() const;   // Bildirim
        private:
            int m_data;
        };
        #endif

        // MyClass.cpp (Kaynak Dosyası)
        #include "MyClass.h"
        #include <iostream>

        void MyClass::setData(int val) { // Tanım: MyClass:: ile nitelenmiş
            m_data = val; // veya this->m_data = val;
        }

        int MyClass::getData() const {   // Tanım: MyClass:: ile nitelenmiş
            return m_data; // veya return this->m_data;
        }
        ```
*   **Neden Nitelikli İsim? (02:29:02):**
    *   Eğer sınıf dışında tanımlarken fonksiyon ismini sınıf ismiyle nitelemezsek (`void setData(int val) { ... }` gibi), derleyici bunu o isimde yeni bir **global (free) fonksiyon** olarak algılar, sınıfın üyesi olarak değil. Bu da genellikle "unresolved external symbol" linker hatasına veya istenmeyen davranışlara yol açar.
*   **Class Definition'ın Yeri (Header vs. CPP) (02:25:54):**
    *   Sınıf tanımları (`class MyClass { ... };`) genellikle **başlık dosyalarında (`.h` veya `.hpp`)** yer alır. Çünkü sınıfın tanımının, o sınıfı kullanan tüm çeviri birimleri (kaynak dosyaları) tarafından bilinmesi gerekir.
    *   **İstisna:** Eğer bir sınıf sadece tek bir `.cpp` dosyasının implementasyon detayı ise ve dışarıya açılmıyorsa, o `.cpp` dosyası içinde de tanımlanabilir veya anonim bir namespace içine alınabilir.

---

**Bölüm 14: Üye Fonksiyonlar İçinde İsim Arama (Name Lookup) Kuralları (02:35:05 - 02:43:13)**

*   Bir non-static üye fonksiyonu içinde **niteliksiz (unqualified)** bir isim kullanıldığında (örn: `m_x`, `some_func`, `localVar`), isim arama şu sırayla yapılır:
    1.  **Block Scope (Yerel Kapsam):** İsim, kullanıldığı en iç bloktan başlayarak dışa doğru tüm kapsayan bloklarda (parametreler de dahil) aranır. Bulunursa arama biter.
    2.  **Class Scope:** Eğer bloklarda bulunamazsa, isim sınıfın tanımı içinde (class scope) aranır. Bu, sınıfın data member'larını, diğer member function'larını ve nested type'larını içerir. Bulunursa arama biter.
        *   Eğer burada bulunan bir data member ise, bu `this->data_member_adı` anlamına gelir.
        *   Eğer burada bulunan bir member function ise, bu `this->member_function_adı()` anlamına gelir.
    3.  **Namespace Scope (ve kapsayan namespace'ler):** Eğer class scope'ta da bulunamazsa, isim global namespace'de ve (varsa) sınıfın bulunduğu namespace'in kapsayan namespace'lerinde aranır.
*   **İsim Çakışması (Shadowing / Masking) (02:37:42):**
    *   Eğer bir yerel değişken veya parametre, bir sınıf üyesiyle aynı isme sahipse, yerel isim sınıf üyesini **maskeler (shadows)**. Bu durumda, niteliksiz isim kullanıldığında yerel olan bulunur.
    ```cpp
    class ShadowExample {
    private:
        int x = 100; // Sınıf üyesi x
    public:
        void process(int x) { // Parametre x (yerel)
            x = 50;         // Bu atama parametre x'e yapılır, sınıf üyesi x'e değil.
            this->x = x;    // Sınıf üyesi x'e, parametre x'in değerini atar.
                            // (this->x = 50 olur)
        }
    };
    ```
*   **Maskelenen Üyelere Erişmek (02:39:44):**
    *   **`this->uyeAdi`:** Eğer bir yerel değişken, sınıfın bir data member'ını veya member function'ını maskeliyorsa, `this->` önekini kullanarak açıkça sınıf üyesine erişilebilir.
    *   **`SinifAdi::uyeAdi`:** Statik olmayan bir üye için de kullanılabilir, bu da `this->uyeAdi` ile aynı anlama gelir. (Statik üyeler için zorunludur).
        ```cpp
        // ShadowExample sınıfındaki process fonksiyonu içinde:
        // this->x = x;  // this->x sınıf üyesini, sağdaki x parametreyi ifade eder.
        // ShadowExample::x = x; // Bu da sınıf üyesini ifade eder (non-static için this->x ile aynı).
        ```
    *   **`::globalUyeAdi`:** Eğer bir global değişken, sınıf üyesi veya yerel bir değişken tarafından maskeleniyorsa, unary scope resolution operatörü (`::`) ile global değişkene erişilebilir.
        ```cpp
        int count = 0; // Global count

        class Counter {
        private:
            int count = 10; // Sınıf üyesi count
        public:
            void increment(int count) { // Parametre count
                count++;          // Parametre artar
                this->count++;    // Sınıf üyesi artar
                ::count++;        // Global count artar
            }
        };
        ```

---
**Genel Kapsayıcı Kod Örneği:**

```cpp
#include <iostream>
#include <string>
#include <vector>

// Bölüm 2: extern "C" için C kodu (ayrı bir c_utils.c dosyasında derlenecek)
/*
// c_utils.c
#include <stdio.h>
void c_greet(const char* name) {
    printf("Hello from C, %s!\n", name);
}
*/

// Bölüm 2: C fonksiyonu için bildirim
#ifdef __cplusplus
extern "C" {
#endif
    void c_greet(const char* name);
#ifdef __cplusplus
}
#endif

// Bölüm 4, 5, 8, 9, 10, 11, 12, 13, 14
class Student {
private: // Erişim belirteci: private bölge
    std::string student_name; // Non-static data member
    int student_id;           // Non-static data member
    std::vector<int> grades;  // Non-static data member

    // Bölüm 11: Private üye fonksiyon (yardımcı)
    void calculateAverageGrade() { // Sınıf içinde tanımlı (implicitly inline)
        if (grades.empty()) {
            std::cout << "No grades available for " << student_name << std::endl;
            return;
        }
        double sum = 0;
        for (int grade : grades) {
            sum += grade;
        }
        std::cout << "Average grade for " << student_name << ": " << sum / grades.size() << std::endl;
    }

public: // Erişim belirteci: public bölge
    // Bölüm 10: Üye fonksiyon (constructor - sonraki derslerde)
    Student(const std::string& name, int id) : student_name(name), student_id(id) { // Sınıf içinde tanım
        std::cout << "Student " << student_name << " (ID: " << student_id << ") created." << std::endl;
    }

    // Bölüm 13: Üye fonksiyon bildirimi (tanımı sınıf dışında)
    void addGrade(int grade);
    void addGrade(double grade); // Bölüm 10: Overloading

    void displayInfo() const { // const üye fonksiyon (sonraki derslerde)
        std::cout << "ID: " << student_id << ", Name: " << student_name << std::endl;
        // student_name = "Test"; // HATA: const üye fonksiyon içinde non-static data member değiştirilemez
        // this->student_id = 0; // HATA

        // Bölüm 14: İsim arama (calculateAverageGrade private olsa da sınıf içinden çağrılabilir)
        // calculateAverageGrade(); // Bu fonksiyon const olmadığı için const fonksiyondan çağrılamaz.
        // Eğer calculateAverageGrade() const olsaydı, çağrılabilirdi.
        // Şimdilik basitçe notları yazdıralım
        std::cout << "Grades: ";
        for(int g : grades) {
            std::cout << g << " ";
        }
        std::cout << std::endl;
    }

    // Bölüm 5: Nested type (public)
    struct Address {
        std::string street;
        std::string city;
    };

private:
    Address student_address; // private nested type nesnesi

public:
    void setAddress(const std::string& street, const std::string& city) {
        // Bölüm 14: İsim çakışması yok, doğrudan erişim
        student_address.street = street;
        student_address.city = city;
    }

    void printAddress() const {
        std::cout << "Address: " << student_address.street << ", " << student_address.city << std::endl;
    }
}; // Sınıf tanımı sonu

// Bölüm 13: Student::addGrade fonksiyonlarının sınıf dışı tanımları
void Student::addGrade(int grade) {
    // Bölüm 14: 'grades' (sınıf üyesi) ve 'grade' (parametre)
    // this->grades.push_back(grade); // Açık 'this' kullanımı
    grades.push_back(grade);          // Örtülü 'this' kullanımı (daha yaygın)
    std::cout << "Added grade " << grade << " for " << this->student_name << std::endl;
}

void Student::addGrade(double grade) { // Overload
    std::cout << "Adding double grade (converted to int): " << static_cast<int>(grade) << std::endl;
    grades.push_back(static_cast<int>(grade)); // double'ı int'e çevirip ekle
}


// Bölüm 1: Mülakat sorusu benzeri
void processValue(int& val) {
    std::cout << "Processing L-value: " << val << std::endl;
}
void processValue(int&& val) {
    std::cout << "Processing R-value: " << val << std::endl;
}
void forwardValue(int&& r_val_ref) { // r_val_ref'in türü R-value referans
    std::cout << "Inside forwardValue..." << std::endl;
    // 'r_val_ref' bir isim olduğu için L-value expression'dır.
    processValue(r_val_ref);
}


int main() {
    // Bölüm 1
    std::cout << "--- Function Overloading Mülakat Sorusu ---" << std::endl;
    forwardValue(100); // 100 R-value'dur

    // Bölüm 2
    std::cout << "\n--- extern \"C\" ---" << std::endl;
    c_greet("C++ User");

    // Bölüm 9, 11, 12
    std::cout << "\n--- Sınıf Kullanımı ---" << std::endl;
    Student s1("Alice Wonderland", 101);
    s1.addGrade(90);
    s1.addGrade(85.5); // Overload çağrılır
    // s1.student_name = "Bob"; // HATA: student_name private
    // s1.calculateAverageGrade(); // HATA: calculateAverageGrade private

    s1.displayInfo();
    s1.setAddress("123 Main St", "Dreamville");
    s1.printAddress();

    Student::Address addr; // Public nested type'a erişim
    addr.city = "Anytown";

    // Bölüm 9: sizeof
    std::cout << "\n--- sizeof ---" << std::endl;
    std::cout << "sizeof(Student): " << sizeof(Student) << std::endl; // string ve vector karmaşık olduğu için boyut platforma bağlı
    std::cout << "sizeof(Student::Address): " << sizeof(Student::Address) << std::endl;

    class Empty {};
    std::cout << "sizeof(Empty): " << sizeof(Empty) << std::endl; // Genellikle 1

    return 0;
}

```
