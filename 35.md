# C++ Programlama Dili - DetaylÄ± Ders NotlarÄ± (36. Ders)

**Tarih:** 30 Ekim 2024  
**Konu:** Variadic Templates, Pack Expansion, Perfect Forwarding, Compile-Time Recursion, Comma Operator Trick

---

## I. Variadic Templates: Parametre Paketi KavramÄ± [00:00:00 - 00:16:00]

Modern C++'Ä±n (C++11 ve sonrasÄ±) jenerik programlama paradigmasÄ±na kazandÄ±rdÄ±ÄŸÄ± en gÃ¼Ã§lÃ¼ araÃ§lardan biri **Variadic Templates**'dir. Bu yapÄ±, ÅŸablonlarÄ±n deÄŸiÅŸken sayÄ±da ve tipte parametre alabilmesini saÄŸlar.

### 1. Åablon Parametre Paketi (Template Parameter Pack)
*   **TanÄ±m:** `typename...` veya `class...` anahtar sÃ¶zcÃ¼klerinden sonra gelen isim, bir "parametre paketi"dir. Bu paket iÃ§inde sÄ±fÄ±r (0) dahil olmak Ã¼zere N tane ÅŸablon tÃ¼r argÃ¼manÄ± bulunabilir.
*   **Syntax:** `template <typename... Args> class MyClass;` ÅŸeklinde tanÄ±mlanÄ±r.
*   **TÃ¼rleri:**
    *   **Type Parameter Pack:** TÃ¼rleri tutar (`typename... Args`).
    *   **Non-Type Parameter Pack:** DeÄŸerleri tutar (`int... Vals`).
    *   **Template-Template Parameter Pack:** ÅablonlarÄ± paket olarak alÄ±r.

### 2. Fonksiyon Parametre Paketi (Function Parameter Pack)
*   Åablon parametre paketinden sonra gelen elipsis (`...`) operatÃ¶rÃ¼, fonksiyonun bu tÃ¼rlerden oluÅŸan bir parametre listesi alacaÄŸÄ±nÄ± belirtir.
*   **Ã–nemli AyrÄ±m:** Åablon parametre paketi ile fonksiyon parametre paketi birbiriyle iliÅŸkilidir ancak aynÄ± ÅŸey deÄŸildir. Åablon tarafÄ± tÃ¼rleri paketlerken, fonksiyon tarafÄ± bu tÃ¼rlerden nesneleri (argÃ¼manlarÄ±) paketler.

### 3. Birden Fazla Parametre Paketi Olabilir mi?
*   **SÄ±nÄ±f ÅablonlarÄ±nda:** HayÄ±r. SÄ±nÄ±f ÅŸablonlarÄ±nda parametre paketi en sonda bulunmak zorundadÄ±r ve bir tanedir.
*   **Fonksiyon ÅablonlarÄ±nda:** Evet, mÃ¼mkÃ¼ndÃ¼r. EÄŸer derleyici tÃ¼r Ã§Ä±karÄ±mÄ±nÄ± (deduction) yapabiliyorsa veya argÃ¼manlar aÃ§Ä±kÃ§a belirtilmiÅŸse (explicit), birden fazla paket bulunabilir.
*   **Trailing/Non-trailing:** Paket en sonda ise "trailing", deÄŸilse "non-trailing" olarak adlandÄ±rÄ±lÄ±r. Fonksiyon Ã§aÄŸrÄ±sÄ±nda argÃ¼manlar paket dÄ±ÅŸÄ±ndaki parametrelere daÄŸÄ±tÄ±ldÄ±ktan sonra kalanlar pakete gider.

### 4. `sizeof...` OperatÃ¶rÃ¼
*   Variadic template'lere Ã¶zel bir operatÃ¶rdÃ¼r.
*   Paket isminden Ã¶nce veya sonra deÄŸil, `sizeof... (paket_ismi)` ÅŸeklinde kullanÄ±lÄ±r.
*   Derleme zamanÄ±nda paketin iÃ§inde kaÃ§ tane Ã¶ÄŸe (tÃ¼r veya deÄŸer) olduÄŸu bilgisini `std::size_t` tÃ¼rÃ¼nde dÃ¶ner.

```cpp
template <typename... Args>
void func(Args... args) {
    // Pakette kaÃ§ argÃ¼man olduÄŸunu Ã¶ÄŸrenelim
    std::size_t count = sizeof...(Args); 
    std::cout << "Gelen arguman sayisi: " << count << std::endl;
}

// KullanÄ±mÄ±:
func(1, 4.5, "merhaba", 'A'); // Ekrana 4 yazar.
```

---

## II. Pack Expansion (Paket Patlatma) ve Ã–rÃ¼ntÃ¼ MantÄ±ÄŸÄ± [00:16:00 - 00:50:00]

Parametre paketi tek baÅŸÄ±na kullanÄ±lamaz; iÃ§eriÄŸine eriÅŸmek iÃ§in paketin "geniÅŸletilmesi" (expansion) gerekir. Hoca bu iÅŸleme halk aÄŸzÄ±yla "paketi patlatma" demektedir.

### 1. GeniÅŸletme MantÄ±ÄŸÄ± (Pattern-based Expansion)
Paket geniÅŸletmesi, paketteki her bir Ã¶ÄŸeyi virgÃ¼llerle ayrÄ±lmÄ±ÅŸ bir listeye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Ancak bu sadece isimlerin listelenmesi deÄŸil, bir "Ã¶rÃ¼ntÃ¼" (pattern) Ã¼zerinden de yapÄ±labilir.

*   **Basit GeniÅŸletme:** `args...` -> `p1, p2, p3...pn`
*   **Pattern ile GeniÅŸletme:** Elipsis (`...`) operatÃ¶rÃ¼, solundaki ifadenin tamamÄ±nÄ± bir Ã¶rÃ¼ntÃ¼ kabul eder ve her parametre iÃ§in o Ã¶rÃ¼ntÃ¼yÃ¼ tekrar eder.

### 2. Ã–rnek Ã–rÃ¼ntÃ¼ler (Patterns)
Diyelim ki elimizde `p1, p2, p3` parametreleri var:
*   `&args...` -> `&p1, &p2, &p3` (Adres operatÃ¶rÃ¼ Ã¶rÃ¼ntÃ¼sÃ¼)
*   `10 * args...` -> `10 * p1, 10 * p2, 10 * p3`
*   `func(args)...` -> `func(p1), func(p2), func(p3)` (Fonksiyon Ã§aÄŸrÄ±sÄ± Ã¶rÃ¼ntÃ¼sÃ¼)

### 3. Perfect Forwarding ile KullanÄ±mÄ±
Variadic template'lerin en kritik kullanÄ±m alanlarÄ±ndan biri **Perfect Forwarding**'dir. TÃ¼m argÃ¼manlarÄ± deÄŸer kategorisini (L-value/R-value) koruyarak baÅŸka bir yere aktarmak iÃ§in kullanÄ±lÄ±r.

```cpp
template <typename T, typename... Args>
std::unique_ptr<T> MyMakeUnique(Args&&... args) {
    // Args&&... -> Universal Reference paketidir.
    // std::forward<Args>(args)... -> Her bir argÃ¼manÄ± tek tek perfect forward eder.
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

ğŸ’¡ **Ã–ÄŸrenci Notu:** `std::forward<Args>(args)...` ifadesinde `...` operatÃ¶rÃ¼ hem `Args` (tÃ¼r paketi) hem de `args` (nesne paketi) Ã¼zerinde aynÄ± anda geniÅŸletme yapar. Yani derleyici bunu `std::forward<T1>(p1), std::forward<T2>(p2)...` ÅŸeklinde aÃ§ar.

---

## III. Parametre Paketindeki Ã–ÄŸelere EriÅŸim - Teknik 1: Compile-Time Recursion [00:50:00 - 01:08:00]

Variadic paketindeki elemanlara doÄŸrudan bir `for` dÃ¶ngÃ¼sÃ¼ ile eriÅŸilemez Ã§Ã¼nkÃ¼ paket bir "array" veya "container" deÄŸildir; bir derleme zamanÄ± listesidir. Ä°lk temel eriÅŸim tekniÄŸi **Ã–zyinelemeli (Recursive) Åablon AÃ§Ä±lÄ±mÄ±**dÄ±r.

### 1. MantÄ±k: BÃ¶l ve YÃ¶net
Paketi ikiye bÃ¶leriz: **Ä°lk eleman (Head)** ve **Geriye kalan paket (Tail)**.
1.  Fonksiyonu `(T first, Args... rest)` ÅŸeklinde tanÄ±mlarÄ±z.
2.  `first` elemanÄ± iÅŸleriz.
3.  Kalan paketi (`rest...`) kendisini tekrar Ã§aÄŸÄ±ran fonksiyona gÃ¶ndeririz.
4.  **Base Case (Durma KoÅŸulu):** Paket bittiÄŸinde veya tek eleman kaldÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lacak ayrÄ± bir overload (yÃ¼kleme) yazarÄ±z.

### 2. Ã–rnek: Print Fonksiyonu
```cpp
// Base Case: Pakette tek eleman kaldÄ±ÄŸÄ±nda bu fonksiyon cagrilir.
template <typename T>
void print(const T& arg) {
    std::cout << arg << std::endl;
}

// Recursive Case: Paketi parcalayarak ilerler.
template <typename T, typename... Args>
void print(const T& first, const Args&... rest) {
    std::cout << first << ", ";
    print(rest...); // Paketi bir eksilterek tekrar cagir
}
```

âš ï¸ **UyarÄ±:** Bu yÃ¶ntemde her bir eleman iÃ§in yeni bir fonksiyon instantiation (Ã¶rneklendirme) oluÅŸturulur. Bu, derleme zamanÄ±nÄ± (compile-time) bir miktar artÄ±rabilir ancak modern derleyiciler iÃ§in bu iÅŸlem Ã§ok hÄ±zlÄ±dÄ±r.

---

## IV. VirgÃ¼l OperatÃ¶rÃ¼ ve Initializer List Hilesi [01:08:00 - 01:25:00]

Recursive yapÄ± karmaÅŸÄ±k geliyorsa veya derleyiciye Ã§ok fazla fonksiyon yazdÄ±rmak istemiyorsak, C'den miras kalan **VirgÃ¼l OperatÃ¶rÃ¼ (Comma Operator)** ve C++11'in **Initializer List** yapÄ±sÄ±nÄ± birlikte kullanarak bir hile yapabiliriz.

### 1. VirgÃ¼l OperatÃ¶rÃ¼nÃ¼n GÃ¼cÃ¼
*   **Sequence Point:** VirgÃ¼l operatÃ¶rÃ¼ (`a, b`), sol operandÄ±n (`a`) yan etkilerinin tamamlandÄ±ÄŸÄ±nÄ± garanti eder ve ifadenin sonucu olarak saÄŸ operandÄ±n (`b`) deÄŸerini dÃ¶ndÃ¼rÃ¼r.
*   **Ã–zellik:** Sol taraf ne olursa olsun yÃ¼rÃ¼tÃ¼lÃ¼r, sonuÃ§ saÄŸ taraftÄ±r.

### 2. Initializer List Hilesi
Bu teknikte amacÄ±mÄ±z, paketi tek bir ifade iÃ§inde patlatmak ve her eleman iÃ§in bir iÅŸlem yapmaktÄ±r.

```cpp
template <typename... Args>
void print_all(Args... args) {
    // (std::cout << args << " ", 0)... Ã¶rÃ¼ntÃ¼sÃ¼ne dikkat!
    // Bu Ã¶rÃ¼ntÃ¼ ÅŸuna aÃ§Ä±lÄ±r: (cout << p1, 0), (cout << p2, 0), ...
    // Bu deÄŸerler bir initializer list iÃ§ine konur.
    (void)std::initializer_list<int>{ (std::cout << args << " ", 0)... };
}
```

*   **Neden `0`?** `initializer_list<int>` oluÅŸturmak iÃ§in saÄŸ operandÄ± `int` olan bir virgÃ¼l operatÃ¶rÃ¼ kullanÄ±yoruz.
*   **Neden `(void)`?** Derleyicinin "kullanÄ±lmayan deÄŸiÅŸken" uyarÄ±sÄ± vermesini engellemek iÃ§in.
*   **AvantajÄ±:** Recursion yoktur, tek bir instantiation iÃ§inde tÃ¼m paket iÅŸlenir.

---

## Master Kod Ã–rneÄŸi: Variadic Temelleri Ã–zetleyen YapÄ±

```cpp
#include <iostream>
#include <string>
#include <initializer_list>

// 1. Teknik: Compile-Time Recursion ile Toplama
template <typename T>
T sum_recursive(T val) {
    return val;
}

template <typename T, typename... Args>
auto sum_recursive(T first, Args... rest) {
    return first + sum_recursive(rest...);
}

// 2. Teknik: Comma Operator & Initializer List ile Yazdirma
template <typename... Args>
void print_with_comma_trick(Args... args) {
    std::cout << "Paket Icerigi: ";
    // VirgÃ¼l operatÃ¶rÃ¼ garantisiyle p1 yazdÄ±rÄ±lÄ±r, sonra 0 dÃ¶ner ve listeye eklenir.
    (void)std::initializer_list<int>{ (std::cout << args << " ", 0)... };
    std::cout << "\nToplam Eleman (sizeof...): " << sizeof...(args) << std::endl;
}

int main() {
    auto total = sum_recursive(10, 20, 30.5, 40);
    std::cout << "Toplam: " << total << std::endl;

    print_with_comma_trick(1, "Necati", 3.14, 'A');

    return 0;
}
```

---

## V. Compile-Time If: `if constexpr` [01:25:00 - 01:53:00]

C++17 standardÄ± ile dile eklenen `if constexpr`, ÅŸablon (template) kodlarÄ±nÄ±n yazÄ±mÄ±nÄ± devrimsel nitelikte kolaylaÅŸtÄ±ran bir araÃ§tÄ±r. Geleneksel `if` deyimi Ã§alÄ±ÅŸma zamanÄ±nda (runtime) kontrol yaparken, `if constexpr` derleme zamanÄ±nda (compile-time) kontrol yapar.

### 1. Temel MantÄ±k ve Ã‡alÄ±ÅŸma Prensibi
*   **Kod SeÃ§imi:** EÄŸer `if constexpr` iÃ§indeki koÅŸul derleme zamanÄ±nda `true` ise, derleyici sadece `if` bloÄŸu iÃ§indeki kodu derler; `else` bloÄŸunu (varsa) gÃ¶rmezden gelir. EÄŸer koÅŸul `false` ise tam tersi olur.
*   **KoÅŸul ÅartÄ±:** Parantez iÃ§indeki koÅŸul mutlaka bir **Constant Expression (Sabit Ä°fadesi)** olmalÄ±dÄ±r. Ã‡alÄ±ÅŸma zamanÄ±nda belli olan deÄŸiÅŸkenler burada kullanÄ±lamaz.
*   **Discarded Statement:** Derleyicinin seÃ§mediÄŸi blok "atÄ±lmÄ±ÅŸ ifade" (discarded statement) olarak kabul edilir. Bu blok ÅŸablonun bir parÃ§asÄ± olsa bile, iÃ§inde o tÃ¼r iÃ§in geÃ§ersiz bir kod (Ã¶rneÄŸin tÃ¼rÃ¼n sahip olmadÄ±ÄŸÄ± bir fonksiyona Ã§aÄŸrÄ±) bulunmasÄ± derleme hatasÄ±na yol aÃ§maz.

### 2. Geleneksel `if` ile FarklarÄ±
*   Geleneksel `if` kullanÄ±ldÄ±ÄŸÄ±nda, her iki blok da derlenmek zorundadÄ±r. Bu durum ÅŸablonlarda bÃ¼yÃ¼k sorun yaratÄ±r; Ã§Ã¼nkÃ¼ bir tÃ¼r iÃ§in geÃ§erli olan kod, diÄŸeri iÃ§in `syntax` hatasÄ± oluÅŸturabilir. `if constexpr` bu sorunu ortadan kaldÄ±rÄ±r.
*   **Geri DÃ¶nÃ¼ÅŸ TÃ¼rÃ¼ Ã‡Ä±karÄ±mÄ± (Auto Return Type Deduction):** Fonksiyonun geri dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ `auto` ise, farklÄ± dallarda farklÄ± tÃ¼rler dÃ¶ndÃ¼rmek normal `if` ile hatadÄ±r. Ancak `if constexpr` ile her dalÄ±n kendi tÃ¼rÃ¼ derlendiÄŸi iÃ§in bu durum yasaldÄ±r.

### 3. Ã–rnek: Fibonacci (Compile-Time Recursion ile)
Normalde Ã¶zyinelemeli (recursive) fonksiyonlar Ã§alÄ±ÅŸma zamanÄ± yÃ¼kÃ¼ getirirken, `if constexpr` ve `constexpr` fonksiyon birleÅŸimiyle bu iÅŸlem derleme zamanÄ±nda "fonksiyon yazdÄ±rÄ±larak" Ã§Ã¶zÃ¼lebilir.

```cpp
template <int N>
constexpr int fibonacci() {
    if constexpr (N >= 2) {
        return fibonacci<N - 1>() + fibonacci<N - 2>();
    } else {
        return N;
    }
}

// KullanÄ±mÄ±:
constexpr int val = fibonacci<7>(); // Derleme zamanÄ±nda 13 hesaplanÄ±r.
```

ğŸ’¡ **Ã–ÄŸrenci Notu:** Bu yapÄ±, derleyicinin her `N` deÄŸeri iÃ§in yeni bir fonksiyon instantiation (Ã¶rneklendirme) yapmasÄ±nÄ± saÄŸlar. Derleme zamanÄ±nda dallanma yapÄ±larak Ã¶zyineleme durdurulur.

---

## VI. Pratik Uygulamalar: `is_pointer` ve `to_string` [01:53:00 - 02:08:00]

Hoca bu bÃ¶lÃ¼mde `if constexpr` yapÄ±sÄ±nÄ±n gerÃ§ek hayat senaryolarÄ±nda (Ã¶rneÄŸin bir kÃ¼tÃ¼phane yazarken) nasÄ±l hayat kurtardÄ±ÄŸÄ±nÄ± iki Ã¶nemli Ã¶rnekle gÃ¶stermiÅŸtir.

### 1. `get_value` Senaryosu
AmacÄ±mÄ±z: EÄŸer gelen argÃ¼man bir pointer ise, pointer'Ä±n gÃ¶sterdiÄŸi deÄŸeri dÃ¶ndÃ¼rmek; deÄŸilse nesnenin kendisini dÃ¶ndÃ¼rmek.

```cpp
template <typename T>
auto get_value(T x) {
    if constexpr (std::is_pointer_v<T>) {
        return *x; // EÄŸer T pointer deÄŸilse bu satÄ±r normalde hata verirdi!
    } else {
        return x;
    }
}
```

âš ï¸ **UyarÄ±:** YukarÄ±daki kodda `if constexpr` yerine normal `if` kullansaydÄ±k, fonksiyona `int` gÃ¶nderdiÄŸimizde derleyici `*x` ifadesini (dereferencing) `int` Ã¼zerinde yapmaya Ã§alÄ±ÅŸacak ve "indirection requires pointer operand" hatasÄ± verecekti. `if constexpr` sayesinde derleyici pointer olmayan tÃ¼rler iÃ§in o bloÄŸu hiÃ§ derlemez.

### 2. `as_string` Ä°le TÃ¼r DÃ¶nÃ¼ÅŸÃ¼mÃ¼
FarklÄ± tÃ¼rleri (string, tam sayÄ±, gerÃ§ek sayÄ±) akÄ±llÄ±ca stringe dÃ¶nÃ¼ÅŸtÃ¼ren jenerik bir fonksiyon:

```cpp
template <typename T>
std::string as_string(T x) {
    if constexpr (std::is_same_v<T, std::string>) {
        return x; // Zaten string
    } else if constexpr (std::is_arithmetic_v<T>) {
        return std::to_string(x); // SayÄ±sal tÃ¼r
    } else {
        return std::string(x); // DiÄŸer (char* vb.)
    }
}
```

---

## VII. `static_assert` Bildirimi [02:08:00 - 02:25:00]

Derleme zamanÄ± doÄŸrulamasÄ± (assertion) yapmak iÃ§in kullanÄ±lÄ±r. ProgramÄ±n Ã§alÄ±ÅŸma zamanÄ±na (runtime) hiÃ§bir yÃ¼k getirmez; sadece derleme aÅŸamasÄ±nda kurallarÄ± denetler.

### 1. Syntax ve KullanÄ±m
*   **C++11/14:** `static_assert(kosul, "hata mesaji");`
*   **C++17:** Hata mesajÄ± opsiyonel hale geldi: `static_assert(kosul);`
*   KoÅŸul yanlÄ±ÅŸ (false) ise, derleyici derlemeyi durdurur ve belirtilen mesajÄ± hata olarak basar.

### 2. Åablonlarda KÄ±sÄ±tlama (Constraint) Olarak KullanÄ±mÄ±
C++20 "Concepts" mekanizmasÄ± Ã¶ncesinde, ÅŸablon parametrelerini kÄ±sÄ±tlamak iÃ§in en sÄ±k kullanÄ±lan yÃ¶ntemdir.

```cpp
template <typename T>
class MyArray {
    // Sadece tam sayÄ± tÃ¼rlerini kabul et
    static_assert(std::is_integral_v<T>, "Hata: Sadece tam sayi kullanilabilir!");
    
    // Boyut kÄ±sÄ±tlamasÄ± (Non-type parameter iÃ§in)
    static_assert(sizeof(T) <= 8, "Hata: Tur boyutu cok buyuk!");
};
```

ğŸ’¡ **Ã–ÄŸrenci Notu:** `static_assert` her yerde kullanÄ±labilir: Global alan, sÄ±nÄ±f gÃ¶vdesi veya fonksiyon iÃ§i. Åablonlarda genellikle ÅŸablonun en baÅŸÄ±nda, parametrelerin uygunluÄŸunu denetlemek iÃ§in kullanÄ±lÄ±r.

---

## VIII. Fold Expressions (Katlama Ä°fadeleri) [02:25:00 - 02:44:18]

C++17 ile gelen bu Ã¶zellik, variadic template paketlerini recursive (Ã¶zyinelemeli) fonksiyon yazmaya gerek kalmadan, tek bir satÄ±rda ve doÄŸrudan bir operatÃ¶rle "katlamayÄ±" (birleÅŸtirmeyi) saÄŸlar.

### 1. DÃ¶rt FarklÄ± Fold TÃ¼rÃ¼
Fold ifadelerinde `...` (elipsis), paket ismi ve operatÃ¶rÃ¼n konumu Ã§ok Ã¶nemlidir:

| TÃ¼r | Syntax | Ã–rnek AÃ§Ä±lÄ±m (p1, p2, p3 iÃ§in) |
| :--- | :--- | :--- |
| **Unary Right Fold** | `(args op ...)` | `(p1 op (p2 op p3))` |
| **Unary Left Fold** | `(... op args)` | `((p1 op p2) op p3)` |
| **Binary Right Fold** | `(args op ... op init)` | `(p1 op (p2 op (p3 op init)))` |
| **Binary Left Fold** | `(init op ... op args)` | `(((init op p1) op p2) op p3)` |

### 2. Neden Parantez?
Fold ifadelerinde en dÄ±ÅŸtaki parantezler **syntax'Ä±n zorunlu bir parÃ§asÄ±dÄ±r.** Parantez koymazsanÄ±z kod derlenmez.

### 3. Ã–rnek: Toplama ve BÃ¶lme Ä°ÅŸlemleri
Toplama gibi birleÅŸme Ã¶zelliÄŸi (associative) olan iÅŸlemlerde sol veya saÄŸ fold fark etmezken, bÃ¶lme veya Ã§Ä±karma gibi iÅŸlemlerde sonuÃ§ tamamen deÄŸiÅŸir.

```cpp
template<typename... Args>
auto sum_all(Args... args) {
    return (... + args); // Unary Left Fold
}

template<typename... Args>
auto div_left(Args... args) {
    return (... / args); // ((p1 / p2) / p3) -> Beklenen bÃ¶lme
}

template<typename... Args>
auto div_right(Args... args) {
    return (args / ...); // (p1 / (p2 / p3)) -> FarklÄ± sonuÃ§!
}
```

---

## Master Kod Ã–rneÄŸi: Modern Åablon AraÃ§larÄ±nÄ±n BirleÅŸimi

```cpp
#include <iostream>
#include <type_traits>
#include <string>

// Fold expression, static_assert ve if constexpr bir arada
template <typename... Args>
auto smart_sum(Args... args) {
    // 1. Kural: En az bir argÃ¼man gelmeli (sizeof...)
    static_assert(sizeof...(args) > 0, "Hata: Hic arguman gonderilmedi!");

    // 2. Kural: Sadece aritmetik tÃ¼rleri topla (if constexpr)
    // (Burada fold expression ile tÃ¼m tÃ¼rlerin aritmetik olup olmadÄ±ÄŸÄ±nÄ± denetliyoruz)
    if constexpr ((std::is_arithmetic_v<Args> && ...)) {
        // Unary Left Fold ile toplama
        return (... + args);
    } else {
        return std::string("Hata: Sayisal olmayan turler toplanamaz!");
    }
}

int main() {
    auto res1 = smart_sum(10, 20.5, 5); // 35.5 (double)
    std::cout << "Sonuc 1: " << res1 << std::endl;

    auto res2 = smart_sum(10, "deneme"); // Else bloÄŸuna girer
    std::cout << "Sonuc 2: " << res2 << std::endl;

    // smart_sum(); // static_assert sayesinde derleme hatasÄ± verir
    
    return 0;
}
```

---
