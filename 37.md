# C++ Standart Template Library (STL), Ä°teratÃ¶r Kategorileri ve Algoritmalar - Ders NotlarÄ± (Ders 37)

**Tarih:** 6 KasÄ±m 2024  
**Konu:** STL BileÅŸenleri, Ä°teratÃ¶r Kategorileri, Implementasyon DetaylarÄ±, Reverse Ä°teratÃ¶rler ve Lambdalara GiriÅŸ

---

## 1. STL'e GiriÅŸ ve Temel BileÅŸenlerin HatÄ±rlatÄ±lmasÄ± [00:00.000 - 01:18.800]

STL (Standard Template Library), isminden de anlaÅŸÄ±lacaÄŸÄ± Ã¼zere aÄŸÄ±rlÄ±klÄ± olarak template (ÅŸablon) kodlardan oluÅŸan bir kÃ¼tÃ¼phanedir. Bu kÃ¼tÃ¼phanenin Ã¼Ã§ temel "baÅŸrol oyuncusu" bulunmaktadÄ±r:

*   **Konteynerlar (Containers):** Verileri bir arada tutan ve arka planda belirli bir veri yapÄ±sÄ±nÄ± (data structure) implemente eden sÄ±nÄ±f ÅŸablonlarÄ±dÄ±r (vektÃ¶r, liste, map vb.).
*   **Ä°teratÃ¶rler (Iterators):** Konteynerlardaki Ã¶ÄŸelerin konumunu tutan, pointerlarÄ±n (iÅŸaretÃ§ilerin) daha yÃ¼ksek dÃ¼zeyde soyutlanmÄ±ÅŸ halidir. Pointer-like (pointer benzeri) bir arayÃ¼z sunarlar (`*`, `++`, `->` operatÃ¶rleri gibi).
*   **Algoritmalar (Algorithms):** KonteynerlarÄ±n belirli aralÄ±klarÄ± (range) Ã¼zerinde iÅŸlem yapan fonksiyon ÅŸablonlarÄ±dÄ±r.

ğŸ’¡ **Ã–ÄŸrenci Notu:** Algoritmalar ile konteynerlarÄ± birbirine baÄŸlayan "kÃ¶prÃ¼" iteratÃ¶rlerdir. Algoritmalar doÄŸrudan konteyner nesnesini deÄŸil, iteratÃ¶rler tarafÄ±ndan belirlenen bir aralÄ±ÄŸÄ± parametre olarak alÄ±rlar.

---

## 2. Bir AlgoritmanÄ±n Anatomisi: `std::count` Ã–rneÄŸi [01:18.800 - 05:00.000]

Hoca, STL algoritmalarÄ±nÄ±n mantÄ±ÄŸÄ±nÄ± anlatmak iÃ§in en sÄ±k kullanÄ±lanlardan biri olan `std::count` algoritmasÄ±nÄ± Ã¶rnek verdi.

*   **`std::count` Ne Yapar?:** Bir aralÄ±ktaki (range) belirli bir deÄŸere sahip Ã¶ÄŸelerin sayÄ±sÄ±nÄ± bulur. 
*   **Esneklik:** Sadece `int` tÃ¼rÃ¼yle deÄŸil, kullanÄ±cÄ± tanÄ±mlÄ± tÃ¼rlerle de (Ã¶rneÄŸin bir `Date` sÄ±nÄ±fÄ± listesindeki belirli bir tarihi saymak gibi) Ã§alÄ±ÅŸabilir.
*   **KullanÄ±m:** `algorithm` baÅŸlÄ±k dosyasÄ± dahil edilmelidir.

---

## 3. Ders Ä°Ã§i Test AraÃ§larÄ±: `Nutility.h` [05:00.000 - 15:00.000]

STL konusunda Ã§ok fazla kod yazÄ±lacaÄŸÄ± iÃ§in hoca, vakit kaybetmemek adÄ±na kendi oluÅŸturduÄŸu **Header-only** bir kÃ¼tÃ¼phane olan `Nutility`yi tanÄ±ttÄ±. Bu kÃ¼tÃ¼phanedeki bazÄ± fonksiyonlar:

*   **`random_fill`:** Bir konteynerÄ± belirli sayÄ±da rastgele Ã¶ÄŸeyle doldurur. ÃœÃ§Ã¼ncÃ¼ parametre olarak bir "generator" (oluÅŸturucu) alÄ±r.
*   **`cprint` (Container Print):** Konteynerdaki Ã¶ÄŸeleri bir separatÃ¶r (ayraÃ§) ile ekrana veya bir dosyaya yazdÄ±rÄ±r. Default olarak `std::cout` ve boÅŸluk karakterini kullanÄ±r.
*   **Generator Nesneleri:** `random_name` (rastgele string) veya `IRand` (belirli aralÄ±kta rastgele int) gibi yardÄ±mcÄ± sÄ±nÄ±flar.

```cpp
#include "Nutility.h"
#include <vector>
#include <string>

int main() {
    std::vector<std::string> svec;
    // 100 tane rastgele ismi vektÃ¶re doldurur
    random_fill(svec, 100, random_name); 
    
    // VektÃ¶rÃ¼ her Ã¶ÄŸe arasÄ±na yeni satÄ±r koyarak ekrana yazdÄ±rÄ±r
    cprint(svec, "\n"); 
}
```

---

## 4. `std::count` AlgoritmasÄ±nÄ±n Implementasyon Analizi [15:00.000 - 29:00.000]

Hoca, `count` algoritmasÄ±nÄ±n sadeleÅŸtirilmiÅŸ bir implementasyonunu gÃ¶stererek "Generic Programming" (Jenerik Programlama) mantÄ±ÄŸÄ±nÄ± aÃ§Ä±kladÄ±:

```cpp
template <class InIter, class T = typename std::iterator_traits<InIter>::value_type>
typename std::iterator_traits<InIter>::difference_type
my_count(InIter beg, InIter end, const T& val) {
    typename std::iterator_traits<InIter>::difference_type n = 0;
    while (beg != end) {
        if (*beg == val) {
            ++n;
        }
        ++beg;
    }
    return n;
}
```

### Teknik Terimler:
1.  **`value_type`:** Ä°teratÃ¶rÃ¼n iÅŸaret ettiÄŸi nesnenin tÃ¼rÃ¼dÃ¼r. Ã–rneÄŸin `std::vector<int>::iterator` iÃ§in `value_type` `int`'tir.
2.  **`difference_type`:** Ä°ki iteratÃ¶r arasÄ±ndaki farkÄ± (adet/mesafe) temsil edebilecek iÅŸaretli tam sayÄ± tÃ¼rÃ¼dÃ¼r (genelde `ptrdiff_t`).
3.  **`std::iterator_traits`:** Bu bir "metafunction" veya "trait" sÄ±nÄ±fÄ±dÄ±r. Ä°teratÃ¶rlerin Ã¶zelliklerini jenerik bir ÅŸekilde elde etmemizi saÄŸlar.

ğŸ’¡ **Ã–ÄŸrenci Notu (Neden `iterator_traits` kullanÄ±yoruz?):** EÄŸer doÄŸrudan `InIter::value_type` yazsaydÄ±k, C tarzÄ± dizilerde (pointerlarda) hata alÄ±rdÄ±k; Ã§Ã¼nkÃ¼ pointerlar sÄ±nÄ±f deÄŸildir ve iÃ§lerinde `nested type` barÄ±ndÄ±ramazlar. `iterator_traits`, pointerlar iÃ§in "partial specialization" yaparak bu sorunu Ã§Ã¶zer ve algoritmanÄ±n hem sÄ±nÄ±flarla hem de ham pointerlarla Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar.

---

## 5. Ä°teratÃ¶r Kategorileri ve Tag SÄ±nÄ±flarÄ± [29:00.000 - 45:00.000]

Her iteratÃ¶r aynÄ± yeteneklere sahip deÄŸildir. STL'de iteratÃ¶rler, sunduklarÄ± operasyonlara gÃ¶re kategorize edilirler. Bu seÃ§im konteyner tarafÄ±ndan belirlenir.

### Ä°teratÃ¶r Kategorileri (HiyerarÅŸik):
1.  **Input Iterator:** Sadece okuma amaÃ§lÄ±, tek yÃ¶nlÃ¼ (one-pass).
2.  **Output Iterator:** Sadece yazma amaÃ§lÄ±, tek yÃ¶nlÃ¼.
3.  **Forward Iterator:** Hem okuma hem yazma, tek yÃ¶nlÃ¼ ama Ã§oklu geÃ§iÅŸ (multi-pass) destekler.
4.  **Bidirectional Iterator:** Ã‡ift yÃ¶nlÃ¼ hareket (`++` ve `--`). `std::list`, `std::set`, `std::map` iteratÃ¶rleri bu kategoridedir.
5.  **Random Access Iterator:** Pointer gibi davranÄ±r. Toplama, Ã§Ä±karma, bÃ¼yÃ¼ktÃ¼r/kÃ¼Ã§Ã¼ktÃ¼r karÅŸÄ±laÅŸtÄ±rmasÄ± ve `[]` operatÃ¶rÃ¼nÃ¼ destekler. `std::vector`, `std::deque`, `std::string` ve C dizileri bu kategoridedir.
6.  **Contiguous Iterator (C++20):** Bellekte Ã¶ÄŸelerin ardÄ±ÅŸÄ±k olduÄŸunu garanti eder.

### Tag SÄ±nÄ±flarÄ± (Empty Classes):
Derleyiciye compile-time'da bilgi vermek iÃ§in kullanÄ±lan boÅŸ sÄ±nÄ±flardÄ±r (`struct input_iterator_tag {}` gibi). Bunlar sadece birer "kimlik" (identity) belirtir. Algoritmalar bu tag'lere bakarak en verimli kod yolunu seÃ§er.

---

## 6. AlgoritmalarÄ±n Ä°teratÃ¶r Beklentileri ve Derleme HatalarÄ± [45:00.000 - 01:03:00]

Algoritmalar, parametre isimlerinde genellikle bekledikleri **minimal** iteratÃ¶r kategorisini belirtirler (Ã–rn: `InIter`, `RanIt`).

âš ï¸ **UyarÄ±:** EÄŸer bir algoritma `Random Access Iterator` bekliyorsa ve siz ona `Bidirectional Iterator` (Ã¶rneÄŸin bir `std::list` iteratÃ¶rÃ¼) verirseniz, kodunuz derlenmeyecektir.

*   **Ã–rnek:** `std::sort` algoritmasÄ± `Random Access Iterator` bekler. Ã‡Ã¼nkÃ¼ iÃ§inde hÄ±zlÄ± sÄ±ralama yaparken iteratÃ¶rleri toplama/Ã§Ä±karma (mesafe Ã¶lÃ§me) iÅŸlemlerine sokar.
*   **Ã–rnek:** `std::count` sadece `Input Iterator` yeteneÄŸi bekler. Bu yÃ¼zden tÃ¼m konteynerlarla Ã§alÄ±ÅŸabilir.

```cpp
std::list<int> my_list = {5, 2, 8};
std::sort(my_list.begin(), my_list.end()); // SENTAKS HATASI! list, Random Access desteklemez.

std::vector<int> my_vec = {5, 2, 8};
std::sort(my_vec.begin(), my_vec.end());   // OK! vector, Random Access destekler.
```

---

## 7. Master Kod Ã–rneÄŸi (BÃ¶lÃ¼m Ã–zeti) [00:00 - 01:03]

AÅŸaÄŸÄ±daki kod, bu bÃ¶lÃ¼mde iÅŸlenen algoritma yapÄ±sÄ±, `iterator_traits` mantÄ±ÄŸÄ± ve kategori kÄ±sÄ±tlamalarÄ±nÄ± Ã¶zetler:

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include <iterator>

// Basit bir jenerik algoritma Ã¶rneÄŸi (Input Iterator yeterli)
template <typename Iter>
void print_elements(Iter beg, Iter end) {
    while (beg != end) {
        // Input Iterator: Okuma (*) ve ilerleme (++) yeterli
        std::cout << *beg << " ";
        ++beg;
    }
    std::cout << std::endl;
}

int main() {
    // 1. Random Access Iterator Ã–rneÄŸi (vector)
    std::vector<int> vec = {10, 20, 30, 40};
    auto it_vec = vec.begin();
    it_vec += 2; // Sadece Random Access'te mÃ¼mkÃ¼n! mesafe: 30
    std::cout << "Vector 2. indis: " << *it_vec << std::endl;

    // 2. Bidirectional Iterator Ã–rneÄŸi (list)
    std::list<int> mylist = {1, 2, 3};
    auto it_list = mylist.begin();
    ++it_list; // OK
    // it_list += 2; // HATA! list toplama desteklemez.
    --it_list; // OK (Bidirectional olduÄŸu iÃ§in geri gidebilir)

    // 3. Algoritma ve Kategori Uyumu
    // std::count her iki konteynerla da Ã§alÄ±ÅŸÄ±r Ã§Ã¼nkÃ¼ sadece Input Iterator bekler.
    long n = std::count(vec.begin(), vec.end(), 20);
    std::cout << "20 sayisi adedi: " << n << std::endl;

    // 4. iterator_traits kullanÄ±mÄ±
    using MyIter = std::vector<int>::iterator;
    std::iterator_traits<MyIter>::value_type val = 50; // int tÃ¼rÃ¼
    std::cout << "Traits ile elde edilen deger: " << val << std::endl;

    return 0;
}
```

---

## 8. Range (AralÄ±k) KavramÄ± ve GeÃ§erlilik KurallarÄ± [01:03:00 - 01:13:30]

STL algoritmalarÄ±nÄ±n Ã§oÄŸu bir "range" Ã¼zerinde Ã§alÄ±ÅŸÄ±r. Bir range, tipik olarak iki iteratÃ¶rle (`beg` ve `end`) ifade edilir.

*   **BoÅŸ Konteyner Durumu:** EÄŸer bir konteyner boÅŸsa, `begin()` ve `end()` fonksiyonlarÄ±nÄ±n dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iteratÃ¶rler birbirine eÅŸittir (`beg == end`). Bu durum bir hata deÄŸil, geÃ§erli bir "boÅŸ aralÄ±k" durumudur.
*   **Dereferencing (Ä°Ã§erik EriÅŸimi):** `end` iteratÃ¶rÃ¼ "past-the-end" (sonrasÄ±) konumuna iliÅŸkindir. DolayÄ±sÄ±yla `*end` iÅŸlemi yapmak kesinlikle **TanÄ±msÄ±z DavranÄ±ÅŸ (Undefined Behavior - UB)**'dÄ±r. STL bu durumda bir exception (istisna) fÄ±rlatmaz, sorumluluk tamamen programcÄ±dadÄ±r.
*   **Ä°leri YÃ¶nlÃ¼ GeÃ§erlilik:** Bir range'in geÃ§erli olmasÄ± iÃ§in `beg` iteratÃ¶rÃ¼nÃ¼n arttÄ±rÄ±larak (`++`) `end` iteratÃ¶rÃ¼ne ulaÅŸÄ±labilir olmasÄ± gerekir. EÄŸer `beg` konumu `end` konumundan daha sonraysa, algoritma sonsuz dÃ¶ngÃ¼ye girer veya bellek hatasÄ± verir.

ğŸ’¡ **Ã–ÄŸrenci Notu:** `end()` iteratÃ¶rÃ¼, C'deki dizilerin son elemanÄ±ndan bir sonraki adresi tutma mantÄ±ÄŸÄ±yla (sentinel/bekÃ§i deÄŸeri) aynÄ±dÄ±r. Okunamaz ama karÅŸÄ±laÅŸtÄ±rma iÃ§in hayati Ã¶nem taÅŸÄ±r.

---

## 9. Ä°teratÃ¶rlerde Const Correctness: `const_iterator` [01:13:30 - 01:26:00]

C++'da const correctness (sabit doÄŸruluÄŸu) Ã§ok Ã¶nemlidir. Ä°teratÃ¶rlerde bu konu ikiye ayrÄ±lÄ±r ve genellikle karÄ±ÅŸtÄ±rÄ±lÄ±r:

1.  **`const iterator`:** Ä°teratÃ¶rÃ¼n kendisinin sabit olmasÄ±dÄ±r (`T* const` gibi). Ä°teratÃ¶rÃ¼ ilerletemezsiniz (`++it` hata verir), ancak iÅŸaret ettiÄŸi deÄŸeri deÄŸiÅŸtirebilirsiniz.
2.  **`const_iterator`:** Ä°teratÃ¶rÃ¼n iÅŸaret ettiÄŸi nesnenin sabit olmasÄ±dÄ±r (`const T*` gibi). Ä°teratÃ¶rÃ¼ ilerletebilirsiniz ama iÅŸaret ettiÄŸi deÄŸeri deÄŸiÅŸtiremezsiniz (`*it = val` hata verir).

Hoca, sadece okuma amaÃ§lÄ± (read-only) dolaÅŸÄ±mlarda `const_iterator` kullanÄ±lmasÄ±nÄ±n en iyi pratik (best practice) olduÄŸunu vurguladÄ±. Bu hem niyetinizi belli eder hem de yanlÄ±ÅŸlÄ±kla yapÄ±lacak "set" iÅŸlemlerini derleme zamanÄ±nda engeller.

```cpp
std::vector<int> ivek = {1, 2, 3};
std::vector<int>::const_iterator cit = ivek.begin();

++cit;      // OK: Ä°teratÃ¶r ilerleyebilir.
*cit = 5;   // SENTAKS HATASI: const_iterator Ã¼zerinden deÄŸer deÄŸiÅŸtirilemez!
```

---

## 10. Modern C++ ve `cbegin()` / `cend()` FonksiyonlarÄ± [01:26:00 - 01:31:00]

C++11 ile birlikte `const_iterator` elde etmeyi kolaylaÅŸtÄ±ran `cbegin()` ve `cend()` fonksiyonlarÄ± dile eklendi.

*   **Neden Gerekli?:** `auto` anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile `begin()` kullandÄ±ÄŸÄ±nÄ±zda, eÄŸer konteyner const deÄŸilse size normal `iterator` dÃ¶ner. DoÄŸrudan `const_iterator` tÃ¼rÃ¼nÃ¼ `auto` ile yakalamak iÃ§in `cbegin()` kullanÄ±lÄ±r.
*   **Global KarÅŸÄ±lÄ±klar:** C++14 ile birlikte dizilerle de uyumlu Ã§alÄ±ÅŸmasÄ± iÃ§in `std::cbegin(container)` ve `std::cend(container)` global fonksiyonlarÄ± da eklenmiÅŸtir.

---

## 11. Reverse Ä°teratÃ¶rler (Ters Ä°teratÃ¶rler) [01:31:00 - 02:05:00]

Reverse iteratÃ¶rler, bir aralÄ±ÄŸÄ± sondan baÅŸa doÄŸru dolaÅŸmamÄ±zÄ± saÄŸlayan iteratÃ¶r adaptÃ¶rleridir.

*   **`rbegin()`:** KonteynerÄ±n son Ã¶ÄŸesine (logical end) iÅŸaret eder.
*   **`rend()`:** KonteynerÄ±n ilk Ã¶ÄŸesinden bir Ã¶nceki konuma (logical beginning) iÅŸaret eder.
*   **DavranÄ±ÅŸ SapmasÄ±:** Reverse iteratÃ¶rde `++it` operatÃ¶rÃ¼, aslÄ±nda arka planda sarmaladÄ±ÄŸÄ± gerÃ§ek iteratÃ¶rÃ¼n `--it` (geri gitme) iÅŸlemini Ã§aÄŸÄ±rmasÄ±dÄ±r.

### "Off-by-One" (Bir KayÄ±k) Implementasyonu:
Reverse iteratÃ¶rler aslÄ±nda teknik bir zorunluluktan dolayÄ± (C dizilerinde ilk elemandan Ã¶ncesinin geÃ§ersiz adres olmasÄ±) "bir sonraki" adresi fiziksel olarak tutarlar:
*   `rbegin()`, fiziksel olarak `end()` konumunu sarmalar.
*   `*rbegin()` dendiÄŸinde, sarmaladÄ±ÄŸÄ± iteratÃ¶rÃ¼n bir eksiÄŸini (`--`) d-referans eder.
*   **`base()` Fonksiyonu:** Reverse iteratÃ¶rÃ¼n sarmaladÄ±ÄŸÄ± normal iteratÃ¶rÃ¼ (bir sonraki konumu) elde etmek iÃ§in kullanÄ±lÄ±r.

âš ï¸ **Kritik Ã–rnek (MÃ¼lakat Sorusu):** Bir reverse iteratÃ¶r (`rit`) ile bulduÄŸunuz Ã¶ÄŸeyi `erase()` ile silmek isterseniz, doÄŸrudan `rit.base()` kullanamazsÄ±nÄ±z. Ã‡Ã¼nkÃ¼ `base()`, silmek istediÄŸiniz Ã¶ÄŸenin **bir saÄŸÄ±ndaki** Ã¶ÄŸeyi iÅŸaret eder. DoÄŸru kullanÄ±m `vec.erase(std::next(rit).base())` veya `vec.erase(--rit.base())` ÅŸeklindedir.

---

## 12. Callables, Predicates ve Functors [02:05:00 - 02:26:00]

BazÄ± algoritmalar (Ã–rn: `std::find_if`, `std::count_if`) Ã¼Ã§Ã¼ncÃ¼ bir parametre olarak "koÅŸul" bekler. Buna **Callable** denir.

*   **Predicate (YÃ¼klem):** Geri dÃ¶nÃ¼ÅŸ deÄŸeri `bool` olan callable'lardÄ±r.
    *   **Unary Predicate:** Tek parametre alan.
    *   **Binary Predicate:** Ä°ki parametre alan.
*   **Functor (Function Object):** `operator()` (fonksiyon Ã§aÄŸrÄ± operatÃ¶rÃ¼) fonksiyonunu overload etmiÅŸ sÄ±nÄ±f nesneleridir.
*   **Functor AvantajÄ±:** Normal fonksiyonlarÄ±n aksine, functorlar "durum" (state) tutabilirler. Hoca, "X sayÄ±sÄ±na tam bÃ¶lÃ¼nen ilk sayÄ±yÄ± bul" Ã¶rneÄŸinde, `X` deÄŸerini sÄ±nÄ±fÄ±n veri elemanÄ±nda saklayarak algoritmayÄ± nasÄ±l dinamik hale getirdiÄŸimizi gÃ¶sterdi.

---

## 13. Lambda Ä°fadelerine (Lambda Expressions) GiriÅŸ [02:26:00 - 02:41:00]

Lambda ifadeleri, isimsiz fonksiyon nesnelerini (functor) derleyicinin bizim yerimize yazmasÄ±nÄ± saÄŸlayan bir C++11 Ã¶zelliÄŸidir.

*   **DÃ¶nÃ¼ÅŸÃ¼m SÃ¼reci:** Lambda Ä°fadesi $\rightarrow$ **Closure Type** (SÄ±nÄ±f Kodu) $\rightarrow$ **Closure Object** (Nesne).
*   **Value Kategorisi:** Bir lambda ifadesi her zaman bir **PR Value**'dur (geÃ§ici nesne ifadesidir).

### Lambda Anatomisi:
`[capture](parameters) specifiers { body }`

1.  **Capture Clause `[]` (Ä°ntroducer):** DÄ±ÅŸarÄ±daki deÄŸiÅŸkenleri sÄ±nÄ±fÄ±n veri elemanÄ± yapma (zapt etme).
2.  **Parameters `()`:** `operator()` fonksiyonunun parametreleri.
3.  **Specifiers:** `mutable`, `constexpr` vb. (Opsiyonel).
4.  **Body `{}`:** Fonksiyonun gÃ¶vdesi.

---

## 14. Master Kod Ã–rneÄŸi (BÃ¶lÃ¼m Ã–zeti) [01:03 - 02:41]

AÅŸaÄŸÄ±daki kod, ters iteratÃ¶rler, functorlar ve lambdalarÄ±n STL iÃ§indeki kullanÄ±m farklarÄ±nÄ± Ã¶zetler:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 1. Durum tutabilen bir Functor (SÄ±nÄ±f)
struct IsDivisible {
    int divisor;
    IsDivisible(int d) : divisor(d) {}

    bool operator()(int val) const {
        return val % divisor == 0;
    }
};

int main() {
    std::vector<int> vec = {1, 3, 4, 7, 10, 15};

    // --- REVERSE ITERATOR Ã–RNEÄÄ° ---
    std::cout << "Sondan basa: ";
    for (auto rit = vec.rbegin(); rit != vec.rend(); ++rit) {
        std::cout << *rit << " ";
    }
    std::cout << "\n";

    // --- FUNCTOR KULLANIMI ---
    int n = 5;
    auto it5 = std::find_if(vec.begin(), vec.end(), IsDivisible(n));
    if (it5 != vec.end())
        std::cout << n << " sayisina bolunen ilk: " << *it5 << "\n";

    // --- LAMBDA KULLANIMI ---
    // Derleyici arka planda IsDivisible gibi bir sÄ±nÄ±f yazar.
    int divisor_val = 2;
    auto it_even = std::find_if(vec.begin(), vec.end(), [divisor_val](int x) {
        return x % divisor_val == 0;
    });

    if (it_even != vec.end())
        std::cout << "Cift olan ilk sayi: " << *it_even << "\n";

    // --- CONST_ITERATOR ve cbegin ---
    auto cit = vec.cbegin();
    // *cit = 100; // HATA: DeÄŸiÅŸtirilemez.

    return 0;
}
```

---

