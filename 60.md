# C++ Concurrency Dersi Teknik Ä°nceleme NotlarÄ± - 1. BÃ¶lÃ¼m

**Ders:** 60  
**Tarih:** 3 Åubat 2025  
**Konu:** Concurrency (EÅŸ ZamanlÄ±lÄ±k / EÅŸ GÃ¼dÃ¼m), `std::thread` GiriÅŸ  
**EÄŸitmen:** Necati Ergin

---

## 1. Concurrency (EÅŸ ZamanlÄ±lÄ±k) KavramÄ± ve Temeller [00:00 - 10:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Modern yazÄ±lÄ±mlarÄ±n belirli bir zaman dilimi iÃ§erisinde birden fazla iÅŸi ayrÄ± ayrÄ± yapabilmesi (at-the-same-time hissi) bir zorunluluktur. C++11 Ã¶ncesinde bu Ã¶zellik dilin standart bir parÃ§asÄ± deÄŸildi; programcÄ±lar POSIX Threads (pthreads) veya Windows API gibi iÅŸletim sistemine (OS) baÄŸÄ±mlÄ± kÃ¼tÃ¼phaneler kullanmak zorundaydÄ±. Bu durum kodun taÅŸÄ±nabilirliÄŸini (portability) bozuyordu.

### âš™ï¸ Teknik Detay ve Terminoloji
*   **Concurrency:** Bir programÄ±n belirli bir zaman diliminde birden fazla iÅŸi "yÃ¼rÃ¼tmesi".
*   **Parallelism:** Ä°ÅŸlemlerin fiziksel olarak "aynÄ± anda" farklÄ± Ã§ekirdeklerde (cores) yapÄ±lmasÄ±.
*   **Thread (Ä°plik/Ä°ÅŸ YÃ¼kÃ¼):** ProgramÄ±n eÅŸ zamanlÄ± olarak yÃ¼rÃ¼tÃ¼len en kÃ¼Ã§Ã¼k birimi.
*   **Task Switching / Context Switching:** Tek Ã§ekirdekli sistemlerde iÅŸlemcinin bir koddan diÄŸerine Ã§ok hÄ±zlÄ± geÃ§erek concurrency illÃ¼zyonu yaratmasÄ±.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art) - Espresso Makinesi Analojisi
HocanÄ±n 05:00'da verdiÄŸi iki kuyruk Ã¶rneÄŸi:

**Concurrency (Zaman PaylaÅŸÄ±mlÄ±):**
```text
Kuyruk A: [P1][P2][P3] \
                         > --- [Tek Espresso Makinesi]
Kuyruk B: [P4][P5][P6] /
(Makine bir A'dan bir B'den alÄ±r, ancak aynÄ± anda sadece bir kahve yapar.)
```

**Parallelism (GerÃ§ek EÅŸ ZamanlÄ±lÄ±k):**
```text
Kuyruk A: [P1][P2][P3] ----> [Espresso Makinesi 1]
Kuyruk B: [P4][P5][P6] ----> [Espresso Makinesi 2]
(AynÄ± anda iki farklÄ± kahve akÄ±ÅŸÄ± mevcuttur.)
```

### ğŸ” Arka Plan (Under the Hood)
C++ standart kÃ¼tÃ¼phanesi bu konuda bir **Wrapper** (SarmalayÄ±cÄ±) gÃ¶revi gÃ¶rÃ¼r. Siz `std::thread` yazdÄ±ÄŸÄ±nÄ±zda, kÃ¼tÃ¼phane arka planda iÅŸletim sisteminin ilgili sistem fonksiyonlarÄ±nÄ± (System Calls) Ã§aÄŸÄ±rÄ±r. 
*   **C++ Memory Model:** C++11 ile birlikte, multi-thread programlamanÄ±n "formal" (biÃ§imsel) garantilerini verebilmek iÃ§in dilde bir bellek modeli oluÅŸturulmuÅŸtur. Bu model olmadan thread'lerin bellek Ã¼zerindeki etkisi tanÄ±mlanamazdÄ±.

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
| Ã–zellik | C++98/03 | Modern C++ (C++11/14/17/20) |
| :--- | :--- | :--- |
| **Thread DesteÄŸi** | Yok (OS BaÄŸÄ±mlÄ± API) | Standart KitaplÄ±k (`std::thread`) |
| **Memory Model** | TanÄ±msÄ±z | Formal Model Mevcut |
| **TaÅŸÄ±nabilirlik** | DÃ¼ÅŸÃ¼k | YÃ¼ksek |
| **Priority (Ã–ncelik)** | API ile mÃ¼mkÃ¼n | Standartta doÄŸrudan yok (Native handle gerekir) |

---

## 2. Standart KÃ¼tÃ¼phane ve Native Handle [10:00 - 15:40]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu?
Standart kÃ¼tÃ¼phane her ÅŸeyi sarmalasa da, iÅŸletim sisteminin sunduÄŸu tÃ¼m ince ayarlarÄ± (Ã–rn: Thread Ã¶nceliÄŸini deÄŸiÅŸtirmek, thread'i belirli bir Ã§ekirdeÄŸe kilitlemek - Affinity) kapsayamaz.

### âš™ï¸ Teknik Detay
C++ tasarÄ±mcÄ±larÄ±, standartta olmayan OS Ã¶zelliklerine eriÅŸebilmemiz iÃ§in `native_handle()` Ã¼ye fonksiyonunu eklemiÅŸlerdir.

```cpp
#include <thread>
#include <iostream>

void workload() { /* ... */ }

int main() {
    std::thread t(workload);
    
    // std::thread standartta Ã¶ncelik ayarÄ± sunmaz.
    // Ancak iÅŸletim sisteminin handle'Ä±nÄ± alabiliriz:
    std::thread::native_handle_type h = t.native_handle(); // <-- Kritik: OS spesifik handle.
    
    // Windows'ta: SetThreadPriority(h, ...)
    // Unix/Linux'ta: pthread_setschedparam(h, ...)
    
    t.join();
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Standart C++ kÃ¼tÃ¼phanesi ile bir thread'in Ã¶nceliÄŸini deÄŸiÅŸtirebilir miyiz?
**Cevap:** HayÄ±r, standart C++ (C++26 Ã¶ncesi/hariÃ§) bu Ã¶zelliÄŸi doÄŸrudan sunmaz. Ancak `native_handle()` fonksiyonu ile iÅŸletim sisteminin API'sine geÃ§iÅŸ yapÄ±larak bu iÅŸlem gerÃ§ekleÅŸtirilebilir.

---

## 3. Thread KullanÄ±m SenaryolarÄ± ve Maliyet [15:40 - 27:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu?
Hangi durumlarda thread kullanmalÄ±yÄ±z? Her problem thread ile Ã§Ã¶zÃ¼lÃ¼r mÃ¼? Necati Hoca iki ana baÅŸlÄ±ÄŸa odaklandÄ±:

#### 1. CPU Bound (Ä°ÅŸlemci YoÄŸun) Ä°ÅŸlemler:
AÄŸÄ±r matematiksel hesaplamalar, ÅŸifreleme, makine Ã¶ÄŸrenimi.
*   **Ã‡Ã¶zÃ¼m:** Veriyi veya iÅŸlemi parÃ§alara ayÄ±rÄ±p Ã§ekirdeklere daÄŸÄ±tmak.
*   **Paralel Algoritmalar (C++17):** Standart algoritmalarÄ±n paralel overload'larÄ±.

```cpp
#include <algorithm>
#include <execution> // <-- C++17 ile geldi

void parallel_demo() {
    std::vector<int> vec(1000000);
    // ... doldurma ...
    
    // Arka planda thread'leri derleyici/kÃ¼tÃ¼phane yÃ¶netir
    std::sort(std::execution::par, vec.begin(), vec.end()); // <-- Hoca: HiÃ§ uÄŸraÅŸmadan paralel Ã§alÄ±ÅŸtÄ±rma!
}
```

#### 2. I/O Bound (GiriÅŸ/Ã‡Ä±kÄ±ÅŸ YoÄŸun) Ä°ÅŸlemler:
Dosya okuma, aÄŸdan veri bekleme (Web scraping), veritabanÄ± sorgularÄ±.
*   **Ã‡Ã¶zÃ¼m:** Bir thread veri beklerken (Blocked/Bloke durumdayken), diÄŸer thread'lerin Ã§alÄ±ÅŸmaya devam etmesi.

#### 3. GUI ve Real-Time Sistemler:
KullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼n donmamasÄ± (Responsiveness) iÃ§in uzun sÃ¼ren iÅŸlerin arka planda (background) yapÄ±lmasÄ±.

### ğŸ” Arka Plan (Complexity & Hazards)
Thread kullanmak bedava deÄŸildir; iki ana maliyeti vardÄ±r:
1.  **Creation Cost (OluÅŸturma Maliyeti):** Ä°ÅŸletim sistemi seviyesinde thread oluÅŸturmak pahalÄ±dÄ±r.
2.  **Complexity (KarmaÅŸÄ±klÄ±k):** Single-thread koda gÃ¶re 3-4 kat daha zordur.
    *   **Race Condition (YarÄ±ÅŸ Durumu):** MantÄ±ksal hata.
    *   **Data Race (Veri YarÄ±ÅŸÄ±):** TanÄ±msÄ±z DavranÄ±ÅŸ (UB - Undefined Behavior).
    *   **Deadlock (Kilitlenme):** Thread'lerin birbirini sonsuza kadar beklemesi.

---

## 4. `std::thread` SÄ±nÄ±fÄ±na GiriÅŸ ve Callable Nesneler [27:00 - 45:00]

### âš™ï¸ Teknik Detay ve Sentaks
`std::thread` bir sÄ±nÄ±f (class) nesnesidir ancak kendisi bir template deÄŸildir; **Constructor'Ä± (yapÄ±cÄ± fonksiyonu) bir variadic template'dir.**

```cpp
#include <thread>

void func() { std::cout << "Merhaba Concurrency\n"; }

int main() {
    // 1. Default Construct: BoÅŸ, herhangi bir akÄ±ÅŸÄ± temsil etmeyen thread nesnesi.
    std::thread t1; 
    
    // 2. Parametreli Construct: Bir callable (Ã§aÄŸrÄ±labilir nesne) alÄ±r.
    std::thread t2(func); // <-- Hoca: Bu satÄ±rda akÄ±ÅŸ baÅŸlar!
    
    // join() veya detach() Ã§aÄŸrÄ±lmak zorundadÄ±r!
    t2.join(); 
}
```

### ğŸ” Arka Plan: `joinable` Durumu
Bir `std::thread` nesnesinin gerÃ§ekten bir iÅŸletim sistemi thread'ini temsil edip etmediÄŸini `joinable()` fonksiyonu ile sorgularÄ±z.

*   **Default construct** edilen thread `joinable` deÄŸildir (0 dÃ¶ner).
*   **Ä°ÅŸ yÃ¼kÃ¼ (workload/task) verilen** thread, iÅŸi bitene (veya join/detach edilene) kadar `joinable` durumdadÄ±r.

```cpp
std::thread t;
std::cout << t.joinable(); // 0 (False) yazar. // <-- Hoca: HenÃ¼z bir iÅŸ yÃ¼kÃ¼ atanmadÄ±.
```

### ğŸš© Kritik Nokta: `std::terminate` Tehlikesi [43:00 - 55:00]
EÄŸer bir thread nesnesi `joinable` durumdayken scope dÄ±ÅŸÄ±na Ã§Ä±karsa (Destructor'Ä± Ã§aÄŸrÄ±lÄ±rsa), Ã§alÄ±ÅŸma zamanÄ±nda `std::terminate` fonksiyonu Ã§aÄŸrÄ±lÄ±r ve program Ã§Ã¶ker (abort edilir).

**HatalÄ± Senaryo (MÃ¼lakatlarda Ã§ok sorulur):**
```cpp
void dangerous() {
    std::thread t(some_function);
    // t.join() veya t.detach() unutuldu!
} // <-- Burada t nesnesinin Ã¶mrÃ¼ biter (Destructor Ã§aÄŸrÄ±lÄ±r).
  // t.joinable() == true olduÄŸu iÃ§in PROGRAM Ã‡Ã–KER! (UB/Terminate)
```

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  Thread nesnesini oluÅŸturmakla iÅŸletim sistemi thread'ini birbirine karÄ±ÅŸtÄ±rmayÄ±n; nesne hayatta olsa da iÃ§ine iÅŸ yÃ¼klenmemiÅŸ olabilir.
2.  `join()` fonksiyonu Ã§aÄŸrÄ±ldÄ±ÄŸÄ± noktada, Ã§aÄŸÄ±ran thread (genelde main), hedef thread iÅŸini bitirene kadar **bloklanÄ±r** (bekler).
3.  `std::thread` kopyalanamaz (**Move-only type**), sadece taÅŸÄ±nabilir.

---

# C++ Concurrency Dersi Teknik Ä°nceleme NotlarÄ± - 2. BÃ¶lÃ¼m

**Ders:** 60  
**Timestamp AralÄ±ÄŸÄ±:** [00:55:00 - 01:14:00]  
**Konu:** `std::jthread` (C++20), `detach()`, ArgÃ¼man GeÃ§iÅŸi ve Non-Deterministik AkÄ±ÅŸ  
**EÄŸitmen:** Necati Ergin

---

## 5. RAII ve KurtarÄ±cÄ±: `std::jthread` [55:00 - 56:30]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir Ã¶nceki bÃ¶lÃ¼mde gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z Ã¼zere, `std::thread` nesnesi `joinable` durumdayken (hÃ¢lÃ¢ bir iÅŸ yÃ¼kÃ¼ne baÄŸlÄ±yken) destructor'Ä± Ã§aÄŸrÄ±lÄ±rsa program `std::terminate` ile sonlanÄ±yordu. Bu, C++'Ä±n temel felsefesi olan **RAII (Resource Acquisition Is Initialization)** prensibine bir nevi ihanetti. ProgramcÄ±nÄ±n her seferinde manuel olarak `join()` veya `detach()` demesi unutulabilir bir hatadÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
C++20 ile gelen `std::jthread` (Joining Thread), bu sorunu otomatikleÅŸtirir.

```cpp
#include <thread>

void work() { /* ... */ }

int main() {
    // C++20 Ã¶ncesi (std::thread):
    {
        std::thread t(work);
        // t.join() demezsek scope sonunda PROGRAM Ã‡Ã–KER.
    }

    // C++20 sonrasÄ± (std::jthread):
    {
        std::jthread jt(work); 
    } // <-- Hoca: jthread'in destructor'Ä± joinable mÄ± diye bakar, 
      // Ã¶yleyse otomatik join() Ã§aÄŸÄ±rÄ±r. Program Ã§Ã¶kmez!
}
```

### ğŸ“Š Standart KarÅŸÄ±laÅŸtÄ±rmasÄ±
| Ã–zellik | `std::thread` (C++11) | `std::jthread` (C++20) |
| :--- | :--- | :--- |
| **Destructor DavranÄ±ÅŸÄ±** | `std::terminate` Ã§aÄŸÄ±rÄ±r | Otomatik `join()` Ã§aÄŸÄ±rÄ±r |
| **Durdurma DesteÄŸi** | Yok | `std::stop_token` ile iÅŸbirliÄŸi yapar |

---

## 6. Bir Thread'i Serbest BÄ±rakmak: `detach()` [56:30 - 58:10]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bazen bir iÅŸin sonucunu beklemek istemeyiz. Ä°ÅŸ arka planda (background) kendi kendine Ã§alÄ±ÅŸsÄ±n ve bitsin isteriz. Bu durumda thread'i ana akÄ±ÅŸtan koparmak (detach) gerekir.

### âš™ï¸ Teknik Detay
*   `detach()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, `std::thread` nesnesi ile OS thread'i arasÄ±ndaki baÄŸ koparÄ±lÄ±r.
*   Nesne artÄ±k `joinable` deÄŸildir.
*   Hoca'nÄ±n tabiriyle: **"ArtÄ±k o benim Ã§ocuÄŸum deÄŸil, benden ayrÄ±ldÄ±, kendi kaderiyle baÅŸ baÅŸa."**

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** `main()` fonksiyonu bittiÄŸinde `detach()` edilmiÅŸ thread'lere ne olur?
**Cevap:** Ana thread (main) sonlandÄ±ÄŸÄ±nda, iÅŸletim sistemi tÃ¼m sÃ¼reci (process) temizler. Detach edilmiÅŸ thread'ler iÅŸini bitiremeden aniden sonlandÄ±rÄ±lÄ±r. Bu durum, dosyalarÄ±n yarÄ±m yazÄ±lmasÄ±na veya kaynak sÄ±zÄ±ntÄ±larÄ±na yol aÃ§abilir. Bu yÃ¼zden `detach()` kullanÄ±rken Ã¶mÃ¼r (lifetime) yÃ¶netimi hayati Ã¶nem taÅŸÄ±r.

---

## 7. Thread Fonksiyonuna ArgÃ¼man GeÃ§ilmesi ve "Dangling Reference" Riski [58:10 - 01:04:00]

### âš™ï¸ Teknik Detay ve Sentaks
`std::thread` constructor'Ä± **Variadic Template** kullanÄ±r ve argÃ¼manlarÄ±nÄ± **Perfect Forwarding** (MÃ¼kemmel AktarÄ±m) mekanizmasÄ±yla taÅŸÄ±r.

```cpp
void print_sum(int a, int b) { std::cout << a + b; }

int main() {
    int x = 10, y = 20;
    std::thread t(print_sum, x, y); // <-- Hoca: x ve y kopyalanarak fonksiyona geÃ§er.
    t.join();
}
```

### ğŸš© Kritik Nokta: Referans SemantiÄŸi ve `std::ref`
Thread'e bir argÃ¼manÄ± referans ile geÃ§mek istiyorsak, derleyici doÄŸrudan `&` kullanÄ±mÄ±na izin vermez. Ã‡Ã¼nkÃ¼ thread nesnesi argÃ¼manlarÄ± kendi iÃ§inde saklarken (internal storage) varsayÄ±lan olarak kopyalar.

```cpp
void update(int& n) { n = 100; }

int main() {
    int val = 5;
    // std::thread t(update, val); // <-- HATA: Derleyici referans geÃ§iÅŸine kÄ±zar!
    
    std::thread t(update, std::ref(val)); // <-- Ã‡Ã–ZÃœM: std::ref (reference_wrapper)
    t.join();
}
```

### ğŸ” Arka Plan (Dangling Reference/UB)
MÃ¼lakatlarda sÄ±kÃ§a sorulan o meÅŸhur tehlike:
```cpp
void func(int& r) {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    r = 99; // <-- HATA: r'nin baÄŸlÄ± olduÄŸu 'x' artÄ±k Ã¶lÃ¼!
}

void fire_and_forget() {
    int x = 10;
    std::thread t(func, std::ref(x));
    t.detach(); 
} // <-- x burada yok edilir (stack frame temizlenir). 
  // Arka plandaki thread Ã¶lÃ¼ bir adrese yazmaya Ã§alÄ±ÅŸÄ±r: UB (Undefined Behavior).
```

---

## 8. Threadlerde Exception Handling (Ä°stisna YÃ¶netimi) [01:02:00 - 01:05:00]

### ğŸš© Kritik Nokta
Hoca bu konunun iÅŸi zorlaÅŸtÄ±ran en bÃ¼yÃ¼k etkenlerden biri olduÄŸunu vurguladÄ±.
1.  Bir thread iÃ§erisinde `throw` edilen bir exception, eÄŸer o thread iÃ§inde `catch` edilmezse doÄŸrudan `std::terminate` Ã§aÄŸrÄ±lÄ±r.
2.  Exception **asla** otomatik olarak main thread'e (veya thread'i baÅŸlatan koda) propagate (sirayet) etmez.

**Ã‡Ã¶zÃ¼m:** Thread iÃ§indeki kod `try-catch` bloÄŸuna alÄ±nmalÄ± veya ileride gÃ¶rÃ¼lecek olan `std::future` gibi yÃ¼ksek seviyeli araÃ§lar kullanÄ±lmalÄ±dÄ±r.

---

## 9. Non-Deterministik AkÄ±ÅŸ ve `std::osyncstream` [01:05:00 - 01:14:00]

### âš™ï¸ Teknik Detay: AkÄ±ÅŸÄ±n BelirsizliÄŸi
Hoca, thread'lerin hangi sÄ±rayla Ã§alÄ±ÅŸacaÄŸÄ±nÄ±n asla garanti edilemeyeceÄŸini (Non-deterministic) bir kodla ispatladÄ±.

```cpp
#include <iostream>
#include <thread>
#include <vector>

void foo(char c) {
    for (int i = 0; i < 100; ++i) {
        std::cout << c; // <-- Hoca: std::cout thread-safe'dir ama senkronize deÄŸildir!
    }
}

int main() {
    std::thread t1(foo, '.');
    std::thread t2(foo, '*');
    std::thread t3(foo, '+');

    t1.join(); t2.join(); t3.join();
}
```

### ğŸ” Derleyici GÃ¶zÃ¼ (Output Interleaving)
YukarÄ±daki kodda Ã§Ä±ktÄ±lar birbirine karÄ±ÅŸabilir: `..***+++..**`. Bunun nedeni `std::cout`'un karakter bazÄ±nda atomik olmasÄ±dÄ±r ancak bir bÃ¼tÃ¼nlÃ¼k garantisi vermemesidir.

**C++20 Ã‡Ã¶zÃ¼mÃ¼: `std::osyncstream`**
```cpp
#include <syncstream> // C++20

void foo_synced(char c) {
    std::osyncstream out(std::cout); // <-- Hoca: Kendi senkronizasyonunu yapar.
    for (int i = 0; i < 100; ++i) {
        out << c;
    }
} // <-- out nesnesinin Ã¶mrÃ¼ bittiÄŸinde (flush), tÃ¼m karakterler tek bir blok olarak yazÄ±lÄ±r.
```

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art) - Zaman Ã‡izelgesi
**Deterministik Olmayan AkÄ±ÅŸ:**
```text
Thread 1 (foo): . . . (OS durdurdu)
Thread 2 (bar): * * * * * (OS durdurdu)
Thread 1 (foo): . . 
SonuÃ§: ...*****.. (SÄ±ra iÅŸletim sisteminin insafÄ±na baÄŸlÄ±!)
```

### ğŸ”— Ã–nceki Derslerle BaÄŸlantÄ±
*   **12. Ders (RAII):** `jthread`'in neden RAII'ye uygun olduÄŸu anlatÄ±lÄ±rken bu derslere atÄ±f yapÄ±ldÄ±.
*   **std::chrono:** `sleep_for` kullanÄ±mÄ± iÃ§in krono kÃ¼tÃ¼phanesinin (daha Ã¶nce iÅŸlenen konu) Ã¶nemi hatÄ±rlatÄ±ldÄ±.

---

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  `detach()` edilen thread'in kullandÄ±ÄŸÄ± yerel deÄŸiÅŸkenlerin (stack) Ã¶mrÃ¼ biterse, thread "Ã§Ã¶p" (dangling) referanslarla baÅŸ baÅŸa kalÄ±r.
2.  `std::cout` kullanÄ±rken Ã§Ä±ktÄ±larÄ±n karÄ±ÅŸmasÄ± bir hata deÄŸil, concurrency'nin doÄŸal bir sonucudur.
3.  Thread fonksiyonlarÄ± asla dÄ±ÅŸarÄ±ya kontrolsÃ¼z exception sÄ±zdÄ±rmamalÄ±dÄ±r.

# C++ Concurrency Dersi Teknik Ä°nceleme NotlarÄ± - 3. BÃ¶lÃ¼m

**Ders:** 60  
**Timestamp AralÄ±ÄŸÄ±:** [01:14:00 - 01:31:00]  
**Konu:** Determinizm Analizi, Thread Nesnelerinin Konteynerlarda TutulmasÄ±, Stack BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±  
**EÄŸitmen:** Necati Ergin

---

## 10. AkÄ±ÅŸÄ±n BelirsizliÄŸi (Non-Determinism) Ãœzerine Derin DalÄ±ÅŸ [01:14:00 - 01:23:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Concurrency dÃ¼nyasÄ±nda yapÄ±lan en bÃ¼yÃ¼k hata, kodun yazÄ±m sÄ±rasÄ±na gÃ¶re Ã§alÄ±ÅŸacaÄŸÄ±nÄ± varsaymaktÄ±r. Hoca, iÅŸletim sistemi zamanlayÄ±cÄ±sÄ±nÄ±n (scheduler) nasÄ±l "insafsÄ±zca" Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶stermek iÃ§in dÃ¶ngÃ¼ sayÄ±larÄ±nÄ± deÄŸiÅŸtirerek deneyler yaptÄ±.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, Ã§Ä±ktÄ±larÄ±n birbirine nasÄ±l karÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶stermek iÃ§in dÃ¶ngÃ¼ sayÄ±larÄ±nÄ± (100 vs 10.000) manipÃ¼le etti:

```cpp
#include <iostream>
#include <thread>

void foo(int n) {
    for (int i = 0; i < n; ++i) {
        std::cout.put('.'); // <-- Karakter bazÄ±nda atomik ama akÄ±ÅŸ bazÄ±nda deÄŸil
    }
}

void bar(int n) {
    for (int i = 0; i < n; ++i) {
        std::cout.put('*');
    }
}

int main() {
    const int count = 10000;
    std::thread t1(foo, count);
    std::thread t2(bar, count);

    // Hoca: "Hangisinin Ã¶nce biteceÄŸi veya hangi karakterin Ã¶nce basÄ±lacaÄŸÄ± tamamen 
    // OS scheduler'Ä±n o anki keyfine baÄŸlÄ±dÄ±r."
    t1.join(); 
    t2.join();
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Kodda `t1` nesnesi `t2`'den Ã¶nce oluÅŸturulursa, ekrana Ã¶nce mutlaka `t1`'in karakterleri mi basÄ±lÄ±r?
**Cevap:** HayÄ±r. Thread nesnesinin oluÅŸturulmasÄ± ile fiziksel thread'in OS tarafÄ±ndan CPU'ya Ã§Ä±karÄ±lmasÄ± (scheduling) arasÄ±nda bir zaman farkÄ± vardÄ±r. `t2` daha geÃ§ oluÅŸturulmasÄ±na raÄŸmen CPU'ya daha Ã¶nce Ã§Ä±kabilir. Buna **"Execution Ordering"** belirsizliÄŸi denir.

---

## 11. Thread Nesnelerinin Konteynerlarda YÃ¶netimi [01:23:00 - 01:26:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
GerÃ§ek senaryolarda 1-2 deÄŸil, onlarca thread oluÅŸturulur. Bu thread'leri tek tek isimlendirmek yerine (t1, t2, t3...) bir konteyner (Ã–rn: `std::vector`) iÃ§inde yÃ¶netmek hem kod temizliÄŸi hem de toplu `join` iÅŸlemi iÃ§in zorunludur.

### âš™ï¸ Teknik Detay ve Sentaks
`std::thread` bir **Move-only type** (Sadece taÅŸÄ±nabilir tÃ¼r) olduÄŸu iÃ§in vektÃ¶re eklerken dikkat edilmelidir.

```cpp
#include <vector>
#include <thread>

void task(int id) { /* ... */ }

int main() {
    std::vector<std::thread> vec;

    for(int i = 0; i < 10; ++i) {
        // vec.push_back(std::thread(task, i)); // <-- PR-Value (GeÃ§ici nesne) olduÄŸu iÃ§in otomatik Move.
        vec.emplace_back(task, i); // <-- Daha verimli: DoÄŸrudan konteyner iÃ§inde construct eder.
    }

    // Toplu Join iÅŸlemi
    for (auto& t : vec) { // <-- Dikkat: Referans kullanÄ±lmalÄ±, kopyalama yasak!
        if (t.joinable()) {
            t.join();
        }
    }
}
```

### ğŸ” Arka Plan (Derleyici GÃ¶zÃ¼)
Derleyici, `std::thread`'in **Copy Constructor**'Ä±nÄ± `delete` etmiÅŸtir. EÄŸer `for (auto t : vec)` yazarsanÄ±z (referanssÄ±z), derleyici kopyalamaya Ã§alÄ±ÅŸacak ve ÅŸu hatayÄ± verecektir:  
`use of deleted function 'std::thread::thread(const std::thread&)'`

---

## 12. Thread Stack BaÄŸÄ±msÄ±zlÄ±ÄŸÄ± ve Bellek GÃ¼venliÄŸi [01:26:00 - 01:29:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
"Birden fazla thread aynÄ± fonksiyonu Ã§aÄŸÄ±rÄ±rsa yerel deÄŸiÅŸkenler birbirine karÄ±ÅŸÄ±r mÄ±?" sorusunun cevabÄ±nÄ± anlamak, concurrency mimarisinin temelidir.

### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art) - Thread Stack Layout
Her thread'in kendi **Stack** alanÄ± vardÄ±r, ancak **Heap** ve **Global/Static** alanlar ortaktÄ±r.

```text
RAM (Process Memory)
+----------------------------+
| Global / Static Variables  | <--- PAYLAÅILAN ALAN (Tehlikeli!)
+----------------------------+
| Heap (new/malloc)          | <--- PAYLAÅILAN ALAN (Tehlikeli!)
+----------------------------+
| Thread 1 Stack [id: 101]   | <--- SADECE T1 ERÄ°ÅÄ°R (GÃ¼venli)
|  - int x;                  |
+----------------------------+
| Thread 2 Stack [id: 102]   | <--- SADECE T2 ERÄ°ÅÄ°R (GÃ¼venli)
|  - int x;                  |
+----------------------------+
```

### âš™ï¸ Teknik Detay
```cpp
void func(int thread_id) {
    int local_val = 0; // <-- Hoca: Bu deÄŸiÅŸken her thread'in kendi stack'indedir.
    local_val++;       // Senkronizasyona (Mutex vb.) Ä°HTÄ°YAÃ‡ YOKTUR.
}
```

---

## 13. Ã‡Ä±ktÄ± Senkronizasyonu: `std::osyncstream` (Tekrar) [01:29:00 - 01:31:00]

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, `std::osyncstream`'in (C++20) Ã§Ä±ktÄ±yÄ± nasÄ±l bloklar halinde bastÄ±ÄŸÄ±nÄ± gÃ¶stererek araya gitmeden Ã¶nceki son Ã¶rneÄŸini tamamladÄ±:

```cpp
#include <syncstream>
#include <iostream>

void safe_print(int id) {
    // osyncstream nesnesi yok olana kadar (destructor) 
    // cout'a basÄ±lacak verileri biriktirir (buffer).
    std::osyncstream(std::cout) << "Thread ID: " << id << " calisiyor.\n"; 
} // <-- Atomik flush burada gerÃ§ekleÅŸir.
```

### ğŸ” Arka Plan (Under the Hood)
`std::osyncstream`, bir **Proxy** sÄ±nÄ±ftÄ±r. Ä°Ã§erisinde bir `std::stringbuf` benzeri yapÄ± tutar. Veriler Ã¶nce bu buffer'a yazÄ±lÄ±r. Destructor Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, dahili bir mutex mekanizmasÄ±yla hedef stream'e (`std::cout`) tÃ¼m iÃ§eriÄŸi tek seferde boÅŸaltÄ±r.

---

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **Dangling Reference Riski:** Thread'e `std::ref` ile bir deÄŸiÅŸken geÃ§ildiÄŸinde, o deÄŸiÅŸkenin Ã¶mrÃ¼nÃ¼n thread'den uzun olduÄŸundan emin olunmalÄ±dÄ±r.
2.  **Kopyalama HatasÄ±:** `std::thread` nesnelerini bir dÃ¶ngÃ¼de veya fonksiyona geÃ§erken kopyalamaya Ã§alÄ±ÅŸmak en sÄ±k yapÄ±lan sentaks hatasÄ±dÄ±r; mutlaka **Move** (taÅŸÄ±ma) veya **Reference** (referans) kullanÄ±lmalÄ±dÄ±r.
3.  **Determinizm YanÄ±lgÄ±sÄ±:** Kodun Ã§alÄ±ÅŸma sÄ±rasÄ±nÄ±n CPU'daki yÃ¼rÃ¼tme sÄ±rasÄ±yla aynÄ± olacaÄŸÄ±nÄ± varsaymak bÃ¼yÃ¼k bir lojik hatadÄ±r.

# C++ Concurrency Dersi Teknik Ä°nceleme NotlarÄ± - 4. BÃ¶lÃ¼m

**Ders:** 60  
**Timestamp AralÄ±ÄŸÄ±:** [01:31:00 - 02:02:30]  
**Konu:** Callable TÃ¼rleri (Global, Functor, Member, Lambda), Move-Only SemantiÄŸi, ArgÃ¼man Ã–mÃ¼r Analizi (`Match` YapÄ±sÄ±) ve Overload Ã‡Ã¶zÃ¼mleme  
**EÄŸitmen:** Necati Ergin

---

## 14. Thread Ä°ÅŸ YÃ¼kÃ¼ (Workload) Olarak Ã‡eÅŸitli Callable TÃ¼rleri [01:31:00 - 01:38:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
C++'ta "Ã§aÄŸrÄ±labilir" (callable) yapÄ±lar Ã§ok Ã§eÅŸitlidir. `std::thread`'in esnek olmasÄ± iÃ§in sadece fonksiyon pointer'larÄ±nÄ± deÄŸil, sÄ±nÄ±flarÄ±n Ã¼ye fonksiyonlarÄ±nÄ±, fonksiyon nesnelerini ve lambda ifadelerini de desteklemesi gerekir.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, tÃ¼m Ã§aÄŸrÄ±labilir yapÄ±larÄ± tek bir Ã¶rnekte topladÄ±:

```cpp
#include <thread>
#include <iostream>
#include <functional>

// 1. Global Fonksiyon
void gmprint(int low, int high) { /* ... */ }

// 2. Function Object (Functor)
struct Functor {
    void operator()(int low, int high) const { /* ... */ }
};

// 3. Member Functions
class MyClass {
public:
    static void smprint(int l, int h) { /* Statik Ã¼ye fonksiyon */ }
    void mprint(int l, int h) const { /* Non-statik Ã¼ye fonksiyon */ }
};

int main() {
    // 1. Global Fonksiyon KullanÄ±mÄ±
    std::thread t1(gmprint, 10, 20);

    // 2. Functor (GeÃ§ici nesne - prvalue)
    std::thread t2(Functor{}, 30, 40);

    // 3. Statik Ãœye Fonksiyon
    std::thread t3(&MyClass::smprint, 50, 60);

    // 4. Non-Statik Ãœye Fonksiyon
    MyClass m;
    // <-- KRÄ°TÄ°K: Member function adresi + nesne adresi (veya kopyasÄ±) gerekir!
    std::thread t4(&MyClass::mprint, &m, 80, 90); 

    // 5. Lambda Ä°fadesi (DoÄŸrudan constructor iÃ§inde)
    std::thread t5([](int l, int h) { /* ... */ }, 120, 130);

    t1.join(); t2.join(); t3.join(); t4.join(); t5.join();
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Bir sÄ±nÄ±fÄ±n non-statik Ã¼ye fonksiyonunu thread'e verirken neden ikinci bir argÃ¼man (nesne adresi) geÃ§iyoruz?
**Cevap:** Ã‡Ã¼nkÃ¼ non-statik Ã¼ye fonksiyonlar gizli bir `this` pointer'Ä±na ihtiyaÃ§ duyar. `std::thread` constructor'Ä±, verilen nesne adresini veya kopyasÄ±nÄ± kullanarak bu fonksiyonu ilgili nesne Ã¼zerinden Ã§aÄŸÄ±rÄ±r (INVOKE mekanizmasÄ±).

---

## 15. Thread SÄ±nÄ±fÄ±nda Sahiplik ve TaÅŸÄ±ma (Move-Only) [01:38:00 - 01:42:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir thread (iÅŸ akÄ±ÅŸÄ±) mantÄ±ksal olarak kopyalanamaz. Bir akÄ±ÅŸÄ±n kopyalanmasÄ± ne anlama gelir? DonanÄ±msal karÅŸÄ±lÄ±ÄŸÄ± yoktur. Bu yÃ¼zden `std::thread` sadece taÅŸÄ±nabilir (**Move-only**) bir tÃ¼rdÃ¼r.

### âš™ï¸ Teknik Detay ve Sentaks
```cpp
void foo() {}

int main() {
    std::thread t1(foo);
    // std::thread t2 = t1; // <-- HATA: Copy constructor deleted!
    
    std::thread t2 = std::move(t1); // <-- DOÄRU: Sahiplik t2'ye geÃ§ti.
    // t1 artÄ±k boÅŸ (not joinable), t2 akÄ±ÅŸÄ± yÃ¶netiyor.
    
    t2.join();
}
```

### ğŸ”— Ã–nceki Derslerle BaÄŸlantÄ±
Hoca, 15. derste iÅŸlenen "Move-only types" konusuna atÄ±f yaptÄ±. `std::unique_ptr` gibi `std::thread` de kaynaÄŸÄ±n tek bir sahibi olmasÄ±nÄ± garanti eder.

---

## 16. ArgÃ¼man GeÃ§iÅŸi ve `Match` YapÄ±sÄ± ile Ã–mÃ¼r Analizi [01:50:00 - 01:56:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Thread'e geÃ§ilen argÃ¼manlar ne zaman kopyalanÄ±r? Ne zaman taÅŸÄ±nÄ±r? Hoca, bunu izlemek iÃ§in "instrumented" (log basan) bir `Match` yapÄ±sÄ± kullandÄ±.

### âš™ï¸ Teknik Detay ve Analiz
```cpp
struct Match {
    Match() = default;
    Match(const Match&) { std::cout << "Copy Constructor\n"; }
    Match(Match&&) { std::cout << "Move Constructor\n"; }
};

void work(const Match& m) { /* ... */ }

int main() {
    Match mx;
    std::thread t(work, mx); // <-- ANALÄ°Z BURADA
    t.join();
}
```

### ğŸ” Arka Plan (Under the Hood)
HocanÄ±n en Ã§ok vurguladÄ±ÄŸÄ± yer burasÄ±ydÄ±:
1.  **AÅŸama 1:** `std::thread` constructor'Ä± iÃ§indeki argÃ¼manlar (mx), thread'in **internal storage**'Ä±na (dahili bellek) kopyalanÄ±r veya taÅŸÄ±nÄ±r. (Burada 1 copy Ã§aÄŸrÄ±lÄ±r).
2.  **AÅŸama 2:** Thread fonksiyonu (`work`) Ã§alÄ±ÅŸmaya baÅŸladÄ±ÄŸÄ±nda, bu dahili depodaki kopya, fonksiyonun parametresine geÃ§ilir.
3.  **Kritik Fark:** EÄŸer `std::ref(mx)` kullanÄ±lÄ±rsa, dahili depoya nesnenin kopyasÄ± deÄŸil, sadece bir `reference_wrapper` kopyasÄ± konur. Nesnenin aslÄ± kopyalanmaz.

---

## 17. Overload Ã‡Ã¶zÃ¼mleme Ã‡eliÅŸkisi (Overload Resolution) [01:56:00 - 02:02:00]

### ğŸš© Kritik Nokta: Derleyici GÃ¶zÃ¼
EÄŸer aynÄ± isme sahip birden fazla fonksiyon varsa (overloading), `std::thread` constructor'Ä± hangisini Ã§aÄŸÄ±racaÄŸÄ±nÄ± bilemez ve **"ambiguous"** (belirsiz) hatasÄ± verir.

```cpp
void foo(int x) {}
void foo(double d) {}

int main() {
    // std::thread t(foo, 5); // <-- HATA: Hangi foo? Derleyici karar veremez!
    
    // Ã‡Ã–ZÃœM 1: static_cast ile adresi netleÅŸtirme
    std::thread t1(static_cast<void(*)(int)>(foo), 5);

    // Ã‡Ã–ZÃœM 2: Function pointer deÄŸiÅŸkeni kullanma
    void (*fp)(double) = foo;
    std::thread t2(fp, 3.5);

    t1.join(); t2.join();
}
```

### ğŸ” Derleyici GÃ¶zÃ¼ (Deduction Failure)
Derleyici, `std::thread` constructor'Ä±na bakarken sadece ilk argÃ¼mana (fonksiyon ismi) odaklanÄ±r. Ä°kinci argÃ¼manÄ±n (`5`) `int` olmasÄ±, ilk argÃ¼manÄ± seÃ§mek iÃ§in bir ipucu olarak kullanÄ±lmaz. Bu yÃ¼zden programcÄ± seÃ§imi **explicit** (aÃ§Ä±kÃ§a) yapmalÄ±dÄ±r.

---

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **Member Function UnutkanlÄ±ÄŸÄ±:** Ãœye fonksiyon geÃ§erken nesne adresini (`&obj` veya `this`) vermeyi unutmak en sÄ±k yapÄ±lan hatadÄ±r.
2.  **Internal Copy:** Thread'e geÃ§ilen nesnelerin varsayÄ±lan olarak kopyalandÄ±ÄŸÄ±nÄ±, `const &` parametresinin bile bu kopyalamayÄ± engellemediÄŸini (dahili depo yÃ¼zÃ¼nden) unutmayÄ±n.
3.  **Overload KarmaÅŸasÄ±:** AÅŸÄ±rÄ± yÃ¼klenmiÅŸ fonksiyon isimlerini doÄŸrudan thread'e vermek belirsizliÄŸe yol aÃ§ar; `static_cast` hayat kurtarÄ±r.

# C++ Concurrency Dersi Teknik Ä°nceleme NotlarÄ± - 5. BÃ¶lÃ¼m (Son)

**Ders:** 60  
**Timestamp AralÄ±ÄŸÄ±:** [02:02:30 - 02:42:52]  
**Konu:** `joinable` Hata SenaryolarÄ±, Exception AktarÄ±mÄ± (`exception_ptr`), Thread ID'ler ve `std::this_thread`  
**EÄŸitmen:** Necati Ergin

---

## 18. `joinable` Durumu ve YanlÄ±ÅŸ KullanÄ±m HatalarÄ± [02:02:30 - 02:06:40]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Bir thread nesnesi Ã¼zerinde `join()` veya `detach()` bir kez Ã§aÄŸrÄ±ldÄ±ktan sonra, nesne artÄ±k fiziksel bir thread'i temsil etmez. EÄŸer programcÄ± dikkatsizlik yapÄ±p ikinci kez `join()` Ã§aÄŸÄ±rmaya Ã§alÄ±ÅŸÄ±rsa, bu mantÄ±ksal bir hatadÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
`joinable` olmayan (yani boÅŸalmÄ±ÅŸ) bir thread nesnesinde `join()` Ã§aÄŸÄ±rmak bir exception fÄ±rlatÄ±r.

```cpp
#include <thread>
#include <iostream>

void foo() {}

int main() {
    std::thread t(foo);
    t.join(); // AkÄ±ÅŸ bitti, t artÄ±k joinable deÄŸil.

    try {
        if (t.joinable()) {
            t.join();
        } else {
            // Hoca: "joinable olmayan thread'e join Ã§aÄŸÄ±rmak hatadÄ±r!"
            t.join(); // <-- HATA: std::system_error (Invalid Argument) fÄ±rlatÄ±r.
        }
    } catch (const std::exception& ex) {
        std::cout << "Hata yakalandi: " << ex.what() << "\n";
    }
}
```

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** Bir thread nesnesi ne zaman `joinable` deÄŸildir?
**Cevap:** 
1.  Default construct edilmiÅŸse (iÃ§inde iÅŸ yoksa).
2.  Ä°Ã§indeki sahiplik baÅŸka bir thread nesnesine taÅŸÄ±nmÄ±ÅŸsa (`std::move`).
3.  Ãœzerinde zaten `join()` veya `detach()` Ã§aÄŸrÄ±lmÄ±ÅŸsa.

---

## 19. Threadlerin Konteynerlarda Toplu YÃ¶netimi [02:06:40 - 02:14:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ã–zellikle Ã§ok sayÄ±da (Ã–rn: 26 harf iÃ§in 26 thread) thread oluÅŸturulacaksa, bunlarÄ± tek bir dÃ¶ngÃ¼de baÅŸlatÄ±p tek bir dÃ¶ngÃ¼de sonlandÄ±rmak kod kalitesini artÄ±rÄ±r.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, alfabenin harflerini basan 26 thread'lik bir vektÃ¶r Ã¶rneÄŸi yaptÄ±:

```cpp
#include <vector>
#include <thread>

void print_char(char c) { /* ... */ }

int main() {
    std::vector<std::thread> tvec;

    // Threadleri baÅŸlatma
    for (int i = 0; i < 26; ++i) {
        // Hoca: emplace_back doÄŸrudan thread constructor'Ä±nÄ± Ã§aÄŸÄ±rÄ±r.
        tvec.emplace_back(print_char, static_cast<char>('A' + i));
    }

    // Threadleri join etme (Toplu RAII benzeri yÃ¶netim)
    for (auto& t : tvec) { // <-- Kritik: Mutlaka referans (&)!
        if (t.joinable()) {
            t.join();
        }
    }
}
```

---

## 20. MÃ¼lakatlarÄ±n GÃ¶zdesi: Dangling Reference Tehlikesi [02:14:00 - 02:18:00]

### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
Hoca, bir mÃ¼lakat sorusu Ã¼zerinden "SarkÄ±k Referans" (Dangling Reference) riskini anlattÄ±.

```cpp
struct Functor {
    int& r; // <-- TEHLÄ°KE: Referans veri elemanÄ±
    Functor(int& _r) : r(_r) {}
    void operator()() {
        // r Ã¼zerinde uzun sÃ¼ren iÅŸlemler...
    }
};

void create_hazard() {
    int local_val = 505;
    std::thread t(Functor{local_val});
    t.detach(); // <-- Hoca: "Ä°ÅŸte facia burada baÅŸlÄ±yor!"
} // local_val'in Ã¶mrÃ¼ bitti. Arka plandaki thread Ã¶lÃ¼ adrese eriÅŸiyor: UB!
```

**Ã‡Ã¶zÃ¼m:** `detach()` kullanÄ±lacaksa thread'in kullandÄ±ÄŸÄ± verilerin Ã¶mrÃ¼ (lifetime) garanti edilmelidir (Ã–rn: Heap Ã¼zerinden veya global).

---

## 21. Exception AktarÄ±mÄ±: `std::exception_ptr` MekanizmasÄ± [02:18:00 - 02:38:00]

### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Thread iÃ§inde bir exception fÄ±rlatÄ±lÄ±rsa program Ã§Ã¶ker (`std::terminate`). Ancak bazen bu hatayÄ± ana thread'de yakalayÄ±p loglamak veya yÃ¶netmek isteriz.

### âš™ï¸ Teknik Detay ve Sentaks
Hoca, exception'Ä± bir thread'den diÄŸerine "paslamayÄ±" (aktarmayÄ±) gÃ¶sterdi:

```cpp
#include <exception>
#include <thread>

std::exception_ptr g_exptr = nullptr; // Global veya paylaÅŸÄ±lan bir alan

void worker() {
    try {
        // HatalÄ± bir iÅŸlem...
        throw std::runtime_error("Thread'de hata olustu!");
    } catch (...) {
        // Hoca: current_exception() o anki hatayÄ± yakalayÄ±p ptr'ye atar.
        g_exptr = std::current_exception(); 
    }
}

int main() {
    std::thread t(worker);
    t.join();

    if (g_exptr) { // HatayÄ± ana thread'e kontrol ediyoruz
        try {
            std::rethrow_exception(g_exptr); // <-- Hoca: HatayÄ± burada tekrar fÄ±rlatÄ±yoruz!
        } catch (const std::exception& ex) {
            std::cout << "Ana thread hatayi yakaladi: " << ex.what() << "\n";
        }
    }
}
```

---

## 22. Thread KimliÄŸi ve `std::this_thread` [02:38:00 - Sonu]

### âš™ï¸ Teknik Detay ve Sentaks
*   **Thread ID:** Her thread'in kendine Ã¶zgÃ¼ bir kimliÄŸi vardÄ±r. `std::thread::id` tÃ¼rÃ¼ndedir.
*   **`get_id()`:** Thread nesnesinin veya o an Ã§alÄ±ÅŸan thread'in ID'sini verir.
*   **`std::this_thread`:** O anki akÄ±ÅŸa mÃ¼dahale eden fonksiyonlarÄ± barÄ±ndÄ±ran namespace.

```cpp
void info() {
    // O an Ã§alÄ±ÅŸan thread'in ID'sini alma
    std::thread::id this_id = std::this_thread::get_id();
    
    // Belirli bir sÃ¼re bloklama
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    // CPU'yu diÄŸer thread'lere bÄ±rakma (Hoca: "Yol veriyor")
    std::this_thread::yield(); 
}

int main() {
    std::thread t(info);
    std::cout << "Thread ID: " << t.get_id() << "\n";
    t.join();
}
```

### ğŸ” Arka Plan (Under the Hood)
`std::thread::id` bir tamsayÄ± (integer) olmak zorunda deÄŸildir. Bir nesnedir ve `std::cout`'a basÄ±labilir (insertion operator overload edilmiÅŸtir). AyrÄ±ca `==`, `<` gibi operatÃ¶rleri destekler, bÃ¶ylece `std::map` gibi konteynerlarda key (anahtar) olarak kullanÄ±labilir.

---

### ğŸš© Dersin KapanÄ±ÅŸ Ã–zeti
Necati Ergin Hoca dersi bitirirken ÅŸu vurgularÄ± yaptÄ±:
1.  `std::thread` dÃ¼ÅŸÃ¼k seviyeli (low-level) bir araÃ§tÄ±r, yÃ¶netimi zordur.
2.  Exception yÃ¶netimi ve nesne Ã¶mÃ¼rleri (lifetime) en kritik konulardÄ±r.
3.  Ã‡arÅŸamba gÃ¼nÃ¼ **Data Race** ve **Mutex** (Mutual Exclusion) konularÄ±na girilecektir.

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  `joinable` kontrolÃ¼ yapmadan `join()` Ã§aÄŸÄ±rmak (`system_error`).
2.  Thread iÃ§indeki hatalarÄ±n `main`'e otomatik akacaÄŸÄ±nÄ± sanmak (mutlaka `exception_ptr` kullanÄ±lmalÄ±).
3.  Thread ID'yi basit bir `int` sanmak (AslÄ±nda `std::thread::id` nesnesidir).

