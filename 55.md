# C++ Programlama Dili - 55. Ders Teknik NotlarÄ±
**Tarih:** 13 Ocak 2025 Pazartesi  
**Konu:** Formatlama ArayÃ¼zÃ¼, GerÃ§ek SayÄ± FormatlamasÄ±, Stream Manipulators (AkÄ±ÅŸ ManipÃ¼latÃ¶rleri) ve Custom Parametric Manipulators

---

### 1. GerÃ§ek SayÄ±larÄ±n (Floating Point) YazÄ±m FormatlarÄ± [01:54 - 03:44]

GerÃ§ek sayÄ±larÄ±n ekrana yazdÄ±rÄ±lmasÄ±nda C'deki `printf` yapÄ±sÄ±na benzer ÅŸekilde Ã¼Ã§ temel mod bulunmaktadÄ±r. Bu modlar `ios::floatfield` alan bayraÄŸÄ± (field flag) ile kontrol edilir.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
SayÄ±sal verilerin baÄŸlama gÃ¶re (bilimsel hesaplama, finansal dÃ¶kÃ¼m, genel kullanÄ±m) farklÄ± hassasiyet ve formatlarda gÃ¶sterilmesi gerekir. VarsayÄ±lan davranÄ±ÅŸ her zaman yeterli deÄŸildir.

#### âš™ï¸ Teknik Detay ve Sentaks
GerÃ§ek sayÄ±larda Ã¼Ã§ yazÄ±m biÃ§imi vardÄ±r:
1.  **Fixed (Sabit Notasyon):** SayÄ±yÄ± noktalÄ± biÃ§imde yazar.
2.  **Scientific (Bilimsel Notasyon):** 10 Ã¼zeri Ã§arpanÄ± ($1.2 \times 10^3$ gibi) ÅŸeklinde yazar.
3.  **Default (VarsayÄ±lan):** Ne fixed ne de scientific set edilmiÅŸse, sayÄ± bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne gÃ¶re derleyici otomatik karar verir.

| Bayrak Durumu | Format Modu | AÃ§Ä±klama |
| :--- | :--- | :--- |
| `fixed` set, `scientific` unset | **Fixed** | Sabit noktalÄ± yazÄ±m. |
| `scientific` set, `fixed` unset | **Scientific** | Bilimsel notasyon. |
| Ä°kisi de unset | **Default** | Otomatik seÃ§im. |
| Ä°kisi de set | **Hex Float** | 16'lÄ±k sayÄ± sisteminde gerÃ§ek sayÄ± yazÄ±mÄ±. |

#### ğŸ” Arka Plan (Under the Hood)
`setf` fonksiyonuna ikinci parametre olarak bir maske (`field flag`) verilir. Alihan BozkÄ±r'Ä±n sorusu Ã¼zerine Necati Hoca bitwise operasyonun arka planÄ±nÄ± ÅŸu ÅŸekilde aÃ§Ä±kladÄ±:
1.  Ä°lgili bitleri sÄ±fÄ±rlamak iÃ§in maskenin deÄŸili (`~mask`) ile mevcut bayraklar bitwise AND (`&`) iÅŸlemine sokulur.
2.  ArdÄ±ndan istenen bayrak ile OR (`|`) yapÄ±larak ilgili alana yeni deÄŸer yerleÅŸtirilir.

```cpp
// Hoca'nÄ±n aÃ§Ä±kladÄ±ÄŸÄ± bitwise mantÄ±ÄŸÄ± (Temsili)
flags = (flags & ~std::ios::floatfield) | std::ios::fixed; 
```

---

### 2. GerÃ§ek SayÄ± Formatlama Ã–rneÄŸi ve Hex Float [05:22 - 10:41]

Hoca, `fixed` ve `scientific` bayraklarÄ±nÄ±n kombinasyonlarÄ±nÄ± bir kod Ã¶rneÄŸi ile gÃ¶sterdi.

```cpp
#include <iostream>
#include <iomanip>

void display_pmt(std::ios& x) {
    if (x.flags() & std::ios::fixed)
        std::cout << "fixed set\n";
    else
        std::cout << "fixed unset\n";

    if (x.flags() & std::ios::scientific)
        std::cout << "scientific set\n";
    else
        std::cout << "scientific unset\n";
}

int main() {
    double d1 = 123.456789;
    double d2 = 1234567.89;

    // Default durum: SayÄ± bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne gÃ¶re karar verir
    std::cout << d1 << " " << d2 << "\n"; // 123.457 1.23457e+06

    // Fixed set etme
    std::cout.setf(std::ios::fixed, std::ios::floatfield);
    std::cout << d1 << " " << d2 << "\n"; // 123.456789 1234567.890000

    // Scientific set etme
    std::cout.setf(std::ios::scientific, std::ios::floatfield);
    std::cout << d1 << " " << d2 << "\n"; 

    // Hex Plot (Her ikisi de set edilmiÅŸse)
    std::cout.setf(std::ios::fixed | std::ios::scientific, std::ios::floatfield);
    std::cout << d1 << "\n"; // <-- Kritik: 16'lÄ±k sayÄ± sisteminde yazar
}
```

---

### 3. Hassasiyet (Precision) ve YardÄ±mcÄ± Fonksiyonlar [10:44 - 15:26]

Hassasiyet kurallarÄ± modlara gÃ¶re deÄŸiÅŸkenlik gÃ¶sterir.

#### âš™ï¸ Teknik Detay ve Sentaks
*   **Default Mode:** Precision, toplam anlamlÄ± basamak sayÄ±sÄ±nÄ± belirler (VarsayÄ±lan 6).
*   **Fixed Mode:** Precision, noktadan sonraki basamak sayÄ±sÄ±nÄ± belirler.

SÄ±nÄ±fÄ±n `precision`, `fill` ve `width` fonksiyonlarÄ± ortak bir davranÄ±ÅŸ sergiler:
1.  **Parametresiz Ã§aÄŸrÄ±:** Mevcut deÄŸeri `get` eder (dÃ¶ndÃ¼rÃ¼r).
2.  **Parametreli Ã§aÄŸrÄ±:** Yeni deÄŸeri `set` eder, **eski deÄŸeri** geri dÃ¶ndÃ¼rÃ¼r.

```cpp
auto old_precision = std::cout.precision(12); // Eski deÄŸeri sakla, yeniyi 12 yap
std::cout << 45.762323 << "\n"; // Noktadan sonra 12 basamak (fixed moddaysa)
std::cout.precision(old_precision); // Eski haline geri getir
```

#### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** `width()` fonksiyonunun diÄŸer formatlama Ã¶zelliklerinden farkÄ± nedir?
**Cevap:** `fill`, `precision` ve bayraklar (flags) kalÄ±cÄ±dÄ±r (sticky). Ancak `width()` fonksiyonu **sadece ilk yazÄ±lacak Ã¶ÄŸe iÃ§in** etkindir. Ä°lk Ã¶ÄŸe yazÄ±ldÄ±ktan sonra otomatik olarak 0'a resetlenir.

---

### 4. Stream Manipulators (AkÄ±ÅŸ ManipÃ¼latÃ¶rleri) [16:44 - 23:11]

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Ã‡Ä±kÄ±ÅŸ iÅŸlemlerinde "chaining" (zincirleme) yapÄ±sÄ± Ã§ok yaygÄ±ndÄ±r (`cout << x << y << z`). Ancak `setf` veya `width` gibi Ã¼ye fonksiyonlar Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda bu zincir bozulur. ManipÃ¼latÃ¶rler, formatlama ayarlarÄ±nÄ± zinciri bozmadan `<<` operatÃ¶rÃ¼ iÃ§ine gÃ¶mmemizi saÄŸlar.

#### ğŸ” Arka Plan (Under the Hood)
ManipÃ¼latÃ¶rler aslÄ±nda `ostream&` alÄ±p `ostream&` dÃ¶ndÃ¼ren fonksiyonlardÄ±r. `ostream` sÄ±nÄ±fÄ± iÃ§inde bu fonksiyon adreslerini (Function Pointer) alan bir `operator<<` overload'u bulunur.

```cpp
// BasitleÅŸtirilmiÅŸ ostream yapÄ±sÄ± (Hoca'nÄ±n ASCII anlatÄ±mÄ±)
class ostream {
public:
    // Fonksiyon pointer alan operatÃ¶r overload'u
    ostream& operator<<(ostream& (*fp)(ostream&)) {
        return fp(*this); // Fonksiyonu Ã§aÄŸÄ±r ve akÄ±ÅŸÄ±n kendisini dÃ¶ndÃ¼r
    }
};
```

#### ğŸš© std::endl vs '\n' MÃ¼lakat Sorusu [21:58]
**Soru:** Neden `std::endl` yerine `\n` tercih edilmelidir?
**Cevap:** `std::endl` sadece yeni satÄ±r karakteri basmaz, aynÄ± zamanda `flush` (tamponu boÅŸaltma) iÅŸlemi yapar. `flush` iÅŸlemi maliyetli bir sistem Ã§aÄŸrÄ±sÄ±dÄ±r (disk/device yazÄ±mÄ±). Gereksiz `std::endl` kullanÄ±mÄ± performansÄ± ciddi oranda dÃ¼ÅŸÃ¼rÃ¼r.

---

### 5. Custom Parametric Manipulators (Parametreli ManipÃ¼latÃ¶r YazÄ±mÄ±) [42:13 - 53:01]

Hoca, belirli sayÄ±da boÅŸluk basan `NS(n)` (Number of Spaces) isimli bir manipÃ¼latÃ¶rÃ¼n nasÄ±l yazÄ±lacaÄŸÄ±nÄ± gÃ¶sterdi.

#### ğŸ§  Rationale
Standart manipÃ¼latÃ¶rlerin (Ã¶rn: `setw`) yetmediÄŸi durumlarda, karmaÅŸÄ±k formatlama mantÄ±ÄŸÄ±nÄ± (Ã¶rn: log dosyasÄ± formatÄ±) bir nesneye hapsetmek kod okunabilirliÄŸini artÄ±rÄ±r.

#### âš™ï¸ Teknik Detay (RAII/Idiom)
Parametreli manipÃ¼latÃ¶rler genellikle bir sÄ±nÄ±f/struct ve bu sÄ±nÄ±f iÃ§in overload edilmiÅŸ bir `operator<<` ile gerÃ§ekleÅŸtirilir.

```cpp
class NS { // Number of Spaces
    int m_n;
public:
    NS(int n) : m_n(n) {} // Parametreyi sakla

    // Hidden Friend operator<<
    friend std::ostream& operator<<(std::ostream& os, const NS& x) {
        for (int i = 0; i < x.m_n; ++i) {
            os.put(' '); // Belirlenen sayÄ±da boÅŸluk bas
        }
        return os;
    }
};

// KullanÄ±m:
std::cout << 23 << NS(12) << "Ali" << NS(5) << "Veli\n";
```

#### ğŸ” Arka Plan (Under the Hood)
1.  `NS(12)` ifadesi bir **Temporary Object** (GeÃ§ici Nesne - PR Value) oluÅŸturur.
2.  `operator<<(std::cout, temporary_object)` Ã§aÄŸrÄ±lÄ±r.
3.  OperatÃ¶r iÃ§indeki dÃ¶ngÃ¼ Ã§alÄ±ÅŸÄ±r ve `ostream` referansÄ± dÃ¶ndÃ¼rÃ¼lerek zincir devam eder.

---

### 6. Format Guard (RAII ile Durum Koruma) [53:30 - 01:05:40]

Hoca, `cout` gibi global nesnelerin format state'ini deÄŸiÅŸtirip Ã¶yle bÄ±rakmanÄ±n ("babanÄ±zÄ±n malÄ± gibi kullanmanÄ±n") risklerine deÄŸindi.

#### ğŸ§  Rationale
Bir fonksiyon iÃ§inde `hex` moduna geÃ§ip Ã§Ä±karsanÄ±z, sizden sonra `cout` kullanan tÃ¼m kodlar (belki de 3. parti kÃ¼tÃ¼phaneler) istemeden `hex` modunda yazar.

#### âš™ï¸ Teknik Detay (Format Guard SÄ±nÄ±fÄ±)
Necati Hoca, "NasÄ±l aldÄ±ysan Ã¶yle bÄ±rak" prensibiyle (RAII - Resource Acquisition Is Initialization) bir `FormatGuard` sÄ±nÄ±fÄ± inÅŸa etti.

```cpp
class FormatGuard {
    std::ostream& m_os;
    std::ios::fmtflags m_flags;
    std::streamsize m_width;
    char m_fill;
    std::streamsize m_precision;

public:
    FormatGuard(std::ostream& os) : m_os(os) {
        // Mevcut state'i sakla (Acquisition)
        m_flags = os.flags();
        m_width = os.width();
        m_fill = os.fill();
        m_precision = os.precision();
    }

    ~FormatGuard() {
        // Eski state'i geri yÃ¼kle (Release/Cleanup)
        m_os.flags(m_flags);
        m_os.width(m_width);
        m_os.fill(m_fill);
        m_os.precision(m_precision);
    }
};

// KullanÄ±m:
void func(int x) {
    FormatGuard guard(std::cout); // <-- Fonksiyon biterken state otomatik dÃ¼zelecek
    std::cout << std::hex << std::uppercase << x;
}
```

---

HaklÄ±sÄ±n, Necati Hoca'nÄ±n her bir cÃ¼mlesi altÄ±n deÄŸerinde, hÄ±z yapÄ±p detay kaÃ§Ä±rmayalÄ±m. KaldÄ±ÄŸÄ±mÄ±z yerden, akÄ±ÅŸlarÄ±n (streams) en mahrem noktalarÄ±ndan biri olan **Buffer (Tampon)** paylaÅŸÄ±mÄ± ve ardÄ±ndan **GiriÅŸ AkÄ±ÅŸlarÄ± (Input Streams)** dÃ¼nyasÄ±na adÄ±m atarak devam ediyoruz.

---

### 7. rdbuf() ile Tampon PaylaÅŸÄ±mÄ± ve BaÄŸÄ±msÄ±z Format State [01:06:00 - 01:11:30]

Necati Hoca, "FormatGuard" yazmanÄ±n bir alternatifi olarak Ã§ok ÅŸÄ±k bir teknik gÃ¶sterdi: Bir akÄ±ÅŸÄ±n tamponunu (streambuf) alÄ±p baÅŸka bir akÄ±ÅŸ nesnesine vermek.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Global `std::cout` nesnesinin ayarlarÄ±nÄ± bozmadan, onunla aynÄ± yere (konsola) yazÄ± yazan ama kendi format Ã¶zelliklerine (independent format state) sahip geÃ§ici bir akÄ±ÅŸ nesnesi yaratmak iÃ§in kullanÄ±lÄ±r.

#### âš™ï¸ Teknik Detay ve Sentaks
`std::ostream` sÄ±nÄ±fÄ±nÄ±n bir constructor'Ä± (yapÄ±cÄ± fonksiyonu) `std::streambuf*` alÄ±r. `rdbuf()` fonksiyonu ise akÄ±ÅŸÄ±n o an kullandÄ±ÄŸÄ± tamponun adresini dÃ¶ndÃ¼rÃ¼r.

```cpp
#include <iostream>
#include <string>

int main() {
    // std::cout'un kullandÄ±ÄŸÄ± tamponu (buffer) paylaÅŸan yeni bir nesne yaratÄ±yoruz
    std::ostream my_cout(std::cout.rdbuf()); // <-- KRÄ°TÄ°K: AynÄ± buffer, farklÄ± state

    my_cout << std::hex << std::showbase << std::uppercase << std::boolalpha;
    
    my_cout << 54807 << " " << (10 > 5) << "\n"; 
    // Ã‡Ä±ktÄ±: 0XD617 true (Kendi format ayarlarÄ±yla yazdÄ±)

    std::cout << 54807 << " " << (10 > 5) << "\n";
    // Ã‡Ä±ktÄ±: 54807 1 (Global cout etkilenmedi, default ayarlarla yazdÄ±!)
}
```

#### ğŸ” Arka Plan (Under the Hood)
C++ Stream HiyerarÅŸisinde asÄ±l iÅŸi yapan "Stream Buffer" nesnesidir. AkÄ±ÅŸ nesneleri (ostream/istream) sadece birer arayÃ¼zdÃ¼r (interface).
*   **Buffer:** Karakterlerin nereye/nasÄ±l yazÄ±lacaÄŸÄ±nÄ± bilir.
*   **State:** SayÄ±nÄ±n 10'luk mu 16'lÄ±k mÄ± yazÄ±lacaÄŸÄ± bilgisini her akÄ±ÅŸ nesnesi kendi iÃ§inde tutar.

#### ğŸ–¼ï¸ GÃ¶rselleÅŸtirme (ASCII Art)
```text
[ std::cout (State A) ] --+
                          |
                          +--> [ std::streambuf (Konsol Tamponu) ]
                          |
[ my_cout   (State B) ] --+
```

---

### 8. GiriÅŸ AkÄ±ÅŸlarÄ± (Input Streams) ve Whitespace Sorunu [01:11:30 - 01:18:00]

FormatlÄ± giriÅŸ iÅŸlemleri (`operator>>`) varsayÄ±lan olarak boÅŸluk karakterlerini (space, tab, newline) "ayÄ±raÃ§" (delimiter) olarak kabul eder ve onlarÄ± atlar (skip).

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
`std::cin >> name;` ifadesiyle "Ã–mer Faruk" ismini okumaya Ã§alÄ±ÅŸÄ±rsanÄ±z, sadece "Ã–mer" kÄ±smÄ±nÄ± alabilirsiniz. BoÅŸluklarÄ± iÃ§eren tÃ¼m satÄ±rÄ± okumak iÃ§in farklÄ± bir araÃ§ gerekir.

#### âš™ï¸ Teknik Detay (std::getline)
Hoca, `std::string` baÅŸlÄ±k dosyasÄ±ndaki global `getline` fonksiyonuna dikkat Ã§ekti.

```cpp
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::cout << "Isminizi girin: ";
    
    // std::cin >> name; // <-- HATA: BoÅŸlukta durur.
    std::getline(std::cin, name); // <-- Ã‡Ã–ZÃœM: SatÄ±r sonuna kadar okur.
    
    // ÃœÃ§Ã¼ncÃ¼ parametre: Delimiter (AyÄ±raÃ§)
    std::getline(std::cin, name, '.'); // Nokta gÃ¶rene kadar oku (Nokta dahil edilmez ama akÄ±ÅŸtan Ã§Ä±kartÄ±lÄ±r).
}
```

#### ğŸš© MÃ¼lakat Sorusu / Kritik Nokta
**Soru:** `std::getline` Ã¼Ã§Ã¼ncÃ¼ parametresi (delimiter) akÄ±ÅŸta (buffer) kalÄ±r mÄ±?
**Cevap:** HayÄ±r. Belirlenen karakter (varsayÄ±lan `\n`) tampondan okunur ve dÄ±ÅŸarÄ± atÄ±lÄ±r (extracted but discarded), ancak hedef string'e eklenmez.

---

### 9. Tamponu Temizlemek: std::cin.ignore() [01:18:00 - 01:23:00]

Hoca, C'den de bildiÄŸimiz o meÅŸhur "hatalÄ± giriÅŸ tamponda kalÄ±r" problemini (The "Ahmet" Scenario) C++ dÃ¼nyasÄ±nda inceledi.

#### âš™ï¸ Teknik Detay ve Sentaks
EÄŸer bir `int` beklerken kullanÄ±cÄ± "ahmet" yazarsa, `operator>>` baÅŸarÄ±sÄ±z olur, akÄ±ÅŸÄ±n hata bayraÄŸÄ± set edilir ve "ahmet" karakterleri tamponda (buffer) beklemeye devam eder. Bir sonraki okuma giriÅŸimi de bu karakterler yÃ¼zÃ¼nden baÅŸarÄ±sÄ±z olur.

```cpp
#include <iostream>
#include <limits> // numeric_limits iÃ§in

int main() {
    int x;
    std::cout << "Sayi girin: ";
    if (!(std::cin >> x)) { // EÄŸer giriÅŸ baÅŸarÄ±sÄ±zsa (Ã–rn: 'ahmet' girildi)
        std::cin.clear(); // Hata bayraÄŸÄ±nÄ± temizle (SaÄŸlÄ±k durumunu dÃ¼zelt)
        
        // Tamponda kalan Ã§Ã¶pÃ¼ temizle
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); 
        // <-- KRÄ°TÄ°K: 'streamsize' tÃ¼rÃ¼nÃ¼n alabileceÄŸi max deÄŸer kadar karakteri 
        // veya '\n' karakterini gÃ¶rene kadar tamponu boÅŸalt.
    }
}
```

#### ğŸ” Arka Plan (Under the Hood)
`std::cin.ignore(n, delim)`:
1.  `n` kadar karakteri akÄ±ÅŸtan Ã§eker ve Ã§Ã¶pe atar.
2.  EÄŸer `n` karakterden Ã¶nce `delim` (ayÄ±raÃ§) ile karÅŸÄ±laÅŸÄ±rsa orada durur.
3.  `std::numeric_limits<std::streamsize>::max()` kullanmak, "ne kadar karakter varsa temizle" demenin standart yoludur.

---

### 10. Ã–zel GiriÅŸ ManipÃ¼latÃ¶rÃ¼: ignore_line [01:23:00 - 01:28:44]

Hoca, `ignore` iÅŸlemini zincirleme (chaining) iÃ§inde kullanabilmek iÃ§in bir manipÃ¼latÃ¶r yazdÄ±.

```cpp
#include <iostream>
#include <limits>

std::istream& ignore_line(std::istream& is) {
    return is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

int main() {
    int x, y;
    // KullanÄ±cÄ± '123 ahmet' girse bile x=123 olur, 'ahmet' temizlenir ve y iÃ§in yeni giriÅŸ beklenir.
    std::cin >> x >> ignore_line >> y; 
}
```

---

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik noktaya dikkat Ã§ekti:**
1.  **Buffer vs State:** AkÄ±ÅŸ nesneleri tamponu paylaÅŸabilir ama format ayarlarÄ± nesneye Ã¶zeldir.
2.  **Extraction Fail:** HatalÄ± giriÅŸ yapÄ±ldÄ±ÄŸÄ±nda (int beklerken harf girilmesi gibi), o karakterler tampondan **Ã§Ä±kartÄ±lmaz**; manuel temizlemek zorunludur.
3.  **`std::numeric_limits`:** TaÅŸÄ±nabilir (portable) kod yazmak iÃ§in `INT_MAX` gibi makrolar yerine bu template yapÄ±sÄ± tercih edilmelidir.

---

AkÄ±ÅŸlarÄ±n "SaÄŸlÄ±k Durumu" (Condition States), bellek Ã¼stÃ¼nde okuma-yazma (String Streams) ve akÄ±ÅŸlarÄ±n mantÄ±ksal sÄ±namalarda kullanÄ±mÄ±yla devam ediyoruz. Necati Hoca'nÄ±n deyimiyle; bir akÄ±m her zaman "afiyette" olmayabilir.

---

### 11. AkÄ±ÅŸÄ±n SaÄŸlÄ±k Durumu: Condition States [01:28:44 - 01:34:00]

C++'ta her akÄ±ÅŸ nesnesi, o anki durumunu belirten bir "saÄŸlÄ±k raporu" tutar. EÄŸer akÄ±ÅŸ saÄŸlÄ±klÄ± deÄŸilse, yapÄ±lacak hiÃ§bir okuma veya yazma iÅŸlemi gerÃ§ekleÅŸmez.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
GiriÅŸ/Ã§Ä±kÄ±ÅŸ iÅŸlemleri dÄ±ÅŸ dÃ¼nyaya baÄŸlÄ±dÄ±r (klavye, dosya, aÄŸ). KullanÄ±cÄ±nÄ±n hatalÄ± veri girmesi veya dosyanÄ±n bitmesi durumunda programÄ±n Ã§Ã¶kmemesi, aksine bu durumu "teÅŸhis" edip (diagnose) yoluna devam etmesi gerekir.

#### âš™ï¸ Teknik Detay: 4 Temel Durum
| Durum | Fonksiyon | AÃ§Ä±klama |
| :--- | :--- | :--- |
| **Good** | `good()` | Her ÅŸey yolunda, akÄ±ÅŸ iÅŸini yapabilir. |
| **EOF** | `eof()` | AkÄ±ÅŸÄ±n sonuna gelindi (End of File). |
| **Fail** | `fail()` | KurtarÄ±labilir (recoverable) hata. Ã–rn: Format uyuÅŸmazlÄ±ÄŸÄ± (`int` yerine `char` girilmesi). |
| **Bad** | `bad()` | KurtarÄ±lamaz (irrecoverable) hata. Ã–rn: Fiziksel okuma hatasÄ±, bellek yetersizliÄŸi. |

---

### 12. Durum Bitleri ve rdstate() Fonksiyonu [01:40:40 - 01:44:10]

Hoca, bu durumlarÄ±n arka planda bitler vasÄ±tasÄ±yla tutulduÄŸunu ve `std::ios_base` sÄ±nÄ±fÄ±ndaki sabitlerle (bitmask) temsil edildiÄŸini aÃ§Ä±kladÄ±.

#### ğŸ” Arka Plan (Under the Hood)
AkÄ±ÅŸÄ±n o anki "saÄŸlÄ±k raporunu" tam olarak almak iÃ§in `rdstate()` fonksiyonu kullanÄ±lÄ±r.

```cpp
#include <iostream>

void display_state(std::ios& s) {
    auto state = s.rdstate(); // Mevcut durum maskesini al (iostate)
    
    if (state == std::ios::goodbit) // goodbit aslÄ±nda 0'dÄ±r
        std::cout << "Stream is OK\n";
    if (state & std::ios::failbit) 
        std::cout << "Fail bit is set!\n";
    if (state & std::ios::eofbit)
        std::cout << "EOF bit is set!\n";
    if (state & std::ios::badbit)
        std::cout << "Bad bit is set!\n";
}
```

---

### 13. AkÄ±ÅŸ Nesnelerinin MantÄ±ksal BaÄŸlamda KullanÄ±mÄ± [01:44:10 - 01:51:20]

"Neden `if (std::cin >> x)` yazabiliyoruz?" sorusunun teknik cevabÄ± burada verildi.

#### ğŸ” Arka Plan (Operator Overloading)
AkÄ±ÅŸ sÄ±nÄ±flarÄ±nÄ±n iki kritik operatÃ¶r fonksiyonu vardÄ±r:
1.  **`operator bool()`:** AkÄ±ÅŸ **fail** veya **bad** durumunda deÄŸilse `true` dÃ¶ndÃ¼rÃ¼r. (Hoca'nÄ±n vurgusu: AslÄ±nda `!fail()` sonucunu dÃ¶ndÃ¼rÃ¼r.)
2.  **`operator !()`:** AkÄ±ÅŸ hatalÄ± durumdaysa `true` dÃ¶ndÃ¼rÃ¼r. (`fail()` ile eÅŸ anlamlÄ±dÄ±r.)

#### âš™ï¸ Teknik Detay ve Sentaks (DÃ¶ngÃ¼ Ä°diyomu)
```cpp
int x, sum = 0;
// 1. std::cin >> x Ã§alÄ±ÅŸÄ±r, cin nesnesini dÃ¶ndÃ¼rÃ¼r.
// 2. While parantezi iÃ§inde cin.operator bool() Ã§aÄŸrÄ±lÄ±r.
// 3. GiriÅŸ baÅŸarÄ±lÄ±ysa dÃ¶ngÃ¼ devam eder, baÅŸarÄ±sÄ±zsa (harf girildi veya EOF) dÃ¶ngÃ¼ kÄ±rÄ±lÄ±r.
while (std::cin >> x) { 
    sum += x;
}
```

---

### 14. clear() vs setstate() FarkÄ± [01:56:00 - 02:07:30]

Bu iki fonksiyon mÃ¼lakatlarÄ±n vazgeÃ§ilmezidir ve Hoca farkÄ±n altÄ±nÄ± kalÄ±n Ã§izgilerle Ã§izdi:

*   **`clear(state)`:** AkÄ±ÅŸtaki tÃ¼m bayraklarÄ± siler ve sadece parametre olarak gÃ¶nderilen bayraÄŸÄ± set eder. (Parametresiz Ã§aÄŸrÄ±lÄ±rsa `goodbit` yapar, yani sÄ±fÄ±rlar).
*   **`setstate(state)`:** Mevcut bayraklara dokunmaz, gÃ¶nderilen bayraÄŸÄ± "ilave" (bitwise OR ile) olarak set eder.

#### ğŸš© Kritik Nokta / MÃ¼lakat Sorusu
**Soru:** HatalÄ± bir giriÅŸi (Ã–rn: harf girilmesi) temizleyip tekrar okuma yapmak iÃ§in ne yapmalÄ±yÄ±z?
**Cevap:** Sadece `clear()` yetmez!
1. `std::cin.clear()` ile hata bayraÄŸÄ± sÄ±fÄ±rlanÄ±r.
2. `std::cin.ignore()` ile tamponda bekleyen ve hataya sebep olan "Ã§Ã¶p" karakterler dÄ±ÅŸarÄ± atÄ±lÄ±r.

---

### 15. Bellek ÃœstÃ¼nde Okuma-Yazma: String Streams [02:07:30 - 02:16:40]

Hoca, `<sstream>` baÅŸlÄ±k dosyasÄ±nda bulunan ve veriyi konsol/dosya yerine bir `std::string` iÃ§ine yazan veya oradan okuyan sÄ±nÄ±flarÄ± tanÄ±ttÄ±.

#### ğŸ§  Neden Ä°htiyaÃ§ Duyuldu? (Rationale)
Veriyi ekrana basmadan Ã¶nce formatlamak (Ã¶rneÄŸin bir tarih string'i oluÅŸturmak) veya bir string iÃ§indeki verileri "kelime kelime" parse etmek (ayrÄ±ÅŸtÄ±rmak) iÃ§in kullanÄ±lÄ±r.

#### âš™ï¸ Teknik Detay (ostringstream)
```cpp
#include <sstream>
#include <iomanip>
#include <string>

std::ostringstream oss;
oss << std::setfill('0') << std::setw(2) << 3 << "/" << std::setw(2) << 6 << "/1988";

std::string date_str = oss.str(); // <-- KRÄ°TÄ°K: Ä°Ã§eride biriken yazÄ±yÄ± string olarak al.
// Ã‡Ä±ktÄ±: "03/06/1988"
```

#### ğŸ” Arka Plan (Under the Hood)
`std::ostringstream` nesnesi kendi iÃ§inde dinamik bÃ¼yÃ¼yen bir tampon (buffer) tutar. `str()` fonksiyonu bu tamponun kopyasÄ±nÄ± dÃ¶ndÃ¼rÃ¼r. EÄŸer tamponu sÄ±fÄ±rlamak isterseniz `oss.str("");` veya `oss.str({})` yapmalÄ±sÄ±nÄ±z.

---

### 16. Uygulama: Kelime AyrÄ±ÅŸtÄ±rma (Parsing) [02:26:40 - 02:31:00]

Hoca, bir satÄ±r yazÄ±yÄ± kelimelerine ayÄ±ran ve sayan o meÅŸhur mÃ¼lakat sorusunu Ã§Ã¶zdÃ¼:

```cpp
std::string line = "Bugun C++ kursunun 57. dersini isliyoruz";
std::istringstream iss(line); // String'i sanki bir giriÅŸ akÄ±ÅŸÄ±ymÄ±ÅŸ gibi veriyoruz
std::string word;
int count = 0;

while (iss >> word) { // Whitespace'leri (boÅŸluklarÄ±) otomatik atlayarak kelime kelime okur
    std::cout << ++count << ". Kelime: " << word << "\n";
}
```

---

### 17. Kritik Ã–rnek: setw Probleminin Ã‡Ã¶zÃ¼mÃ¼ [02:36:00 - 02:42:05]

Dersin sonuna doÄŸru Hoca, `setw` manipÃ¼latÃ¶rÃ¼nÃ¼n neden bazen kullanÄ±cÄ± tanÄ±mlÄ± sÄ±nÄ±flarda (Date gibi) Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± ve StringStream ile Ã§Ã¶zÃ¼mÃ¼nÃ¼ gÃ¶sterdi.

**Hata:** `cout << setw(20) << myDate;` dendiÄŸinde, `setw` sadece tarihin ilk elemanÄ±na (gÃ¼ne) etki eder. Tarihin kalanÄ± sola dayanÄ±r.
**Ã‡Ã¶zÃ¼m:** Ã–nce tarihi bir `ostringstream` ile tek bir string haline getirip, sonra o string'i `setw` ile `cout`'a vermek.

---

**Bu bÃ¶lÃ¼mde Hoca ÅŸu 3 kritik hataya dikkat Ã§ekti:**
1.  **State Ignorance:** AkÄ±ÅŸÄ±n hata bayraÄŸÄ± set edilmiÅŸse, siz `clear()` yapana kadar hiÃ§bir yeni I/O iÅŸlemi Ã§alÄ±ÅŸmaz (zombi akÄ±ÅŸ).
2.  **Chaining vs Setw:** `setw` Sticky (kalÄ±cÄ±) deÄŸildir, her bir `<<` operatÃ¶rÃ¼nden sonra resetlenir.
3.  **str() vs c_str():** String stream'den alÄ±nan sonucun bir `std::string` olduÄŸunu, doÄŸrudan C-Style string gibi davranmadÄ±ÄŸÄ±nÄ± unutmayÄ±n.

---
