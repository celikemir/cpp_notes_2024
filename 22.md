Harika bir istek! İşte bir C++ dersini dinleyen çalışkan bir öğrencinin alabileceği gibi detaylı notlar:

**Ders Notları: C++ `std::string` Sınıfı Detayları ve İlgili Kavramlar**

**Ders Bilgileri:**
*   **Tarih:** 11 Eylül 2024, Çarşamba
*   **Ders No:** 22
*   **Saat:** 19:30
*   **Ana Konu:** Standart Kütüphane `std::string` sınıfının incelenmesine devam.

---

**1. Giriş ve Ders Akışı (00:00.000 - 00:17.260)**
*   Dersin başlangıcı ve genel bilgilendirme.
*   Kaldığımız yerden `std::string` sınıfının "mutator" (değiştirici) fonksiyonları ile devam edileceği belirtildi.
*   Ses ve görüntüde problem olursa bildirilmesi istendi.

---

**2. `std::string` Mutator (Değiştirici) Fonksiyonlara Genel Bakış (00:18.320 - 00:43.820)**
*   **Mutator Fonksiyonlar:** String nesnesinin tuttuğu değeri (içeriği) değiştiren fonksiyonlardır.
*   **Kategoriler:**
    *   **Atama Fonksiyonları:** `operator=` ve `assign` overload'ları (önceki derslerde görüldü).
    *   **Sona Ekleme Fonksiyonları:** `operator+=` ve `append` overload'ları (önceki derslerde görüldü).
    *   **`resize()` Fonksiyonu:** String'in boyutunu (karakter sayısını) değiştirir.
    *   **`insert()` Fonksiyonları:** String'e belirli bir konuma karakter/karakterler ekler.
    *   **`erase()` Fonksiyonları:** String'den karakter/karakterler siler.
    *   **`replace()` Fonksiyonları:** String'in bir bölümünü başka bir karakter dizisiyle değiştirir.

---

**3. `insert()` Fonksiyonları Detaylı İnceleme (01:14.840 - 01:24.160, Aktif Anlatım: 01:46.080 - 13:12.940)**

*   **Genel STL Konteyner `insert()` Mantığı (01:46.080 - 02:48.180):**
    *   Çoğu STL konteynerinde (örn: `std::vector`, `std::list`, `std::deque`) `insert()` fonksiyonu bulunur. İstisnalar: `std::array` (sabit boyutlu) ve `std::forward_list` (farklı isimlendirme: `insert_after`).
    *   **Temel Arayüz:** Her zaman ilk parametre, eklemenin yapılacağı konumu belirten bir iteratördür. Diğer parametreler, *neyin* ekleneceğini tanımlar.
    *   Örneğin, `container.begin()` iteratörü verilirse, eklenen öğe konteynerin yeni ilk öğesi olur.
    *   Eklenebilecekler: Tek bir değer, N adet aynı değer, başka bir konteynerden bir aralık (range), bir `std::initializer_list`.

*   **`std::string` için `insert()` (02:48.180 - 05:00.360):**
    *   `std::string`, karakterlerden (`char`) oluşan bir konteynerdir.
    *   Dolayısıyla `insert` fonksiyonları da karakter veya karakter dizileri eklemek üzerine çalışır.

*   **İteratör Arayüzlü `insert()` Overload'ları ve Örnekleri (05:00.360 - 09:03.520):**
    *   **Tek Karakter Ekleme:** `iterator insert(const_iterator p, charT c);`
        *   `p`: Ekleme yapılacak konumu gösteren iteratör.
        *   `c`: Eklenecek karakter.
        *   **Örnek:**
            ```cpp
            std::string s = "ACDEF";
            // s.begin() (A'nın olduğu yer) konumuna '!' ekle
            s.insert(s.begin(), '!'); // s becomes "!ACDEF"
            std::cout << s << std::endl;

            // s.begin() + 3 (D'nin olduğu yer) konumuna '*' ekle
            s.insert(s.begin() + 3, '*'); // s becomes "!A*CDEF" (Eski D, yeni *'dan sonra gelir)
            std::cout << s << std::endl;
            ```
    *   **Birden Fazla Aynı Karakteri Ekleme:** `iterator insert(const_iterator p, size_type n, charT c);`
        *   `n`: Eklenecek karakter sayısı.
        *   **Örnek:**
            ```cpp
            std::string s1 = "ABC";
            // s1.begin() + 1 (B'nin olduğu yer) konumuna 3 tane 'X' ekle
            s1.insert(s1.begin() + 1, 3, 'X'); // s1 becomes "AXXXBC"
            std::cout << s1 << std::endl;
            ```
    *   **Bir Aralıktaki (Range) Karakterleri Ekleme:** `template<class InputIt> iterator insert(const_iterator p, InputIt first, InputIt last);`
        *   `first`, `last`: Başka bir karakter dizisinin (örn: başka bir string, char array) başlangıç ve bitiş iteratörleri.
        *   **Örnek:**
            ```cpp
            std::string s_main = "FrontBack";
            std::string s_to_insert = "Middle";
            // s_main.begin() + 5 (B'nin olduğu yer) konumuna s_to_insert'in tamamını ekle
            s_main.insert(s_main.begin() + 5, s_to_insert.begin(), s_to_insert.end());
            // s_main becomes "FrontMiddleBack"
            std::cout << s_main << std::endl;
            ```

*   **`insert()` Fonksiyonlarının Geri Dönüş Değeri (10:04.560 - 12:41.740):**
    *   **İndeks Arayüzlü `insert()`:** Geri dönüş değeri `*this` (string nesnesinin kendisine bir referans). Bu, zincirleme çağrılara olanak tanır.
    *   **İteratör Arayüzlü `insert()`:** Geri dönüş değeri, eklenen *ilk* öğenin konumunu gösteren bir iteratördür. Bu, eklenen öğeye hemen erişmek veya sonraki işlemlerde kullanmak için önemlidir.
        *   **Örnek:**
            ```cpp
            std::string str = "ADEF"; // A D E F
                                      // 0 1 2 3
            // str.begin() + 1 (D'nin olduğu yer) konumuna '*' ekle
            auto it = str.insert(str.begin() + 1, '*');
            // str becomes "A*DEF"
            // it, eklenen '*' karakterini gösterir.
            std::cout << "String: " << str << std::endl;
            std::cout << "Inserted character: " << *it << std::endl;
            if (it != str.end() && (it + 1) != str.end()) {
                 std::cout << "Character after inserted: " << *(it + 1) << std::endl; // 'D'
            }
            ```

---

**4. `resize()` Fonksiyonu Detaylı İnceleme (13:19.480 - 18:52.060)**

*   **Tanım:** Sequence container'larda (örn: `std::vector`, `std::string`, `std::list`, `std::deque`) bulunan, konteynerin öğe sayısını (string için karakter sayısını/uzunluğunu) değiştiren bir fonksiyondur.
*   `reserve()` ile karıştırılmamalıdır. `reserve()` kapasiteyi ayarlar, `resize()` ise gerçek öğe sayısını (size/length) değiştirir.
*   **Kullanım Amaçları:**
    1.  **Boyutu Artırmak (Insertion):** Mevcut boyuttan daha büyük bir değere `resize` yapılırsa, string'in sonuna yeni karakterler eklenir.
    2.  **Boyutu Azaltmak (Erasure):** Mevcut boyuttan daha küçük bir değere `resize` yapılırsa, string'in sonundan karakterler silinir.
*   **Parametreler:**
    1.  `size_type count`: String'in yeni uzunluğu.
    2.  `charT ch` (opsiyonel): Eğer `count` mevcut uzunluktan büyükse, eklenecek karakterleri belirtir.
        *   Bu parametre verilmezse, default-constructed `charT` değeri kullanılır. `std::string` (yani `std::basic_string<char>`) için bu, null karakterdir (`\0`).
*   **Örnekler:**
    ```cpp
    std::string s = "Nazim"; // length = 5
    std::cout << "Original: [" << s << "], Length: " << s.length() << std::endl;

    // Boyutu artırma, '*' ile doldurma
    s.resize(10, '*'); // s becomes "Nazim*****"
    std::cout << "Resized to 10 with '*': [" << s << "], Length: " << s.length() << std::endl;

    // Boyutu artırma, null karakterlerle doldurma (default argüman)
    std::string s2 = "Test";
    s2.resize(8); // s2 becomes "Test\0\0\0\0" (ancak cout bunu "Test" olarak gösterebilir)
                  // Gerçek içeriği görmek için döngüyle veya debugger ile bakmak gerekir.
    std::cout << "Resized s2 to 8 (default char): [" << s2 << "], Length: " << s2.length() << std::endl;
    std::cout << "s2[4] is null: " << (s2[4] == '\0') << std::endl;


    // Boyutu azaltma
    s.resize(3); // s becomes "Naz"
    std::cout << "Resized to 3: [" << s << "], Length: " << s.length() << std::endl;

    // String'i tamamen boşaltma
    s.resize(0); // s becomes "" (empty string)
    std::cout << "Resized to 0: [" << s << "], Length: " << s.length() << std::endl;
    std::cout << "Is empty: " << std::boolalpha << s.empty() << std::endl;
    ```
*   **Not:** `resize(0)` string'i boşaltmanın yollarından biridir.

---

**5. `erase()` Fonksiyonları Detaylı İnceleme (18:56.620 - 32:30.920)**

*   STL konteynerlerinde silme işlemleri için temel fonksiyonlardır. `std::string` de bir konteyner olduğu için bu arayüzlere sahiptir.
*   İki ana arayüzü vardır: İteratör bazlı ve İndeks bazlı (string'e özel).

*   **İteratör Arayüzlü `erase()` (19:03.100 - 26:26.740):**
    *   Bu arayüz, `std::vector`, `std::list`, `std::deque` gibi birçok STL konteyneriyle ortaktır.
    *   **Tek Öğeyi Silme:** `iterator erase(const_iterator pos);`
        *   `pos`: Silinecek öğenin konumunu gösteren iteratör.
        *   **Geri Dönüş Değeri:** Silinen öğeden sonra gelen (silinmemiş) ilk öğenin konumunu gösteren bir iteratör. Eğer son öğe silinirse, konteynerin `end()` iteratörünü döndürür.
        *   **Örnek:**
            ```cpp
            std::string s = "Necati"; // N e c a t i
                                      // 0 1 2 3 4 5
            // 'c' karakterini (indeks 2) sil
            auto it = s.erase(s.begin() + 2);
            // s becomes "Neati"
            // it, 'a' karakterini gösterir (indeks 2'deki yeni karakter)
            std::cout << "String: " << s << std::endl;
            if (it != s.end()) {
                std::cout << "Iterator points to: " << *it << std::endl;
            }
            ```
    *   **Bir Aralıktaki (Range) Öğeleri Silme:** `iterator erase(const_iterator first, const_iterator last);`
        *   `first`: Silinecek aralığın başlangıcını gösteren iteratör (dahil).
        *   `last`: Silinecek aralığın sonunu gösteren iteratör (hariç). Yani `[first, last)` aralığı silinir.
        *   **Geri Dönüş Değeri:** `last` iteratörünün orijinal konumundaki (eğer silinmediyse) veya silinen aralıktan sonraki ilk öğenin konumunu gösteren bir iteratör.
        *   **Örnek:**
            ```cpp
            std::string s2 = "NecatiErgin"; // N e c a t i E r g i n
                                           // 0 1 2 3 4 5 6 7 8 9 10
            // "cati" kısmını (indeks 2'den başla, indeks 6'ya kadar ama 6 hariç) sil
            // s2.begin() + 2 -> 'c', s2.begin() + 6 -> 'E'
            auto it2 = s2.erase(s2.begin() + 2, s2.begin() + 6);
            // s2 becomes "NeErgin"
            // it2, 'E' karakterini gösterir
            std::cout << "String s2: " << s2 << std::endl;
            if (it2 != s2.end()) {
                std::cout << "Iterator it2 points to: " << *it2 << std::endl;
            }
            ```
        *   **Örnek (Döngüde İlk Karakteri Silme):**
            ```cpp
            std::string s_loop = "Hello";
            while(!s_loop.empty()){
                std::cout << s_loop << std::endl;
                s_loop.erase(s_loop.begin());
            }
            ```

*   **İndeks Arayüzlü `erase()` (String'e Özel) (26:27.740 - 30:55.720):**
    *   `string& erase(size_type index = 0, size_type count = std::string::npos);`
    *   `index`: Silmeye başlanacak karakterin indeksi.
    *   `count`: Silinecek karakter sayısı.
    *   **Davranışlar:**
        1.  `s.erase(idx, n);` : `idx` indeksinden başlayarak `n` karakter siler.
        2.  `s.erase(idx);` : `idx` indeksinden başlayarak string'in sonuna kadar tüm karakterleri siler. (Çünkü `count` için default argüman `std::string::npos` kullanılır).
        3.  `s.erase();` : Tüm string'i siler (boşaltır). (Çünkü `index` için default 0, `count` için default `npos` kullanılır).
    *   **Geri Dönüş Değeri:** `*this` (string nesnesinin kendisine referans).
    *   **Örnek:**
        ```cpp
        std::string s_idx = "AlihanBozkir";
        // "han" (indeks 3'ten başlayarak 3 karakter) sil
        s_idx.erase(3, 3); // s_idx becomes "AliBozkir"
        std::cout << "s_idx after erase(3,3): " << s_idx << std::endl;

        // "Bozkir" (indeks 3'ten sona kadar) sil
        s_idx.erase(3); // s_idx becomes "Ali"
        std::cout << "s_idx after erase(3): " << s_idx << std::endl;

        // Tüm string'i sil
        s_idx.erase(); // s_idx becomes ""
        std::cout << "s_idx after erase(): [" << s_idx << "], Is empty: " << s_idx.empty() << std::endl;
        ```

*   **String'i Tamamen Silmenin (Boşaltmanın) Yolları - Özet (30:56.820 - 35:00.120):**
    *   `s.clear();` (En yaygın ve okunaklı yöntem)
    *   `s = "";` (Boş C-string atama)
    *   `s.assign("");`
    *   `s.resize(0);`
    *   `s.erase();` (İndeks arayüzlü, parametresiz)
    *   `s.erase(0, std::string::npos);`
    *   `s.erase(s.begin(), s.end());` (İteratör arayüzlü)
    *   `s = std::string{};` (Default-constructed geçici string atama)

---

**6. `pop_back()` Fonksiyonu (36:28.200 - 37:57.520)**

*   Sequence container'larda (`std::vector`, `std::string`, `std::list`, `std::deque`) bulunur.
*   String'in (veya konteynerin) son karakterini (öğesini) siler.
*   Geri dönüş değeri `void`'dur (bir şey döndürmez).
*   **Önemli:** Boş bir string üzerinde `pop_back()` çağırmak tanımsız davranışa (undefined behavior) yol açar. Bu nedenle çağrı yapmadan önce string'in boş olup olmadığı kontrol edilmelidir (`!s.empty()`).
*   **Örnek:**
    ```cpp
    std::string s_pop = "Resul";
    std::cout << "Popping back from: " << s_pop << std::endl;
    while (!s_pop.empty()) {
        s_pop.pop_back();
        std::cout << "Current string: [" << s_pop << "]" << std::endl;
    }
    ```

---

Tamamdır, `std::string` arama fonksiyonlarından devam ediyoruz:

---

**7. `std::string` Arama Fonksiyonları (38:38.560 - 55:00.140)**

*   String içinde belirli bir karakteri, alt string'i veya karakter kümesinden birini aramak için kullanılır.
*   İsimleri genellikle `find` kelimesini içerir.
*   **Genel Özellikler (Tüm `find` Ailesi İçin):**
    1.  **Geri Dönüş Değeri:** `size_type`. Bulunan ilk eşleşmenin **indeksini** döndürürler.
    2.  **Bulunamama Durumu:** Eğer aranan öğe bulunamazsa, `std::string::npos` statik üye sabitini döndürürler. `npos`, genellikle `size_type`'ın alabileceği en büyük değerdir ve geçerli bir indeks olmaması garantilidir.
    3.  **Aramanın Başlangıç Pozisyonu:** Çoğu `find` fonksiyonu, aramanın nereden başlayacağını belirten opsiyonel bir `size_type pos = 0` parametresi alır.
        *   Eğer bu parametre verilmezse (veya 0 verilirse), arama string'in başından (`indeks 0`) başlar.
        *   Farklı bir `pos` değeri verilirse, arama o indeksten itibaren yapılır. Bu, aynı string içinde birden fazla eşleşmeyi bulmak için döngülerde kullanışlıdır.
*   **`find()` Fonksiyonu (Aramayı baştan sona yapar) (44:02.600 - 46:36.400, 48:21.460 - 49:30.380):**
    *   Belirli bir karakteri, C-string'i (null-terminated), `std::string` nesnesini veya belirli bir adresten başlayan belirli sayıda karakteri arar.
    *   **Overload'lar (Bazıları):**
        *   `size_type find(charT ch, size_type pos = 0) const;` (Tek karakter arama)
        *   `size_type find(const charT* s, size_type pos = 0) const;` (C-string arama)
        *   `size_type find(const charT* s, size_type pos, size_type count) const;` (`s` adresindeki ilk `count` karakteri arama)
        *   `size_type find(const std::basic_string& str, size_type pos = 0) const;` (Başka bir `std::string` arama)
    *   **Örnek (Tek karakter ve döngüsel arama):**
        ```cpp
        std::string text = "abracadabra";
        char target_char = 'a';
        size_type found_pos = 0; // Aramaya başlanacak pozisyon

        std::cout << "Finding all '" << target_char << "' in \"" << text << "\":" << std::endl;
        while ((found_pos = text.find(target_char, found_pos)) != std::string::npos) {
            std::cout << "Found '" << target_char << "' at index: " << found_pos << std::endl;
            text[found_pos] = '*'; // Bulunanı değiştirelim ki bir sonraki aramada tekrar bulunmasın
                                     // (ya da found_pos++ ile devam edilebilir)
            found_pos++; // Bir sonraki aramaya bulunan pozisyonun bir sonrasından başla
        }
        std::cout << "Modified text: " << text << std::endl; // "*br*c*d*br*"

        std::string s_find = "KahramanMaras";
        std::string key = "man";
        size_t pos_key = s_find.find(key);
        if (pos_key != std::string::npos) {
            std::cout << "\"" << key << "\" found at index: " << pos_key << std::endl; // 5
        } else {
            std::cout << "\"" << key << "\" not found." << std::endl;
        }
        ```

*   **`rfind()` Fonksiyonu (Aramayı sondan başa yapar) (46:39.140 - 48:10.000, 49:40.080 - 51:02.420):**
    *   `find()` ile aynı arananları kabul eder, ancak aramayı string'in sonundan başına doğru yapar.
    *   Döndürdüğü indeks hala string'in başından itibaren sayılan indekstir.
    *   **Aramanın Başlangıç Pozisyonu (`pos`):** `rfind` için `pos` parametresi, aramanın *hangi indeksten itibaren geriye doğru* yapılacağını belirtir. Eğer verilmezse, `std::string::npos` (veya string'in son indeksi) kabul edilir ve tüm string sondan başa taranır.
    *   **Örnek:**
        ```cpp
        std::string s_rfind = "banana";
        // Son 'na' yı bul
        size_t last_na = s_rfind.rfind("na");
        if (last_na != std::string::npos) {
            std::cout << "Last \"na\" in \"" << s_rfind << "\" found at index: " << last_na << std::endl; // 4
        }

        // İndeks 3'ten ('a') itibaren geriye doğru ilk 'na' yı bul
        size_t mid_na = s_rfind.rfind("na", 3);
        if (mid_na != std::string::npos) {
            std::cout << "Last \"na\" from index 3 backwards in \"" << s_rfind << "\" found at index: " << mid_na << std::endl; // 2
        }
        ```

*   **`find_first_of()` Fonksiyonu (Verilen kümedeki karakterlerden herhangi birinin ilkini bulur) (51:11.020 - 52:18.800):**
    *   Parametre olarak aldığı karakter kümesindeki (bu bir C-string, `std::string` veya belirli sayıda karakter olabilir) *herhangi bir* karakterin, ana string içinde bulunduğu *ilk* konumu arar.
    *   **Overload'lar (Bazıları):**
        *   `size_type find_first_of(const charT* s, size_type pos = 0) const;`
        *   `size_type find_first_of(const std::basic_string& str, size_type pos = 0) const;`
        *   `size_type find_first_of(charT ch, size_type pos = 0) const;`
    *   **Örnek:**
        ```cpp
        std::string text_ffo = "Hello World!";
        std::string chars_to_find = "oW!"; // 'o', 'W', veya '!' karakterlerinden birini ara

        size_t first_of_pos = text_ffo.find_first_of(chars_to_find);
        if (first_of_pos != std::string::npos) {
            std::cout << "In \"" << text_ffo << "\", one of \"" << chars_to_find
                      << "\" first found at index: " << first_of_pos
                      << " (character: '" << text_ffo[first_of_pos] << "')" << std::endl; // 4 ('o')
        }
        ```

*   **`find_first_not_of()` Fonksiyonu (Verilen kümede OLMAYAN karakterlerden herhangi birinin ilkini bulur) (52:18.880 - 53:20.100):**
    *   `find_first_of`'un tersidir. Parametre olarak aldığı karakter kümesinde *bulunmayan* bir karakterin, ana string içinde bulunduğu *ilk* konumu arar.
    *   **Örnek:**
        ```cpp
        std::string text_ffno = "123ABC456";
        std::string digits = "0123456789";

        // Rakam olmayan ilk karakteri bul
        size_t first_not_digit_pos = text_ffno.find_first_not_of(digits);
        if (first_not_digit_pos != std::string::npos) {
            std::cout << "In \"" << text_ffno << "\", first non-digit character found at index: "
                      << first_not_digit_pos << " (character: '"
                      << text_ffno[first_not_digit_pos] << "')" << std::endl; // 3 ('A')
        }
        ```

*   **`find_last_of()` Fonksiyonu (Verilen kümedeki karakterlerden herhangi birinin sonuncusunu bulur) (53:22.380 - 54:23.100):**
    *   `find_first_of` gibidir, ancak aramayı sondan başa yapar ve bulunan *son* eşleşmenin indeksini döndürür.
    *   **Örnek:**
        ```cpp
        std::string text_flo = "apple_pie_apple";
        std::string vowels = "aeiou";

        size_t last_vowel_pos = text_flo.find_last_of(vowels);
        if (last_vowel_pos != std::string::npos) {
            std::cout << "In \"" << text_flo << "\", last vowel found at index: "
                      << last_vowel_pos << " (character: '"
                      << text_flo[last_vowel_pos] << "')" << std::endl; // 14 ('e')
        }
        ```

*   **`find_last_not_of()` Fonksiyonu (Verilen kümede OLMAYAN karakterlerden herhangi birinin sonuncusunu bulur) (54:29.720 - 54:50.140):**
    *   `find_first_not_of` gibidir, ancak aramayı sondan başa yapar ve bulunan *son* eşleşmenin indeksini döndürür.
    *   **Örnek:**
        ```cpp
        std::string text_flno = "data_file.txt.bkp";
        std::string extensions = ".bkptx"; // . b k p t x karakterlerini içermeyen son karakter

        size_t last_not_ext_char_pos = text_flno.find_last_not_of(extensions);
        if (last_not_ext_char_pos != std::string::npos) {
            std::cout << "In \"" << text_flno << "\", last char not in \"" << extensions
                      << "\" found at index: " << last_not_ext_char_pos
                      << " (character: '" << text_flno[last_not_ext_char_pos] << "')" << std::endl; // 8 ('e')
        }
        ```
*   **Önemli Not:** `find_..._of` ve `find_..._not_of` fonksiyonları tek tek karakterler üzerinden küme eşleşmesi yapar, alt string (substring) araması yapmazlar.

---

**8. C++20 ile Gelen `starts_with()` ve `ends_with()` Fonksiyonları (56:02.500 - 59:51.320)**

*   Belirli bir string'in, verilen başka bir string (veya karakter, veya C-string) ile başlayıp başlamadığını (`starts_with`) veya bitip bitmediğini (`ends_with`) kontrol eder.
*   Bu fonksiyonlar C++20 standardı ile `std::string` sınıfına eklenmiştir.
*   **Geri Dönüş Değeri:** `bool` (`true` eğer başlıyor/bitiyorsa, `false` aksi halde).
*   **Overload'lar:** Genellikle tek karakter, C-string ve `std::string_view` (ve dolayısıyla `std::string`) parametreleri alabilirler.
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string>
    #include <string_view> // Gerekli olabilir

    int main() {
        std::string filename = "document_final_v2.pdf";
        std::string_view prefix = "document";
        char suffix_char = 'f';
        const char* suffix_cstr = ".pdf";

        if (filename.starts_with(prefix)) {
            std::cout << "\"" << filename << "\" starts with \"" << prefix << "\"" << std::endl;
        }
        if (filename.starts_with('d')) {
            std::cout << "\"" << filename << "\" starts with 'd'" << std::endl;
        }

        if (filename.ends_with(suffix_cstr)) {
            std::cout << "\"" << filename << "\" ends with \"" << suffix_cstr << "\"" << std::endl;
        }
        if (filename.ends_with(suffix_char)) { // Bu 'f' ile biter, true döner.
            std::cout << "\"" << filename << "\" ends with '" << suffix_char << "'" << std::endl;
        }
         if (filename.ends_with('x')) { // Bu 'x' ile bitmez, false döner.
            std::cout << "\"" << filename << "\" does not end with 'x'" << std::endl;
        } else {
            std::cout << "\"" << filename << "\" does not end with 'x'" << std::endl;
        }
        return 0;
    }
    ```

---

**9. C++23 ile Gelen `contains()` Fonksiyonu (01:00:02.500 - 01:03:23.580)**

*   Belirli bir string'in, verilen başka bir string'i (veya karakteri, C-string'i, `std::string_view`'ı) içerip içermediğini kontrol eder.
*   Bu fonksiyon C++23 standardı ile `std::string` sınıfına eklenmiştir.
*   **Geri Dönüş Değeri:** `bool` (`true` eğer içeriyorsa, `false` aksi halde).
*   `find()` fonksiyonunu çağırıp sonucun `std::string::npos` olup olmadığını kontrol etmek yerine daha okunaklı bir yol sunar.
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string>
    #include <string_view> // Gerekli olabilir

    int main() {
        std::string sentence = "The quick brown fox jumps over the lazy dog.";
        std::string_view sub = "brown fox";
        char ch = 'q';
        const char* c_str_sub = "lazy";

        if (sentence.contains(sub)) {
            std::cout << "\"" << sentence << "\" contains \"" << sub << "\"" << std::endl;
        }
        if (sentence.contains(ch)) {
            std::cout << "\"" << sentence << "\" contains '" << ch << "'" << std::endl;
        }
        if (sentence.contains("cat")) { // "cat" içermez
            std::cout << "\"" << sentence << "\" contains \"cat\"" << std::endl;
        } else {
            std::cout << "\"" << sentence << "\" does not contain \"cat\"" << std::endl;
        }
        return 0;
    }
    ```
    *Not: Bu kodu C++23 destekleyen bir derleyici ile derlemeniz gerekir.*

---

**10. `std::string` Toplama (Concatenation) Operatörleri (01:04:02.180 - 01:08:33.880)**

*   `operator+` (toplama operatörü) string'leri, C-string'leri ve karakterleri birleştirmek (concatenate) için overload edilmiştir.
*   Bu operatörler **global fonksiyonlar** olarak tanımlanmıştır (genellikle `std::literals::string_literals` namespace'i içinde veya `std` altında).
*   **Önemli:** `operator+` çağrısı yeni bir `std::string` nesnesi oluşturur ve döndürür; orijinal string'ler değişmez (bu bir mutator değildir).
*   **Geçerli Kombinasyonlar:**
    *   `std::string + std::string`
    *   `std::string + const char*`
    *   `const char* + std::string`
    *   `std::string + char`
    *   `char + std::string`
*   **Hatalı Kullanım (İki C-string'i doğrudan `+` ile toplamak):**
    *   `const char* + const char*` -> Bu işlem C++'da tanımlı değildir ve pointer aritmetiği olarak yorumlanmaya çalışılır, bu da genellikle derleme hatasına veya tanımsız davranışa yol açar.
    *   **Doğru Yöntem:** Operantlardan en az birinin `std::string` olması gerekir veya C-string'lerden birini explicit olarak `std::string`'e dönüştürmek gerekir.
*   **Örnek:**
    ```cpp
    std::string s1 = "Hello";
    std::string s2 = "World";
    const char* c_str = " C++";
    char exclamation = '!';

    std::string result1 = s1 + " " + s2; // "Hello World"
    std::cout << "result1: " << result1 << std::endl;

    std::string result2 = s1 + c_str; // "Hello C++"
    std::cout << "result2: " << result2 << std::endl;

    std::string result3 = c_str + s1; // " C++Hello" (Not: Baştaki boşluğa dikkat)
    // Daha iyi: std::string("C++") + s1; veya std::string(c_str + 1) + s1;
    std::cout << "result3: " << result3 << std::endl;


    std::string result4 = s1 + exclamation; // "Hello!"
    std::cout << "result4: " << result4 << std::endl;

    // Hatalı:
    // std::string error_result = "String1" + "String2"; // Derleme hatası
    // Doğrusu:
    std::string correct_result = std::string("String1") + "String2";
    // veya (C++14 ve sonrası User-Defined Literals ile)
    // using namespace std::string_literals;
    // std::string correct_result_s = "String1"s + "String2";
    std::cout << "correct_result: " << correct_result << std::endl;
    ```

---

Tamamdır, C++ User-Defined String Literals (`...`s) konusundan notlara devam ediyoruz:

---

**11. C++ User-Defined String Literals (`...`s) (01:08:41.960 - 01:12:37.140)**

*   C++14 standardı ile dile eklenen bir özelliktir.
*   Normal bir C-string literalinin (örn: `"text"`) sonuna `s` sonekini ekleyerek doğrudan bir `std::string` nesnesi oluşturulmasını sağlar.
*   Bu, özellikle string birleştirme (`operator+`) veya `auto` ile tür çıkarımı gibi durumlarda kodu daha okunaklı ve daha az hataya açık hale getirir.
*   **Kullanım:**
    1.  `#include <string>` başlık dosyasını dahil edin.
    2.  `using namespace std::string_literals;` veya `using namespace std::literals::string_literals;` (daha spesifik) using direktifini kullanın. Alternatif olarak, her kullanımda `std::literals::string_literals::operator""s` şeklinde tam niteleme yapılabilir ama bu pratik değildir.
*   **Farkı:**
    *   `"Merhaba"` ifadesinin türü `const char[8]` (ve ifadelere geçtiğinde `const char*`'a bozunur).
    *   `"Merhaba"s` ifadesinin türü doğrudan `std::string`'dir.
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string> // std::string için
    #include <typeinfo> // typeid için

    // Gerekli using direktifi
    using namespace std::string_literals;

    int main() {
        auto c_style_literal = "Bu bir C-string literalidir.";
        auto std_string_literal = "Bu bir std::string literalidir."s;

        std::cout << "c_style_literal type: " << typeid(c_style_literal).name() << std::endl;
        // Çıktı platforma ve derleyiciye göre değişebilir, ama const char* veya char[] türevi bir şey gösterir.
        // Örneğin: PKc (Pointer to Konstant Char)

        std::cout << "std_string_literal type: " << typeid(std_string_literal).name() << std::endl;
        // Çıktı platforma ve derleyiciye göre değişebilir, ama std::string ile ilgili bir şey gösterir.
        // Örneğin: NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
        // (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>)

        // String birleştirme örneği
        std::string name = "Necati"s;
        std::string surname = "Ergin"s;
        std::string fullName = name + " "s + surname; // " "s de bir std::string olur
        std::cout << "Full Name: " << fullName << std::endl;

        // Hatalı durumdan kaçınma
        // const char* str1 = "abc";
        // const char* str2 = "def";
        // auto combined_error = str1 + str2; // HATA!
        auto combined_correct = "abc"s + "def"; // DOĞRU! std::string + const char* (çünkü "def"s değil)
                                              // veya "abc"s + "def"s
        std::cout << "Combined Correct: " << combined_correct << std::endl;

        return 0;
    }
    ```
*   **`auto` ile Tür Çıkarımı:**
    *   `auto x = "oguzhan";` -> `x`'in türü `const char*` olur.
    *   `auto x = "oguzhan"s;` -> `x`'in türü `std::string` olur.
*   **Arka Plan:** `...s` aslında `operator""s` isimli bir *literal operatör fonksiyonunun* çağrılmasıdır. Bu operatör, `const char*` ve `size_t` (uzunluk) parametreleri alır ve bir `std::string` nesnesi döndürür. Bu konu daha ileri C++ konularındandır.

---

**12. String Literallerinin Türü: C vs C++ (01:09:03.680 - 01:09:59.080)**

*   **C dilinde:** Bir string literali (örn: `"text"`) `char[]` türündedir (elemanları `char` olan bir dizi). Bu, pratikte `char*` türüne bozunur. C'de string literallerini değiştirmek tanımsız davranıştır, ancak tür sistemi bunu `const` ile zorunlu kılmaz.
    ```c
    // C'de yasal (ama tehlikeli)
    char *p = "hello";
    // p[0] = 'H'; // Tanımsız davranış!
    ```
*   **C++ dilinde:** Bir string literali `const char[]` türündedir (elemanları `const char` olan bir dizi). Bu, pratikte `const char*` türüne bozunur. Bu `const` nitelemesi, string literallerinin değiştirilemez olduğunu derleme zamanında daha iyi ifade eder.
    ```cpp
    // C++'da
    const char *p_cpp = "world";
    // char *p_error_cpp = "world"; // Hata! (const char* dan char* a dönüşüm yok)
                                  // (Bazı eski derleyiciler uyarı verebilir veya izin verebilir,
                                  //  ancak modern C++'da bu bir hatadır)
    // p_cpp[0] = 'W'; // Hata! p_cpp const char* olduğu için.
    ```
*   Bu fark, özellikle C'den C++'a kod taşırken veya C ve C++ API'leri arasında çalışırken önemlidir.

---

**13. `std::string` ve STL Algoritmaları (01:13:00.840 - 01:19:43.860)**

*   `std::string`, karakterlerden oluşan bir STL konteyneridir. Bu nedenle, STL algoritma kütüphanesindeki (`<algorithm>`) birçok jenerik fonksiyon, `std::string` nesneleri üzerinde doğrudan kullanılabilir.
*   Bu, `std::string` sınıfının kendi üye fonksiyonları arasında bulunmayan bazı işlemlerin (örn: sıralama, ters çevirme, belirli bir koşula uyan tüm öğeleri silme) kolayca yapılabilmesini sağlar.
*   Algoritmalar genellikle iteratör çiftleri (`begin`, `end`) ile bir aralık (range) üzerinde çalışır.
*   **Örnekler:**
    *   **`std::sort` (Sıralama):** String'in karakterlerini ASCII/Unicode değerlerine göre sıralar.
        ```cpp
        #include <iostream>
        #include <string>
        #include <algorithm> // std::sort, std::reverse için
        #include <vector>    // std::begin, std::end (C++11 ve sonrası)

        int main() {
            std::string s_sort = "zyxwabc";
            std::sort(s_sort.begin(), s_sort.end());
            std::cout << "Sorted string: " << s_sort << std::endl; // "abcwxyz"

            // Büyükten küçüğe sıralama (reverse iteratörler veya custom karşılaştırıcı ile)
            std::sort(s_sort.rbegin(), s_sort.rend());
            std::cout << "Reverse sorted string: " << s_sort << std::endl; // "zyxw_cba"
        }
        ```
    *   **`std::reverse` (Ters Çevirme):** String'in karakter sırasını tersine çevirir.
        ```cpp
        // ... (yukarıdaki include'lar)
        std::string s_reverse = "Fatih Akgul";
        std::reverse(s_reverse.begin(), s_reverse.end());
        std::cout << "Reversed string: " << s_reverse << std::endl; // "lugkA hitaF"
        ```
    *   **"Global" Fonksiyon Terimi:** Hocanın "global fonksiyon" derken kastettiği, bir sınıfın üye fonksiyonu (member function) olmayan, genellikle bir namespace (örn: `std`) içinde tanımlanmış serbest (free) fonksiyonlardır. Global namespace'de olmak zorunda değildir.
*   **Trim İşlemi Gibi Durumlar:** Java veya C# gibi dillerde string sınıflarında `trim()` (baştaki ve sondaki boşlukları silme) gibi fonksiyonlar bulunurken, C++ `std::string`'de bu doğrudan yoktur. Ancak bu tür işlemler, STL algoritmaları (örn: `find_first_not_of`, `find_last_not_of` ve `erase`) kullanılarak birkaç adımda gerçekleştirilebilir. (Hoca bu örneği vermedi ama genel mantığı açıkladı).

---

**14. Konteynerlerde Belirli Değere Sahip Öğeleri Silme (C++20 Öncesi ve Sonrası) (01:20:05.480 - 01:32:11.480)**

*   **Senaryo 1: Belirli Bir Değere Sahip *İlk* Öğeyi Silmek (01:20:50.380 - 01:23:30.180)**
    *   Bu işlem genellikle iki adımdır:
        1.  `find()` (veya bir `find` ailesi üyesi) ile öğenin konumunu (iteratör veya indeks) bul.
        2.  Bulunan konumu `erase()` fonksiyonuna vererek sil.
    *   **Örnek:**
        ```cpp
        std::string s_first_erase = "AlihanBozkir";
        char char_to_erase = 'i';

        // İteratör ile
        auto it_found = std::find(s_first_erase.begin(), s_first_erase.end(), char_to_erase);
        if (it_found != s_first_erase.end()) {
            s_first_erase.erase(it_found); // İlk 'i' silinir.
        }
        std::cout << "After erasing first '" << char_to_erase << "': " << s_first_erase << std::endl; // "AlhanBozkir"

        // İndeks ile (string'e özel)
        s_first_erase = "AlihanBozkir"; // Reset
        size_t pos_found = s_first_erase.find(char_to_erase);
        if (pos_found != std::string::npos) {
            s_first_erase.erase(pos_found, 1); // pos_found'dan itibaren 1 karakter sil.
        }
        std::cout << "After erasing first '" << char_to_erase << "' (index based): " << s_first_erase << std::endl; // "AlhanBozkir"
        ```

*   **Senaryo 2: Belirli Bir Değere Sahip *Tüm* Öğeleri Silmek**
    *   **C++20 Öncesi: Erase-Remove Idiom (01:23:35.580 - 01:26:15.480)**
        1.  `std::remove(begin, end, value_to_remove)`: Bu algoritma, `value_to_remove` değerine eşit olmayan öğeleri aralığın başına taşır ve *silinmemiş* öğelerin sonunu gösteren bir iteratör (`new_end`) döndürür. **Fiziksel silme yapmaz, sadece öğeleri kaydırır.** Aralığın `[new_end, end)` kısmı "çöp" (belirsiz değerli) öğeler içerir.
        2.  `container.erase(new_end, container.end())`: Konteynerin `erase` üye fonksiyonu çağrılarak `new_end`'den itibaren sona kadar olan "çöp" öğeler fiziksel olarak silinir.
        *   **Dezavantajı:** İki adımlı olması ve silinen öğe sayısını doğrudan vermemesi.
        *   **Örnek:**
            ```cpp
            std::string s_erase_all_idiom = "Adanali kahraman pasa";
            char val_to_remove = 'a';

            // Adım 1: std::remove
            auto new_logical_end = std::remove(s_erase_all_idiom.begin(), s_erase_all_idiom.end(), val_to_remove);
            // s_erase_all_idiom şimdi "Adnli khrmn ps" + (eski 'a'ların olduğu çöp kısım) olabilir.
            // new_logical_end, ilk çöp karakteri gösterir.

            // Adım 2: Konteynerin erase üye fonksiyonu
            s_erase_all_idiom.erase(new_logical_end, s_erase_all_idiom.end());
            std::cout << "Erase-Remove Idiom for 'a': " << s_erase_all_idiom << std::endl; // "Adnli khrmn ps"
            ```
    *   **C++20 ve Sonrası: `std::erase(container, value)` Global Fonksiyonu (01:26:53.100 - 01:28:43.520)**
        *   `#include <string>` (veya ilgili konteyner başlığı) içinde tanımlanır.
        *   Yukarıdaki Erase-Remove idiomunu tek bir fonksiyon çağrısında yapar.
        *   **Geri Dönüş Değeri:** Silinen öğe sayısı (`size_type`).
        *   **Örnek:**
            ```cpp
            std::string s_std_erase = "Adanali kahraman pasa";
            char val_to_remove_std = 'a';

            size_t num_removed = std::erase(s_std_erase, val_to_remove_std);
            std::cout << "std::erase for 'a': " << s_std_erase << std::endl; // "Adnli khrmn ps"
            std::cout << "Number of 'a's removed: " << num_removed << std::endl; // 8
            ```

*   **Senaryo 3: Belirli Bir Koşula Uyan *Tüm* Öğeleri Silmek**
    *   **C++20 Öncesi: Erase-Remove-If Idiom (01:29:00.220 - 01:31:15.500)**
        1.  `std::remove_if(begin, end, predicate)`: `std::remove` gibidir, ancak üçüncü parametre olarak bir değer değil, bir *koşul (predicate)* alır. Bu koşul, `true` döndürdüğünde öğenin "silinmesi gerektiğini" işaret eden bir çağrılabilir (genellikle bir lambda ifadesi veya fonksiyon işaretçisi) olmalıdır.
        2.  `container.erase(new_end, container.end())`: Aynı şekilde fiziksel silme yapılır.
        *   **Örnek (Rakamları Silme):**
            ```cpp
            #include <cctype> // std::isdigit için

            std::string s_erase_if_idiom = "Ayhan123Oguzhan456Necati789";
            // std::remove_if ile rakam olanları işaretle
            auto new_end_if = std::remove_if(s_erase_if_idiom.begin(), s_erase_if_idiom.end(),
                                            [](unsigned char c){ return std::isdigit(c); });
            // Fiziksel silme
            s_erase_if_idiom.erase(new_end_if, s_erase_if_idiom.end());
            std::cout << "Erase-Remove-If Idiom for digits: " << s_erase_if_idiom << std::endl; // "AyhanOguzhanNecati"
            ```
    *   **C++20 ve Sonrası: `std::erase_if(container, predicate)` Global Fonksiyonu (01:31:16.260 - 01:32:11.480)**
        *   Erase-Remove-If idiomunu tek bir çağrıda yapar.
        *   **Geri Dönüş Değeri:** Silinen öğe sayısı (`size_type`).
        *   **Örnek (Rakamları Silme):**
            ```cpp
            std::string s_std_erase_if = "Ayhan123Oguzhan456Necati789";
            size_t num_digits_removed = std::erase_if(s_std_erase_if,
                                                     [](unsigned char c){ return std::isdigit(c); });
            std::cout << "std::erase_if for digits: " << s_std_erase_if << std::endl; // "AyhanOguzhanNecati"
            std::cout << "Number of digits removed: " << num_digits_removed << std::endl; // 9
            ```

---

Elbette, `std::string`'in C-string'e dönüştürülmesi ve global yardımcı fonksiyonlar konularıyla devam edelim:

---

**15. `std::string`'den C-string'e Dönüşüm: `c_str()` ve `data()` (01:32:48.900 - 01:38:03.860)**

*   `std::string` nesnesinin tuttuğu karakter dizisine, null-terminated C-stili bir string (yani `const char*`) olarak erişmek için kullanılırlar. Bu, C API'leriyle veya C-string bekleyen eski C++ fonksiyonlarıyla etkileşimde bulunurken çok önemlidir.

*   **`const char* c_str() const;`**
    *   Her zaman null-terminated bir karakter dizisinin başlangıç adresini döndürür.
    *   Döndürülen pointer `const char*` türündedir, yani bu pointer üzerinden string içeriği **değiştirilemez**.
    *   **Geçerlilik (Invalidation):** `std::string` nesnesi üzerinde herhangi bir **mutator** (değiştirici) fonksiyon (örn: `insert`, `erase`, `append`, `operator=`, `resize` vb.) çağrıldığında veya string nesnesi yok edildiğinde, daha önce `c_str()` ile alınmış olan pointer geçersiz hale gelebilir (dangling pointer). Bu nedenle, `c_str()` ile alınan pointer'ı uzun süre saklamak yerine, ihtiyaç duyulduğu anda alıp hemen kullanmak daha güvenlidir.
    *   **Kullanım Alanları:** C fonksiyonlarına (örn: `fopen`, `printf %s`, `strcmp`) veya C-string bekleyen API'lere string içeriğini geçmek.

*   **`char* data();` (C++11 öncesi ve non-const string için)**
*   **`const char* data() const;` (const string için veya C++11 ve sonrası her durumda)**
    *   **C++11 Öncesi:** `data()` fonksiyonu null-terminated bir sonuç döndürme garantisi **vermiyordu**. Sadece karakter dizisinin başlangıç adresini veriyordu. Eğer string boşsa null olmayan bir pointer döndürebilirdi.
    *   **C++11 ve Sonrası:** `data()` fonksiyonunun davranışı `c_str()` ile aynı hale getirilmiştir. Yani artık `data()` da null-terminated bir sonuç döndürür (eğer string boş değilse, son karakterden sonra bir `\0` olur). Boş string için `data()` çağrıldığında, yazılabilir bir `\0` karakterine işaret eden bir pointer döndürür.
    *   **Non-const `data()` (C++17'ye kadar vardı, C++20'de kaldırıldı gibi görünüyor, daha çok `const char* data() const` standardı):** Eskiden, const olmayan bir string için çağrıldığında `char*` döndürürdü. Bu, teorik olarak içeriğin değiştirilmesine izin verirdi, ancak bu çok tehlikeliydi çünkü string'in iç tutarlılığını (uzunluk bilgisi vb.) bozabilirdi. **Genel kural, `data()` veya `c_str()` ile alınan pointer üzerinden string'i değiştirmemektir.**
    *   **Güncel Durum (C++11 ve sonrası):** Pratikte `c_str()` ve `data()` arasında çok büyük bir fark kalmamıştır. Her ikisi de null-terminated karakter dizisine `const char*` erişimi sağlar. İkisi de aynı invalidation kurallarına tabidir. Genellikle `c_str()` tercih edilir çünkü amacı daha nettir (C-string'e erişim).
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string>
    #include <cstdio> // fopen, printf için
    #include <cstring> // strcmp için

    void print_c_string(const char* cstr_val) {
        printf("C-String: %s\n", cstr_val);
    }

    int main() {
        std::string my_str = "Hello C++";

        // c_str() kullanımı
        const char* c_ptr = my_str.c_str();
        print_c_string(c_ptr);
        std::cout << "Length using strlen: " << std::strlen(c_ptr) << std::endl;

        // data() kullanımı (C++11 sonrası c_str() gibi)
        const char* data_ptr = my_str.data();
        if (std::strcmp(data_ptr, "Hello C++") == 0) {
            std::cout << "data_ptr content is identical." << std::endl;
        }

        // Invalidation örneği (basit)
        std::string dynamic_str = "Initial";
        const char* ptr_before_modify = dynamic_str.c_str();
        std::cout << "Before modification: " << ptr_before_modify << std::endl;

        dynamic_str += " Content Added"; // String modifiye edildi

        // ptr_before_modify şimdi geçersiz olabilir! Tekrar almak gerekir.
        const char* ptr_after_modify = dynamic_str.c_str();
        std::cout << "After modification: " << ptr_after_modify << std::endl;

        // ÖNEMLİ: ptr_before_modify'ı burada kullanmak tehlikelidir.
        // printf("Trying to use stale ptr_before_modify: %s\n", ptr_before_modify); // TANIMSIZ DAVRANIŞ!

        return 0;
    }
    ```
*   **Tür Dönüştürme Operatörü Yok:** `std::string` sınıfının `const char*` türüne doğrudan bir tür dönüştürme operatörü (conversion operator) yoktur. Yani `const char* p = my_str;` gibi bir atama doğrudan çalışmaz; `my_str.c_str()` veya `my_str.data()` açıkça çağrılmalıdır.

---

**16. Global Yardımcı Fonksiyonlar (Non-Member Functions) (01:38:06.860 - 01:45:14.120)**

*   Modern C++ (özellikle C++11, C++17, C++20) ile birlikte, konteynerlerin bazı yaygın üye fonksiyonlarının global, jenerik karşılıkları eklenmiştir. Bunlar genellikle `<iterator>` veya `<string>` gibi başlık dosyalarında `std` namespace'i altında bulunur.
*   **Amaçları:**
    1.  **Jenerik Programlama Kolaylığı:** Şablon (template) kodlarında, farklı konteyner türleri (ve hatta C-stili diziler) için aynı arayüzle çalışmayı sağlar.
    2.  **Argument-Dependent Lookup (ADL) ile Uyumluluk:** Özel namespace'lerde tanımlı konteynerler için daha iyi çalışabilir.
    3.  **C-stili Dizilerle Kullanım:** En önemli faydalarından biri, C-stili diziler için de bu global fonksiyonların (örn: `std::begin`, `std::end`, `std::size`) overload'larının olmasıdır, bu da onlarla daha tutarlı bir şekilde çalışmayı sağlar.

*   **`std::begin(container)` ve `std::end(container)` (C++11):**
    *   `container.begin()` ve `container.end()` üye fonksiyonlarının global karşılıklarıdır.
    *   Bir konteynerin (veya C-stili dizinin) başlangıç ve bitiş (son elemandan bir sonraki) iteratörlerini döndürürler.
    *   **C-stili Dizi Örneği:**
        ```cpp
        #include <iostream>
        #include <vector> // std::begin, std::end için (genel iteratörler)
        #include <algorithm> // std::sort için

        int main() {
            int arr[] = {5, 1, 4, 2, 8};
            std::string str_for_global = "test";

            // C-stili dizi için std::begin ve std::end
            std::sort(std::begin(arr), std::end(arr));
            std::cout << "Sorted C-array: ";
            for (int i = 0; i < 5; ++i) {
                std::cout << arr[i] << " ";
            }
            std::cout << std::endl;

            // std::string için de kullanılabilir
            // std::sort(std::begin(str_for_global), std::end(str_for_global)); // Geçerli
            std::cout << "First char of string: " << *std::begin(str_for_global) << std::endl;
        }
        ```
    *   `std::cbegin`, `std::cend`, `std::rbegin`, `std::rend`, `std::crbegin`, `std::crend` gibi diğer iteratör döndüren üye fonksiyonların da global karşılıkları vardır.

*   **`std::size(container)` (C++17):**
    *   `container.size()` üye fonksiyonunun global karşılığıdır.
    *   Konteynerin (veya C-stili dizinin) eleman sayısını döndürür.
    *   C-stili diziler için `sizeof(arr) / sizeof(arr[0])` gibi ifadeler yazmak yerine `std::size(arr)` kullanmak daha güvenli ve okunaklıdır.

*   **`std::ssize(container)` (C++20):**
    *   `std::size` gibidir, ancak işaretli bir tamsayı türü (`std::ptrdiff_t` gibi) döndürür. Bu, bazı hesaplamalarda (negatif sonuçlar olasıysa) veya `unsigned` türlerle ilgili olası hatalardan kaçınmak için kullanışlıdır.

*   **`std::empty(container)` (C++17):**
    *   `container.empty()` üye fonksiyonunun global karşılığıdır.
    *   Konteynerin boş olup olmadığını (`bool`) döndürür.

*   **`std::data(container)` (C++17):**
    *   `container.data()` üye fonksiyonunun global karşılığıdır.
    *   Konteynerin altında yatan ardışık veri bloğunun başlangıç adresine bir pointer döndürür. `std::string` için bu `const char*` olur.
*   **Örnek (Global Fonksiyonların Toplu Kullanımı):**
    ```cpp
    #include <iostream>
    #include <string>
    #include <vector> // Global fonksiyonların başlık dosyası
    #include <iterator> // std::size, std::empty, std::data için de gerekebilir.

    int main() {
        std::string s = "example";
        int c_array[] = {10, 20, 30};

        if (!std::empty(s)) {
            std::cout << "String s is not empty." << std::endl;
            std::cout << "Size of s: " << std::size(s) << std::endl; // 7
            std::cout << "Signed size of s: " << std::ssize(s) << std::endl; // 7 (C++20)
            std::cout << "First char of s using std::begin: " << *std::begin(s) << std::endl; // 'e'
            std::cout << "Data pointer of s: " << std::data(s) << std::endl; // "example"
        }

        if (!std::empty(c_array)) { // C-dizisi için de çalışır
            std::cout << "C_array is not empty." << std::endl;
            std::cout << "Size of c_array: " << std::size(c_array) << std::endl; // 3
            std::cout << "Signed size of c_array: " << std::ssize(c_array) << std::endl; // 3 (C++20)
            std::cout << "First element of c_array: " << *std::begin(c_array) << std::endl; // 10
            std::cout << "Data pointer of c_array: " << *std::data(c_array) << std::endl; // 10
        }
        return 0;
    }
    ```

---

**17. `std::string` ve `swap` İşlemi (01:45:15.520 - 01:52:47.980)**

*   İki `std::string` nesnesinin içeriğini (ve kapasitelerini, diğer iç durumlarını) takas etmek için kullanılır.
*   **Verimlilik:** `std::string` için `swap` işlemi çok verimlidir (genellikle sabit zamanda, O(1)). Çünkü gerçek karakter verilerini kopyalamak yerine, string nesnelerinin içindeki pointer'ları (ve boyut/kapasite bilgilerini) takas eder. Bu, özellikle büyük string'ler için büyük bir performans avantajıdır.
*   **Kullanım Yolları:**
    1.  **Üye Fonksiyonu `swap()`:** `str1.swap(str2);`
    2.  **Global `std::swap()`:** `std::swap(str1, str2);`
        *   Global `std::swap`, `std::string` gibi türler için özelleştirilmiştir (specialized) veya ADL (Argument-Dependent Lookup) sayesinde verimli üye fonksiyonunu çağırır. Bu nedenle, genellikle jenerik kodda `std::swap` tercih edilir.
*   **Yanlış Yöntem (Manuel Swap):**
    ```cpp
    // KÖTÜ - VERİMSİZ!
    std::string temp = str1;
    str1 = str2;
    str2 = temp;
    ```
    Bu yöntem, üç adet derin kopyalama (deep copy) ve potansiyel bellek ayırma/bırakma işlemi yapar, bu da çok maliyetlidir.
*   **Doğru Yöntem Örneği:**
    ```cpp
    #include <iostream>
    #include <string>
    #include <algorithm> // std::swap için

    int main() {
        std::string s_swap1 = "String Alpha";
        std::string s_swap2 = "Another Beta String";

        std::cout << "Before swap:\n";
        std::cout << "s_swap1: " << s_swap1 << std::endl;
        std::cout << "s_swap2: " << s_swap2 << std::endl;

        // Yöntem 1: Üye fonksiyonu
        // s_swap1.swap(s_swap2);

        // Yöntem 2: Global std::swap (tercih edilen)
        std::swap(s_swap1, s_swap2);

        std::cout << "\nAfter swap:\n";
        std::cout << "s_swap1: " << s_swap1 << std::endl;
        std::cout << "s_swap2: " << s_swap2 << std::endl;

        return 0;
    }
    ```
*   **`std::swap` ve Taşıma Semantiği (Move Semantics) (01:48:39.340 - 01:52:45.100):**
    *   C++11 öncesi, jenerik `std::swap` kopyalama semantiği kullanıyordu (`T temp = a; a = b; b = temp;`).
    *   C++11 ve sonrası, jenerik `std::swap` taşıma semantiğini kullanır:
        ```cpp
        // template<class T>
        // void swap(T& a, T& b) {
        //     T temp = std::move(a);
        //     a = std::move(b);
        //     b = std::move(temp);
        // }
        ```
    *   Bu, `std::string` gibi taşıma semantiğini verimli bir şekilde destekleyen türler için zaten hızlı olan `swap`'ı daha da genel hale getirir. Ayrıca, yalnızca taşınabilir (move-only) türlerin de `std::swap` ile takas edilebilmesini sağlar.
    *   **Moved-from State:** `std::swap` örneği, "moved-from state" (üzerinden taşıma yapılmış nesne) kavramının önemini gösterir. `a = std::move(b)` yapıldıktan sonra `b` moved-from state'e geçer, ancak hemen ardından `b = std::move(temp)` ile ona yeni bir değer atanır. Bu, moved-from state'deki nesnelerin hala geçerli (valid) ama belirsiz (unspecified) bir durumda olduğunu ve onlara yeni değer atanabileceğini gösterir.

---

Harika, `shrink_to_fit()`, `replace()` ve `substr()` fonksiyonları ile devam edelim:

---

**18. `shrink_to_fit()` Fonksiyonu (01:52:49.040 - 01:55:59.740)**

*   C++11 ile `std::vector`, `std::deque` ve `std::string` gibi konteynerlere eklenmiştir.
*   **Amacı:** Konteynerin kapasitesini (`capacity()`) mevcut öğe sayısına (`size()` veya `length()`) mümkün olduğunca yaklaştırmak için bir "talepte" (request) bulunmaktır.
*   **Davranış:**
    *   String'in kapasitesi genellikle sadece büyür (öğe eklendikçe), ancak öğeler silindiğinde otomatik olarak küçülmez. Bu, sık sık büyüyüp küçülen string'lerde gereksiz yere fazla bellek tutulmasına neden olabilir.
    *   `shrink_to_fit()` çağrıldığında, implementasyon genellikle yeni, daha küçük bir bellek bloğu ayırır, mevcut öğeleri bu yeni bloğa kopyalar/taşır ve eski büyük bloğu serbest bırakır.
*   **Garanti Yok (Non-binding Request):** Standart, `shrink_to_fit()` çağrısının kapasiteyi gerçekten azaltacağını **garanti etmez**. Bu, sadece bir "isteğimdir". Ancak çoğu modern C++ implementasyonu bu isteğe uyar ve kapasiteyi azaltır.
*   **Ne Zaman Kullanılır:** Bir string'in maksimum boyutuna ulaştığını ve bundan sonra çok fazla küçüleceğini (veya bir daha büyümeyeceğini) bildiğiniz durumlarda, kullanılmayan fazla belleği sisteme geri vermek için çağrılabilir. Ancak sık sık çağrılması (özellikle string tekrar büyüyecekse) maliyetli olabilir çünkü bellek yeniden ayırma ve kopyalama/taşıma işlemleri içerir.
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string>

    int main() {
        std::string s;
        std::cout << "Initial - Size: " << s.size() << ", Capacity: " << s.capacity() << std::endl;

        s.reserve(1000); // Büyük bir kapasite ayıralım
        std::cout << "After reserve(1000) - Size: " << s.size() << ", Capacity: " << s.capacity() << std::endl;

        s = "Some short text"; // Stringe kısa bir içerik atayalım
        std::cout << "After assignment - Size: " << s.size() << ", Capacity: " << s.capacity() << std::endl;
        // Kapasite hala büyük olabilir (örn: 1000 veya daha fazla)

        s.shrink_to_fit(); // Kapasiteyi küçültme talebi
        std::cout << "After shrink_to_fit() - Size: " << s.size() << ", Capacity: " << s.capacity() << std::endl;
        // Kapasite şimdi size'a çok daha yakın olmalı (örn: 15, 22 gibi)

        // Örnek (Hocanın verdiği)
        std::string s_large(400000, 'A');
        std::cout << "Large string - Size: " << s_large.size()
                  << ", Capacity: " << s_large.capacity() << std::endl;

        s_large.erase(50); // String'in çoğunu sil, size 50 olur
        std::cout << "After erase(50) - Size: " << s_large.size()
                  << ", Capacity: " << s_large.capacity() << std::endl; // Kapasite hala büyük

        s_large.shrink_to_fit();
        std::cout << "After shrink_to_fit - Size: " << s_large.size()
                  << ", Capacity: " << s_large.capacity() << std::endl; // Kapasite küçülmüş olmalı

        return 0;
    }
    ```

---

**19. `replace()` Fonksiyonları (01:56:00.320 - 01:59:46.480)**

*   `std::string` nesnesinin belirli bir bölümünü (bir alt string'i) başka bir karakter dizisiyle değiştirmek için kullanılır.
*   `erase()` ve ardından `insert()` işlemlerinin bir kombinasyonu gibi düşünülebilir, ancak genellikle daha optimize edilmiştir.
*   Çok sayıda overload'u vardır, hem indeks tabanlı hem de iteratör tabanlı arayüzler sunar.
*   **Genel Yapı (İndeks Tabanlı - Birkaç Örnek):**
    *   `string& replace(size_type pos, size_type count, const std::basic_string& str_to_insert);`
        *   `pos`: Değiştirilecek bölümün başlangıç indeksi.
        *   `count`: `pos`'tan itibaren değiştirilecek karakter sayısı.
        *   `str_to_insert`: Yerine konulacak `std::string`.
    *   `string& replace(size_type pos, size_type count, const charT* cstr_to_insert);`
        *   `cstr_to_insert`: Yerine konulacak C-string.
    *   `string& replace(size_type pos, size_type count, size_type count2, charT ch);`
        *   `count2`: `ch` karakterinden `count2` tane konulur.
    *   `string& replace(const_iterator first, const_iterator last, const std::basic_string& str_to_insert);` (İteratör tabanlı)
        *   `[first, last)` aralığı `str_to_insert` ile değiştirilir.
*   **Geri Dönüş Değeri:** Genellikle `*this` (string nesnesinin kendisine referans).
*   **Örnek (İndeks Tabanlı):**
    ```cpp
    #include <iostream>
    #include <string>

    int main() {
        std::string s = "This is an old string.";
        std::cout << "Original: " << s << std::endl;

        // "old" (indeks 11, uzunluk 3) kısmını "new" ile değiştir
        s.replace(11, 3, "new");
        std::cout << "After replace 1: " << s << std::endl; // "This is an new string."

        // " string" (indeks 14, uzunluk 7) kısmını " example" ile değiştir
        std::string replacement_str = " example";
        s.replace(14, 7, replacement_str);
        std::cout << "After replace 2: " << s << std::endl; // "This is an new example."

        // "This" (indeks 0, uzunluk 4) kısmını 5 tane 'X' ile değiştir
        s.replace(0, 4, 5, 'X');
        std::cout << "After replace 3: " << s << std::endl; // "XXXXX is an new example."

        // İteratör tabanlı örnek
        std::string s_iter = "abcdefgh";
        // "cde" kısmını (s_iter.begin()+2 den s_iter.begin()+5 e kadar) "XYZ" ile değiştir
        s_iter.replace(s_iter.begin() + 2, s_iter.begin() + 5, "XYZ");
        std::cout << "After iter_replace: " << s_iter << std::endl; // "abXYZfgh"

        return 0;
    }
    ```
*   Hoca, tüm overload'ları detaylandırmadı, genel mantığın anlaşılmasının yeterli olduğunu belirtti.

---

**20. `substr()` Fonksiyonu (01:59:47.180 - 02:02:20.640)**

*   `std::string` nesnesinden bir alt string (substring) kopyası oluşturur ve bu yeni kopyayı **yeni bir `std::string` nesnesi olarak** döndürür.
*   Orijinal string değişmez.
*   **Parametreler:**
    1.  `size_type pos = 0`: Alt string'in başlayacağı indeks.
    2.  `size_type count = std::string::npos`: Alt string'e alınacak karakter sayısı.
        *   Eğer `count` verilmezse veya `std::string::npos` olarak verilirse, `pos` indeksinden itibaren string'in sonuna kadar tüm karakterler alınır.
        *   Eğer `pos + count` orijinal string'in boyutunu aşarsa, sadece `pos`'tan sona kadar olan karakterler alınır (hata vermez, mevcut olanı alır).
        *   Eğer `pos` string'in boyutuna eşit veya büyükse, `std::out_of_range` exception fırlatılır.
*   **Geri Dönüş Değeri:** İstenen alt string'i içeren yeni bir `std::string` nesnesi.
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string>
    #include <stdexcept> // std::out_of_range için

    int main() {
        std::string s = "HelloWorld";
                            //0123456789

        // "World" kısmını al (indeks 5'ten başlayarak sonuna kadar)
        std::string sub1 = s.substr(5);
        std::cout << "sub1 (from index 5): " << sub1 << std::endl; // "World"

        // "Hello" kısmını al (indeks 0'dan başlayarak 5 karakter)
        std::string sub2 = s.substr(0, 5);
        std::cout << "sub2 (index 0, count 5): " << sub2 << std::endl; // "Hello"

        // "loW" kısmını al (indeks 3'ten başlayarak 3 karakter)
        std::string sub3 = s.substr(3, 3);
        std::cout << "sub3 (index 3, count 3): " << sub3 << std::endl; // "loW"

        // Tüm string'in bir kopyasını al (parametre yok veya (0, npos))
        std::string sub_copy = s.substr(); // veya s.substr(0, std::string::npos)
        std::cout << "sub_copy (full copy): " << sub_copy << std::endl; // "HelloWorld"

        try {
            // Geçersiz pozisyon
            std::string sub_error = s.substr(20); // Hata: out_of_range
            std::cout << "This won't be printed: " << sub_error << std::endl;
        } catch (const std::out_of_range& oor) {
            std::cerr << "Out of Range error: " << oor.what() << std::endl;
        }

        return 0;
    }
    ```
*   **Önemli Not:** `substr()` her çağrıldığında yeni bir string nesnesi oluşturur ve karakterleri kopyalar. Büyük string'lerin substring'leri üzerinde sık sık salt okuma amaçlı çalışılacaksa ve performans kritikse, `std::string_view` (C++17) daha iyi bir alternatif olabilir.

---

**21. `std::string_view` Kavramına Giriş (Performans ve Kopyalama Maliyeti) (02:02:20.640 - 02:13:00.380)**

*   **İhtiyaç:** `std::string::substr()` veya string'leri fonksiyonlara değerle (by value) geçmek, yeni bellek ayırmayı ve karakter kopyalamayı gerektirir. Büyük string'ler ve sık substring işlemleri için bu maliyetli olabilir. Özellikle salt okuma (read-only) senaryolarında bu kopyalama gereksizdir.
*   **`std::string_view` (C++17):**
    *   Başlık dosyası: `<string_view>`
    *   Bir karakter dizisine (bu dizi bir `std::string`, C-string literal, `char` dizisi veya başka bir `std::string_view` olabilir) **sahip olmayan (non-owning)** bir "görünümdür".
    *   Temelde, gözlemlediği karakter dizisinin başlangıcına bir pointer ve dizinin uzunluğunu tutar.
    *   **Avantajları:**
        1.  **Kopyalama Yok:** `std::string_view` oluşturmak çok hızlıdır çünkü sadece bir pointer ve bir uzunluk kopyalanır, karakter verileri kopyalanmaz.
        2.  **Bellek Ayırma Yok:** Yeni bellek ayırmaz.
        3.  **Arayüz:** `std::string`'in birçok `const` üye fonksiyonuna (örn: `length`, `size`, `operator[]`, `substr` (yeni bir `string_view` döndürür), `find` ailesi vb.) sahiptir. Bu sayede `std::string` gibi kullanılabilir (salt okuma işlemleri için).
    *   **Dezavantajları / Dikkat Edilmesi Gerekenler:**
        1.  **Dangling View Tehlikesi:** `std::string_view`, altında yatan karakter dizisine sahip olmadığı için, eğer o orijinal dizi yok edilirse veya geçerliliğini yitirirse, `string_view` geçersiz (dangling) hale gelir. Bu, C-string literalleri (genellikle program ömrü boyunca geçerli) veya ömrü `string_view`'dan uzun olan `std::string` nesneleri için bir sorun değildir, ancak geçici `std::string` nesnelerinden `string_view` oluştururken dikkatli olunmalıdır.
            ```cpp
            std::string_view get_sv() {
                std::string temp = "temporary";
                return temp; // KÖTÜ! temp yok olacak, dönen string_view dangling olacak.
            }
            // Doğrusu:
            // std::string get_string() { return "persistent_enough"; }
            // std::string_view sv = get_string(); // Bu da riskli olabilir, eğer get_string geçici döndürüyorsa.
            // En güvenlisi:
            // std::string persisted_str = "live long";
            // std::string_view safe_sv = persisted_str;
            ```
        2.  **Null Sonlandırma Garantisi Yok:** Bir `std::string_view`, gözlemlediği karakter dizisinin null-terminated olmasını garanti etmez (eğer bir C-string veya `std::string`'den oluşturulmadıysa). `data()` fonksiyonu bir pointer döndürür, ancak bunun sonrasında `\0` olacağı garanti değildir. `std::string`'den oluşturulan `string_view`'lar genellikle bu sorunu yaşamaz.
    *   **Kullanım Alanları:**
        *   Fonksiyonlara string parametrelerini (özellikle salt okuma amaçlıysa) kopyalama maliyeti olmadan geçmek.
        *   Büyük metin dosyalarını işlerken parçalara (substring'lere) kopyalama yapmadan erişmek.
*   **`std::span` (C++20):** `std::string_view`'ın daha jenerik bir versiyonudur; sadece karakterler için değil, bellekte ardışık (contiguous) herhangi bir türden öğe dizisi için bir "görünüm" sağlar.

---

Elbette, `std::string` ile ilgili I/O işlemleri, sayısal dönüşümler ve `copy()` fonksiyonuyla devam edelim:

---

**22. `std::string` ve Giriş/Çıkış (I/O) İşlemleri (02:17:51.020 - 02:23:04.320)**

*   `std::string` nesneleri, C++ I/O akışları (`<iostream>`, `<fstream>`, `<sstream>`) ile kolayca kullanılabilir.
*   **Çıkış (Output) - `operator<<` (Insertion Operator):**
    *   `std::ostream` (örn: `std::cout`, `std::ofstream` nesneleri) için overload edilmiştir.
    *   Bir `std::string` nesnesini doğrudan bir çıkış akışına yazdırabilirsiniz.
    ```cpp
    std::string greeting = "Hello, User!";
    std::cout << greeting << std::endl;
    ```

*   **Giriş (Input):**
    *   **Formatlı Giriş - `operator>>` (Extraction Operator):**
        *   `std::istream` (örn: `std::cin`, `std::ifstream` nesneleri) için overload edilmiştir.
        *   Bir giriş akışından bir `std::string`'e okuma yapar.
        *   **Davranış:** Varsayılan olarak, baştaki boşluk karakterlerini (whitespace: boşluk, tab, newline vb.) atlar, ardından boşluk olmayan ilk karakterden bir sonraki boşluk karakterine kadar olan karakterleri okur ve string'e atar. Yani kelime kelime okuma yapar.
        *   **Örnek:**
            ```cpp
            #include <iostream>
            #include <string>

            int main() {
                std::string firstName, lastName;
                std::cout << "Enter your first and last name: "; // Örneğin: "John Doe"
                std::cin >> firstName >> lastName; // firstName "John", lastName "Doe" olur.

                std::cout << "First name: " << firstName << std::endl;
                std::cout << "Last name: " << lastName << std::endl;
                return 0;
            }
            ```
    *   **Satır Bazlı Giriş - `std::getline(istream& is, string& str, char delim = '\n');`:**
        *   `#include <string>` başlık dosyasında tanımlı global bir fonksiyondur.
        *   Bir giriş akışından ( `is` ) bir string'e ( `str` ) tüm bir satırı (veya belirli bir sınırlayıcı `delim` karakterine kadar olan kısmı) okur.
        *   **Parametreler:**
            1.  `istream& is`: Okuma yapılacak giriş akımı (örn: `std::cin`, bir `std::ifstream` nesnesi).
            2.  `string& str`: Okunan verinin depolanacağı `std::string` nesnesi (referans olarak alınır).
            3.  `char delim` (opsiyonel): Okumayı sonlandıracak sınırlayıcı karakter. Varsayılan değeri `'\n'` (newline) karakteridir. Sınırlayıcı karakter akımdan okunur ve atılır, ancak `str` string'ine dahil edilmez.
        *   **Kullanım:** Boşluk içeren kullanıcı girdilerini (örn: tam cümleler, adresler) okumak için idealdir.
        *   **Örnek:**
            ```cpp
            #include <iostream>
            #include <string>

            int main() {
                std::string fullName;
                std::cout << "Enter your full name: ";
                std::getline(std::cin, fullName); // Tüm satırı okur
                std::cout << "Full name entered: " << fullName << std::endl;

                std::string data_line;
                std::cout << "Enter data until a semicolon: ";
                std::getline(std::cin, data_line, ';'); // Noktalı virgüle kadar okur
                std::cout << "Data up to semicolon: " << data_line << std::endl;
                return 0;
            }
            ```
        *   **`std::cin` ile `std::getline` Karışık Kullanımı:** `std::cin >> var;` çağrısından sonra `std::getline(std::cin, ...)` çağrısı yapılacaksa, `std::cin`'in buffer'ında kalan newline karakteri sorun yaratabilir. `std::getline` bu newline'ı hemen okuyup boş bir satır olarak algılayabilir. Çözüm olarak, `std::cin.ignore()` kullanılabilir:
            ```cpp
            // int age;
            // std::string name;
            // std::cout << "Enter age: ";
            // std::cin >> age;
            // std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Newline'ı temizle
            // std::cout << "Enter name: ";
            // std::getline(std::cin, name);
            ```

---

**23. Sayısal Dönüşümler (String <-> Sayı) (02:23:05.380 - 02:35:53.580)**

*   `std::string` nesnelerinde tutulan sayısal ifadeleri gerçek sayı türlerine (int, double vb.) veya tam tersini yapmak için C++11 ile standart kütüphaneye fonksiyonlar eklenmiştir. Bunlar `<string>` başlık dosyasında bulunur.

*   **String'den Sayıya Dönüşüm (Parsing - S to X Ailesi):**
    *   Fonksiyon isimleri genellikle `sto` (string to) ile başlar: `stoi` (string to int), `stol` (string to long), `stoul` (string to unsigned long), `stoll` (string to long long), `stoull` (string to unsigned long long), `stof` (string to float), `stod` (string to double), `stold` (string to long double).
    *   **Genel Parametre Yapısı (örn: `stoi`):**
        `int stoi(const std::string& str, std::size_t* pos = nullptr, int base = 10);`
        1.  `const std::string& str`: Dönüştürülecek string.
        2.  `std::size_t* pos` (opsiyonel, default `nullptr`): Eğer `nullptr` değilse, fonksiyon bu pointer'ın gösterdiği `std::size_t` değişkenine, string içinde sayısal dönüşüm için **kullanılmayan ilk karakterin indeksini** yazar. Eğer tüm string kullanıldıysa, string'in `length()` değerini yazar. Bu, string'in geri kalanını ayrıca işlemek için kullanışlıdır.
        3.  `int base` (opsiyonel, default `10`): Sayının yorumlanacağı taban (örn: 10 için onluk, 16 için hexadecimal, 8 için octal, 2 için binary). Eğer `base` 0 ise, taban string'in ön ekine göre belirlenir (`0x` için 16, `0` için 8, aksi halde 10).
    *   **Exception'lar:**
        *   `std::invalid_argument`: String'in başında geçerli bir sayısal ifade bulunamazsa.
        *   `std::out_of_range`: Dönüştürülen sayı, hedef türün (örn: `int`) sınırlarının dışındaysa.
    *   **Örnek:**
        ```cpp
        #include <iostream>
        #include <string>
        #include <stdexcept> // std::invalid_argument, std::out_of_range

        int main() {
            std::string s_dec = "12345 trailing text";
            std::string s_hex = "0x1A Lipsum";
            std::string s_oct = "077"; // base 0 ile 8'lik olarak yorumlanır
            std::string s_float = "-3.14e-2";
            std::string s_invalid = "not_a_number";

            std::size_t chars_processed;

            try {
                int val_dec = std::stoi(s_dec, &chars_processed);
                std::cout << "Decimal: " << val_dec << ", Chars processed: " << chars_processed
                          << ", Remainder: \"" << s_dec.substr(chars_processed) << "\"" << std::endl;
                // Çıktı: Decimal: 12345, Chars processed: 5, Remainder: " trailing text"

                long val_hex = std::stol(s_hex, nullptr, 16); // veya base 0
                std::cout << "Hex (as long): " << val_hex << std::endl; // 26

                int val_oct = std::stoi(s_oct, nullptr, 0); // base 0 ile 077 -> 63 (onluk)
                std::cout << "Octal (077) with base 0: " << val_oct << std::endl;


                double val_double = std::stod(s_float, &chars_processed);
                std::cout << "Double: " << val_double << ", Chars processed: " << chars_processed << std::endl;
                // Çıktı: Double: -0.0314, Chars processed: 8

                // Geçersiz dönüşüm denemesi
                // int val_inv = std::stoi(s_invalid); // std::invalid_argument fırlatır
            } catch (const std::invalid_argument& ia) {
                std::cerr << "Invalid argument: " << ia.what() << std::endl;
            } catch (const std::out_of_range& oor) {
                std::cerr << "Out of range: " << oor.what() << std::endl;
            }
            return 0;
        }
        ```

*   **Sayıdan String'e Dönüşüm (Formatting - `to_string` Ailesi):**
    *   `std::to_string(value)` global fonksiyonu kullanılır.
    *   Çeşitli sayısal türler ( `int`, `long`, `unsigned long`, `long long`, `unsigned long long`, `float`, `double`, `long double` ) için overload edilmiştir.
    *   Parametre olarak aldığı sayısal değeri bir `std::string`'e dönüştürür ve bu yeni string'i döndürür.
    *   Formatlama üzerinde çok fazla kontrol sunmaz (örn: ondalık hassasiyeti, genişlik). Daha detaylı formatlama için `<sstream>` ( `std::ostringstream` ) veya C++20 ile gelen `<format>` kütüphanesi kullanılabilir.
    *   **Örnek:**
        ```cpp
        #include <iostream>
        #include <string>

        int main() {
            int i_val = 42;
            double d_val = 3.14159;
            unsigned long ul_val = 1234567890UL;

            std::string s_i = std::to_string(i_val);
            std::string s_d = std::to_string(d_val);
            std::string s_ul = std::to_string(ul_val);

            std::cout << "Int to string: \"" << s_i << "\"" << std::endl;
            std::cout << "Double to string: \"" << s_d << "\"" << std::endl;
            std::cout << "Unsigned long to string: \"" << s_ul << "\"" << std::endl;

            // String birleştirme ile kullanımı
            std::string filename = "log_" + std::to_string(2024) + ".txt";
            std::cout << "Generated filename: " << filename << std::endl;

            return 0;
        }
        ```

---

**24. `copy()` Fonksiyonu (Bir String'in İçeriğini Bir Karakter Dizisine Kopyalama) (02:35:53.880 - 02:40:54.180)**

*   `size_type copy(charT* dest, size_type count, size_type pos = 0) const;`
*   `std::string` nesnesinin bir bölümünü, kullanıcı tarafından sağlanan bir `char` (veya `charT`) dizisine ( `dest` ) kopyalar.
*   **Parametreler:**
    1.  `charT* dest`: Kopyalamanın yapılacağı hedef karakter dizisinin başlangıç adresi. Bu dizinin `count` kadar karakteri alabilecek kadar büyük olması ve geçerli bir bellek alanına işaret etmesi çağırıcının sorumluluğundadır.
    2.  `size_type count`: Kopyalanacak maksimum karakter sayısı.
    3.  `size_type pos` (opsiyonel, default `0`): Kaynak `std::string` içinde kopyalamanın başlayacağı indeks.
*   **Geri Dönüş Değeri:** `size_type` türünde, gerçekten kopyalanan karakter sayısı. Bu sayı `count`'tan veya string'in `pos`'tan sonraki kalan karakter sayısından küçük olanıdır.
*   **ÖNEMLİ:** `copy()` fonksiyonu, hedef diziye ( `dest` ) bir null sonlandırıcı (`\0`) **EKLEMEZ**. Eğer kopyalanan veriyi bir C-string olarak kullanmak istiyorsanız, null sonlandırıcıyı manuel olarak eklemeniz gerekir.
*   **Kullanım:** Genellikle `std::string` verisini, null sonlandırıcıya ihtiyaç duymayan veya kendi sonlandırma mekanizması olan C-stili API'lere veya veri yapılarına aktarmak için kullanılır.
*   **Örnek:**
    ```cpp
    #include <iostream>
    #include <string>
    #include <vector> // std::vector<char> için
    #include <cstdio> // puts için

    int main() {
        std::string source_str = "Fatih Akgul";
                        //01234567890

        char buffer[100];
        std::size_t chars_copied;

        // Tüm string'i kopyala (ilk 100 karakterini veya string boyutu kadarını)
        chars_copied = source_str.copy(buffer, 99, 0); // 99, buffer'da null için yer bırakır
        buffer[chars_copied] = '\0'; // Manuel null sonlandırma
        std::cout << "Copied to buffer: ";
        puts(buffer); // C-string olarak yazdır
        std::cout << "Characters copied: " << chars_copied << std::endl;

        // String'in bir parçasını kopyala ("Akgul" kısmı)
        char part_buffer[20];
        // "Akgul" -> indeks 6, uzunluk 5
        chars_copied = source_str.copy(part_buffer, 5, 6);
        part_buffer[chars_copied] = '\0'; // Manuel null sonlandırma
        std::cout << "Copied part: ";
        puts(part_buffer);
        std::cout << "Characters copied for part: " << chars_copied << std::endl;

        // Eğer count, stringin kalanından büyükse
        char small_buffer[5];
        // "Fatih" -> string'in başından 5 karakter, ancak buffer sadece 4 karakter + null alabilir
        chars_copied = source_str.copy(small_buffer, 4, 0);
        small_buffer[chars_copied] = '\0';
        std::cout << "Copied to small_buffer: ";
        puts(small_buffer); // "Fati"
        std::cout << "Characters copied to small_buffer: " << chars_copied << std::endl;


        return 0;
    }
    ```
*   UTF-8, UTF-16 gibi farklı string kodlamaları sorulduğunda, hoca bu konunun çok geniş olduğunu, bu dersin/kursun kapsamı dışında olduğunu ve saatler sürecek ayrı bir anlatım gerektirdiğini belirtti.

---

**25. Dersin Kapanışı ve Gelecek Konulara Bakış (02:40:55.440 - 02:42:40.220)**

*   `std::string` sınıfıyla ilgili temel ve sık kullanılan fonksiyonların çoğuna değinildi. (Ranges kütüphanesiyle ilgili kısımlar veya bazı özel overload'lar hariç).
*   **Gelecek Hafta Zorlaşacak:** C++'ın Nesne Yönelimli Programlama (OOP) özelliklerine geçilecek.
*   **Ana Başlık: Kalıtım (Inheritance)**
    *   İlgili kavramlar: "is-a" ilişkisi, runtime polymorphism (çalışma zamanı çok biçimliliği), `virtual` fonksiyonlar, `multiple inheritance` (çoklu kalıtım), `public`, `protected`, `private` kalıtım türleri.
    *   Bu konu 2-3 hafta sürebilir.
*   **Ödev:** Bir sınıf tasarlama ödevi verilecek ve yapanlarla kod review (kod incelemesi) seansları düzenlenecek.
*   Dersin sona erdiği ve bir sonraki hafta görüşüleceği belirtildi.

---

**Tüm Anlatılanları Kapsayan Genel Kod Örneği (Birleştirilmiş Konseptler):**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm> // std::sort, std::remove, std::reverse
#include <stdexcept> // Hata yönetimi için
#include <cctype>    // std::isdigit
#include <limits>    // std::numeric_limits (cin.ignore için)

// C++14 ve sonrası string literalleri için
using namespace std::string_literals;

// Basit bir loglama fonksiyonu
void log_action(const std::string& action, const std::string& str_state) {
    std::cout << "[LOG] Action: " << action << " -> State: \"" << str_state << "\""
              << " (Length: " << str_state.length() << ", Capacity: " << str_state.capacity() << ")" << std::endl;
}

int main() {
    // 1. Başlangıç ve Atama
    std::string main_str = "   Hello, C++ World! Counting 123...   "s;
    log_action("Initial Assignment", main_str);

    // 2. Arama ve Contains (C++20/23)
    std::string search_term = "C++"s;
    size_t found_pos = main_str.find(search_term);
    if (found_pos != std::string::npos) {
        std::cout << "\"" << search_term << "\" found at index: " << found_pos << std::endl;
    }
    #if __cplusplus >= 202002L // C++20 (starts_with/ends_with)
    if (main_str.starts_with("   Hello")) {
        std::cout << "String starts with \"   Hello\"" << std::endl;
    }
    #endif
    #if __cplusplus >= 202302L // C++23 (contains)
    if (main_str.contains("World")) {
         std::cout << "String contains \"World\"" << std::endl;
    }
    #endif

    // 3. Mutator Fonksiyonlar: insert, erase, replace
    // Baştaki ve sondaki boşlukları "trim" benzeri bir işlemle kaldıralım (basit yöntem)
    size_t first_char = main_str.find_first_not_of(" \t\n\r\f\v");
    if (first_char != std::string::npos) {
        main_str.erase(0, first_char);
    }
    size_t last_char = main_str.find_last_not_of(" \t\n\r\f\v");
    if (last_char != std::string::npos) {
        main_str.erase(last_char + 1);
    }
    log_action("Trimmed-like", main_str);

    main_str.insert(main_str.find("World"), "Amazing "); // "Amazing World"
    log_action("Insert 'Amazing'", main_str);

    main_str.replace(main_str.find("123"), 3, "numbers"); // "Counting numbers..."
    log_action("Replace '123' with 'numbers'", main_str);

    // 4. Resize ve Shrink
    size_t original_len_for_resize = main_str.length();
    main_str.resize(original_len_for_resize + 5, '*'); // Sonuna '*' ekle
    log_action("Resized (longer)", main_str);
    main_str.resize(original_len_for_resize); // Eski boyutuna geri dön
    log_action("Resized (shorter)", main_str);
    main_str.shrink_to_fit();
    log_action("Shrink to fit", main_str);

    // 5. Algoritmalar: sort, reverse
    std::string to_sort = main_str.substr(main_str.find("Hello"), 5); // "Hello"
    std::sort(to_sort.begin(), to_sort.end());
    std::cout << "Sorted 'Hello': " << to_sort << std::endl; // "He_llo" -> " Hlelo"
    std::reverse(main_str.begin(), main_str.end());
    log_action("Reversed main_str", main_str);
    std::reverse(main_str.begin(), main_str.end()); // Tekrar eski haline
    log_action("Reversed back main_str", main_str);


    // 6. Sayısal Dönüşümler
    std::string num_str_part = "Age:42";
    int age = 0;
    size_t processed_idx;
    try {
        // "Age:" kısmını atlayıp sayıyı almak için find ve substr kullan
        size_t colon_pos = num_str_part.find(':');
        if (colon_pos != std::string::npos) {
            age = std::stoi(num_str_part.substr(colon_pos + 1), &processed_idx);
            std::cout << "Parsed age: " << age << ", processed from substring: " << processed_idx << " chars." << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Conversion error: " << e.what() << std::endl;
    }
    std::string year_str = std::to_string(2024);
    main_str += " Year: " + year_str;
    log_action("Added year", main_str);

    // 7. C-string'e erişim
    const char* c_version = main_str.c_str();
    std::cout << "C-string version: " << c_version << std::endl;

    // 8. I/O
    std::string user_input;
    std::cout << "Enter a line of text: ";
    // Önceki std::cin'den kalabilecek newline'ları temizle (eğer std::cin >> kullanılsaydı)
    // std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    std::getline(std::cin, user_input);
    std::cout << "You entered: \"" << user_input << "\"" << std::endl;

    // 9. Erase-if (C++20)
    #if __cplusplus >= 202002L
    std::string mix_str = "Text1With2Numbers3";
    std::cout << "Original mix_str: " << mix_str << std::endl;
    size_t removed_count = std::erase_if(mix_str, [](unsigned char c){ return std::isdigit(c); });
    std::cout << "After erase_if (digits): " << mix_str << ", removed: " << removed_count << std::endl;
    #endif

    std::cout << "--- End of Demo ---" << std::endl;

    return 0;
}
```
